#!/usr/bin/env node

/**
 * Route Validation Script
 * 
 * This script validates that development routes (server/routes.ts) and 
 * production routes (api/index.js) are properly synchronized.
 * 
 * Used in:
 * - Pre-commit hooks
 * - CI/CD pipeline
 * - Development workflow
 */

import crypto from 'crypto';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROUTES_SOURCE = path.join(__dirname, '../server/routes.ts');
const API_TARGET = path.join(__dirname, '../api/index.js');
const SYNC_MANIFEST = path.join(__dirname, '../.sync-manifest.json');

console.log('ðŸ” Validating route synchronization...');

// Calculate file hash
function calculateHash(filePath) {
  if (!fs.existsSync(filePath)) {
    return null;
  }
  
  const content = fs.readFileSync(filePath, 'utf8');
  return crypto.createHash('md5').update(content).digest('hex');
}

// Extract route signatures from TypeScript file
function extractRouteSignatures(content) {
  const routes = [];
  const routePattern = /app\.(get|post|put|delete|patch)\s*\(\s*["'`]([^"'`]+)["'`]/g;
  
  let match;
  while ((match = routePattern.exec(content)) !== null) {
    const [, method, path] = match;
    routes.push(`${method.toUpperCase()} ${path}`);
  }
  
  return routes.sort();
}

// Extract route signatures from JavaScript file
function extractJsRouteSignatures(content) {
  const routes = [];
  const routePattern = /app\.(get|post|put|delete|patch)\s*\(\s*["'`]([^"'`]+)["'`]/g;
  
  let match;
  while ((match = routePattern.exec(content)) !== null) {
    const [, method, path] = match;
    routes.push(`${method.toUpperCase()} ${path}`);
  }
  
  return routes.sort();
}

// Check if API file was auto-generated
function isAutoGenerated(content) {
  return content.includes('// Auto-generated API file for Vercel deployment') ||
         content.includes('âš ï¸  DO NOT EDIT THIS FILE MANUALLY');
}

// Read sync manifest
function readSyncManifest() {
  if (!fs.existsSync(SYNC_MANIFEST)) {
    return null;
  }
  
  try {
    const content = fs.readFileSync(SYNC_MANIFEST, 'utf8');
    return JSON.parse(content);
  } catch (error) {
    console.warn('âš ï¸  Corrupted sync manifest, will recreate');
    return null;
  }
}

// Write sync manifest
function writeSyncManifest(data) {
  fs.writeFileSync(SYNC_MANIFEST, JSON.stringify(data, null, 2));
}

// Main validation function
async function validateSync() {
  try {
    console.log('ðŸš€ LocalCooks Route Validation System');
    console.log('=====================================');
    
    // Check if source file exists
    if (!fs.existsSync(ROUTES_SOURCE)) {
      console.error('âŒ Development routes file not found:', ROUTES_SOURCE);
      process.exit(1);
    }
    
    // Check if target file exists
    if (!fs.existsSync(API_TARGET)) {
      console.error('âŒ Production API file not found:', API_TARGET);
      console.error('ðŸ’¡ Run "npm run sync-routes" to generate it');
      process.exit(1);
    }
    
    // Read files
    const sourceContent = fs.readFileSync(ROUTES_SOURCE, 'utf8');
    const targetContent = fs.readFileSync(API_TARGET, 'utf8');
    
    // Calculate hashes
    const sourceHash = calculateHash(ROUTES_SOURCE);
    const targetHash = calculateHash(API_TARGET);
    
    // Read previous sync state
    const manifest = readSyncManifest();
    
    // Extract route signatures
    const sourceRoutes = extractRouteSignatures(sourceContent);
    const targetRoutes = extractJsRouteSignatures(targetContent);
    
    console.log(`ðŸ“Š Found ${sourceRoutes.length} routes in development`);
    console.log(`ðŸ“Š Found ${targetRoutes.length} routes in production`);
    
    // Check if API file is auto-generated
    const isGenerated = isAutoGenerated(targetContent);
    
    if (!isGenerated) {
      console.warn('âš ï¸  Production API file appears to be manually edited');
      console.warn('ðŸ’¡ Consider using auto-generation for consistency');
    }
    
    // Compare route counts
    if (sourceRoutes.length !== targetRoutes.length) {
      console.error('âŒ Route count mismatch!');
      console.error(`   Development: ${sourceRoutes.length} routes`);
      console.error(`   Production:  ${targetRoutes.length} routes`);
      
      // Show missing routes
      const missingInProd = sourceRoutes.filter(route => !targetRoutes.includes(route));
      const extraInProd = targetRoutes.filter(route => !sourceRoutes.includes(route));
      
      if (missingInProd.length > 0) {
        console.error('\nðŸ”´ Missing in production:');
        missingInProd.forEach(route => console.error(`   - ${route}`));
      }
      
      if (extraInProd.length > 0) {
        console.error('\nðŸŸ¡ Extra in production:');
        extraInProd.forEach(route => console.error(`   - ${route}`));
      }
      
      console.error('\nðŸ’¡ Run "npm run sync-routes" to fix synchronization');
      process.exit(1);
    }
    
    // Compare route signatures
    const routeMismatches = [];
    sourceRoutes.forEach((route, index) => {
      if (route !== targetRoutes[index]) {
        routeMismatches.push({ source: route, target: targetRoutes[index] });
      }
    });
    
    if (routeMismatches.length > 0) {
      console.error('âŒ Route signature mismatches!');
      routeMismatches.forEach(({ source, target }) => {
        console.error(`   Source: ${source}`);
        console.error(`   Target: ${target}`);
      });
      console.error('\nðŸ’¡ Run "npm run sync-routes" to fix synchronization');
      process.exit(1);
    }
    
    // Check if files have changed since last sync
    if (manifest) {
      if (manifest.sourceHash !== sourceHash) {
        console.warn('âš ï¸  Development routes have changed since last sync');
        console.warn('ðŸ’¡ Run "npm run sync-routes" to update production');
        
        // Still exit successfully but with warning
        process.exit(1);
      }
      
      if (manifest.targetHash !== targetHash && isGenerated) {
        console.warn('âš ï¸  Production API file has changed unexpectedly');
        console.warn('ðŸ’¡ This should not happen with auto-generated files');
      }
    }
    
    // Update sync manifest
    const newManifest = {
      lastSync: new Date().toISOString(),
      sourceHash,
      targetHash,
      routeCount: sourceRoutes.length,
      isAutoGenerated: isGenerated,
      routes: sourceRoutes
    };
    
    writeSyncManifest(newManifest);
    
    // Success!
    console.log('');
    console.log('âœ… Route synchronization validation passed!');
    console.log(`ðŸ”’ ${sourceRoutes.length} routes are properly synchronized`);
    console.log('ðŸ“ˆ Development and production environments match');
    
    return true;
    
  } catch (error) {
    console.error('');
    console.error('ðŸ’¥ Validation failed:', error.message);
    console.error('');
    console.error('ðŸ”§ Troubleshooting:');
    console.error('1. Check that both routes files exist and are readable');
    console.error('2. Ensure route syntax is consistent');
    console.error('3. Run "npm run sync-routes" to regenerate production file');
    process.exit(1);
  }
}

// Show sync status
async function showStatus() {
  const manifest = readSyncManifest();
  
  if (!manifest) {
    console.log('ðŸ“‹ No sync history found');
    console.log('ðŸ’¡ Run "npm run validate-sync" to initialize');
    return;
  }
  
  console.log('ðŸ“‹ Route Synchronization Status');
  console.log('===============================');
  console.log(`Last sync: ${new Date(manifest.lastSync).toLocaleString()}`);
  console.log(`Route count: ${manifest.routeCount}`);
  console.log(`Auto-generated: ${manifest.isAutoGenerated ? 'âœ…' : 'âŒ'}`);
  console.log('');
  console.log('Routes:');
  manifest.routes.forEach(route => console.log(`  - ${route}`));
}

// CLI interface
const scriptPath = fileURLToPath(import.meta.url);
const isMainModule = process.argv[1] === scriptPath;

if (isMainModule) {
  const command = process.argv[2];

  if (command === 'status') {
    showStatus();
  } else {
    validateSync();
  }
}

export { showStatus, validateSync };
