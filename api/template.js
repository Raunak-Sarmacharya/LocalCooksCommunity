// Auto-generated API file for Vercel deployment
// Source: server/routes.ts
// Generated: {{TIMESTAMP}}
// 
// ⚠️  DO NOT EDIT THIS FILE MANUALLY
// ⚠️  All changes should be made in server/routes.ts
// ⚠️  Run 'npm run sync-routes' to update this file

import { Pool } from '@neondatabase/serverless';
import connectPgSimple from 'connect-pg-simple';
import { randomBytes, scrypt, timingSafeEqual } from 'crypto';
import express from 'express';
import session from 'express-session';
import fs from 'fs';
import createMemoryStore from 'memorystore';
import multer from 'multer';
import path from 'path';
import { promisify } from 'util';

// Setup
const app = express();
const scryptAsync = promisify(scrypt);
const MemoryStore = createMemoryStore(session);
const PgStore = connectPgSimple(session);

// {{MIDDLEWARE_SETUP}}

// Configure multer for file uploads
let upload;

try {
  // Check if we're in production
  const uploadIsProduction = process.env.VERCEL_ENV === 'production' || process.env.NODE_ENV === 'production';
  
  // File filter to only allow certain file types
  const fileFilter = (req, file, cb) => {
    // Allow PDF, JPG, JPEG, PNG files
    const allowedMimes = [
      'application/pdf',
      'image/jpeg',
      'image/jpg', 
      'image/png',
      'image/webp'
    ];
    
    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type. Only PDF, JPG, JPEG, PNG, and WebP files are allowed.'));
    }
  };

  if (uploadIsProduction) {
    // Production: Use memory storage for Vercel Blob
    const memoryStorage = multer.memoryStorage();
    upload = multer({
      storage: memoryStorage,
      fileFilter: fileFilter,
      limits: {
        fileSize: 10 * 1024 * 1024, // 10MB limit
      },
    });
  } else {
    // Development: Use disk storage
    const uploadsDir = path.join(process.cwd(), 'uploads', 'documents');
    
    // Only create directory in development
    if (!fs.existsSync(uploadsDir)) {
      fs.mkdirSync(uploadsDir, { recursive: true });
    }

    const diskStorage = multer.diskStorage({
      destination: (req, file, cb) => {
        cb(null, uploadsDir);
      },
      filename: (req, file, cb) => {
        // Generate unique filename: userId_documentType_timestamp_originalname
        const userId = req.session.userId || req.headers['x-user-id'] || 'unknown';
        const timestamp = Date.now();
        const documentType = file.fieldname; // 'foodSafetyLicense' or 'foodEstablishmentCert'
        const ext = path.extname(file.originalname);
        const baseName = path.basename(file.originalname, ext);
        
        const filename = `${userId}_${documentType}_${timestamp}_${baseName}${ext}`;
        cb(null, filename);
      }
    });

    upload = multer({
      storage: diskStorage,
      fileFilter: fileFilter,
      limits: {
        fileSize: 10 * 1024 * 1024, // 10MB limit
      },
    });
  }

  console.log('File upload configuration initialized successfully');
} catch (error) {
  console.error('Failed to initialize file upload configuration:', error);
  // Create a proper dummy upload middleware with all required methods
  const dummyMiddleware = (req, res, next) => {
    res.status(500).json({ message: "File upload not available in this environment" });
  };
  
  upload = {
    single: () => dummyMiddleware,
    fields: () => dummyMiddleware,
    array: () => dummyMiddleware,
    any: () => dummyMiddleware,
    none: () => dummyMiddleware
  };
}

// {{DATABASE_SETUP}}

// Database connection with small pool size for serverless
let pool;
let sessionStore;

try {
  if (process.env.DATABASE_URL) {
    pool = new Pool({
      connectionString: process.env.DATABASE_URL,
      max: 1 // Small pool for serverless
    });

    // Create PG session store
    sessionStore = new PgStore({
      pool: pool,
      createTableIfMissing: true,
      // Add automatic cleanup configuration
      pruneSessionInterval: 60 * 15, // Prune every 15 minutes (in seconds)
      errorLog: console.error,
      debugLog: console.log
    });

    console.log('Connected to database and initialized session store');

    // Create session table
    (async () => {
      try {
        await pool.query(`
          CREATE TABLE IF NOT EXISTS "session" (
            "sid" varchar NOT NULL COLLATE "default",
            "sess" json NOT NULL,
            "expire" timestamp(6) NOT NULL,
            CONSTRAINT "session_pkey" PRIMARY KEY ("sid")
          );
          CREATE INDEX IF NOT EXISTS "IDX_session_expire" ON "session" ("expire");
        `);
        console.log('Session table created or verified');
      } catch (err) {
        console.error('Error setting up session table:', err);
      }
    })();

    // Run initial session cleanup on startup
    (async () => {
      try {
        console.log('Running startup session cleanup...');
        const cleanupResult = await cleanupExpiredSessions();
        console.log(`Startup cleanup: Removed ${cleanupResult.cleaned} expired sessions`);
        
        const stats = await getSessionStats();
        console.log('Session stats after startup cleanup:', {
          total: stats.total_sessions,
          active: stats.active_sessions,
          expired: stats.expired_sessions
        });
      } catch (err) {
        console.error('Error during startup session cleanup:', err);
      }
    })();

  } else {
    console.log('DATABASE_URL not provided, using in-memory storage');
    sessionStore = new MemoryStore({
      checkPeriod: 86400000 // prune expired entries every 24h
    });
  }
} catch (error) {
  console.error('Database connection error:', error);
  // Fallback to memory store
  sessionStore = new MemoryStore({
    checkPeriod: 86400000 // prune expired entries every 24h
  });
}

// In-memory fallback for users
const users = new Map();

// Middleware
app.use(express.json());

// Session setup
const sessionSecret = process.env.SESSION_SECRET || 'local-cooks-dev-secret';
const isProduction = process.env.NODE_ENV === 'production';

console.log('Setting up session with', {
  production: isProduction,
  storeType: pool ? 'PostgreSQL' : 'Memory',
  sessionSecret: sessionSecret ? 'Provided' : 'Missing'
});

app.use(session({
  secret: sessionSecret,
  resave: true,
  saveUninitialized: true,
  store: sessionStore,
  cookie: {
    secure: isProduction,
    httpOnly: true,
    maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
    sameSite: isProduction ? 'strict' : 'lax'
  }
}));

// {{HELPER_FUNCTIONS}}

// Helper functions extracted from server/routes.ts
async function hashPassword(password) {
  const salt = randomBytes(16).toString('hex');
  const hash = await scryptAsync(password, salt, 64);
  return `${salt}:${hash.toString('hex')}`;
}

async function comparePasswords(supplied, stored) {
  const [salt, key] = stored.split(':');
  const hashedBuffer = await scryptAsync(supplied, salt, 64);
  const keyBuffer = Buffer.from(key, 'hex');
  return timingSafeEqual(hashedBuffer, keyBuffer);
}

// Database helper functions
async function getUserByUsername(username) {
  if (!pool) {
    // Fallback to in-memory storage
    for (const [id, user] of users.entries()) {
      if (user.username === username) {
        return { id, ...user };
      }
    }
    return null;
  }

  try {
    const result = await pool.query('SELECT * FROM users WHERE username = $1', [username]);
    return result.rows[0] || null;
  } catch (error) {
    console.error('Error fetching user by username:', error);
    return null;
  }
}

async function getUser(id) {
  if (!pool) {
    return users.get(id) || null;
  }

  try {
    const result = await pool.query('SELECT * FROM users WHERE id = $1', [id]);
    return result.rows[0] || null;
  } catch (error) {
    console.error('Error fetching user:', error);
    return null;
  }
}

async function createUser(userData) {
  if (!pool) {
    const id = Date.now();
    users.set(id, { ...userData, id });
    return { id, ...userData };
  }

  try {
    const result = await pool.query(
      'INSERT INTO users (username, email, password_hash, full_name, created_at) VALUES ($1, $2, $3, $4, NOW()) RETURNING *',
      [userData.username, userData.email, userData.password_hash, userData.full_name]
    );
    return result.rows[0];
  } catch (error) {
    console.error('Error creating user:', error);
    throw error;
  }
}

// Microlearning helper functions
async function hasApprovedApplication(userId) {
  if (!pool) {
    console.log('No database connection, assuming no approved application');
    return false;
  }

  try {
    const result = await pool.query(
      'SELECT COUNT(*) FROM applications WHERE user_id = $1 AND status = $2',
      [userId, 'approved']
    );
    
    const count = parseInt(result.rows[0].count);
    console.log(`User ${userId} has ${count} approved applications`);
    return count > 0;
  } catch (error) {
    console.error('Error checking approved application:', error);
    return false;
  }
}

async function getMicrolearningProgress(userId) {
  if (!pool) {
    // Fallback to in-memory storage
    return {
      completedVideos: 0,
      videoProgress: {},
      accessLevel: 1,
      canAccessTraining: true
    };
  }

  try {
    // Create table if it doesn't exist
    await pool.query(`
      CREATE TABLE IF NOT EXISTS video_progress (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL,
        video_id INTEGER NOT NULL,
        progress DECIMAL(5,2) DEFAULT 0,
        completed BOOLEAN DEFAULT FALSE,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(user_id, video_id)
      )
    `);

    const result = await pool.query(
      'SELECT video_id, progress, completed FROM video_progress WHERE user_id = $1',
      [userId]
    );

    const videoProgress = {};
    let completedVideos = 0;

    result.rows.forEach(row => {
      videoProgress[row.video_id] = {
        progress: parseFloat(row.progress),
        completed: row.completed
      };
      if (row.completed) {
        completedVideos++;
      }
    });

    // Check if user has approved application for access control
    const hasApproved = await hasApprovedApplication(userId);
    
    return {
      completedVideos,
      videoProgress,
      accessLevel: hasApproved ? 10 : 1, // First video free, rest require approval
      canAccessTraining: true
    };
  } catch (error) {
    console.error('Error getting microlearning progress:', error);
    return {
      completedVideos: 0,
      videoProgress: {},
      accessLevel: 1,
      canAccessTraining: true
    };
  }
}

// Session cleanup functions
async function cleanupExpiredSessions() {
  if (!pool) {
    return { cleaned: 0, remaining: 0 };
  }

  try {
    const result = await pool.query(
      'DELETE FROM session WHERE expire < NOW() RETURNING sid'
    );
    
    const cleaned = result.rowCount || 0;
    
    const countResult = await pool.query('SELECT COUNT(*) as remaining FROM session');
    const remaining = parseInt(countResult.rows[0].remaining);
    
    return { cleaned, remaining };
  } catch (error) {
    console.error('Error cleaning up expired sessions:', error);
    return { cleaned: 0, remaining: 0 };
  }
}

async function getSessionStats() {
  if (!pool) {
    return {
      total_sessions: 0,
      active_sessions: 0,
      expired_sessions: 0
    };
  }

  try {
    const result = await pool.query(`
      SELECT 
        COUNT(*) as total_sessions,
        COUNT(CASE WHEN expire > NOW() THEN 1 END) as active_sessions,
        COUNT(CASE WHEN expire <= NOW() THEN 1 END) as expired_sessions
      FROM session
    `);
    
    return result.rows[0];
  } catch (error) {
    console.error('Error getting session stats:', error);
    return {
      total_sessions: 0,
      active_sessions: 0,
      expired_sessions: 0
    };
  }
}

// {{ROUTES}}

// Routes will be inserted here by the sync script

// {{ERROR_HANDLING}}

// Global error handler
app.use((err, req, res, next) => {
  console.error('Global error handler:', err);
  
  // Handle multer errors specifically
  if (err instanceof multer.MulterError) {
    if (err.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({ message: 'File too large. Maximum size is 3.5MB.' });
    }
    return res.status(400).json({ message: 'File upload error: ' + err.message });
  }
  
  // Handle other file upload errors
  if (err.message && err.message.includes('Invalid file type')) {
    return res.status(400).json({ message: err.message });
  }
  
  // Default error response
  res.status(500).json({
    message: 'Internal server error',
    error: process.env.NODE_ENV === 'development' ? err.message : 'Something went wrong'
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ message: 'Route not found' });
});

export default app; 