var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc3) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc3 = __getOwnPropDesc(from, key)) || desc3.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// server/firebase-admin.ts
var firebase_admin_exports = {};
__export(firebase_admin_exports, {
  firebaseAdmin: () => firebaseAdmin,
  initializeFirebaseAdmin: () => initializeFirebaseAdmin,
  isFirebaseAdminConfigured: () => isFirebaseAdminConfigured,
  verifyFirebaseToken: () => verifyFirebaseToken
});
import admin from "firebase-admin";
function initializeFirebaseAdmin() {
  if (firebaseAdmin) {
    return firebaseAdmin;
  }
  try {
    if (process.env.FIREBASE_PROJECT_ID && process.env.FIREBASE_CLIENT_EMAIL && process.env.FIREBASE_PRIVATE_KEY) {
      console.log("\u{1F525} Initializing Firebase Admin with service account credentials...");
      try {
        firebaseAdmin = admin.initializeApp({
          credential: admin.credential.cert({
            projectId: process.env.FIREBASE_PROJECT_ID,
            clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
            privateKey: process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, "\n")
          }),
          projectId: process.env.FIREBASE_PROJECT_ID
        });
        console.log("\u2705 Firebase Admin initialized with service account for project:", process.env.FIREBASE_PROJECT_ID);
        return firebaseAdmin;
      } catch (error) {
        console.error("\u274C Failed to initialize Firebase Admin with service account:", error.message);
      }
    }
    if (!process.env.VITE_FIREBASE_PROJECT_ID) {
      console.warn("Firebase Admin not configured - Firebase auth verification will be disabled (missing both service account and VITE_FIREBASE_PROJECT_ID)");
      return null;
    }
    try {
      firebaseAdmin = admin.initializeApp({
        projectId: process.env.VITE_FIREBASE_PROJECT_ID
      });
      console.log("\u{1F525} Firebase Admin initialized with default credentials for project:", process.env.VITE_FIREBASE_PROJECT_ID);
      console.warn("\u26A0\uFE0F Using default credentials - this may not work in production. Consider setting up service account credentials.");
    } catch (error) {
      console.log("\u{1F525} Firebase Admin initialization failed, will rely on client-side checks:", error.message || "Unknown error");
      return null;
    }
    return firebaseAdmin;
  } catch (error) {
    console.error("\u274C Failed to initialize Firebase Admin:", error);
    return null;
  }
}
async function verifyFirebaseToken(token) {
  try {
    const app3 = initializeFirebaseAdmin();
    if (!app3) {
      console.warn("Firebase Admin not initialized - cannot verify token");
      return null;
    }
    const decodedToken = await admin.auth().verifyIdToken(token);
    return decodedToken;
  } catch (error) {
    console.error("Error verifying Firebase token:", error);
    return null;
  }
}
function isFirebaseAdminConfigured() {
  return !!(process.env.FIREBASE_PROJECT_ID || process.env.VITE_FIREBASE_PROJECT_ID);
}
var firebaseAdmin;
var init_firebase_admin = __esm({
  "server/firebase-admin.ts"() {
    "use strict";
    firebaseAdmin = null;
  }
});

// shared/phone-validation.ts
import { z } from "zod";
var normalizePhoneNumber, isValidNorthAmericanPhone, phoneNumberSchema, optionalPhoneNumberSchema, validateAndNormalizePhone;
var init_phone_validation = __esm({
  "shared/phone-validation.ts"() {
    "use strict";
    normalizePhoneNumber = (phone) => {
      if (!phone) return null;
      const trimmed = phone.trim();
      if (!trimmed) return null;
      const cleaned = trimmed.replace(/[^\d+]/g, "");
      if (cleaned.startsWith("+")) {
        const digitsAfterPlus = cleaned.substring(1);
        if (digitsAfterPlus.length >= 1 && digitsAfterPlus.length <= 15 && /^\d+$/.test(digitsAfterPlus)) {
          if (digitsAfterPlus.startsWith("1") && digitsAfterPlus.length === 11) {
            return cleaned;
          }
          if (digitsAfterPlus.length === 10) {
            return `+1${digitsAfterPlus}`;
          }
          return null;
        }
        return null;
      }
      const digitsOnly = cleaned.replace(/\D/g, "");
      if (digitsOnly.length === 11 && digitsOnly.startsWith("1")) {
        return `+${digitsOnly}`;
      }
      if (digitsOnly.length === 10) {
        return `+1${digitsOnly}`;
      }
      return null;
    };
    isValidNorthAmericanPhone = (phone) => {
      if (!phone) return false;
      let normalized;
      if (phone.startsWith("+1") && phone.length === 12) {
        normalized = phone;
      } else {
        normalized = normalizePhoneNumber(phone);
      }
      if (!normalized) return false;
      if (!normalized.startsWith("+1") || normalized.length !== 12) {
        return false;
      }
      const digits = normalized.substring(2);
      if (digits.length !== 10 || !/^\d{10}$/.test(digits)) {
        return false;
      }
      const areaCodeFirstDigit = parseInt(digits[0]);
      if (areaCodeFirstDigit < 2 || areaCodeFirstDigit > 9) return false;
      const exchangeCodeFirstDigit = parseInt(digits[3]);
      if (exchangeCodeFirstDigit < 2 || exchangeCodeFirstDigit > 9) return false;
      return true;
    };
    phoneNumberSchema = z.string().min(1, "Phone number is required").refine(
      (val) => {
        const normalized = normalizePhoneNumber(val);
        return normalized !== null && isValidNorthAmericanPhone(normalized);
      },
      {
        message: "Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
      }
    ).transform((val) => {
      const normalized = normalizePhoneNumber(val);
      return normalized || val;
    });
    optionalPhoneNumberSchema = z.string().optional().refine(
      (val) => {
        if (!val || val.trim() === "") return true;
        const normalized = normalizePhoneNumber(val);
        return normalized !== null && isValidNorthAmericanPhone(normalized);
      },
      {
        message: "Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
      }
    ).transform((val) => {
      if (!val || val.trim() === "") return null;
      const normalized = normalizePhoneNumber(val);
      return normalized || val;
    });
    validateAndNormalizePhone = (phone) => {
      if (!phone) return null;
      return normalizePhoneNumber(phone);
    };
  }
});

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  applicationStatusEnum: () => applicationStatusEnum,
  applicationTypeEnum: () => applicationTypeEnum,
  applications: () => applications,
  bookingDurationUnitEnum: () => bookingDurationUnitEnum,
  bookingStatusEnum: () => bookingStatusEnum,
  bookingTypeEnum: () => bookingTypeEnum,
  certificationStatusEnum: () => certificationStatusEnum,
  chefKitchenAccess: () => chefKitchenAccess,
  chefKitchenApplications: () => chefKitchenApplications,
  chefKitchenProfiles: () => chefKitchenProfiles,
  chefLocationAccess: () => chefLocationAccess,
  chefLocationProfiles: () => chefLocationProfiles,
  customFieldSchema: () => customFieldSchema,
  documentVerificationStatusEnum: () => documentVerificationStatusEnum,
  equipmentAvailabilityTypeEnum: () => equipmentAvailabilityTypeEnum,
  equipmentBookings: () => equipmentBookings,
  equipmentCategoryEnum: () => equipmentCategoryEnum,
  equipmentConditionEnum: () => equipmentConditionEnum,
  equipmentListings: () => equipmentListings,
  equipmentPricingModelEnum: () => equipmentPricingModelEnum,
  insertApplicationSchema: () => insertApplicationSchema,
  insertChefKitchenAccessSchema: () => insertChefKitchenAccessSchema,
  insertChefKitchenApplicationSchema: () => insertChefKitchenApplicationSchema,
  insertChefKitchenProfileSchema: () => insertChefKitchenProfileSchema,
  insertChefLocationAccessSchema: () => insertChefLocationAccessSchema,
  insertChefLocationProfileSchema: () => insertChefLocationProfileSchema,
  insertEquipmentBookingSchema: () => insertEquipmentBookingSchema,
  insertEquipmentListingSchema: () => insertEquipmentListingSchema,
  insertKitchenAvailabilitySchema: () => insertKitchenAvailabilitySchema,
  insertKitchenBookingSchema: () => insertKitchenBookingSchema,
  insertKitchenDateOverrideSchema: () => insertKitchenDateOverrideSchema,
  insertKitchenSchema: () => insertKitchenSchema,
  insertLocationRequirementsSchema: () => insertLocationRequirementsSchema,
  insertLocationSchema: () => insertLocationSchema,
  insertMicrolearningCompletionSchema: () => insertMicrolearningCompletionSchema,
  insertPaymentTransactionSchema: () => insertPaymentTransactionSchema,
  insertPlatformSettingSchema: () => insertPlatformSettingSchema,
  insertPortalUserApplicationSchema: () => insertPortalUserApplicationSchema,
  insertPortalUserLocationAccessSchema: () => insertPortalUserLocationAccessSchema,
  insertStorageBookingSchema: () => insertStorageBookingSchema,
  insertStorageListingSchema: () => insertStorageListingSchema,
  insertUserSchema: () => insertUserSchema,
  insertVideoProgressSchema: () => insertVideoProgressSchema,
  kitchenAvailability: () => kitchenAvailability,
  kitchenBookings: () => kitchenBookings,
  kitchenDateOverrides: () => kitchenDateOverrides,
  kitchenPreferenceEnum: () => kitchenPreferenceEnum,
  kitchens: () => kitchens,
  listingStatusEnum: () => listingStatusEnum,
  locationRequirements: () => locationRequirements,
  locations: () => locations,
  microlearningCompletions: () => microlearningCompletions,
  paymentHistory: () => paymentHistory,
  paymentStatusEnum: () => paymentStatusEnum,
  paymentTransactions: () => paymentTransactions,
  platformSettings: () => platformSettings,
  portalUserApplications: () => portalUserApplications,
  portalUserLocationAccess: () => portalUserLocationAccess,
  storageBookings: () => storageBookings,
  storageListings: () => storageListings,
  storagePricingModelEnum: () => storagePricingModelEnum,
  storageTypeEnum: () => storageTypeEnum,
  transactionStatusEnum: () => transactionStatusEnum,
  updateApplicationDocumentsSchema: () => updateApplicationDocumentsSchema,
  updateApplicationStatusSchema: () => updateApplicationStatusSchema,
  updateChefKitchenApplicationDocumentsSchema: () => updateChefKitchenApplicationDocumentsSchema,
  updateChefKitchenApplicationSchema: () => updateChefKitchenApplicationSchema,
  updateChefKitchenApplicationStatusSchema: () => updateChefKitchenApplicationStatusSchema,
  updateChefKitchenProfileSchema: () => updateChefKitchenProfileSchema,
  updateChefLocationProfileSchema: () => updateChefLocationProfileSchema,
  updateDocumentVerificationSchema: () => updateDocumentVerificationSchema,
  updateEquipmentBookingSchema: () => updateEquipmentBookingSchema,
  updateEquipmentBookingStatusSchema: () => updateEquipmentBookingStatusSchema,
  updateEquipmentListingSchema: () => updateEquipmentListingSchema,
  updateEquipmentListingStatusSchema: () => updateEquipmentListingStatusSchema,
  updateKitchenBookingSchema: () => updateKitchenBookingSchema,
  updateKitchenDateOverrideSchema: () => updateKitchenDateOverrideSchema,
  updateKitchenSchema: () => updateKitchenSchema,
  updateLocationRequirementsSchema: () => updateLocationRequirementsSchema,
  updateLocationSchema: () => updateLocationSchema,
  updatePaymentTransactionSchema: () => updatePaymentTransactionSchema,
  updatePlatformSettingSchema: () => updatePlatformSettingSchema,
  updatePortalUserApplicationStatusSchema: () => updatePortalUserApplicationStatusSchema,
  updateStorageBookingSchema: () => updateStorageBookingSchema,
  updateStorageBookingStatusSchema: () => updateStorageBookingStatusSchema,
  updateStorageListingSchema: () => updateStorageListingSchema,
  updateStorageListingStatusSchema: () => updateStorageListingStatusSchema,
  userRoleEnum: () => userRoleEnum,
  users: () => users,
  videoProgress: () => videoProgress
});
import { boolean, date, integer, jsonb, numeric, pgEnum, pgTable, serial, text, timestamp } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z as z2 } from "zod";
var kitchenPreferenceEnum, certificationStatusEnum, applicationStatusEnum, userRoleEnum, documentVerificationStatusEnum, applicationTypeEnum, bookingStatusEnum, storageTypeEnum, storagePricingModelEnum, bookingDurationUnitEnum, listingStatusEnum, equipmentCategoryEnum, equipmentConditionEnum, equipmentPricingModelEnum, equipmentAvailabilityTypeEnum, paymentStatusEnum, transactionStatusEnum, bookingTypeEnum, users, applications, insertApplicationSchema, updateApplicationStatusSchema, updateApplicationDocumentsSchema, updateDocumentVerificationSchema, insertUserSchema, microlearningCompletions, videoProgress, insertMicrolearningCompletionSchema, insertVideoProgressSchema, locations, locationRequirements, kitchens, kitchenAvailability, kitchenDateOverrides, kitchenBookings, chefLocationAccess, chefKitchenAccess, chefKitchenProfiles, chefLocationProfiles, portalUserApplications, portalUserLocationAccess, insertLocationSchema, updateLocationSchema, insertLocationRequirementsSchema, customFieldSchema, updateLocationRequirementsSchema, insertKitchenSchema, updateKitchenSchema, insertKitchenAvailabilitySchema, insertKitchenDateOverrideSchema, updateKitchenDateOverrideSchema, insertKitchenBookingSchema, updateKitchenBookingSchema, insertChefLocationAccessSchema, insertChefKitchenAccessSchema, insertChefKitchenProfileSchema, updateChefKitchenProfileSchema, insertChefLocationProfileSchema, updateChefLocationProfileSchema, insertPortalUserApplicationSchema, updatePortalUserApplicationStatusSchema, insertPortalUserLocationAccessSchema, storageListings, insertStorageListingSchema, updateStorageListingSchema, updateStorageListingStatusSchema, equipmentListings, insertEquipmentListingSchema, updateEquipmentListingSchema, updateEquipmentListingStatusSchema, storageBookings, insertStorageBookingSchema, updateStorageBookingSchema, updateStorageBookingStatusSchema, equipmentBookings, insertEquipmentBookingSchema, updateEquipmentBookingSchema, updateEquipmentBookingStatusSchema, platformSettings, insertPlatformSettingSchema, updatePlatformSettingSchema, chefKitchenApplications, insertChefKitchenApplicationSchema, updateChefKitchenApplicationSchema, updateChefKitchenApplicationStatusSchema, updateChefKitchenApplicationDocumentsSchema, paymentTransactions, paymentHistory, insertPaymentTransactionSchema, updatePaymentTransactionSchema;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    init_phone_validation();
    kitchenPreferenceEnum = pgEnum("kitchen_preference", ["commercial", "home", "notSure"]);
    certificationStatusEnum = pgEnum("certification_status", ["yes", "no", "notSure"]);
    applicationStatusEnum = pgEnum("application_status", ["inReview", "approved", "rejected", "cancelled"]);
    userRoleEnum = pgEnum("user_role", ["admin", "chef", "manager"]);
    documentVerificationStatusEnum = pgEnum("document_verification_status", ["pending", "approved", "rejected", "expired"]);
    applicationTypeEnum = pgEnum("application_type", ["chef"]);
    bookingStatusEnum = pgEnum("booking_status", ["pending", "confirmed", "cancelled"]);
    storageTypeEnum = pgEnum("storage_type", ["dry", "cold", "freezer"]);
    storagePricingModelEnum = pgEnum("storage_pricing_model", ["monthly-flat", "per-cubic-foot", "hourly", "daily"]);
    bookingDurationUnitEnum = pgEnum("booking_duration_unit", ["hourly", "daily", "monthly"]);
    listingStatusEnum = pgEnum("listing_status", ["draft", "pending", "approved", "rejected", "active", "inactive"]);
    equipmentCategoryEnum = pgEnum("equipment_category", ["food-prep", "cooking", "refrigeration", "cleaning", "specialty"]);
    equipmentConditionEnum = pgEnum("equipment_condition", ["excellent", "good", "fair", "needs-repair"]);
    equipmentPricingModelEnum = pgEnum("equipment_pricing_model", ["hourly", "daily", "weekly", "monthly"]);
    equipmentAvailabilityTypeEnum = pgEnum("equipment_availability_type", ["included", "rental"]);
    paymentStatusEnum = pgEnum("payment_status", ["pending", "paid", "refunded", "failed", "partially_refunded"]);
    transactionStatusEnum = pgEnum("transaction_status", ["pending", "processing", "succeeded", "failed", "canceled", "refunded", "partially_refunded"]);
    bookingTypeEnum = pgEnum("booking_type_enum", ["kitchen", "storage", "equipment", "bundle"]);
    users = pgTable("users", {
      id: serial("id").primaryKey(),
      username: text("username").notNull().unique(),
      password: text("password").notNull(),
      role: userRoleEnum("role"),
      // Allow null initially - user will choose role
      googleId: text("google_id").unique(),
      facebookId: text("facebook_id").unique(),
      firebaseUid: text("firebase_uid").unique(),
      isVerified: boolean("is_verified").default(false).notNull(),
      has_seen_welcome: boolean("has_seen_welcome").default(false).notNull(),
      // Support dual roles - users can be both chef and manager
      isChef: boolean("is_chef").default(false).notNull(),
      isManager: boolean("is_manager").default(false).notNull(),
      isPortalUser: boolean("is_portal_user").default(false).notNull(),
      // Portal user (third-party kitchen users)
      applicationType: applicationTypeEnum("application_type"),
      // DEPRECATED: kept for backward compatibility
      // Manager onboarding fields
      managerOnboardingCompleted: boolean("manager_onboarding_completed").default(false).notNull(),
      // Whether manager completed onboarding
      managerOnboardingSkipped: boolean("manager_onboarding_skipped").default(false).notNull(),
      // Whether manager skipped onboarding
      managerOnboardingStepsCompleted: jsonb("manager_onboarding_steps_completed").default({}).notNull(),
      // JSON object tracking completed onboarding steps
      // Stripe Connect fields for manager payments
      stripeConnectAccountId: text("stripe_connect_account_id").unique(),
      // Stripe Connect Express account ID
      stripeConnectOnboardingStatus: text("stripe_connect_onboarding_status").default("not_started").notNull()
      // Status: 'not_started', 'in_progress', 'complete', 'failed'
    });
    applications = pgTable("applications", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").references(() => users.id),
      fullName: text("full_name").notNull(),
      email: text("email").notNull(),
      phone: text("phone").notNull(),
      foodSafetyLicense: certificationStatusEnum("food_safety_license").notNull(),
      foodEstablishmentCert: certificationStatusEnum("food_establishment_cert").notNull(),
      kitchenPreference: kitchenPreferenceEnum("kitchen_preference").notNull(),
      feedback: text("feedback"),
      status: applicationStatusEnum("status").default("inReview").notNull(),
      // Document verification fields
      foodSafetyLicenseUrl: text("food_safety_license_url"),
      foodEstablishmentCertUrl: text("food_establishment_cert_url"),
      foodSafetyLicenseStatus: documentVerificationStatusEnum("food_safety_license_status").default("pending"),
      foodEstablishmentCertStatus: documentVerificationStatusEnum("food_establishment_cert_status").default("pending"),
      documentsAdminFeedback: text("documents_admin_feedback"),
      documentsReviewedBy: integer("documents_reviewed_by").references(() => users.id),
      documentsReviewedAt: timestamp("documents_reviewed_at"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    insertApplicationSchema = createInsertSchema(applications, {
      fullName: z2.string().min(2, "Name must be at least 2 characters"),
      email: z2.string().email("Please enter a valid email address"),
      phone: phoneNumberSchema,
      // Uses shared phone validation
      foodSafetyLicense: z2.enum(["yes", "no", "notSure"]),
      foodEstablishmentCert: z2.enum(["yes", "no", "notSure"]),
      kitchenPreference: z2.enum(["commercial", "home", "notSure"]),
      feedback: z2.string().optional(),
      userId: z2.number().optional(),
      // Document fields are optional during initial application submission
      foodSafetyLicenseUrl: z2.string().optional(),
      foodEstablishmentCertUrl: z2.string().optional(),
      // Allow setting document status during creation
      foodSafetyLicenseStatus: z2.enum(["pending", "approved", "rejected"]).optional(),
      foodEstablishmentCertStatus: z2.enum(["pending", "approved", "rejected"]).optional()
    }).omit({
      id: true,
      status: true,
      createdAt: true,
      documentsAdminFeedback: true,
      documentsReviewedBy: true,
      documentsReviewedAt: true
    });
    updateApplicationStatusSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["inReview", "approved", "rejected", "cancelled"])
    });
    updateApplicationDocumentsSchema = z2.object({
      id: z2.number(),
      foodSafetyLicenseUrl: z2.string().optional(),
      foodEstablishmentCertUrl: z2.string().optional()
    });
    updateDocumentVerificationSchema = z2.object({
      id: z2.number(),
      foodSafetyLicenseStatus: z2.enum(["pending", "approved", "rejected"]).optional(),
      foodEstablishmentCertStatus: z2.enum(["pending", "approved", "rejected"]).optional(),
      documentsAdminFeedback: z2.string().optional(),
      documentsReviewedBy: z2.number().optional()
    });
    insertUserSchema = z2.object({
      username: z2.string().min(3, "Username must be at least 3 characters"),
      password: z2.string().min(6, "Password must be at least 6 characters"),
      role: z2.enum(["admin", "chef", "manager"]).default("chef"),
      googleId: z2.string().optional(),
      facebookId: z2.string().optional(),
      firebaseUid: z2.string().optional(),
      isChef: z2.boolean().default(false),
      isManager: z2.boolean().default(false),
      isPortalUser: z2.boolean().default(false)
    });
    microlearningCompletions = pgTable("microlearning_completions", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").references(() => users.id).notNull(),
      completedAt: timestamp("completed_at").defaultNow().notNull(),
      confirmed: boolean("confirmed").default(false).notNull(),
      certificateGenerated: boolean("certificate_generated").default(false).notNull(),
      videoProgress: jsonb("video_progress"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    videoProgress = pgTable("video_progress", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").references(() => users.id).notNull(),
      videoId: text("video_id").notNull(),
      progress: numeric("progress", { precision: 5, scale: 2 }).default("0").notNull(),
      completed: boolean("completed").default(false).notNull(),
      completedAt: timestamp("completed_at"),
      updatedAt: timestamp("updated_at").defaultNow().notNull(),
      watchedPercentage: numeric("watched_percentage", { precision: 5, scale: 2 }).default("0").notNull(),
      isRewatching: boolean("is_rewatching").default(false).notNull()
    });
    insertMicrolearningCompletionSchema = createInsertSchema(microlearningCompletions, {
      userId: z2.number(),
      confirmed: z2.boolean().optional(),
      certificateGenerated: z2.boolean().optional(),
      videoProgress: z2.any().optional()
    }).omit({
      id: true,
      completedAt: true,
      createdAt: true,
      updatedAt: true
    });
    insertVideoProgressSchema = createInsertSchema(videoProgress, {
      userId: z2.number(),
      videoId: z2.string().min(1, "Video ID is required"),
      progress: z2.number().min(0).max(100).optional(),
      completed: z2.boolean().optional(),
      watchedPercentage: z2.number().min(0).max(100).optional(),
      isRewatching: z2.boolean().optional()
    }).omit({
      id: true,
      completedAt: true,
      updatedAt: true
    });
    locations = pgTable("locations", {
      id: serial("id").primaryKey(),
      name: text("name").notNull(),
      address: text("address").notNull(),
      managerId: integer("manager_id").references(() => users.id),
      notificationEmail: text("notification_email"),
      // Email where notifications will be sent
      notificationPhone: text("notification_phone"),
      // Phone number where SMS notifications will be sent
      cancellationPolicyHours: integer("cancellation_policy_hours").default(24).notNull(),
      cancellationPolicyMessage: text("cancellation_policy_message").default("Bookings cannot be cancelled within {hours} hours of the scheduled time.").notNull(),
      defaultDailyBookingLimit: integer("default_daily_booking_limit").default(2).notNull(),
      minimumBookingWindowHours: integer("minimum_booking_window_hours").default(1).notNull(),
      logoUrl: text("logo_url"),
      // Logo URL for the location (for manager header)
      brandImageUrl: text("brand_image_url"),
      // Brand image URL for the location (displayed on public kitchen listings)
      timezone: text("timezone").default("America/St_Johns").notNull(),
      // Timezone for this location (default: Newfoundland)
      // Kitchen license fields for manager onboarding
      kitchenLicenseUrl: text("kitchen_license_url"),
      // URL to uploaded kitchen license document
      kitchenLicenseStatus: text("kitchen_license_status").default("pending"),
      // pending, approved, rejected
      kitchenLicenseApprovedBy: integer("kitchen_license_approved_by").references(() => users.id),
      // Admin who approved/rejected
      kitchenLicenseApprovedAt: timestamp("kitchen_license_approved_at"),
      // When license was approved/rejected
      kitchenLicenseFeedback: text("kitchen_license_feedback"),
      // Admin feedback on license
      kitchenLicenseExpiry: date("kitchen_license_expiry"),
      // Expiration date of the kitchen license
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    locationRequirements = pgTable("location_requirements", {
      id: serial("id").primaryKey(),
      locationId: integer("location_id").references(() => locations.id, { onDelete: "cascade" }).notNull().unique(),
      // Personal Information
      requireFirstName: boolean("require_first_name").default(true).notNull(),
      requireLastName: boolean("require_last_name").default(true).notNull(),
      requireEmail: boolean("require_email").default(true).notNull(),
      requirePhone: boolean("require_phone").default(true).notNull(),
      // Business Information
      requireBusinessName: boolean("require_business_name").default(true).notNull(),
      requireBusinessType: boolean("require_business_type").default(true).notNull(),
      requireExperience: boolean("require_experience").default(true).notNull(),
      requireBusinessDescription: boolean("require_business_description").default(false).notNull(),
      // Certifications
      requireFoodHandlerCert: boolean("require_food_handler_cert").default(true).notNull(),
      requireFoodHandlerExpiry: boolean("require_food_handler_expiry").default(true).notNull(),
      requireFoodEstablishmentCert: boolean("require_food_establishment_cert").default(false).notNull(),
      requireFoodEstablishmentExpiry: boolean("require_food_establishment_expiry").default(false).notNull(),
      // Kitchen Usage
      requireUsageFrequency: boolean("require_usage_frequency").default(true).notNull(),
      requireSessionDuration: boolean("require_session_duration").default(true).notNull(),
      // Agreements
      requireTermsAgree: boolean("require_terms_agree").default(true).notNull(),
      requireAccuracyAgree: boolean("require_accuracy_agree").default(true).notNull(),
      // Custom Fields (JSONB array of field definitions)
      customFields: jsonb("custom_fields").default([]),
      // Array of { id, label, type, required, options?, placeholder? }
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    kitchens = pgTable("kitchens", {
      id: serial("id").primaryKey(),
      locationId: integer("location_id").references(() => locations.id).notNull(),
      name: text("name").notNull(),
      description: text("description"),
      imageUrl: text("image_url"),
      // Image URL for the kitchen (displayed on public kitchen listings)
      galleryImages: jsonb("gallery_images").default([]),
      // Array of image URLs for kitchen gallery carousel
      amenities: jsonb("amenities").default([]),
      // Array of amenities/features for the kitchen
      isActive: boolean("is_active").default(true).notNull(),
      // Pricing fields (all prices stored as integers in cents to avoid floating-point precision issues)
      hourlyRate: numeric("hourly_rate"),
      // Base hourly rate in cents (e.g., 5000 = $50.00/hour)
      currency: text("currency").default("CAD").notNull(),
      // Currency code (ISO 4217)
      minimumBookingHours: integer("minimum_booking_hours").default(1).notNull(),
      // Minimum booking duration
      pricingModel: text("pricing_model").default("hourly").notNull(),
      // Pricing structure ('hourly', 'daily', 'weekly')
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    kitchenAvailability = pgTable("kitchen_availability", {
      id: serial("id").primaryKey(),
      kitchenId: integer("kitchen_id").references(() => kitchens.id).notNull(),
      dayOfWeek: integer("day_of_week").notNull(),
      // 0-6, Sunday is 0
      startTime: text("start_time").notNull(),
      // HH:MM format
      endTime: text("end_time").notNull(),
      // HH:MM format
      isAvailable: boolean("is_available").default(true).notNull()
    });
    kitchenDateOverrides = pgTable("kitchen_date_overrides", {
      id: serial("id").primaryKey(),
      kitchenId: integer("kitchen_id").references(() => kitchens.id).notNull(),
      specificDate: timestamp("specific_date").notNull(),
      // Specific date for override
      startTime: text("start_time"),
      // HH:MM format, null if closed all day
      endTime: text("end_time"),
      // HH:MM format, null if closed all day
      isAvailable: boolean("is_available").default(false).notNull(),
      // false = closed, true = custom hours
      reason: text("reason"),
      // Optional reason (e.g., "Holiday", "Maintenance")
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    kitchenBookings = pgTable("kitchen_bookings", {
      id: serial("id").primaryKey(),
      chefId: integer("chef_id").references(() => users.id),
      // Nullable for external/third-party bookings
      kitchenId: integer("kitchen_id").references(() => kitchens.id).notNull(),
      bookingDate: timestamp("booking_date").notNull(),
      startTime: text("start_time").notNull(),
      // HH:MM format
      endTime: text("end_time").notNull(),
      // HH:MM format
      status: bookingStatusEnum("status").default("pending").notNull(),
      specialNotes: text("special_notes"),
      bookingType: text("booking_type").default("chef").notNull(),
      // 'chef', 'external', 'manager_blocked'
      createdBy: integer("created_by").references(() => users.id),
      // Manager who created the booking (for external/manual bookings)
      externalContactName: text("external_contact_name"),
      // For third-party bookings
      externalContactEmail: text("external_contact_email"),
      // For third-party bookings
      externalContactPhone: text("external_contact_phone"),
      // For third-party bookings
      externalContactCompany: text("external_contact_company"),
      // For third-party bookings
      // Pricing fields (all prices stored as integers in cents)
      totalPrice: numeric("total_price"),
      // Total booking price in cents
      hourlyRate: numeric("hourly_rate"),
      // Rate used for this booking (in cents)
      durationHours: numeric("duration_hours"),
      // Calculated duration (decimal for partial hours)
      storageItems: jsonb("storage_items").default([]),
      // Array of storage booking IDs: [{storageBookingId: 1, storageListingId: 5}]
      equipmentItems: jsonb("equipment_items").default([]),
      // Array of equipment booking IDs: [{equipmentBookingId: 2, equipmentListingId: 8}]
      paymentStatus: paymentStatusEnum("payment_status").default("pending"),
      // Payment status
      paymentIntentId: text("payment_intent_id"),
      // Stripe PaymentIntent ID (nullable, unique)
      damageDeposit: numeric("damage_deposit").default("0"),
      // Damage deposit amount (in cents)
      serviceFee: numeric("service_fee").default("0"),
      // Platform commission (in cents)
      currency: text("currency").default("CAD").notNull(),
      // Currency code
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    chefLocationAccess = pgTable("chef_location_access", {
      id: serial("id").primaryKey(),
      chefId: integer("chef_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      locationId: integer("location_id").references(() => locations.id, { onDelete: "cascade" }).notNull(),
      grantedBy: integer("granted_by").references(() => users.id, { onDelete: "cascade" }).notNull(),
      // admin who granted access
      grantedAt: timestamp("granted_at").defaultNow().notNull()
    });
    chefKitchenAccess = pgTable("chef_kitchen_access", {
      id: serial("id").primaryKey(),
      chefId: integer("chef_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      kitchenId: integer("kitchen_id").references(() => kitchens.id, { onDelete: "cascade" }).notNull(),
      grantedBy: integer("granted_by").references(() => users.id, { onDelete: "cascade" }).notNull(),
      grantedAt: timestamp("granted_at").defaultNow().notNull()
    });
    chefKitchenProfiles = pgTable("chef_kitchen_profiles", {
      id: serial("id").primaryKey(),
      chefId: integer("chef_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      kitchenId: integer("kitchen_id").references(() => kitchens.id, { onDelete: "cascade" }).notNull(),
      status: text("status").default("pending").notNull(),
      // 'pending', 'approved', 'rejected'
      sharedAt: timestamp("shared_at").defaultNow().notNull(),
      reviewedBy: integer("reviewed_by").references(() => users.id, { onDelete: "set null" }),
      // manager who reviewed
      reviewedAt: timestamp("reviewed_at"),
      reviewFeedback: text("review_feedback")
      // optional feedback from manager
    });
    chefLocationProfiles = pgTable("chef_location_profiles", {
      id: serial("id").primaryKey(),
      chefId: integer("chef_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      locationId: integer("location_id").references(() => locations.id, { onDelete: "cascade" }).notNull(),
      status: text("status").default("pending").notNull(),
      // 'pending', 'approved', 'rejected'
      sharedAt: timestamp("shared_at").defaultNow().notNull(),
      reviewedBy: integer("reviewed_by").references(() => users.id, { onDelete: "set null" }),
      // manager who reviewed
      reviewedAt: timestamp("reviewed_at"),
      reviewFeedback: text("review_feedback")
      // optional feedback from manager
    });
    portalUserApplications = pgTable("portal_user_applications", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      locationId: integer("location_id").references(() => locations.id, { onDelete: "cascade" }).notNull(),
      fullName: text("full_name").notNull(),
      email: text("email").notNull(),
      phone: text("phone").notNull(),
      company: text("company"),
      // Optional company name
      status: applicationStatusEnum("status").default("inReview").notNull(),
      // 'inReview', 'approved', 'rejected', 'cancelled'
      feedback: text("feedback"),
      // Manager feedback
      reviewedBy: integer("reviewed_by").references(() => users.id, { onDelete: "set null" }),
      // manager who reviewed
      reviewedAt: timestamp("reviewed_at"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    portalUserLocationAccess = pgTable("portal_user_location_access", {
      id: serial("id").primaryKey(),
      portalUserId: integer("portal_user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      locationId: integer("location_id").references(() => locations.id, { onDelete: "cascade" }).notNull(),
      grantedBy: integer("granted_by").references(() => users.id, { onDelete: "cascade" }).notNull(),
      // manager who granted access
      grantedAt: timestamp("granted_at").defaultNow().notNull(),
      applicationId: integer("application_id").references(() => portalUserApplications.id, { onDelete: "set null" })
      // Link to original application
    });
    insertLocationSchema = createInsertSchema(locations, {
      name: z2.string().min(2, "Location name must be at least 2 characters"),
      address: z2.string().min(5, "Address must be at least 5 characters"),
      managerId: z2.number().optional(),
      notificationEmail: z2.string().email("Please enter a valid email address").optional(),
      notificationPhone: optionalPhoneNumberSchema
      // Optional phone for SMS notifications
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateLocationSchema = z2.object({
      id: z2.number(),
      name: z2.string().min(2).optional(),
      address: z2.string().min(5).optional(),
      managerId: z2.number().optional(),
      notificationEmail: z2.string().email("Please enter a valid email address").optional(),
      notificationPhone: optionalPhoneNumberSchema
      // Optional phone for SMS notifications
    });
    insertLocationRequirementsSchema = createInsertSchema(locationRequirements, {
      locationId: z2.number()
    }).omit({ id: true, createdAt: true, updatedAt: true });
    customFieldSchema = z2.object({
      id: z2.string(),
      // Unique identifier for the field
      label: z2.string().min(1, "Label is required"),
      type: z2.enum(["text", "textarea", "number", "select", "checkbox", "date"]),
      required: z2.boolean().default(false),
      placeholder: z2.string().optional(),
      options: z2.array(z2.string()).optional()
      // For select fields
    });
    updateLocationRequirementsSchema = z2.object({
      requireFirstName: z2.boolean().optional(),
      requireLastName: z2.boolean().optional(),
      requireEmail: z2.boolean().optional(),
      requirePhone: z2.boolean().optional(),
      requireBusinessName: z2.boolean().optional(),
      requireBusinessType: z2.boolean().optional(),
      requireExperience: z2.boolean().optional(),
      requireBusinessDescription: z2.boolean().optional(),
      requireFoodHandlerCert: z2.boolean().optional(),
      requireFoodHandlerExpiry: z2.boolean().optional(),
      requireFoodEstablishmentCert: z2.boolean().optional(),
      requireFoodEstablishmentExpiry: z2.boolean().optional(),
      requireUsageFrequency: z2.boolean().optional(),
      requireSessionDuration: z2.boolean().optional(),
      requireTermsAgree: z2.boolean().optional(),
      requireAccuracyAgree: z2.boolean().optional(),
      customFields: z2.array(customFieldSchema).optional()
    });
    insertKitchenSchema = createInsertSchema(kitchens, {
      locationId: z2.number(),
      name: z2.string().min(1, "Kitchen name is required"),
      description: z2.string().optional(),
      isActive: z2.boolean().optional(),
      hourlyRate: z2.number().int().positive("Hourly rate must be positive").optional(),
      currency: z2.string().min(3).max(3).optional(),
      minimumBookingHours: z2.number().int().positive("Minimum booking hours must be positive").optional(),
      pricingModel: z2.enum(["hourly", "daily", "weekly"]).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateKitchenSchema = z2.object({
      id: z2.number(),
      name: z2.string().min(1).optional(),
      description: z2.string().optional(),
      isActive: z2.boolean().optional(),
      hourlyRate: z2.number().int().positive("Hourly rate must be positive").optional(),
      currency: z2.string().min(3).max(3).optional(),
      minimumBookingHours: z2.number().int().positive("Minimum booking hours must be positive").optional(),
      pricingModel: z2.enum(["hourly", "daily", "weekly"]).optional()
    });
    insertKitchenAvailabilitySchema = createInsertSchema(kitchenAvailability, {
      kitchenId: z2.number(),
      dayOfWeek: z2.number().min(0).max(6),
      startTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)"),
      endTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)"),
      isAvailable: z2.boolean().optional()
    }).omit({
      id: true
    });
    insertKitchenDateOverrideSchema = createInsertSchema(kitchenDateOverrides, {
      kitchenId: z2.number(),
      specificDate: z2.string().or(z2.date()),
      startTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)").optional(),
      endTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)").optional(),
      isAvailable: z2.boolean().optional(),
      reason: z2.string().optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateKitchenDateOverrideSchema = z2.object({
      id: z2.number(),
      startTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)").optional(),
      endTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)").optional(),
      isAvailable: z2.boolean().optional(),
      reason: z2.string().optional()
    });
    insertKitchenBookingSchema = createInsertSchema(kitchenBookings, {
      chefId: z2.number(),
      // REQUIRED - matches actual DB
      kitchenId: z2.number(),
      bookingDate: z2.string().or(z2.date()),
      startTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)"),
      endTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)"),
      status: z2.enum(["pending", "confirmed", "cancelled"]).optional(),
      specialNotes: z2.string().optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateKitchenBookingSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["pending", "confirmed", "cancelled"]).optional(),
      specialNotes: z2.string().optional()
    });
    insertChefLocationAccessSchema = createInsertSchema(chefLocationAccess, {
      chefId: z2.number(),
      locationId: z2.number(),
      grantedBy: z2.number()
    }).omit({
      id: true,
      grantedAt: true
    });
    insertChefKitchenAccessSchema = createInsertSchema(chefKitchenAccess, {
      chefId: z2.number(),
      kitchenId: z2.number(),
      grantedBy: z2.number()
    }).omit({
      id: true,
      grantedAt: true
    });
    insertChefKitchenProfileSchema = createInsertSchema(chefKitchenProfiles, {
      chefId: z2.number(),
      kitchenId: z2.number(),
      status: z2.enum(["pending", "approved", "rejected"]).optional()
    }).omit({
      id: true,
      sharedAt: true,
      reviewedBy: true,
      reviewedAt: true,
      reviewFeedback: true
    });
    updateChefKitchenProfileSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["pending", "approved", "rejected"]),
      reviewFeedback: z2.string().optional()
    });
    insertChefLocationProfileSchema = createInsertSchema(chefLocationProfiles, {
      chefId: z2.number(),
      locationId: z2.number(),
      status: z2.enum(["pending", "approved", "rejected"]).optional()
    }).omit({
      id: true,
      sharedAt: true,
      reviewedBy: true,
      reviewedAt: true,
      reviewFeedback: true
    });
    updateChefLocationProfileSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["pending", "approved", "rejected"]),
      reviewFeedback: z2.string().optional()
    });
    insertPortalUserApplicationSchema = createInsertSchema(portalUserApplications, {
      userId: z2.number(),
      locationId: z2.number(),
      fullName: z2.string().min(2, "Name must be at least 2 characters"),
      email: z2.string().email("Please enter a valid email address"),
      phone: phoneNumberSchema,
      // Uses shared phone validation
      company: z2.string().optional()
    }).omit({
      id: true,
      status: true,
      createdAt: true,
      reviewedBy: true,
      reviewedAt: true,
      feedback: true
    });
    updatePortalUserApplicationStatusSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["inReview", "approved", "rejected", "cancelled"]),
      feedback: z2.string().optional()
    });
    insertPortalUserLocationAccessSchema = createInsertSchema(portalUserLocationAccess, {
      portalUserId: z2.number(),
      locationId: z2.number(),
      grantedBy: z2.number(),
      applicationId: z2.number().optional()
    }).omit({
      id: true,
      grantedAt: true
    });
    storageListings = pgTable("storage_listings", {
      id: serial("id").primaryKey(),
      kitchenId: integer("kitchen_id").references(() => kitchens.id, { onDelete: "cascade" }).notNull(),
      storageType: storageTypeEnum("storage_type").notNull(),
      name: text("name").notNull(),
      description: text("description"),
      // Physical specifications
      dimensionsLength: numeric("dimensions_length"),
      // feet/meters
      dimensionsWidth: numeric("dimensions_width"),
      dimensionsHeight: numeric("dimensions_height"),
      totalVolume: numeric("total_volume"),
      // cubic feet/meters (auto-calculated)
      shelfCount: integer("shelf_count"),
      shelfMaterial: text("shelf_material"),
      accessType: text("access_type"),
      // 'walk-in', 'shelving-unit', 'rack-system'
      // Features & amenities (JSONB for flexibility - following existing pattern)
      features: jsonb("features").default([]),
      securityFeatures: jsonb("security_features").default([]),
      climateControl: boolean("climate_control").default(false),
      temperatureRange: text("temperature_range"),
      // "35-40Â°F"
      humidityControl: boolean("humidity_control").default(false),
      powerOutlets: integer("power_outlets").default(0),
      // Pricing (all in cents)
      pricingModel: storagePricingModelEnum("pricing_model").notNull(),
      basePrice: numeric("base_price").notNull(),
      // Base price in cents (integer)
      pricePerCubicFoot: numeric("price_per_cubic_foot"),
      // For per-cubic-foot model (in cents)
      // Booking duration (flexible: hourly, daily, or monthly)
      minimumBookingDuration: integer("minimum_booking_duration").default(1).notNull(),
      // Minimum booking duration (number)
      bookingDurationUnit: bookingDurationUnitEnum("booking_duration_unit").default("monthly").notNull(),
      // Unit: hourly, daily, or monthly
      currency: text("currency").default("CAD").notNull(),
      // Locked to CAD
      // Status & moderation (admin approval workflow)
      status: listingStatusEnum("status").default("draft").notNull(),
      approvedBy: integer("approved_by").references(() => users.id, { onDelete: "set null" }),
      // Admin who approved
      approvedAt: timestamp("approved_at"),
      rejectionReason: text("rejection_reason"),
      // If rejected by admin
      // Availability
      isActive: boolean("is_active").default(true).notNull(),
      availabilityCalendar: jsonb("availability_calendar").default({}),
      // Blocked dates, maintenance windows
      // Compliance & documentation
      certifications: jsonb("certifications").default([]),
      photos: jsonb("photos").default([]),
      // Array of image URLs
      documents: jsonb("documents").default([]),
      // Array of document URLs
      // Rules & restrictions
      houseRules: jsonb("house_rules").default([]),
      prohibitedItems: jsonb("prohibited_items").default([]),
      insuranceRequired: boolean("insurance_required").default(false),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertStorageListingSchema = createInsertSchema(storageListings, {
      kitchenId: z2.number(),
      name: z2.string().min(3, "Name must be at least 3 characters"),
      storageType: z2.enum(["dry", "cold", "freezer"]),
      pricingModel: z2.enum(["monthly-flat", "per-cubic-foot", "hourly", "daily"]),
      basePrice: z2.number().int().positive("Base price must be positive"),
      pricePerCubicFoot: z2.number().int().positive("Price per cubic foot must be positive").optional(),
      minimumBookingDuration: z2.number().int().positive("Minimum booking duration must be positive").optional(),
      bookingDurationUnit: z2.enum(["hourly", "daily", "monthly"]).optional(),
      dimensionsLength: z2.number().positive().optional(),
      dimensionsWidth: z2.number().positive().optional(),
      dimensionsHeight: z2.number().positive().optional(),
      totalVolume: z2.number().positive().optional(),
      shelfCount: z2.number().int().min(0).optional(),
      temperatureRange: z2.string().optional(),
      features: z2.array(z2.string()).optional(),
      securityFeatures: z2.array(z2.string()).optional(),
      certifications: z2.array(z2.string()).optional(),
      photos: z2.array(z2.string()).optional(),
      documents: z2.array(z2.string()).optional(),
      houseRules: z2.array(z2.string()).optional(),
      prohibitedItems: z2.array(z2.string()).optional(),
      availabilityCalendar: z2.record(z2.any()).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      status: true,
      approvedBy: true,
      approvedAt: true,
      rejectionReason: true,
      currency: true
      // Always CAD, not user-selectable
    });
    updateStorageListingSchema = z2.object({
      id: z2.number(),
      name: z2.string().min(3).optional(),
      description: z2.string().optional(),
      storageType: z2.enum(["dry", "cold", "freezer"]).optional(),
      pricingModel: z2.enum(["monthly-flat", "per-cubic-foot", "hourly", "daily"]).optional(),
      basePrice: z2.number().int().positive().optional(),
      pricePerCubicFoot: z2.number().int().positive().optional(),
      minimumBookingDuration: z2.number().int().positive().optional(),
      bookingDurationUnit: z2.enum(["hourly", "daily", "monthly"]).optional(),
      dimensionsLength: z2.number().positive().optional(),
      dimensionsWidth: z2.number().positive().optional(),
      dimensionsHeight: z2.number().positive().optional(),
      totalVolume: z2.number().positive().optional(),
      shelfCount: z2.number().int().min(0).optional(),
      shelfMaterial: z2.string().optional(),
      accessType: z2.string().optional(),
      temperatureRange: z2.string().optional(),
      climateControl: z2.boolean().optional(),
      humidityControl: z2.boolean().optional(),
      powerOutlets: z2.number().int().min(0).optional(),
      isActive: z2.boolean().optional(),
      insuranceRequired: z2.boolean().optional(),
      features: z2.array(z2.string()).optional(),
      securityFeatures: z2.array(z2.string()).optional(),
      certifications: z2.array(z2.string()).optional(),
      photos: z2.array(z2.string()).optional(),
      documents: z2.array(z2.string()).optional(),
      houseRules: z2.array(z2.string()).optional(),
      prohibitedItems: z2.array(z2.string()).optional(),
      availabilityCalendar: z2.record(z2.any()).optional()
    });
    updateStorageListingStatusSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["draft", "pending", "approved", "rejected", "active", "inactive"]),
      rejectionReason: z2.string().optional()
    });
    equipmentListings = pgTable("equipment_listings", {
      id: serial("id").primaryKey(),
      kitchenId: integer("kitchen_id").references(() => kitchens.id, { onDelete: "cascade" }).notNull(),
      // Category & type
      category: equipmentCategoryEnum("category").notNull(),
      equipmentType: text("equipment_type").notNull(),
      // 'mixer', 'oven', 'fryer', etc.
      brand: text("brand"),
      model: text("model"),
      // Specifications
      description: text("description"),
      condition: equipmentConditionEnum("condition").notNull(),
      age: integer("age"),
      // years
      serviceHistory: text("service_history"),
      dimensions: jsonb("dimensions").default({}),
      // {width, depth, height, weight}
      powerRequirements: text("power_requirements"),
      // '110V', '208V', '240V', '3-phase'
      // Equipment-specific fields (JSONB for flexibility)
      specifications: jsonb("specifications").default({}),
      certifications: jsonb("certifications").default([]),
      safetyFeatures: jsonb("safety_features").default([]),
      // Availability type: included (free with kitchen) or rental (paid addon)
      availabilityType: equipmentAvailabilityTypeEnum("availability_type").default("rental").notNull(),
      // Pricing - SIMPLIFIED to flat session rate (in cents)
      // For rental equipment: charged once per kitchen booking session, regardless of duration
      sessionRate: numeric("session_rate").default("0"),
      // Flat session rate in cents (e.g., 2500 = $25.00/session)
      pricingModel: equipmentPricingModelEnum("pricing_model"),
      // Nullable for included equipment
      // Legacy rate fields - kept for backwards compatibility but session_rate is primary
      hourlyRate: numeric("hourly_rate"),
      // @deprecated - use sessionRate
      dailyRate: numeric("daily_rate"),
      // @deprecated - use sessionRate
      weeklyRate: numeric("weekly_rate"),
      // @deprecated - use sessionRate
      monthlyRate: numeric("monthly_rate"),
      // @deprecated - use sessionRate
      minimumRentalHours: integer("minimum_rental_hours"),
      // @deprecated
      minimumRentalDays: integer("minimum_rental_days"),
      // @deprecated
      currency: text("currency").default("CAD").notNull(),
      // Usage terms
      usageRestrictions: jsonb("usage_restrictions").default([]),
      trainingRequired: boolean("training_required").default(false),
      cleaningResponsibility: text("cleaning_responsibility"),
      // 'renter', 'host', 'shared'
      // Status & moderation (admin approval workflow)
      status: listingStatusEnum("status").default("draft").notNull(),
      // Reuse same enum
      approvedBy: integer("approved_by").references(() => users.id, { onDelete: "set null" }),
      approvedAt: timestamp("approved_at"),
      rejectionReason: text("rejection_reason"),
      // Availability
      isActive: boolean("is_active").default(true).notNull(),
      availabilityCalendar: jsonb("availability_calendar").default({}),
      prepTimeHours: integer("prep_time_hours").default(4),
      // Cleaning time between rentals
      // Visuals & documentation
      photos: jsonb("photos").default([]),
      manuals: jsonb("manuals").default([]),
      // PDF URLs
      maintenanceLog: jsonb("maintenance_log").default([]),
      // Damage & liability (deposits in cents)
      damageDeposit: numeric("damage_deposit").default("0"),
      // Refundable deposit (in cents)
      insuranceRequired: boolean("insurance_required").default(false),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertEquipmentListingSchema = createInsertSchema(equipmentListings, {
      kitchenId: z2.number(),
      category: z2.enum(["food-prep", "cooking", "refrigeration", "cleaning", "specialty"]),
      equipmentType: z2.string().min(1, "Equipment type is required"),
      condition: z2.enum(["excellent", "good", "fair", "needs-repair"]),
      availabilityType: z2.enum(["included", "rental"]),
      pricingModel: z2.enum(["hourly", "daily", "weekly", "monthly"]).optional(),
      // Optional for included equipment
      hourlyRate: z2.number().int().positive("Hourly rate must be positive").optional(),
      dailyRate: z2.number().int().positive("Daily rate must be positive").optional(),
      weeklyRate: z2.number().int().positive("Weekly rate must be positive").optional(),
      monthlyRate: z2.number().int().positive("Monthly rate must be positive").optional(),
      minimumRentalHours: z2.number().int().min(1).optional(),
      minimumRentalDays: z2.number().int().min(1).optional(),
      damageDeposit: z2.number().int().min(0).optional(),
      age: z2.number().int().min(0).optional(),
      prepTimeHours: z2.number().int().min(0).optional(),
      dimensions: z2.record(z2.any()).optional(),
      specifications: z2.record(z2.any()).optional(),
      certifications: z2.array(z2.string()).optional(),
      safetyFeatures: z2.array(z2.string()).optional(),
      usageRestrictions: z2.array(z2.string()).optional(),
      photos: z2.array(z2.string()).optional(),
      manuals: z2.array(z2.string()).optional(),
      maintenanceLog: z2.array(z2.any()).optional(),
      availabilityCalendar: z2.record(z2.any()).optional(),
      cleaningResponsibility: z2.enum(["renter", "host", "shared"]).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      status: true,
      approvedBy: true,
      approvedAt: true,
      rejectionReason: true,
      currency: true
      // Always CAD, not user-selectable
    });
    updateEquipmentListingSchema = z2.object({
      id: z2.number(),
      category: z2.enum(["food-prep", "cooking", "refrigeration", "cleaning", "specialty"]).optional(),
      equipmentType: z2.string().min(1).optional(),
      brand: z2.string().optional(),
      model: z2.string().optional(),
      description: z2.string().optional(),
      condition: z2.enum(["excellent", "good", "fair", "needs-repair"]).optional(),
      age: z2.number().int().min(0).optional(),
      serviceHistory: z2.string().optional(),
      dimensions: z2.record(z2.any()).optional(),
      powerRequirements: z2.string().optional(),
      specifications: z2.record(z2.any()).optional(),
      availabilityType: z2.enum(["included", "rental"]).optional(),
      pricingModel: z2.enum(["hourly", "daily", "weekly", "monthly"]).optional(),
      hourlyRate: z2.number().int().positive().optional(),
      dailyRate: z2.number().int().positive().optional(),
      weeklyRate: z2.number().int().positive().optional(),
      monthlyRate: z2.number().int().positive().optional(),
      minimumRentalHours: z2.number().int().min(1).optional(),
      minimumRentalDays: z2.number().int().min(1).optional(),
      usageRestrictions: z2.array(z2.string()).optional(),
      trainingRequired: z2.boolean().optional(),
      cleaningResponsibility: z2.enum(["renter", "host", "shared"]).optional(),
      isActive: z2.boolean().optional(),
      prepTimeHours: z2.number().int().min(0).optional(),
      damageDeposit: z2.number().int().min(0).optional(),
      insuranceRequired: z2.boolean().optional(),
      certifications: z2.array(z2.string()).optional(),
      safetyFeatures: z2.array(z2.string()).optional(),
      photos: z2.array(z2.string()).optional(),
      manuals: z2.array(z2.string()).optional(),
      maintenanceLog: z2.array(z2.any()).optional(),
      availabilityCalendar: z2.record(z2.any()).optional()
    });
    updateEquipmentListingStatusSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["draft", "pending", "approved", "rejected", "active", "inactive"]),
      rejectionReason: z2.string().optional()
    });
    storageBookings = pgTable("storage_bookings", {
      id: serial("id").primaryKey(),
      storageListingId: integer("storage_listing_id").references(() => storageListings.id, { onDelete: "cascade" }).notNull(),
      kitchenBookingId: integer("kitchen_booking_id").references(() => kitchenBookings.id, { onDelete: "cascade" }),
      // NULLABLE - storage can be booked independently
      chefId: integer("chef_id").references(() => users.id, { onDelete: "set null" }),
      // Chef making the booking
      startDate: timestamp("start_date").notNull(),
      endDate: timestamp("end_date").notNull(),
      status: bookingStatusEnum("status").default("pending").notNull(),
      totalPrice: numeric("total_price").notNull(),
      // In cents (daily_rate Ã number_of_days)
      pricingModel: storagePricingModelEnum("pricing_model").notNull(),
      // Always 'daily' now
      paymentStatus: paymentStatusEnum("payment_status").default("pending"),
      paymentIntentId: text("payment_intent_id"),
      // Stripe PaymentIntent ID
      serviceFee: numeric("service_fee").default("0"),
      // Platform commission in cents
      currency: text("currency").default("CAD").notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertStorageBookingSchema = createInsertSchema(storageBookings, {
      storageListingId: z2.number(),
      kitchenBookingId: z2.number().optional().nullable(),
      // Optional - for standalone storage bookings
      chefId: z2.number().optional(),
      startDate: z2.string().or(z2.date()),
      endDate: z2.string().or(z2.date()),
      status: z2.enum(["pending", "confirmed", "cancelled"]).optional(),
      totalPrice: z2.number().int().positive("Total price must be positive"),
      pricingModel: z2.enum(["monthly-flat", "per-cubic-foot", "hourly", "daily"]),
      paymentStatus: z2.enum(["pending", "paid", "refunded", "failed", "partially_refunded"]).optional(),
      paymentIntentId: z2.string().optional(),
      serviceFee: z2.number().int().min(0).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      currency: true
      // Always CAD, not user-selectable
    });
    updateStorageBookingSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["pending", "confirmed", "cancelled"]).optional(),
      paymentStatus: z2.enum(["pending", "paid", "refunded", "failed", "partially_refunded"]).optional(),
      paymentIntentId: z2.string().optional(),
      serviceFee: z2.number().int().min(0).optional()
    });
    updateStorageBookingStatusSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["pending", "confirmed", "cancelled"])
    });
    equipmentBookings = pgTable("equipment_bookings", {
      id: serial("id").primaryKey(),
      equipmentListingId: integer("equipment_listing_id").references(() => equipmentListings.id, { onDelete: "cascade" }).notNull(),
      kitchenBookingId: integer("kitchen_booking_id").references(() => kitchenBookings.id, { onDelete: "cascade" }).notNull(),
      // REQUIRED - no standalone bookings
      chefId: integer("chef_id").references(() => users.id, { onDelete: "set null" }),
      // Nullable for external bookings
      startDate: timestamp("start_date").notNull(),
      endDate: timestamp("end_date").notNull(),
      status: bookingStatusEnum("status").default("pending").notNull(),
      // Reuse existing enum
      totalPrice: numeric("total_price").notNull(),
      // In cents
      pricingModel: equipmentPricingModelEnum("pricing_model").notNull(),
      // Reuse enum
      damageDeposit: numeric("damage_deposit").default("0"),
      // In cents (only for rental)
      paymentStatus: paymentStatusEnum("payment_status").default("pending"),
      // Reuse enum
      paymentIntentId: text("payment_intent_id"),
      // Stripe PaymentIntent ID (nullable, unique)
      serviceFee: numeric("service_fee").default("0"),
      // Platform commission in cents
      currency: text("currency").default("CAD").notNull(),
      // NOTE: No delivery/pickup fields - equipment stays in kitchen
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertEquipmentBookingSchema = createInsertSchema(equipmentBookings, {
      equipmentListingId: z2.number(),
      kitchenBookingId: z2.number(),
      chefId: z2.number().optional(),
      startDate: z2.string().or(z2.date()),
      endDate: z2.string().or(z2.date()),
      status: z2.enum(["pending", "confirmed", "cancelled"]).optional(),
      totalPrice: z2.number().int().positive("Total price must be positive"),
      pricingModel: z2.enum(["hourly", "daily", "weekly", "monthly"]),
      damageDeposit: z2.number().int().min(0).optional(),
      paymentStatus: z2.enum(["pending", "paid", "refunded", "failed", "partially_refunded"]).optional(),
      paymentIntentId: z2.string().optional(),
      serviceFee: z2.number().int().min(0).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      currency: true
      // Always CAD, not user-selectable
    });
    updateEquipmentBookingSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["pending", "confirmed", "cancelled"]).optional(),
      paymentStatus: z2.enum(["pending", "paid", "refunded", "failed", "partially_refunded"]).optional(),
      paymentIntentId: z2.string().optional(),
      damageDeposit: z2.number().int().min(0).optional(),
      serviceFee: z2.number().int().min(0).optional()
    });
    updateEquipmentBookingStatusSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["pending", "confirmed", "cancelled"])
    });
    platformSettings = pgTable("platform_settings", {
      id: serial("id").primaryKey(),
      key: text("key").notNull().unique(),
      value: text("value").notNull(),
      description: text("description"),
      updatedBy: integer("updated_by").references(() => users.id),
      updatedAt: timestamp("updated_at").defaultNow().notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    insertPlatformSettingSchema = createInsertSchema(platformSettings);
    updatePlatformSettingSchema = z2.object({
      value: z2.string().optional(),
      description: z2.string().optional()
    });
    chefKitchenApplications = pgTable("chef_kitchen_applications", {
      id: serial("id").primaryKey(),
      chefId: integer("chef_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      locationId: integer("location_id").references(() => locations.id, { onDelete: "cascade" }).notNull(),
      // Personal Info (collected per application)
      fullName: text("full_name").notNull(),
      email: text("email").notNull(),
      phone: text("phone").notNull(),
      // Business Info
      kitchenPreference: kitchenPreferenceEnum("kitchen_preference").notNull(),
      businessDescription: text("business_description"),
      cookingExperience: text("cooking_experience"),
      // Food Safety License
      foodSafetyLicense: certificationStatusEnum("food_safety_license").notNull(),
      foodSafetyLicenseUrl: text("food_safety_license_url"),
      foodSafetyLicenseStatus: documentVerificationStatusEnum("food_safety_license_status").default("pending"),
      foodSafetyLicenseExpiry: date("food_safety_license_expiry"),
      // Food Establishment Certificate (optional)
      foodEstablishmentCert: certificationStatusEnum("food_establishment_cert").notNull(),
      foodEstablishmentCertUrl: text("food_establishment_cert_url"),
      foodEstablishmentCertStatus: documentVerificationStatusEnum("food_establishment_cert_status").default("pending"),
      foodEstablishmentCertExpiry: date("food_establishment_cert_expiry"),
      // Application Status
      status: applicationStatusEnum("status").default("inReview").notNull(),
      feedback: text("feedback"),
      // Manager Review
      reviewedBy: integer("reviewed_by").references(() => users.id, { onDelete: "set null" }),
      reviewedAt: timestamp("reviewed_at"),
      // Custom Fields Data (JSONB object storing values for custom fields)
      customFieldsData: jsonb("custom_fields_data").default({}),
      // { [fieldId]: value }
      // Timestamps
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertChefKitchenApplicationSchema = createInsertSchema(chefKitchenApplications, {
      chefId: z2.number(),
      locationId: z2.number(),
      fullName: z2.string().min(2, "Name must be at least 2 characters"),
      email: z2.string().email("Please enter a valid email address"),
      phone: phoneNumberSchema,
      kitchenPreference: z2.enum(["commercial", "home", "notSure"]),
      businessDescription: z2.string().optional(),
      cookingExperience: z2.string().optional(),
      foodSafetyLicense: z2.enum(["yes", "no", "notSure"]),
      foodSafetyLicenseUrl: z2.string().optional(),
      foodSafetyLicenseExpiry: z2.string().optional(),
      foodEstablishmentCert: z2.enum(["yes", "no", "notSure"]),
      foodEstablishmentCertUrl: z2.string().optional(),
      foodEstablishmentCertExpiry: z2.string().optional(),
      customFieldsData: z2.record(z2.any()).optional()
      // Custom fields data as JSON object
    }).omit({
      id: true,
      status: true,
      createdAt: true,
      updatedAt: true,
      reviewedBy: true,
      reviewedAt: true,
      feedback: true,
      foodSafetyLicenseStatus: true,
      foodEstablishmentCertStatus: true
    });
    updateChefKitchenApplicationSchema = z2.object({
      id: z2.number(),
      fullName: z2.string().min(2).optional(),
      email: z2.string().email().optional(),
      phone: phoneNumberSchema.optional(),
      kitchenPreference: z2.enum(["commercial", "home", "notSure"]).optional(),
      businessDescription: z2.string().optional(),
      cookingExperience: z2.string().optional(),
      foodSafetyLicenseUrl: z2.string().optional(),
      foodEstablishmentCertUrl: z2.string().optional()
    });
    updateChefKitchenApplicationStatusSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["inReview", "approved", "rejected", "cancelled"]),
      feedback: z2.string().optional()
    });
    updateChefKitchenApplicationDocumentsSchema = z2.object({
      id: z2.number(),
      foodSafetyLicenseUrl: z2.string().optional(),
      foodEstablishmentCertUrl: z2.string().optional(),
      foodSafetyLicenseStatus: z2.enum(["pending", "approved", "rejected"]).optional(),
      foodEstablishmentCertStatus: z2.enum(["pending", "approved", "rejected"]).optional()
    });
    paymentTransactions = pgTable("payment_transactions", {
      id: serial("id").primaryKey(),
      bookingId: integer("booking_id").notNull(),
      // References kitchen_bookings.id, storage_bookings.id, or equipment_bookings.id
      bookingType: bookingTypeEnum("booking_type").notNull(),
      // Which booking table this transaction belongs to
      chefId: integer("chef_id").references(() => users.id, { onDelete: "set null" }),
      // Chef who made the payment
      managerId: integer("manager_id").references(() => users.id, { onDelete: "set null" }),
      // Manager who receives the payment
      // Payment amounts (all in cents)
      amount: numeric("amount").notNull(),
      // Total transaction amount (includes service fee)
      baseAmount: numeric("base_amount").notNull(),
      // Base amount before service fee
      serviceFee: numeric("service_fee").notNull().default("0"),
      // Platform service fee
      managerRevenue: numeric("manager_revenue").notNull(),
      // Manager earnings (base_amount - service_fee)
      refundAmount: numeric("refund_amount").default("0"),
      // Total refunded amount
      netAmount: numeric("net_amount").notNull(),
      // Final amount after refunds (amount - refund_amount)
      currency: text("currency").notNull().default("CAD"),
      // Stripe integration
      paymentIntentId: text("payment_intent_id"),
      // Stripe PaymentIntent ID (nullable, unique when set)
      chargeId: text("charge_id"),
      // Stripe Charge ID
      refundId: text("refund_id"),
      // Stripe Refund ID
      paymentMethodId: text("payment_method_id"),
      // Stripe PaymentMethod ID
      // Status tracking
      status: transactionStatusEnum("status").notNull().default("pending"),
      stripeStatus: text("stripe_status"),
      // Raw Stripe status for comparison
      // Metadata and tracking
      metadata: jsonb("metadata").default({}),
      // Additional metadata
      refundReason: text("refund_reason"),
      // Reason for refund
      failureReason: text("failure_reason"),
      // Reason for payment failure
      webhookEventId: text("webhook_event_id"),
      // Stripe webhook event ID
      lastSyncedAt: timestamp("last_synced_at"),
      // Last time synced with Stripe
      // Timestamps
      createdAt: timestamp("created_at").notNull().defaultNow(),
      updatedAt: timestamp("updated_at").notNull().defaultNow(),
      paidAt: timestamp("paid_at"),
      // When payment was successfully captured
      refundedAt: timestamp("refunded_at")
      // When refund was issued
    });
    paymentHistory = pgTable("payment_history", {
      id: serial("id").primaryKey(),
      transactionId: integer("transaction_id").references(() => paymentTransactions.id, { onDelete: "cascade" }).notNull(),
      previousStatus: transactionStatusEnum("previous_status"),
      newStatus: transactionStatusEnum("new_status").notNull(),
      eventType: text("event_type").notNull(),
      // 'status_change', 'refund', 'webhook', 'manual_update', etc.
      eventSource: text("event_source"),
      // 'stripe_webhook', 'admin', 'system', 'sync', etc.
      stripeEventId: text("stripe_event_id"),
      // Stripe event ID if from webhook
      description: text("description"),
      // Human-readable description
      metadata: jsonb("metadata").default({}),
      // Additional event data
      createdAt: timestamp("created_at").notNull().defaultNow(),
      createdBy: integer("created_by").references(() => users.id, { onDelete: "set null" })
      // User who triggered the change
    });
    insertPaymentTransactionSchema = createInsertSchema(paymentTransactions);
    updatePaymentTransactionSchema = z2.object({
      status: z2.enum(["pending", "processing", "succeeded", "failed", "canceled", "refunded", "partially_refunded"]).optional(),
      stripeStatus: z2.string().optional(),
      refundAmount: z2.number().optional(),
      refundReason: z2.string().optional(),
      failureReason: z2.string().optional(),
      chargeId: z2.string().optional(),
      refundId: z2.string().optional(),
      paidAt: z2.date().optional(),
      refundedAt: z2.date().optional(),
      lastSyncedAt: z2.date().optional(),
      metadata: z2.record(z2.any()).optional()
    });
  }
});

// server/db.ts
var db_exports = {};
__export(db_exports, {
  db: () => db,
  pool: () => pool
});
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-serverless";
import ws from "ws";
var pool, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    neonConfig.webSocketConstructor = ws;
    if (!process.env.DATABASE_URL) {
      console.warn("DATABASE_URL not set - falling back to in-memory storage");
    }
    pool = process.env.DATABASE_URL ? new Pool({ connectionString: process.env.DATABASE_URL }) : {};
    db = process.env.DATABASE_URL ? drizzle(pool, { schema: schema_exports }) : {};
  }
});

// server/r2-storage.ts
var r2_storage_exports = {};
__export(r2_storage_exports, {
  deleteFromR2: () => deleteFromR2,
  fileExistsInR2: () => fileExistsInR2,
  getPresignedUrl: () => getPresignedUrl,
  isR2Configured: () => isR2Configured,
  uploadToR2: () => uploadToR2
});
import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand, HeadObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
function getR2PublicUrl() {
  if (process.env.CLOUDFLARE_R2_PUBLIC_URL) {
    return process.env.CLOUDFLARE_R2_PUBLIC_URL;
  }
  if (R2_ACCOUNT_ID && R2_BUCKET_NAME) {
    return `https://${R2_ACCOUNT_ID}.r2.cloudflarestorage.com/${R2_BUCKET_NAME}`;
  }
  return "";
}
function getS3Client() {
  if (!s3Client) {
    if (!R2_ACCOUNT_ID || !R2_ACCESS_KEY_ID || !R2_SECRET_ACCESS_KEY || !R2_BUCKET_NAME) {
      throw new Error("Cloudflare R2 credentials not configured. Please set CLOUDFLARE_ACCOUNT_ID, CLOUDFLARE_R2_ACCESS_KEY_ID, CLOUDFLARE_R2_SECRET_ACCESS_KEY, and CLOUDFLARE_R2_BUCKET_NAME environment variables.");
    }
    if (!R2_ENDPOINT) {
      throw new Error("R2 endpoint could not be constructed. Please check CLOUDFLARE_ACCOUNT_ID is set.");
    }
    s3Client = new S3Client({
      region: "auto",
      // R2 uses 'auto' as the region
      endpoint: R2_ENDPOINT,
      credentials: {
        accessKeyId: R2_ACCESS_KEY_ID,
        secretAccessKey: R2_SECRET_ACCESS_KEY
      },
      // Force path style for R2 compatibility
      forcePathStyle: false
    });
  }
  return s3Client;
}
async function uploadToR2(file, userId, folder = "documents") {
  try {
    const client = getS3Client();
    const timestamp2 = Date.now();
    const documentType = file.fieldname || "file";
    const ext = file.originalname.split(".").pop() || "";
    const baseName = file.originalname.replace(/\.[^/.]+$/, "");
    const sanitizedBaseName = baseName.replace(/[^a-zA-Z0-9-_]/g, "_");
    const filename = `${userId}_${documentType}_${timestamp2}_${sanitizedBaseName}.${ext}`;
    const key = `${folder}/${filename}`;
    let fileBuffer;
    if (file.buffer) {
      fileBuffer = file.buffer;
    } else if (file.path) {
      const fs5 = await import("fs");
      fileBuffer = fs5.readFileSync(file.path);
    } else {
      throw new Error("File buffer or path not available");
    }
    const command = new PutObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: key,
      Body: fileBuffer,
      ContentType: file.mimetype
      // Make file publicly accessible (if your R2 bucket allows public access)
      // Note: You need to configure CORS and public access in Cloudflare dashboard
    });
    await client.send(command);
    let publicUrl;
    if (R2_PUBLIC_URL) {
      publicUrl = R2_PUBLIC_URL.endsWith("/") ? `${R2_PUBLIC_URL}${key}` : `${R2_PUBLIC_URL}/${key}`;
    } else {
      publicUrl = `https://${R2_ACCOUNT_ID}.r2.cloudflarestorage.com/${R2_BUCKET_NAME}/${key}`;
    }
    console.log(`\u2705 File uploaded to R2: ${key} -> ${publicUrl}`);
    return publicUrl;
  } catch (error) {
    console.error("\u274C Error uploading to R2:", error);
    throw new Error(`Failed to upload file to R2: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
async function deleteFromR2(fileUrl) {
  try {
    const client = getS3Client();
    let actualFileUrl = fileUrl;
    if (fileUrl.includes("/api/files/r2-proxy")) {
      try {
        const urlObj2 = new URL(fileUrl, "http://localhost");
        const urlParam = urlObj2.searchParams.get("url");
        if (urlParam) {
          actualFileUrl = decodeURIComponent(urlParam);
          console.log(`\u{1F50D} Extracted R2 URL from proxy: ${actualFileUrl}`);
        } else {
          console.error("\u274C Proxy URL missing url parameter:", fileUrl);
          return false;
        }
      } catch (urlError) {
        console.error("\u274C Error parsing proxy URL:", urlError);
        return false;
      }
    }
    const urlObj = new URL(actualFileUrl);
    let pathname = urlObj.pathname.startsWith("/") ? urlObj.pathname.slice(1) : urlObj.pathname;
    const pathParts = pathname.split("/").filter((p) => p);
    const bucketIndex = pathParts.indexOf(R2_BUCKET_NAME);
    let key;
    if (bucketIndex >= 0) {
      key = pathParts.slice(bucketIndex + 1).join("/");
    } else {
      const knownFolders = ["documents", "kitchen-applications", "images", "profiles"];
      const firstPart = pathParts[0];
      if (knownFolders.includes(firstPart)) {
        key = pathname;
      } else {
        key = pathname;
      }
    }
    key = key.replace(/^\/+|\/+$/g, "");
    if (!key || key.length === 0) {
      console.error(`\u274C Invalid key extracted from URL: ${fileUrl} -> ${actualFileUrl}`);
      return false;
    }
    console.log("\u{1F50D} R2 Delete Debug:", {
      originalUrl: fileUrl,
      actualFileUrl,
      extractedKey: key,
      bucketName: R2_BUCKET_NAME,
      pathname: urlObj.pathname,
      pathParts,
      bucketIndex
    });
    const command = new DeleteObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: key
    });
    await client.send(command);
    console.log(`\u2705 File deleted from R2: ${key}`);
    return true;
  } catch (error) {
    console.error("\u274C Error deleting from R2:", {
      error: error instanceof Error ? error.message : "Unknown error",
      fileUrl,
      stack: error instanceof Error ? error.stack : void 0
    });
    return false;
  }
}
async function fileExistsInR2(fileUrl) {
  try {
    const client = getS3Client();
    const urlObj = new URL(fileUrl);
    const key = urlObj.pathname.startsWith("/") ? urlObj.pathname.slice(1) : urlObj.pathname;
    const keyParts = key.split("/");
    const bucketIndex = keyParts.indexOf(R2_BUCKET_NAME);
    const actualKey = bucketIndex >= 0 ? keyParts.slice(bucketIndex + 1).join("/") : key;
    const command = new HeadObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: actualKey
    });
    await client.send(command);
    return true;
  } catch (error) {
    return false;
  }
}
async function getPresignedUrl(fileUrl, expiresIn = 3600) {
  try {
    const client = getS3Client();
    const urlObj = new URL(fileUrl);
    let pathname = urlObj.pathname.startsWith("/") ? urlObj.pathname.slice(1) : urlObj.pathname;
    const pathParts = pathname.split("/").filter((p) => p);
    const bucketIndex = pathParts.indexOf(R2_BUCKET_NAME);
    let key;
    if (bucketIndex >= 0) {
      key = pathParts.slice(bucketIndex + 1).join("/");
    } else {
      const knownFolders = ["documents", "kitchen-applications", "images", "profiles"];
      const firstPart = pathParts[0];
      if (knownFolders.includes(firstPart)) {
        key = pathname;
      } else {
        key = pathname;
      }
    }
    key = key.replace(/^\/+|\/+$/g, "");
    if (!key || key.length === 0) {
      throw new Error(`Invalid key extracted from URL: ${fileUrl}`);
    }
    console.log("\u{1F50D} R2 Presigned URL Debug:", {
      fileUrl,
      extractedKey: key,
      bucketName: R2_BUCKET_NAME,
      pathname: urlObj.pathname,
      pathParts,
      bucketIndex
    });
    const command = new GetObjectCommand({
      Bucket: R2_BUCKET_NAME,
      Key: key
    });
    const presignedUrl = await getSignedUrl(client, command, { expiresIn });
    console.log("\u2705 Generated presigned URL for R2 file:", key);
    return presignedUrl;
  } catch (error) {
    console.error("\u274C Error generating presigned URL:", {
      error: error instanceof Error ? error.message : "Unknown error",
      fileUrl,
      stack: error instanceof Error ? error.stack : void 0
    });
    throw new Error(`Failed to generate presigned URL: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
function isR2Configured() {
  return !!(R2_ACCOUNT_ID && R2_ACCESS_KEY_ID && R2_SECRET_ACCESS_KEY && R2_BUCKET_NAME);
}
var R2_ACCOUNT_ID, R2_ACCESS_KEY_ID, R2_SECRET_ACCESS_KEY, R2_BUCKET_NAME, R2_PUBLIC_URL, R2_ENDPOINT, s3Client;
var init_r2_storage = __esm({
  "server/r2-storage.ts"() {
    "use strict";
    R2_ACCOUNT_ID = process.env.CLOUDFLARE_ACCOUNT_ID;
    R2_ACCESS_KEY_ID = process.env.CLOUDFLARE_R2_ACCESS_KEY_ID;
    R2_SECRET_ACCESS_KEY = process.env.CLOUDFLARE_R2_SECRET_ACCESS_KEY;
    R2_BUCKET_NAME = process.env.CLOUDFLARE_R2_BUCKET_NAME;
    R2_PUBLIC_URL = getR2PublicUrl();
    R2_ENDPOINT = R2_ACCOUNT_ID ? `https://${R2_ACCOUNT_ID}.r2.cloudflarestorage.com` : "";
    s3Client = null;
  }
});

// server/phone-utils.ts
var phone_utils_exports = {};
__export(phone_utils_exports, {
  getChefPhone: () => getChefPhone,
  getManagerPhone: () => getManagerPhone,
  getPortalUserPhone: () => getPortalUserPhone,
  normalizePhoneForStorage: () => normalizePhoneForStorage
});
async function getManagerPhone(location, managerId, pool3) {
  let phone = location?.notificationPhone || location?.notification_phone || null;
  if (phone) {
    const normalized = validateAndNormalizePhone(phone);
    if (normalized) {
      return normalized;
    }
    console.warn(`\u26A0\uFE0F Location notification phone is invalid format: ${phone}`);
  }
  if (!phone && managerId && pool3) {
    try {
      const result = await pool3.query(
        "SELECT phone FROM applications WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1",
        [managerId]
      );
      if (result.rows.length > 0 && result.rows[0].phone) {
        phone = result.rows[0].phone;
        const normalized = validateAndNormalizePhone(phone);
        if (normalized) {
          return normalized;
        }
        console.warn(`\u26A0\uFE0F Manager application phone is invalid format: ${phone}`);
      }
    } catch (error) {
      console.warn("Could not retrieve manager phone from application:", error);
    }
  }
  return null;
}
async function getChefPhone(chefId, pool3) {
  if (!chefId || !pool3) return null;
  try {
    const result = await pool3.query(
      "SELECT phone FROM applications WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1",
      [chefId]
    );
    if (result.rows.length > 0 && result.rows[0].phone) {
      const phone = result.rows[0].phone;
      const normalized = validateAndNormalizePhone(phone);
      if (normalized) {
        return normalized;
      }
      console.warn(`\u26A0\uFE0F Chef application phone is invalid format: ${phone}`);
    }
  } catch (error) {
    console.warn("Could not retrieve chef phone from application:", error);
  }
  return null;
}
async function getPortalUserPhone(userId, locationId, pool3) {
  if (!userId || !pool3) return null;
  let phone = null;
  if (locationId) {
    try {
      const result = await pool3.query(
        "SELECT phone FROM portal_user_applications WHERE user_id = $1 AND location_id = $2 ORDER BY created_at DESC LIMIT 1",
        [userId, locationId]
      );
      if (result.rows.length > 0 && result.rows[0].phone) {
        phone = result.rows[0].phone;
        const normalized = validateAndNormalizePhone(phone);
        if (normalized) {
          return normalized;
        }
        console.warn(`\u26A0\uFE0F Portal user application phone is invalid format: ${phone}`);
        phone = null;
      }
    } catch (error) {
      console.warn("Could not retrieve portal user phone from portal_user_applications:", error);
    }
  }
  if (!phone) {
    try {
      const result = await pool3.query(
        "SELECT phone FROM applications WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1",
        [userId]
      );
      if (result.rows.length > 0 && result.rows[0].phone) {
        phone = result.rows[0].phone;
        const normalized = validateAndNormalizePhone(phone);
        if (normalized) {
          return normalized;
        }
        console.warn(`\u26A0\uFE0F Applications table phone is invalid format: ${phone}`);
      }
    } catch (error) {
      console.warn("Could not retrieve phone from applications table:", error);
    }
  }
  return null;
}
function normalizePhoneForStorage(phone) {
  if (!phone) return null;
  return validateAndNormalizePhone(phone);
}
var init_phone_utils = __esm({
  "server/phone-utils.ts"() {
    "use strict";
    init_phone_validation();
  }
});

// server/services/pricing-service.ts
var pricing_service_exports = {};
__export(pricing_service_exports, {
  calculateDurationHours: () => calculateDurationHours,
  calculateKitchenBookingPrice: () => calculateKitchenBookingPrice,
  calculatePlatformFee: () => calculatePlatformFee,
  calculatePlatformFeeDynamic: () => calculatePlatformFeeDynamic,
  calculateTotalWithFees: () => calculateTotalWithFees,
  getKitchenPricing: () => getKitchenPricing,
  getServiceFeeRate: () => getServiceFeeRate
});
function calculateDurationHours(startTime, endTime) {
  const [startHours, startMinutes] = startTime.split(":").map(Number);
  const [endHours, endMinutes] = endTime.split(":").map(Number);
  const startTotalMinutes = startHours * 60 + startMinutes;
  const endTotalMinutes = endHours * 60 + endMinutes;
  const durationMinutes = endTotalMinutes - startTotalMinutes;
  const durationHours = durationMinutes / 60;
  return Math.max(0, durationHours);
}
async function getKitchenPricing(kitchenId, dbPool) {
  try {
    const activePool = dbPool || pool2;
    if (!activePool) {
      throw new Error("Database pool not initialized");
    }
    const result = await activePool.query(`
      SELECT 
        hourly_rate::text as hourly_rate,
        currency,
        minimum_booking_hours
      FROM kitchens
      WHERE id = $1
    `, [kitchenId]);
    if (result.rows.length === 0) {
      return null;
    }
    const row = result.rows[0];
    const hourlyRateCents = row.hourly_rate ? parseFloat(row.hourly_rate) : 0;
    return {
      hourlyRate: hourlyRateCents,
      currency: row.currency || "CAD",
      minimumBookingHours: row.minimum_booking_hours || 1
    };
  } catch (error) {
    console.error("Error getting kitchen pricing:", error);
    throw error;
  }
}
async function calculateKitchenBookingPrice(kitchenId, startTime, endTime, dbPool) {
  try {
    const pricing = await getKitchenPricing(kitchenId, dbPool);
    if (!pricing || !pricing.hourlyRate || pricing.hourlyRate <= 0) {
      const durationHours2 = calculateDurationHours(startTime, endTime);
      return {
        totalPriceCents: 0,
        durationHours: durationHours2,
        hourlyRateCents: 0,
        currency: pricing?.currency || "CAD"
      };
    }
    const durationHours = calculateDurationHours(startTime, endTime);
    const effectiveDuration = Math.max(durationHours, pricing.minimumBookingHours);
    const totalPriceCents = Math.round(pricing.hourlyRate * effectiveDuration);
    return {
      totalPriceCents,
      durationHours: effectiveDuration,
      hourlyRateCents: pricing.hourlyRate,
      currency: pricing.currency
    };
  } catch (error) {
    console.error("Error calculating kitchen booking price:", error);
    throw error;
  }
}
async function getServiceFeeRate(dbPool) {
  try {
    const activePool = dbPool || pool2;
    if (!activePool) {
      console.warn("Database pool not available, using default service fee rate of 5%");
      return 0.05;
    }
    const result = await activePool.query(
      "SELECT value FROM platform_settings WHERE key = $1",
      ["service_fee_rate"]
    );
    if (result.rows.length === 0) {
      console.warn("Service fee rate not found in platform_settings, using default 5%");
      return 0.05;
    }
    const rate = parseFloat(result.rows[0].value);
    if (isNaN(rate) || rate < 0 || rate > 1) {
      console.warn(`Invalid service fee rate: ${rate}, using default 5%`);
      return 0.05;
    }
    return rate;
  } catch (error) {
    console.error("Error getting service fee rate from platform_settings:", error);
    return 0.05;
  }
}
function calculatePlatformFee(basePriceCents, commissionRate = 0.05) {
  return Math.round(basePriceCents * commissionRate);
}
async function calculatePlatformFeeDynamic(basePriceCents, dbPool) {
  const rate = await getServiceFeeRate(dbPool);
  return calculatePlatformFee(basePriceCents, rate);
}
function calculateTotalWithFees(basePriceCents, serviceFeeCents = 0, damageDepositCents = 0) {
  return basePriceCents + serviceFeeCents + damageDepositCents;
}
var pool2;
var init_pricing_service = __esm({
  "server/services/pricing-service.ts"() {
    "use strict";
    pool2 = null;
    try {
      const dbModule = (init_db(), __toCommonJS(db_exports));
      pool2 = dbModule.pool || null;
    } catch (e) {
      pool2 = null;
    }
  }
});

// server/email.ts
var email_exports = {};
__export(email_exports, {
  generateApplicationWithDocumentsEmail: () => generateApplicationWithDocumentsEmail,
  generateApplicationWithoutDocumentsEmail: () => generateApplicationWithoutDocumentsEmail,
  generateBookingCancellationEmail: () => generateBookingCancellationEmail,
  generateBookingCancellationNotificationEmail: () => generateBookingCancellationNotificationEmail,
  generateBookingConfirmationEmail: () => generateBookingConfirmationEmail,
  generateBookingNotificationEmail: () => generateBookingNotificationEmail,
  generateBookingRequestEmail: () => generateBookingRequestEmail,
  generateBookingStatusChangeNotificationEmail: () => generateBookingStatusChangeNotificationEmail,
  generateChefAllDocumentsApprovedEmail: () => generateChefAllDocumentsApprovedEmail,
  generateChefKitchenAccessApprovedEmail: () => generateChefKitchenAccessApprovedEmail,
  generateChefLocationAccessApprovedEmail: () => generateChefLocationAccessApprovedEmail,
  generateChefProfileRequestEmail: () => generateChefProfileRequestEmail,
  generateDocumentStatusChangeEmail: () => generateDocumentStatusChangeEmail,
  generateDocumentUpdateEmail: () => generateDocumentUpdateEmail,
  generateEmailVerificationEmail: () => generateEmailVerificationEmail,
  generateFullVerificationEmail: () => generateFullVerificationEmail,
  generateKitchenAvailabilityChangeEmail: () => generateKitchenAvailabilityChangeEmail,
  generateKitchenSettingsChangeEmail: () => generateKitchenSettingsChangeEmail,
  generateLocationEmailChangedEmail: () => generateLocationEmailChangedEmail,
  generateManagerCredentialsEmail: () => generateManagerCredentialsEmail,
  generateManagerMagicLinkEmail: () => generateManagerMagicLinkEmail,
  generatePasswordResetEmail: () => generatePasswordResetEmail,
  generatePromoCodeEmail: () => generatePromoCodeEmail,
  generateStatusChangeEmail: () => generateStatusChangeEmail,
  generateWelcomeEmail: () => generateWelcomeEmail,
  sendApplicationReceivedEmail: () => sendApplicationReceivedEmail,
  sendApplicationRejectedEmail: () => sendApplicationRejectedEmail,
  sendEmail: () => sendEmail
});
import nodemailer from "nodemailer";
import { fileURLToPath, pathToFileURL } from "url";
import { dirname, join } from "path";
function createBookingDateTimeFallback(dateStr, timeStr, timezone = "America/St_Johns") {
  const [year, month, day] = dateStr.split("-").map(Number);
  const [hours, minutes] = timeStr.split(":").map(Number);
  return new Date(year, month - 1, day, hours, minutes);
}
function createBookingDateTime2(dateStr, timeStr, timezone = "America/St_Johns") {
  return createBookingDateTimeImpl(dateStr, timeStr, timezone);
}
async function sendApplicationReceivedEmail(applicationData) {
  const supportEmail = getSupportEmail();
  const organizationName = getOrganizationName();
  const subject = `Application Received - ${organizationName}`;
  const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting">Hello ${applicationData.fullName},</h2>
      <p class="message">
        Thank you for submitting your application to join ${organizationName}. 
        We've received your application and our team will review it shortly.
      </p>
      <div class="status-badge">Status: Under Review</div>
      <div class="info-box">
        <strong>What happens next?</strong><br>
        Our team typically reviews applications within 2-3 business days. 
        You'll receive an email notification once we've made a decision.
      </div>
      <a href="${getDashboardUrl()}" class="cta-button" style="color: white !important; text-decoration: none !important;">Track Application Status</a>
    </div>
    <div class="footer">
      <p class="footer-text">Thank you for your interest in ${organizationName}!</p>
      <div class="footer-links">
        <a href="mailto:${supportEmail}">Support</a> \u2022 
        <a href="mailto:${supportEmail}?subject=Unsubscribe">Unsubscribe</a> \u2022 
        <a href="${getPrivacyUrl()}">Privacy Policy</a>
      </div>
    </div>
  </div>
</body>
</html>`;
  const textContent = `
Application Received - ${organizationName}

Hello ${applicationData.fullName},

Thank you for submitting your application to join ${organizationName}. We've received your application and our team will review it shortly.

Status: Under Review

What happens next?
Our team typically reviews applications within 2-3 business days. You'll receive an email notification once we've made a decision.

Track your application status: ${getDashboardUrl()}

Thank you for your interest in ${organizationName}!

If you have any questions, contact us at ${supportEmail}

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} ${organizationName}
`;
  return sendEmail({
    to: applicationData.email,
    subject,
    html: htmlContent,
    text: textContent
  });
}
async function sendApplicationRejectedEmail(applicationData, reason) {
  const supportEmail = getSupportEmail();
  const organizationName = getOrganizationName();
  const subject = `Application Update - ${organizationName}`;
  const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting">Hello ${applicationData.fullName},</h2>
      <p class="message">
        Thank you for your interest in joining ${organizationName}. After careful review, we're unable to approve your application at this time.
      </p>
      <div class="status-badge">Status: Not Approved</div>
      
      ${reason ? `
      <div class="info-box">
        <strong>Feedback:</strong> ${reason}
      </div>
      ` : ""}
      
      <div class="info-box">
        <strong>\u{1F4DA} Next Steps:</strong><br>
        We encourage you to gain more experience and reapply in the future. 
        We'd be happy to reconsider your application when you're ready.
      </div>
      
      <a href="https://local-cooks-community.vercel.app/apply" class="cta-button" style="color: white !important; text-decoration: none !important;">Learn About Requirements</a>
    </div>
    <div class="footer">
      <p class="footer-text">Thank you for your interest in ${organizationName}!</p>
      <div class="footer-links">
        <a href="mailto:${supportEmail}">Support</a> \u2022 
        <a href="mailto:${supportEmail}?subject=Unsubscribe">Unsubscribe</a> \u2022 
        <a href="https://local-cooks-community.vercel.app/privacy">Privacy Policy</a>
      </div>
    </div>
  </div>
</body>
</html>`;
  const textContent = `
Application Update - ${organizationName}

Hello ${applicationData.fullName},

Thank you for your interest in joining ${organizationName}. After careful review, we're unable to approve your application at this time.

Status: Not Approved

${reason ? `Feedback: ${reason}

` : ""}Next Steps:
We encourage you to gain more experience and reapply in the future. We'd be happy to reconsider your application when you're ready.

Learn more about requirements: https://local-cooks-community.vercel.app/apply

Thank you for your interest in ${organizationName}!

If you have any questions, contact us at ${supportEmail}

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} ${organizationName}
`;
  return sendEmail({
    to: applicationData.email,
    subject,
    html: htmlContent,
    text: textContent
  });
}
var createBookingDateTimeImpl, loadAttempted, recentEmails, DUPLICATE_PREVENTION_WINDOW, createTransporter, getEmailConfig, sendEmail, getDomainFromEmail, getOrganizationName, getUnsubscribeEmail, getSupportEmail, detectEmailProvider, formatDateForCalendar, escapeIcalText, generateEventUid, generateIcsFile, generateCalendarUrl, getUniformEmailStyles, generateStatusChangeEmail, generateVendorCredentials, generateFullVerificationEmail, generateApplicationWithDocumentsEmail, generateApplicationWithoutDocumentsEmail, generateDocumentStatusChangeEmail, generatePasswordResetEmail, generateEmailVerificationEmail, generateWelcomeEmail, getSubdomainUrl, getWebsiteUrl, getDashboardUrl, getPrivacyUrl, getVendorDashboardUrl, getPromoUrl, generateDocumentUpdateEmail, generatePromoCodeEmail, generateChefAllDocumentsApprovedEmail, generateManagerMagicLinkEmail, generateManagerCredentialsEmail, generateBookingNotificationEmail, generateBookingCancellationNotificationEmail, generateBookingStatusChangeNotificationEmail, generateBookingRequestEmail, generateBookingConfirmationEmail, generateBookingCancellationEmail, generateKitchenAvailabilityChangeEmail, generateKitchenSettingsChangeEmail, generateChefProfileRequestEmail, generateChefLocationAccessApprovedEmail, generateChefKitchenAccessApprovedEmail, generateLocationEmailChangedEmail;
var init_email = __esm({
  "server/email.ts"() {
    "use strict";
    createBookingDateTimeImpl = createBookingDateTimeFallback;
    loadAttempted = false;
    (async () => {
      if (loadAttempted) return;
      loadAttempted = true;
      try {
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = dirname(__filename);
        const possiblePaths = [
          join(__dirname, "../shared/timezone-utils.js"),
          // From server/email.js to shared/timezone-utils.js (CORRECT PATH for dist)
          join(__dirname, "../shared/timezone-utils"),
          // Without .js extension
          join(__dirname, "../../shared/timezone-utils.js"),
          // Alternative path
          "/var/task/shared/timezone-utils.js",
          // Absolute path for Vercel dist structure
          "/var/task/api/shared/timezone-utils.js"
          // Absolute path for Vercel api structure
        ];
        for (const filePath of possiblePaths) {
          try {
            const timezoneUtilsUrl = pathToFileURL(filePath).href;
            const timezoneUtils = await import(timezoneUtilsUrl);
            if (timezoneUtils && timezoneUtils.createBookingDateTime) {
              createBookingDateTimeImpl = timezoneUtils.createBookingDateTime;
              console.log(`Successfully loaded timezone-utils from: ${timezoneUtilsUrl}`);
              return;
            }
          } catch {
            continue;
          }
        }
        console.warn("Failed to load timezone-utils from any path, using fallback implementation");
      } catch (error) {
        console.error("Error during timezone-utils initialization:", error);
      }
    })();
    recentEmails = /* @__PURE__ */ new Map();
    DUPLICATE_PREVENTION_WINDOW = 3e4;
    createTransporter = (config) => {
      const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
      return nodemailer.createTransport({
        host: config.host,
        port: config.port,
        secure: config.secure,
        auth: {
          user: config.auth.user,
          pass: config.auth.pass
        },
        // Enhanced configuration for Vercel serverless functions
        tls: {
          rejectUnauthorized: false,
          // Allow self-signed certificates
          ciphers: "SSLv3"
        },
        // Reduced timeouts for serverless functions (max 10s execution time)
        connectionTimeout: isProduction2 ? 15e3 : 6e4,
        // 15s production, 60s development
        greetingTimeout: isProduction2 ? 1e4 : 3e4,
        // 10s production, 30s development
        socketTimeout: isProduction2 ? 15e3 : 6e4,
        // 15s production, 60s development
        // Add authentication method
        authMethod: "PLAIN",
        // Enable debug for troubleshooting in development only
        debug: process.env.NODE_ENV === "development",
        logger: process.env.NODE_ENV === "development",
        // Pool configuration for better performance
        pool: isProduction2 ? true : false,
        maxConnections: 1,
        // Single connection for serverless
        maxMessages: 1
        // Single message per connection for serverless
      });
    };
    getEmailConfig = () => {
      const forceDirectSMTP = process.env.FORCE_DIRECT_SMTP === "true";
      const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
      if (forceDirectSMTP && isProduction2) {
        console.log("\u{1F504} Forcing direct SMTP connection (bypassing MailChannels)");
      }
      return {
        host: process.env.EMAIL_HOST || "smtp.hostinger.com",
        port: parseInt(process.env.EMAIL_PORT || "587"),
        secure: process.env.EMAIL_SECURE === "true",
        auth: {
          user: process.env.EMAIL_USER || "",
          pass: process.env.EMAIL_PASS || ""
        }
      };
    };
    sendEmail = async (content, options) => {
      const startTime = Date.now();
      let transporter = null;
      try {
        if (options?.trackingId) {
          const lastSent = recentEmails.get(options.trackingId);
          const now = Date.now();
          if (lastSent && now - lastSent < DUPLICATE_PREVENTION_WINDOW) {
            console.log(`Preventing duplicate email for tracking ID: ${options.trackingId} (sent ${now - lastSent}ms ago)`);
            return true;
          }
          recentEmails.set(options.trackingId, now);
          if (recentEmails.size > 100) {
            const cutoffTime = now - DUPLICATE_PREVENTION_WINDOW;
            recentEmails.forEach((timestamp2, id) => {
              if (timestamp2 < cutoffTime) recentEmails.delete(id);
            });
          }
        }
        if (!process.env.EMAIL_USER || !process.env.EMAIL_PASS) {
          console.error("Email configuration is missing. Please set EMAIL_USER and EMAIL_PASS environment variables.");
          return false;
        }
        const config = getEmailConfig();
        const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
        console.log("\u{1F4E7} COMPREHENSIVE EMAIL SEND INITIATED:", {
          to: content.to,
          subject: content.subject,
          emailType: content.subject.includes("Application") ? "\u{1F3AF} APPLICATION_EMAIL" : "\u{1F4DD} SYSTEM_EMAIL",
          trackingId: options?.trackingId || `auto_${Date.now()}`,
          hasText: !!content.text,
          hasHtml: !!content.html,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          config: {
            host: config.host,
            port: config.port,
            secure: config.secure,
            user: config.auth.user ? config.auth.user.replace(/(.{3}).*@/, "$1***@") : "not set",
            domain: getDomainFromEmail(config.auth.user),
            organization: getOrganizationName(),
            hasEmailFrom: !!process.env.EMAIL_FROM,
            isProduction: isProduction2,
            environment: process.env.VERCEL_ENV || process.env.NODE_ENV,
            vercelRegion: process.env.VERCEL_REGION || "unknown"
          }
        });
        transporter = createTransporter(config);
        const fromName = getOrganizationName();
        const fromEmail = process.env.EMAIL_FROM || `${fromName} <${config.auth.user}>`;
        if (!isProduction2) {
          try {
            await new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject(new Error("SMTP verification timeout"));
              }, 1e4);
              transporter.verify((error, success) => {
                clearTimeout(timeout);
                if (error) {
                  console.error("SMTP connection verification failed:", error);
                  reject(error);
                } else {
                  console.log("SMTP connection verified successfully");
                  resolve(success);
                }
              });
            });
          } catch (verifyError) {
            console.error("Failed to verify SMTP connection:", verifyError);
          }
        }
        const domain = getDomainFromEmail(config.auth.user);
        const unsubscribeEmail = getUnsubscribeEmail();
        const organizationName = getOrganizationName();
        const mailOptions = {
          from: fromEmail,
          to: content.to,
          subject: content.subject,
          text: content.text,
          html: content.html,
          // Add attachments if provided (e.g., .ics calendar files)
          attachments: content.attachments || [],
          // Optimized headers for better deliverability with Hostinger SMTP
          headers: {
            "Organization": organizationName,
            "X-Mailer": "Local Cooks Community",
            // Proper sender identification for DKIM/SPF alignment
            "Sender": config.auth.user,
            "Return-Path": config.auth.user,
            "Reply-To": config.auth.user,
            // Standard priority headers (avoid high priority to reduce spam score)
            "Importance": "Normal",
            // Merge any additional headers from content
            ...content.headers || {}
          },
          // Proper encoding settings for DKIM
          encoding: "utf8",
          // Enhanced delivery options for Hostinger SMTP
          envelope: {
            from: config.auth.user,
            to: content.to
          },
          // DKIM-compatible message ID with proper domain
          messageId: `<${Date.now()}.${Math.random().toString(36).substr(2, 9)}@${domain}>`,
          date: /* @__PURE__ */ new Date()
          // DKIM signing is handled by Hostinger SMTP server
        };
        let info;
        let attempts = 0;
        const maxAttempts = 2;
        while (attempts < maxAttempts) {
          attempts++;
          console.log(`\u{1F4E7} Attempt ${attempts}/${maxAttempts} sending email to ${content.to}`);
          try {
            const emailPromise = transporter.sendMail(mailOptions);
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(() => reject(new Error("Email sending timeout - exceeded 25 seconds")), 25e3);
            });
            info = await Promise.race([emailPromise, timeoutPromise]);
            console.log(`\u2705 Email sent successfully on attempt ${attempts}`);
            break;
          } catch (attemptError) {
            console.warn(`\u26A0\uFE0F Attempt ${attempts} failed for ${content.to}:`, attemptError instanceof Error ? attemptError.message : String(attemptError));
            if (attempts >= maxAttempts) {
              throw attemptError;
            }
            await new Promise((resolve) => setTimeout(resolve, 1e3 * attempts));
          }
        }
        const executionTime = Date.now() - startTime;
        console.log("Email sent successfully:", {
          messageId: info.messageId,
          accepted: info.accepted,
          rejected: info.rejected,
          response: info.response,
          domain,
          organization: organizationName,
          fromEmail,
          executionTime: `${executionTime}ms`,
          isProduction: isProduction2
        });
        if (transporter && typeof transporter.close === "function") {
          transporter.close();
        }
        return true;
      } catch (error) {
        const executionTime = Date.now() - startTime;
        console.error("Error sending email:", {
          error: error instanceof Error ? error.message : error,
          executionTime: `${executionTime}ms`,
          to: content.to,
          subject: content.subject,
          trackingId: options?.trackingId,
          isProduction: process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production"
        });
        if (error instanceof Error) {
          console.error("Error details:", error.message);
          if ("code" in error) {
            console.error("Error code:", error.code);
          }
          if ("responseCode" in error) {
            console.error("SMTP Response code:", error.responseCode);
          }
        }
        if (transporter && typeof transporter.close === "function") {
          try {
            transporter.close();
          } catch (closeError) {
            console.error("Error closing transporter:", closeError);
          }
        }
        return false;
      }
    };
    getDomainFromEmail = (email) => {
      if (process.env.EMAIL_DOMAIN) {
        return process.env.EMAIL_DOMAIN;
      }
      if (process.env.EMAIL_FROM) {
        const match2 = process.env.EMAIL_FROM.match(/<([^>]+)>/);
        if (match2) {
          const emailPart = match2[1];
          const domainMatch = emailPart.match(/@(.+)$/);
          if (domainMatch) {
            return domainMatch[1];
          }
        }
      }
      const match = email.match(/@(.+)$/);
      if (match) {
        return match[1];
      }
      return "localcooks.community";
    };
    getOrganizationName = () => {
      return process.env.EMAIL_ORGANIZATION || "Local Cooks Community";
    };
    getUnsubscribeEmail = () => {
      return "localcooks@localcook.shop";
    };
    getSupportEmail = () => {
      const domain = getDomainFromEmail(process.env.EMAIL_USER || "");
      return `support@${domain}`;
    };
    detectEmailProvider = (email) => {
      const emailLower = email.toLowerCase();
      const domain = emailLower.split("@")[1] || "";
      if (domain === "gmail.com" || domain === "googlemail.com" || domain.endsWith(".google.com")) {
        return "google";
      }
      if (domain === "outlook.com" || domain === "hotmail.com" || domain === "live.com" || domain === "msn.com" || domain.endsWith(".outlook.com")) {
        return "outlook";
      }
      if (domain === "yahoo.com" || domain === "yahoo.co.uk" || domain === "yahoo.ca" || domain.endsWith(".yahoo.com")) {
        return "yahoo";
      }
      if (domain === "icloud.com" || domain === "me.com" || domain === "mac.com" || domain.endsWith(".icloud.com")) {
        return "apple";
      }
      return "generic";
    };
    formatDateForCalendar = (date2) => {
      const year = date2.getUTCFullYear();
      const month = String(date2.getUTCMonth() + 1).padStart(2, "0");
      const day = String(date2.getUTCDate()).padStart(2, "0");
      const hours = String(date2.getUTCHours()).padStart(2, "0");
      const minutes = String(date2.getUTCMinutes()).padStart(2, "0");
      const seconds = String(date2.getUTCSeconds()).padStart(2, "0");
      return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
    };
    escapeIcalText = (text2) => {
      return text2.replace(/\\/g, "\\\\").replace(/;/g, "\\;").replace(/,/g, "\\,").replace(/\n/g, "\\n").replace(/\r/g, "");
    };
    generateEventUid = (bookingDate, startTime, location) => {
      const dateStr = bookingDate instanceof Date ? bookingDate.toISOString().split("T")[0] : bookingDate.split("T")[0];
      const hashInput = `${dateStr}-${startTime}-${location}`;
      let hash = 0;
      for (let i = 0; i < hashInput.length; i++) {
        const char = hashInput.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      const positiveHash = Math.abs(hash).toString(36);
      return `${dateStr.replace(/-/g, "")}T${startTime.replace(/:/g, "")}-${positiveHash}@localcooks.com`;
    };
    generateIcsFile = (title, startDateTime, endDateTime, location, description, organizerEmail, attendeeEmails, eventUid) => {
      const startDateStr = formatDateForCalendar(startDateTime);
      const endDateStr = formatDateForCalendar(endDateTime);
      const now = formatDateForCalendar(/* @__PURE__ */ new Date());
      const uid = eventUid || `${Date.now()}-${Math.random().toString(36).substr(2, 9)}@localcooks.com`;
      const lines = [
        "BEGIN:VCALENDAR",
        "VERSION:2.0",
        "PRODID:-//Local Cooks Community//Kitchen Booking System//EN",
        "CALSCALE:GREGORIAN",
        "METHOD:REQUEST",
        // Indicates this is a calendar invitation
        "BEGIN:VEVENT",
        `UID:${uid}`,
        `DTSTAMP:${now}`,
        // When the event was created
        `DTSTART:${startDateStr}`,
        // Start time in UTC
        `DTEND:${endDateStr}`,
        // End time in UTC
        `SUMMARY:${escapeIcalText(title)}`,
        `DESCRIPTION:${escapeIcalText(description)}`,
        `LOCATION:${escapeIcalText(location)}`,
        "STATUS:CONFIRMED",
        "SEQUENCE:0",
        // Increment on updates for synchronization
        "TRANSP:OPAQUE"
        // Indicates busy time
      ];
      if (organizerEmail) {
        lines.push(`ORGANIZER;CN=Local Cooks Community:mailto:${organizerEmail}`);
      } else {
        const supportEmail = getSupportEmail();
        lines.push(`ORGANIZER;CN=Local Cooks Community:mailto:${supportEmail}`);
      }
      if (attendeeEmails && attendeeEmails.length > 0) {
        attendeeEmails.forEach((email) => {
          if (email && email.includes("@")) {
            lines.push(`ATTENDEE;CN=${email.split("@")[0]};RSVP=TRUE;CUTYPE=INDIVIDUAL:mailto:${email}`);
          }
        });
      }
      lines.push(
        "BEGIN:VALARM",
        "ACTION:DISPLAY",
        "TRIGGER:-PT15M",
        // 15 minutes before
        "DESCRIPTION:Reminder: Kitchen booking in 15 minutes",
        "END:VALARM",
        "BEGIN:VALARM",
        "ACTION:EMAIL",
        "TRIGGER:-P1D",
        // 1 day before
        "DESCRIPTION:Reminder: Kitchen booking tomorrow",
        "END:VALARM",
        "END:VEVENT",
        "END:VCALENDAR"
      );
      return lines.join("\r\n");
    };
    generateCalendarUrl = (email, title, bookingDate, startTime, endTime, location, description, timezone = "America/St_Johns") => {
      try {
        let bookingDateStr;
        if (bookingDate instanceof Date) {
          bookingDateStr = bookingDate.toISOString().split("T")[0];
        } else if (typeof bookingDate === "string") {
          bookingDateStr = bookingDate.split("T")[0];
        } else {
          bookingDateStr = String(bookingDate);
        }
        const startDateTime = createBookingDateTime2(bookingDateStr, startTime, timezone);
        const endDateTime = createBookingDateTime2(bookingDateStr, endTime, timezone);
        const startDateStr = formatDateForCalendar(startDateTime);
        const endDateStr = formatDateForCalendar(endDateTime);
        const provider = detectEmailProvider(email);
        switch (provider) {
          case "google":
            const googleParams = new URLSearchParams({
              action: "TEMPLATE",
              text: encodeURIComponent(title),
              dates: `${startDateStr}/${endDateStr}`,
              // ISO 8601 format in UTC
              details: encodeURIComponent(description),
              location: encodeURIComponent(location),
              sf: "true",
              // Show form
              output: "xml"
              // Output format
            });
            return `https://calendar.google.com/calendar/render?${googleParams.toString()}`;
          case "outlook":
            const outlookParams = new URLSearchParams({
              subject: title,
              startdt: startDateTime.toISOString(),
              enddt: endDateTime.toISOString(),
              body: description,
              location
            });
            return `https://outlook.live.com/calendar/0/deeplink/compose?${outlookParams.toString()}`;
          case "yahoo":
            const yahooParams = new URLSearchParams({
              v: "60",
              // version
              view: "d",
              type: "20",
              title,
              st: startDateStr.replace(/[-:]/g, "").replace("T", "").replace("Z", ""),
              dur: String(Math.round((endDateTime.getTime() - startDateTime.getTime()) / 6e4)),
              // duration in minutes
              desc: description,
              in_loc: location
            });
            return `https://calendar.yahoo.com/?${yahooParams.toString()}`;
          case "apple":
            const appleParams = new URLSearchParams({
              action: "TEMPLATE",
              text: title,
              dates: `${startDateStr}/${endDateStr}`,
              details: description,
              location
            });
            return `https://calendar.google.com/calendar/render?${appleParams.toString()}`;
          case "generic":
          default:
            const genericParams = new URLSearchParams({
              action: "TEMPLATE",
              text: title,
              dates: `${startDateStr}/${endDateStr}`,
              details: description,
              location
            });
            return `https://calendar.google.com/calendar/render?${genericParams.toString()}`;
        }
      } catch (error) {
        console.error("Error generating calendar URL:", error);
        return `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(title)}&location=${encodeURIComponent(location)}`;
      }
    };
    getUniformEmailStyles = () => `
<style>
  @import url('https://fonts.googleapis.com/css2?family=Lobster&display=swap');
  
  body { 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
    line-height: 1.6; 
    color: #475569; 
    margin: 0; 
    padding: 0; 
    background: #f1f5f9;
  }
  .email-container { 
    max-width: 600px; 
    margin: 0 auto; 
    background: white; 
    border-radius: 12px; 
    overflow: hidden; 
    box-shadow: 0 4px 20px rgba(0,0,0,0.08);
  }
  .header { 
    background: linear-gradient(135deg, hsl(347, 91%, 51%) 0%, hsl(347, 91%, 45%) 100%); 
    color: white; 
    padding: 24px 32px; 
    text-align: center; 
  }
  .header-image {
    max-width: 280px;
    height: auto;
    display: block;
    margin: 0 auto;
  }
  .content { 
    padding: 40px 32px; 
  }
  .greeting {
    font-size: 24px;
    font-weight: 600;
    color: #1e293b;
    margin: 0 0 16px 0;
  }
  .message {
    font-size: 16px;
    line-height: 1.6;
    color: #475569;
    margin: 0 0 24px 0;
  }
  .status-badge { 
    display: inline-block; 
    padding: 12px 20px; 
    background: linear-gradient(135deg, #fef7f7 0%, #fecaca 100%); 
    color: hsl(347, 91%, 51%); 
    border: 1px solid hsl(347, 91%, 70%);
    border-radius: 8px; 
    font-weight: 600; 
    margin: 16px 0; 
  }
  .status-badge.approved {
    background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
    color: #16a34a;
    border-color: #bbf7d0;
  }
  .status-badge.rejected {
    background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
    color: #dc2626;
    border-color: #fecaca;
  }
  .status-badge.cancelled {
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    color: #64748b;
    border-color: #cbd5e1;
  }
  .cta-button { 
    display: inline-block; 
    padding: 14px 28px; 
    background: linear-gradient(135deg, hsl(347, 91%, 51%) 0%, hsl(347, 91%, 45%) 100%); 
    color: white !important; 
    text-decoration: none; 
    border-radius: 8px; 
    font-weight: 600;
    margin: 24px 0;
    box-shadow: 0 2px 8px hsla(347, 91%, 51%, 0.3);
    mso-hide: none;
    mso-text-raise: 0;
  }
  .info-box {
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    padding: 20px;
    margin: 24px 0;
  }
  .credentials-table {
    width: 100%;
    border-collapse: collapse;
    margin: 16px 0;
  }
  .credentials-table td {
    padding: 12px 16px;
    background: #fff;
    border: 1px solid #e2e8f0;
  }
  .credentials-table td:first-child {
    font-weight: 600;
    color: hsl(347, 91%, 51%);
    background: #f8fafc;
  }
  .credentials-table code {
    font-family: 'Courier New', monospace;
    font-size: 14px;
    color: #1e293b;
    font-weight: 600;
  }
  .footer { 
    background: #f8fafc; 
    padding: 24px 32px; 
    text-align: center; 
    border-top: 1px solid #e2e8f0;
  }
  .footer-text {
    font-size: 14px;
    color: #64748b;
    margin: 0 0 8px 0;
  }
  .footer-links {
    font-size: 13px;
    color: #94a3b8;
  }
  .footer-links a { 
    color: hsl(347, 91%, 51%); 
    text-decoration: none;
  }
  .divider {
    height: 1px;
    background: linear-gradient(90deg, transparent 0%, #e2e8f0 50%, transparent 100%);
    margin: 24px 0;
  }
  .warning-box {
    background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
    border: 1px solid #f59e0b;
    border-radius: 8px;
    padding: 16px;
    margin: 16px 0;
  }
  .warning-text {
    font-size: 14px;
    color: #92400e;
    margin: 0;
  }
  a { color: hsl(347, 91%, 51%); text-decoration: underline; }
</style>`;
    generateStatusChangeEmail = (applicationData) => {
      const getSubjectLine = (status) => {
        switch (status) {
          case "approved":
            return "Application Approved - Local Cooks Community";
          case "rejected":
            return "Application Update - Local Cooks Community";
          case "cancelled":
            return "Application Status Update - Local Cooks Community";
          case "under_review":
            return "Application Under Review - Local Cooks Community";
          default:
            return "Application Status Update - Local Cooks Community";
        }
      };
      const subject = getSubjectLine(applicationData.status);
      const generatePlainText = (status, fullName) => {
        const statusMessages = {
          approved: `Congratulations! Your application has been approved.`,
          rejected: `Thank you for your application. After careful review, we are unable to move forward at this time.`,
          cancelled: `Your application has been cancelled.`,
          under_review: `Your application is currently under review.`,
          pending: `Your application has been received and is pending review.`
        };
        return `Hello ${fullName},

${statusMessages[status] || "Your application status has been updated."}

Status: ${status.charAt(0).toUpperCase() + status.slice(1)}

${status === "approved" ? `Access your dashboard: ${getDashboardUrl()}

\u{1F393} NEXT STEP: Complete your food safety training to unlock all features and get certified!` : ""}${status === "cancelled" ? `

You can submit a new application anytime: ${getWebsiteUrl()}/apply` : ""}

If you have any questions, please contact us at ${getSupportEmail()}.

Best regards,
Local Cooks Community Team

Visit: ${getWebsiteUrl()}
`;
      };
      const getMessage = (status) => {
        switch (status) {
          case "approved":
            return "Congratulations! Your application has been approved. You now have full access to the Local Cooks platform, including our comprehensive food safety training program.";
          case "rejected":
            return "Thank you for your application. After careful review, we are unable to move forward with your application at this time. We appreciate your interest in Local Cooks.";
          case "cancelled":
            return "Your application has been cancelled. You can submit a new application anytime when you're ready to join the Local Cooks community.";
          case "under_review":
            return "Your application is currently under review by our team. We will notify you once the review is complete.";
          case "pending":
            return "Your application has been received and is pending review. We will contact you with updates soon.";
          default:
            return "Your application status has been updated. Please check your dashboard for more details.";
        }
      };
      const message = getMessage(applicationData.status);
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting">Hello ${applicationData.fullName},</h2>
      <p class="message">${message}</p>
      <div class="status-badge${applicationData.status === "approved" ? " approved" : applicationData.status === "rejected" ? " rejected" : applicationData.status === "cancelled" ? " cancelled" : ""}">
        Status: ${applicationData.status.charAt(0).toUpperCase() + applicationData.status.slice(1)}
      </div>
      ${applicationData.status === "approved" ? `
      <div class="info-box">
        <strong>\u{1F393} Your Next Step: Food Safety Training</strong>
        <p>You now have full access to our comprehensive food safety training program. Complete all 22 training videos to:</p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>Earn your official Local Cooks certification</li>
          <li>Learn essential HACCP principles</li>
          <li>Access advanced platform features</li>
          <li>Build customer trust with verified status</li>
        </ul>
      </div>
      <a href="${getDashboardUrl()}" class="cta-button" style="color: white !important; text-decoration: none !important;">Start Food Safety Training</a>` : ""}${applicationData.status === "cancelled" ? `
      <div class="info-box">
        <strong>Ready to Apply Again?</strong>
        <p>You can submit a new application anytime when you're ready to join the Local Cooks community. We look forward to welcoming you to our platform!</p>
      </div>
      <a href="${getWebsiteUrl()}/apply" class="cta-button" style="color: white !important; text-decoration: none !important;">Submit New Application</a>` : ""}
      <div class="divider"></div>
    </div>
    <div class="footer">
      <p class="footer-text">Thank you for your interest in <a href="${getWebsiteUrl()}" class="footer-links">Local Cooks</a>!</p>
      <p class="footer-text">If you have any questions, contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p>
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: applicationData.email,
        subject,
        text: generatePlainText(applicationData.status, applicationData.fullName),
        html
      };
    };
    generateVendorCredentials = (fullName, phone) => {
      let cleanPhone = phone.replace(/[^0-9]/g, "");
      if (cleanPhone.length === 11 && cleanPhone.startsWith("1")) {
        cleanPhone = cleanPhone.substring(1);
      }
      const username = cleanPhone;
      const namePrefix = fullName.replace(/[^a-zA-Z]/g, "").toLowerCase().substring(0, 3) || "usr";
      const phoneSuffix = cleanPhone.slice(-4) || "0000";
      const password = namePrefix + phoneSuffix;
      return { username, password };
    };
    generateFullVerificationEmail = (userData) => {
      const { username, password } = generateVendorCredentials(userData.fullName, userData.phone);
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chef Account Approved - Login Credentials Included</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting">Congratulations ${userData.fullName}!</h2>
      <p class="message">
        Your documents have been approved and you are now <strong>fully verified</strong>! You can now start accepting orders and serving customers through our Local Cooks platform.
      </p>
      <div class="status-badge approved">Status: Approved</div>
      
      <div class="info-box">
        <strong>Your Login Credentials:</strong>
        <table class="credentials-table">
          <tr>
            <td>Username:</td>
            <td><code>${username}</code></td>
          </tr>
          <tr>
            <td>Password:</td>
            <td><code>${password}</code></td>
          </tr>
        </table>
      </div>
      
      <div class="warning-box">
        <p class="warning-text">
          <strong>Important:</strong> Please change your password after your first login for security.
        </p>
      </div>
      
      <div class="info-box">
        <strong>\u{1F680} Next Steps - Choose Your Path:</strong>
        <p>You now have two important accounts to set up:</p>
      </div>
      
      <div style="text-align: center; margin: 24px 0; width: 100%;">
        <div style="display: block; margin: 0 auto; max-width: 320px;">
          <a href="https://localcook.shop/app/shop/index.php" class="cta-button" style="display: block; width: 100%; background: #2563eb; color: white !important; margin-bottom: 16px; box-sizing: border-box;">
            \u{1F468}\u200D\u{1F373} Access Chef Dashboard
          </a>
          <a href="${getVendorDashboardUrl()}" class="cta-button" style="display: block; width: 100%; background: #16a34a; color: white !important; box-sizing: border-box;">
            \u{1F4B3} Set Up Stripe Payments
          </a>
        </div>
      </div>
      
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px; margin: 20px 0;">
        <p style="margin: 0; font-size: 14px; color: #64748b;">
          <strong>\u{1F468}\u200D\u{1F373} Chef Dashboard:</strong> Use your credentials above to log into your chef dashboard where you can manage your profile, products, and orders.
          <br><br>
          <strong>\u{1F4B3} Stripe Payments:</strong> Set up your payment processing to start receiving payments from customers. This is required to get paid for orders.
        </p>
      </div>
      
      <div class="divider"></div>
      
    </div>
    <div class="footer">
      <p class="footer-text">Welcome to the <strong>Local Cooks Community</strong>!</p>
      <p class="footer-text">If you have any questions, contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p>
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: userData.email,
        subject: "Chef Account Approved - Login Credentials Included",
        html,
        headers: {
          "X-Priority": "3",
          "X-MSMail-Priority": "Normal",
          "Importance": "Normal",
          "List-Unsubscribe": `<mailto:${getUnsubscribeEmail()}>`
        }
      };
    };
    generateApplicationWithDocumentsEmail = (applicationData) => {
      const supportEmail = getSupportEmail();
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Application and Documents Received - Under Review</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting">Hello ${applicationData.fullName},</h2>
      <p class="message">
        Thank you for submitting your application to Local Cooks! We have received both your application and your supporting documents.
      </p>
      <p class="message">
        Our team will now review your application and documents together. You'll receive another email once the review is complete.
      </p>
      <div class="status-badge">Status: Under Review</div>
    </div>
    <div class="footer">
      <p class="footer-text">Thank you for your interest in <a href="${getWebsiteUrl()}" class="footer-links">Local Cooks</a>!</p>
      <p class="footer-text">If you have any questions, contact us at <a href="mailto:${supportEmail}" class="footer-links">${supportEmail}</a>.</p>
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: applicationData.email,
        subject: "Application and Documents Received - Under Review",
        html
      };
    };
    generateApplicationWithoutDocumentsEmail = (applicationData) => {
      const supportEmail = getSupportEmail();
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Local Cooks Application Confirmation - Next Steps</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting">Hello ${applicationData.fullName},</h2>
      <p class="message">
        Thank you for submitting your application to Local Cooks! We have received your application and it will be reviewed soon.
      </p>
      <p class="message">
        <strong>Next Steps:</strong> Please visit your dashboard to upload the required documents to complete your application.
      </p>
      <div class="status-badge">Status: Under Review</div>
    </div>
    <div class="footer">
      <p class="footer-text">Thank you for your interest in <a href="${getWebsiteUrl()}" class="footer-links">Local Cooks</a>!</p>
      <p class="footer-text">If you have any questions, contact us at <a href="mailto:${supportEmail}" class="footer-links">${supportEmail}</a>.</p>
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: applicationData.email,
        subject: "Local Cooks Application Confirmation - Next Steps",
        html
      };
    };
    generateDocumentStatusChangeEmail = (userData) => {
      const getSubjectLine = (documentType, status) => {
        const docName2 = documentType === "foodSafetyLicenseStatus" ? "Food Safety License" : "Food Establishment Certificate";
        switch (status) {
          case "approved":
            return `${docName2} Approved - Local Cooks Community`;
          case "rejected":
            return `${docName2} Update Required - Local Cooks Community`;
          default:
            return `${docName2} Status Update - Local Cooks Community`;
        }
      };
      const subject = getSubjectLine(userData.documentType, userData.status);
      const generatePlainText = (documentType, status, fullName, adminFeedback) => {
        const docName2 = documentType === "foodSafetyLicenseStatus" ? "Food Safety License" : "Food Establishment Certificate";
        const statusMessages = {
          approved: `Great news! Your ${docName2} has been approved.`,
          rejected: `Your ${docName2} requires some updates before it can be approved.`,
          pending: `Your ${docName2} is being reviewed by our team.`
        };
        return `Hello ${fullName},

${statusMessages[status] || `Your ${docName2} status has been updated.`}

Document: ${docName2}
Status: ${status.charAt(0).toUpperCase() + status.slice(1)}

${adminFeedback ? `Admin Feedback: ${adminFeedback}

` : ""}${status === "approved" ? `Access your dashboard: ${getDashboardUrl()}` : status === "rejected" ? `Please update your document and resubmit: ${getDashboardUrl()}` : ""}

If you have any questions, please contact us at ${getSupportEmail()}.

Best regards,
Local Cooks Community Team

Visit: ${getWebsiteUrl()}
`;
      };
      const getMessage = (documentType, status) => {
        const docName2 = documentType === "foodSafetyLicenseStatus" ? "Food Safety License" : "Food Establishment Certificate";
        switch (status) {
          case "approved":
            return `Congratulations! Your ${docName2} has been approved by our verification team. This brings you one step closer to being fully verified on Local Cooks.`;
          case "rejected":
            return `Your ${docName2} could not be approved at this time. Please review the feedback below and upload an updated document.`;
          case "pending":
            return `Your ${docName2} is currently being reviewed by our verification team. We will notify you once the review is complete.`;
          default:
            return `Your ${docName2} status has been updated. Please check your dashboard for more details.`;
        }
      };
      const message = getMessage(userData.documentType, userData.status);
      const docName = userData.documentType === "foodSafetyLicenseStatus" ? "Food Safety License" : "Food Establishment Certificate";
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting">Hello ${userData.fullName},</h2>
      <p class="message">${message}</p>
      <div class="status-badge${userData.status === "approved" ? " approved" : userData.status === "rejected" ? " rejected" : ""}">
        \u{1F4C4} ${docName}: ${userData.status.charAt(0).toUpperCase() + userData.status.slice(1)}
      </div>
      ${userData.adminFeedback ? `
      <div class="info-box">
        <strong>\u{1F4AC} Admin Feedback:</strong><br>
        ${userData.adminFeedback}
      </div>` : ""}
      ${userData.status === "approved" ? `<a href="${getDashboardUrl()}" class="cta-button" style="color: white !important; text-decoration: none !important;">Access Your Dashboard</a>` : userData.status === "rejected" ? `<a href="${getDashboardUrl()}" class="cta-button" style="color: white !important; text-decoration: none !important;">Update Document</a>` : ""}
      <div class="divider"></div>
    </div>
    <div class="footer">
      <p class="footer-text">Thank you for your interest in <a href="${getWebsiteUrl()}" class="footer-links">Local Cooks</a>!</p>
      <p class="footer-text">If you have any questions, contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p>
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: userData.email,
        subject,
        text: generatePlainText(userData.documentType, userData.status, userData.fullName, userData.adminFeedback),
        html
      };
    };
    generatePasswordResetEmail = (userData) => {
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Password Reset Request - Local Cooks</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting">Hello ${userData.fullName},</h2>
      <p class="message">
        We received a request to reset your password for your Local Cooks account. If you didn't make this request, you can safely ignore this email.
      </p>
      <p class="message">
        Click the button below to create a new password. This link will expire in 1 hour for security.
      </p>
      <a href="${userData.resetUrl}" class="cta-button" style="color: white !important; text-decoration: none !important;">Reset My Password</a>
      <div class="warning-box">
        <p class="warning-text">
          <strong>Important:</strong> If you didn't request this password reset, please contact our support team immediately.
        </p>
      </div>
    </div>
    <div class="footer">
      <p class="footer-text">Keep your account secure with <strong>Local Cooks</strong></p>
      <p class="footer-text">If you have any questions, contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p>
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: userData.email,
        subject: "Password Reset Request - Local Cooks",
        html,
        headers: {
          "X-Priority": "3",
          "X-MSMail-Priority": "Normal",
          "Importance": "Normal",
          "List-Unsubscribe": `<mailto:${getUnsubscribeEmail()}>`
        }
      };
    };
    generateEmailVerificationEmail = (userData) => {
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Email Verification Required - Local Cooks</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting">Welcome ${userData.fullName}!</h2>
      <p class="message">
        Thank you for joining Local Cooks Community! We're excited to have you on board.
      </p>
      <p class="message">
        To complete your registration and activate your account, please verify your email address by clicking the button below.
      </p>
      <a href="${userData.verificationUrl}" class="cta-button" style="color: white !important; text-decoration: none !important;">Verify My Email</a>
      <div class="status-badge">Status: Verification Required</div>
    </div>
    <div class="footer">
      <p class="footer-text">Welcome to the <strong>Local Cooks</strong> community!</p>
      <p class="footer-text">If you have any questions, contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p>
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: userData.email,
        subject: "Email Verification Required - Local Cooks",
        html,
        headers: {
          "X-Priority": "3",
          "X-MSMail-Priority": "Normal",
          "Importance": "Normal",
          "List-Unsubscribe": `<mailto:${getUnsubscribeEmail()}>`
        }
      };
    };
    generateWelcomeEmail = (userData) => {
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Account Created - Local Cooks Community</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting">Hello ${userData.fullName},</h2>
      <p class="message">
        Welcome to Local Cooks Community! Your account has been successfully created and verified.
      </p>
      <p class="message">
        You can now access your dashboard to complete your profile setup and start your food safety training modules.
      </p>
      <div class="status-badge approved">Status: Account Active</div>
      <a href="${getDashboardUrl()}" class="cta-button" style="color: white !important; text-decoration: none !important;">Access Your Dashboard</a>
    </div>
    <div class="footer">
      <p class="footer-text">Thank you for joining <strong>Local Cooks</strong> Community!</p>
      <p class="footer-text">If you have any questions, contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p>
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: userData.email,
        subject: "Account Created - Local Cooks Community",
        html
      };
    };
    getSubdomainUrl = (userType = "main") => {
      const baseDomain = process.env.BASE_DOMAIN || "localcooks.ca";
      if (process.env.NODE_ENV !== "production" && !process.env.BASE_URL) {
        return "http://localhost:5000";
      }
      if (process.env.BASE_URL && !process.env.BASE_URL.includes("localhost")) {
        const url = new URL(process.env.BASE_URL);
        const hostname = url.hostname;
        const parts = hostname.split(".");
        if (parts.length >= 3) {
          return process.env.BASE_URL;
        }
        if (userType === "main") {
          return process.env.BASE_URL;
        }
        return `https://${userType}.${baseDomain}`;
      }
      if (userType === "main") {
        return `https://${baseDomain}`;
      }
      return `https://${userType}.${baseDomain}`;
    };
    getWebsiteUrl = () => {
      return getSubdomainUrl("main");
    };
    getDashboardUrl = (userType = "chef") => {
      const baseUrl = getSubdomainUrl(userType);
      if (userType === "chef") {
        return `${baseUrl}/auth?redirect=/dashboard`;
      } else if (userType === "kitchen") {
        return `${baseUrl}/portal`;
      } else if (userType === "admin") {
        return `${baseUrl}/admin`;
      }
      return `${baseUrl}/auth?redirect=/dashboard`;
    };
    getPrivacyUrl = () => {
      const baseUrl = getWebsiteUrl();
      return `${baseUrl}/privacy`;
    };
    getVendorDashboardUrl = () => {
      return process.env.VENDOR_DASHBOARD_URL || "https://localcook.shop/app/shop/index.php?redirect=https%3A%2F%2Flocalcook.shop%2Fapp%2Fshop%2Fvendor_onboarding.php";
    };
    getPromoUrl = () => {
      return "https://localcook.shop/app/index.php";
    };
    generateDocumentUpdateEmail = (userData) => {
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document Update Received - Local Cooks</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting">Hello ${userData.fullName},</h2>
      <p class="message">
        Thank you for updating your documents. Our team will review them and update your verification status as soon as possible.
      </p>
      <p class="message">
        You'll receive another email once your documents have been reviewed.
      </p>
      <div class="status-badge">
        \u{1F4C4} Document Update Received
      </div>
      <div class="divider"></div>
    </div>
    <div class="footer">
      <p class="footer-text">Thank you for your interest in <a href="${getWebsiteUrl()}" class="footer-links">Local Cooks</a>!</p>
      <p class="footer-text">If you have any questions, contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p>
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: userData.email,
        subject: "Document Update Received - Local Cooks",
        html,
        headers: {
          "X-Priority": "3",
          "X-MSMail-Priority": "Normal",
          "Importance": "Normal",
          "List-Unsubscribe": `<mailto:${getUnsubscribeEmail()}>`
        }
      };
    };
    generatePromoCodeEmail = (userData) => {
      const organizationName = getOrganizationName();
      const supportEmail = getSupportEmail();
      const defaultPromoStyle = userData.promoStyle || { colorTheme: "green", borderStyle: "dashed" };
      const messageContent = userData.customMessage || userData.message || "";
      const getSectionData = (sectionId) => {
        if (!userData.sections) return null;
        if (Array.isArray(userData.sections)) {
          return userData.sections.find((s) => s.id === sectionId || s.id === `${sectionId}-section`) || null;
        }
        if (typeof userData.sections === "object") {
          return userData.sections[sectionId] || userData.sections[`${sectionId}-section`] || userData.sections[sectionId.replace("-section", "")] || null;
        }
        return null;
      };
      const getPromoStyling = (colorTheme, borderStyle) => {
        const themes = {
          green: {
            background: "linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)",
            textColor: "#16a34a",
            accentColor: "#15803d",
            borderColor: "#16a34a",
            border: "2px dashed #16a34a",
            boxShadow: "0 4px 16px rgba(22, 163, 74, 0.15)"
          },
          blue: {
            background: "linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)",
            textColor: "#2563eb",
            accentColor: "#1d4ed8",
            borderColor: "#2563eb",
            border: "2px dashed #2563eb",
            boxShadow: "0 4px 16px rgba(37, 99, 235, 0.15)"
          },
          purple: {
            background: "linear-gradient(135deg, #faf5ff 0%, #e9d5ff 100%)",
            textColor: "#7c3aed",
            accentColor: "#6d28d9",
            borderColor: "#7c3aed",
            border: "2px dashed #7c3aed",
            boxShadow: "0 4px 16px rgba(124, 58, 237, 0.15)"
          },
          red: {
            background: "linear-gradient(135deg, #fef2f2 0%, #fecaca 100%)",
            textColor: "#dc2626",
            accentColor: "#b91c1c",
            borderColor: "#dc2626",
            border: "2px dashed #dc2626",
            boxShadow: "0 4px 16px rgba(220, 38, 38, 0.15)"
          },
          orange: {
            background: "linear-gradient(135deg, #fff7ed 0%, #fed7aa 100%)",
            textColor: "#ea580c",
            accentColor: "#c2410c",
            borderColor: "#ea580c",
            border: "2px dashed #ea580c",
            boxShadow: "0 4px 16px rgba(234, 88, 12, 0.15)"
          },
          pink: {
            background: "linear-gradient(135deg, #fdf2f8 0%, #fce7f3 100%)",
            textColor: "#e11d48",
            accentColor: "#be185d",
            borderColor: "#e11d48",
            border: "2px dashed #e11d48",
            boxShadow: "0 4px 16px rgba(225, 29, 72, 0.15)"
          },
          yellow: {
            background: "linear-gradient(135deg, #fefce8 0%, #fef3c7 100%)",
            textColor: "#ca8a04",
            accentColor: "#a16207",
            borderColor: "#ca8a04",
            border: "2px dashed #ca8a04",
            boxShadow: "0 4px 16px rgba(202, 138, 4, 0.15)"
          },
          gray: {
            background: "linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%)",
            textColor: "#475569",
            accentColor: "#334155",
            borderColor: "#475569",
            border: "2px dashed #475569",
            boxShadow: "0 4px 16px rgba(71, 85, 105, 0.15)"
          }
        };
        const theme = themes[colorTheme] || themes.green;
        if (borderStyle === "solid") {
          theme.border = `2px solid ${theme.borderColor}`;
        } else if (borderStyle === "dotted") {
          theme.border = `2px dotted ${theme.borderColor}`;
        }
        return theme;
      };
      const generateAdvancedSections = (sections = []) => {
        return sections.map((section) => {
          switch (section.type) {
            case "text":
              const hasBackground = section.styling?.backgroundColor && section.styling.backgroundColor !== "transparent";
              const paddingValue = hasBackground ? "12px" : section.styling?.padding || "8px 0";
              return `
            <div style="
              font-size: ${section.styling?.fontSize || "16px"};
              color: ${section.styling?.color || "#374151"};
              font-weight: ${section.styling?.fontWeight || "400"};
              font-style: ${section.styling?.fontStyle || "normal"};
              text-align: ${section.styling?.textAlign || "left"};
              padding: ${paddingValue};
              margin: ${section.styling?.margin || "0"};
              line-height: 1.6;
              ${hasBackground ? `background: ${section.styling.backgroundColor};` : ""}
              ${hasBackground ? `border-radius: 8px;` : ""}
            ">
              ${section.content || section.text || ""}
            </div>
          `;
            case "button":
              return `
            <div style="text-align: ${section.styling?.textAlign || "center"}; margin: 20px 0;">
              <a href="${section.styling?.url || getPromoUrl()}" style="
                display: inline-block;
                background: ${section.styling?.backgroundColor || styling.accentColor};
                color: ${section.styling?.color || "#ffffff"} !important;
                text-decoration: none !important;
                padding: ${section.styling?.padding || "12px 24px"};
                border-radius: 6px;
                font-weight: ${section.styling?.fontWeight || "600"};
                font-size: ${section.styling?.fontSize || "16px"};
                border: none;
                cursor: pointer;
              ">
                ${section.content || section.text || "Click Here"}
              </a>
            </div>
          `;
            case "image":
              if (section.content) {
                const hasOverlay = section.overlay?.enabled && section.overlay?.text;
                if (hasOverlay) {
                  return `
                <div style="text-align: ${section.styling?.textAlign || "center"}; margin: 20px 0;">
                  <div style="position: relative; display: inline-block; width: ${section.styling?.width || "200px"}; height: ${section.styling?.height || "120px"};">
                    <img 
                      src="${section.content}" 
                      alt="Email image"
                      style="
                        width: 100%;
                        height: 100%;
                        object-fit: ${section.styling?.objectFit || "cover"};
                        border-radius: ${section.styling?.borderRadius || "8px"};
                        border: 1px solid #e2e8f0;
                        display: block;
                        max-width: 100%;
                      "
                    />
                    <!--[if mso]>
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10;">
                    <![endif]-->
                    <div style="
                      position: absolute;
                      top: 50%;
                      left: 50%;
                      transform: translate(-50%, -50%);
                      color: ${section.overlay.styling?.color || "#ffffff"};
                      font-size: ${section.overlay.styling?.fontSize || "18px"};
                      font-weight: ${section.overlay.styling?.fontWeight || "600"};
                      text-align: center;
                      background-color: ${section.overlay.styling?.backgroundColor || "rgba(0, 0, 0, 0.5)"};
                      padding: ${section.overlay.styling?.padding || "12px 20px"};
                      border-radius: ${section.overlay.styling?.borderRadius || "6px"};
                      text-shadow: ${section.overlay.styling?.textShadow || "1px 1px 2px rgba(0, 0, 0, 0.7)"};
                      max-width: 90%;
                      word-wrap: break-word;
                      z-index: 10;
                      line-height: 1.4;
                    ">
                      ${section.overlay.text}
                    </div>
                    <!--[if mso]>
                    </div>
                    <![endif]-->
                  </div>
                </div>
              `;
                } else {
                  return `
                <div style="text-align: ${section.styling?.textAlign || "center"}; margin: 20px 0;">
                  <img 
                    src="${section.content}" 
                    alt="Email image"
                    style="
                      width: ${section.styling?.width || "200px"};
                      height: ${section.styling?.height || "120px"};
                      object-fit: ${section.styling?.objectFit || "cover"};
                      border-radius: ${section.styling?.borderRadius || "8px"};
                      border: 1px solid #e2e8f0;
                      display: block;
                      max-width: 100%;
                    "
                  />
                </div>
              `;
                }
              }
              return "";
            default:
              return "";
          }
        }).join("");
      };
      const generateDivider = () => {
        if (!userData.dividers?.enabled) return "";
        return `
      <div style="margin: ${userData.dividers.margin || "24px 0"};">
        <hr style="
          border: none;
          border-top: ${userData.dividers.thickness || "1px"} ${userData.dividers.style || "solid"} ${userData.dividers.color || "#e2e8f0"};
          opacity: ${userData.dividers.opacity || "1"};
          margin: 0;
        " />
      </div>
    `;
      };
      const getGreeting = () => {
        const greetingSection = getSectionData("greeting") || getSectionData("greeting-section");
        if (greetingSection?.content || greetingSection?.text) {
          return greetingSection.content || greetingSection.text;
        }
        return userData.greeting || "Hello! \u{1F44B}";
      };
      const getCustomMessage = () => {
        const messageSection = getSectionData("custom-message") || getSectionData("custom-message-section");
        if (messageSection?.content || messageSection?.text) {
          return messageSection.content || messageSection.text;
        }
        return messageContent || "Thank you for being a valued customer!";
      };
      const generatePlainText = (email, promoCode, customMessage) => {
        if (promoCode) {
          return `Special Promo Code from ${organizationName}

${customMessage}

Your Promo Code: ${promoCode}

To use your promo code:
1. Visit our website: ${getPromoUrl()}
2. Apply during checkout or registration
3. Enjoy your special offer!

Questions? Contact us at ${supportEmail}

Best regards,
${organizationName} Team

Visit: ${getPromoUrl()}
`;
        } else {
          return `Message from ${organizationName}

${customMessage}

Questions? Contact us at ${supportEmail}

Best regards,
${organizationName} Team

Visit: ${getPromoUrl()}
`;
        }
      };
      const subject = userData.subject || (userData.promoCode ? `\u{1F381} Exclusive Promo Code: ${userData.promoCode}` : "Important Update from Local Cooks Community");
      const styling = getPromoStyling(defaultPromoStyle.colorTheme, defaultPromoStyle.borderStyle);
      const finalGreeting = getGreeting();
      const finalMessage = getCustomMessage();
      const generateUsageStepsSection = () => {
        const defaultSteps = [
          `Visit our website: <a href="${userData.orderButton?.url || getPromoUrl()}" style="color: ${userData.usageSteps?.styling?.linkColor || "#1d4ed8"};">${userData.orderButton?.url || getPromoUrl()}</a>`,
          "Browse our amazing local cooks and their delicious offerings",
          "Apply your promo code during checkout",
          "Enjoy your special offer!"
        ];
        const steps = userData.usageSteps?.steps && userData.usageSteps.steps.length > 0 ? userData.usageSteps.steps : defaultSteps;
        const stepsHtml = steps.map((step) => `<li>${step}</li>`).join("");
        return `
      <div class="usage-steps">
        <h4>${userData.usageSteps?.title || "\u{1F680} How to use your promo code:"}</h4>
        <ol>
          ${stepsHtml}
        </ol>
      </div>
      ${generateDivider()}
    `;
      };
      const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
  <style>
    /* Override email container styles for customization */
    body { 
      background: ${userData.emailContainer?.backgroundColor || "#f1f5f9"} !important;
      ${userData.emailContainer?.backgroundImage ? `background-image: url(${userData.emailContainer.backgroundImage}) !important;` : ""}
      ${userData.emailContainer?.backgroundSize ? `background-size: ${userData.emailContainer.backgroundSize} !important;` : ""}
      ${userData.emailContainer?.backgroundPosition ? `background-position: ${userData.emailContainer.backgroundPosition} !important;` : ""}
      ${userData.emailContainer?.backgroundRepeat ? `background-repeat: ${userData.emailContainer.backgroundRepeat} !important;` : ""}
      ${userData.emailContainer?.backgroundAttachment ? `background-attachment: ${userData.emailContainer.backgroundAttachment} !important;` : ""}
    }
    .email-container { 
      max-width: ${userData.emailContainer?.maxWidth || "600px"} !important; 
      border-radius: ${userData.emailContainer?.borderRadius || "12px"} !important; 
      box-shadow: ${userData.emailContainer?.boxShadow || "0 4px 20px rgba(0,0,0,0.08)"} !important;
    }
    
    .promo-code-box {
      background: ${userData.promoCodeStyling?.backgroundColor || "#f3f4f6"};
      border: ${userData.promoCodeStyling?.borderWidth || userData.promoCodeStyling?.borderStyle || userData.promoCodeStyling?.borderColor ? `${userData.promoCodeStyling?.borderWidth || "2px"} ${userData.promoCodeStyling?.borderStyle || "dashed"} ${userData.promoCodeStyling?.borderColor || "#9ca3af"}` : "2px dashed #9ca3af"};
      border-radius: ${userData.promoCodeStyling?.borderRadius || "12px"};
      padding: ${userData.promoCodeStyling?.padding || "20px"};
      box-shadow: ${userData.promoCodeStyling?.boxShadow || "0 2px 4px rgba(0,0,0,0.1)"};
      display: inline-block;
      min-width: 200px;
    }
    .promo-code {
      font-family: 'Courier New', monospace;
      font-size: ${userData.promoCodeStyling?.fontSize || "24px"};
      font-weight: ${userData.promoCodeStyling?.fontWeight || "bold"};
      color: ${userData.promoCodeStyling?.textColor || "#1f2937"};
      letter-spacing: 2px;
      margin: 0;
    }
    .promo-label {
      font-size: ${userData.promoCodeStyling?.labelFontSize || "16px"};
      font-weight: ${userData.promoCodeStyling?.labelFontWeight || "600"};
      color: ${userData.promoCodeStyling?.labelColor || "#374151"};
      margin: 0;
      text-align: center;
    }
    .greeting {
      font-size: ${getSectionData("greeting")?.styling?.fontSize || getSectionData("greeting-section")?.styling?.fontSize || "18px"};
      font-weight: ${getSectionData("greeting")?.styling?.fontWeight || getSectionData("greeting-section")?.styling?.fontWeight || "normal"};
      font-style: ${getSectionData("greeting")?.styling?.fontStyle || getSectionData("greeting-section")?.styling?.fontStyle || "normal"};
      color: ${getSectionData("greeting")?.styling?.color || getSectionData("greeting-section")?.styling?.color || "#1f2937"};
      text-align: ${getSectionData("greeting")?.styling?.textAlign || getSectionData("greeting-section")?.styling?.textAlign || "left"};
      line-height: ${getSectionData("greeting")?.styling?.lineHeight || getSectionData("greeting-section")?.styling?.lineHeight || "1.6"};
      letter-spacing: ${getSectionData("greeting")?.styling?.letterSpacing || getSectionData("greeting-section")?.styling?.letterSpacing || "normal"};
      text-transform: ${getSectionData("greeting")?.styling?.textTransform || getSectionData("greeting-section")?.styling?.textTransform || "none"};
      margin: ${getSectionData("greeting")?.styling?.margin || getSectionData("greeting-section")?.styling?.margin || "0"};
      ${getSectionData("greeting")?.styling?.marginTop ? `margin-top: ${getSectionData("greeting")?.styling?.marginTop};` : ""}
      ${getSectionData("greeting")?.styling?.marginRight ? `margin-right: ${getSectionData("greeting")?.styling?.marginRight};` : ""}
      ${getSectionData("greeting")?.styling?.marginBottom ? `margin-bottom: ${getSectionData("greeting")?.styling?.marginBottom || "16px"};` : "margin-bottom: 16px;"}
      ${getSectionData("greeting")?.styling?.marginLeft ? `margin-left: ${getSectionData("greeting")?.styling?.marginLeft};` : ""}
      padding: ${getSectionData("greeting")?.styling?.padding || getSectionData("greeting-section")?.styling?.padding || "0"};
      ${getSectionData("greeting")?.styling?.paddingTop ? `padding-top: ${getSectionData("greeting")?.styling?.paddingTop};` : ""}
      ${getSectionData("greeting")?.styling?.paddingRight ? `padding-right: ${getSectionData("greeting")?.styling?.paddingRight};` : ""}
      ${getSectionData("greeting")?.styling?.paddingBottom ? `padding-bottom: ${getSectionData("greeting")?.styling?.paddingBottom};` : ""}
      ${getSectionData("greeting")?.styling?.paddingLeft ? `padding-left: ${getSectionData("greeting")?.styling?.paddingLeft};` : ""}
    }
    .custom-message {
      font-size: ${getSectionData("custom-message")?.styling?.fontSize || getSectionData("custom-message-section")?.styling?.fontSize || "16px"};
      font-weight: ${getSectionData("custom-message")?.styling?.fontWeight || getSectionData("custom-message-section")?.styling?.fontWeight || "normal"};
      font-style: ${getSectionData("custom-message")?.styling?.fontStyle || getSectionData("custom-message-section")?.styling?.fontStyle || "normal"};
      color: ${getSectionData("custom-message")?.styling?.color || getSectionData("custom-message-section")?.styling?.color || "#374151"};
      text-align: ${getSectionData("custom-message")?.styling?.textAlign || getSectionData("custom-message-section")?.styling?.textAlign || "left"};
      line-height: ${getSectionData("custom-message")?.styling?.lineHeight || getSectionData("custom-message-section")?.styling?.lineHeight || "1.7"};
      letter-spacing: ${getSectionData("custom-message")?.styling?.letterSpacing || getSectionData("custom-message-section")?.styling?.letterSpacing || "normal"};
      text-transform: ${getSectionData("custom-message")?.styling?.textTransform || getSectionData("custom-message-section")?.styling?.textTransform || "none"};
      white-space: pre-line; /* Preserves line breaks from admin input */
      margin: ${getSectionData("custom-message")?.styling?.margin || getSectionData("custom-message-section")?.styling?.margin || "24px 0"};
      ${getSectionData("custom-message")?.styling?.marginTop ? `margin-top: ${getSectionData("custom-message")?.styling?.marginTop};` : ""}
      ${getSectionData("custom-message")?.styling?.marginRight ? `margin-right: ${getSectionData("custom-message")?.styling?.marginRight};` : ""}
      ${getSectionData("custom-message")?.styling?.marginBottom ? `margin-bottom: ${getSectionData("custom-message")?.styling?.marginBottom};` : ""}
      ${getSectionData("custom-message")?.styling?.marginLeft ? `margin-left: ${getSectionData("custom-message")?.styling?.marginLeft};` : ""}
      padding: ${getSectionData("custom-message")?.styling?.padding || getSectionData("custom-message-section")?.styling?.padding || "0"};
      ${getSectionData("custom-message")?.styling?.paddingTop ? `padding-top: ${getSectionData("custom-message")?.styling?.paddingTop};` : ""}
      ${getSectionData("custom-message")?.styling?.paddingRight ? `padding-right: ${getSectionData("custom-message")?.styling?.paddingRight};` : ""}
      ${getSectionData("custom-message")?.styling?.paddingBottom ? `padding-bottom: ${getSectionData("custom-message")?.styling?.paddingBottom};` : ""}
      ${getSectionData("custom-message")?.styling?.paddingLeft ? `padding-left: ${getSectionData("custom-message")?.styling?.paddingLeft};` : ""}
    }
    .custom-header {
      background: ${userData.header?.styling?.backgroundColor || "linear-gradient(135deg, #F51042 0%, #FF5470 100%)"};
      ${userData.header?.styling?.backgroundImage ? `background-image: url(${userData.header.styling.backgroundImage});` : ""}
      ${userData.header?.styling?.backgroundSize ? `background-size: ${userData.header.styling.backgroundSize};` : ""}
      ${userData.header?.styling?.backgroundPosition ? `background-position: ${userData.header.styling.backgroundPosition};` : ""}
      ${userData.header?.styling?.backgroundRepeat ? `background-repeat: ${userData.header.styling.backgroundRepeat};` : ""}
      ${userData.header?.styling?.backgroundAttachment ? `background-attachment: ${userData.header.styling.backgroundAttachment};` : ""}
      border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")};
      -webkit-border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")};
      -moz-border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")};
      border-top-left-radius: ${userData.emailContainer?.borderRadius || "12px"};
      border-top-right-radius: ${userData.emailContainer?.borderRadius || "12px"};
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      padding: ${userData.header?.styling?.padding || "24px 32px"};
      text-align: ${userData.header?.styling?.textAlign || "center"};
      margin: 0 0 24px 0;
      overflow: hidden;
    }
    .custom-header h1 {
      color: ${userData.header?.styling?.titleColor || "#ffffff"};
      font-size: ${userData.header?.styling?.titleFontSize || "32px"};
      font-weight: 700;
      margin: 0 0 8px 0;
      line-height: 1.2;
    }
    .custom-header p {
      color: ${userData.header?.styling?.subtitleColor || "#ffffff"};
      font-size: ${userData.header?.styling?.subtitleFontSize || "18px"};
      margin: 0;
      opacity: 0.9;
    }
    .custom-order-button {
      display: inline-block;
      background: ${userData.orderButton?.styling?.backgroundColor || "linear-gradient(135deg, hsl(347, 91%, 51%) 0%, hsl(347, 91%, 45%) 100%)"};
      color: ${userData.orderButton?.styling?.color || "#ffffff"} !important;
      text-decoration: none !important;
      padding: ${userData.orderButton?.styling?.padding || "14px 28px"};
      border-radius: ${userData.orderButton?.styling?.borderRadius || "8px"};
      font-weight: ${userData.orderButton?.styling?.fontWeight || "600"};
      font-size: ${userData.orderButton?.styling?.fontSize || "16px"};
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px hsla(347, 91%, 51%, 0.3);
      line-height: 1.4;
      text-align: center;
      word-wrap: break-word;
      word-break: break-word;
      hyphens: auto;
      max-width: 100%;
      box-sizing: border-box;
      min-height: 48px;
      vertical-align: middle;
    }
    .usage-steps {
      background: ${userData.usageSteps?.styling?.backgroundColor || "linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)"};
      border: 1px solid ${userData.usageSteps?.styling?.borderColor || "#93c5fd"};
      border-radius: ${userData.usageSteps?.styling?.borderRadius || "8px"};
      padding: ${userData.usageSteps?.styling?.padding || "20px"};
      margin: 24px 0;
    }
    .usage-steps h4 {
      color: ${userData.usageSteps?.styling?.titleColor || "#1d4ed8"};
      font-size: 16px;
      font-weight: 600;
      margin: 0 0 12px 0;
    }
    .usage-steps ol {
      margin: 0;
      padding-left: 20px;
      color: ${userData.usageSteps?.styling?.textColor || "#1e40af"};
    }
    .usage-steps li {
      margin: 6px 0;
      font-size: 14px;
    }
    .custom-footer {
      background: ${userData.footer?.styling?.backgroundColor || "#f8fafc"};
      padding: ${userData.footer?.styling?.padding || "24px 32px"};
      text-align: ${userData.footer?.styling?.textAlign || "center"};
      border-top: 1px solid ${userData.footer?.styling?.borderColor || "#e2e8f0"};
    }
    .custom-footer .footer-text {
      font-size: ${userData.footer?.styling?.fontSize || "14px"};
      color: ${userData.footer?.styling?.textColor || "#64748b"};
      margin: 0 0 8px 0;
      line-height: 1.5;
    }
    .custom-footer .footer-link {
      color: ${userData.footer?.styling?.linkColor || "#F51042"};
      text-decoration: none;
    }
    .cta-container {
      text-align: ${userData.orderButton?.styling?.textAlign || "center"};
      margin: 32px 0;
      padding: 0 20px;
      overflow: hidden;
    }
    
    /* Mobile-specific styles */
    @media only screen and (max-width: 600px) {
      .email-container {
        max-width: ${userData.emailContainer?.mobileMaxWidth || "100%"} !important;
        padding: ${userData.emailContainer?.mobilePadding || "16px"} !important;
      }
      
      .greeting {
        font-size: calc(${getSectionData("greeting")?.styling?.fontSize || "18px"} * ${userData.emailContainer?.mobileFontScale ? parseFloat(userData.emailContainer.mobileFontScale) / 100 : 1}) !important;
      }
      
      .custom-message {
        font-size: calc(${getSectionData("custom-message")?.styling?.fontSize || "16px"} * ${userData.emailContainer?.mobileFontScale ? parseFloat(userData.emailContainer.mobileFontScale) / 100 : 1}) !important;
      }
      
      .custom-order-button {
        ${userData.emailContainer?.mobileButtonSize === "full-width" ? "width: calc(100% - 40px) !important; display: block !important; text-align: center !important; margin: 0 auto !important;" : ""}
        ${userData.emailContainer?.mobileButtonSize === "large" ? "padding: 16px 32px !important; font-size: 18px !important; min-height: 56px !important;" : ""}
        ${userData.emailContainer?.mobileButtonSize === "small" ? "padding: 10px 20px !important; font-size: 14px !important; min-height: 40px !important;" : ""}
        line-height: 1.3 !important;
        word-wrap: break-word !important;
        overflow-wrap: break-word !important;
        max-width: calc(100% - 40px) !important;
      }
      
      .promo-code-box {
        padding: 16px !important;
        margin: 16px 0 !important;
      }
      
      .promo-code {
        font-size: calc(${userData.promoCodeStyling?.fontSize || "24px"} * ${userData.emailContainer?.mobileFontScale ? parseFloat(userData.emailContainer.mobileFontScale) / 100 : 1}) !important;
      }
      
      .custom-header {
        padding: 20px 16px !important;
        border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")} !important;
        -webkit-border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")} !important;
        -moz-border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")} !important;
        border-top-left-radius: ${userData.emailContainer?.borderRadius || "12px"} !important;
        border-top-right-radius: ${userData.emailContainer?.borderRadius || "12px"} !important;
        overflow: hidden !important;
      }
      
      .custom-header h1 {
        font-size: calc(${userData.header?.styling?.titleFontSize || "32px"} * ${userData.emailContainer?.mobileFontScale ? parseFloat(userData.emailContainer.mobileFontScale) / 100 : 1}) !important;
      }
      
      .custom-header p {
        font-size: calc(${userData.header?.styling?.subtitleFontSize || "18px"} * ${userData.emailContainer?.mobileFontScale ? parseFloat(userData.emailContainer.mobileFontScale) / 100 : 1}) !important;
      }
      
      .usage-steps {
        padding: 16px !important;
        margin: 16px 0 !important;
      }
      
      .custom-footer {
        padding: 20px 16px !important;
      }
    }
    
    /* Additional mobile email client compatibility */
    @media screen and (max-width: 480px) {
      .custom-header {
        border-radius: ${userData.emailContainer?.borderRadius || "12px"} ${userData.emailContainer?.borderRadius || "12px"} 0 0 !important;
        -webkit-border-top-left-radius: ${userData.emailContainer?.borderRadius || "12px"} !important;
        -webkit-border-top-right-radius: ${userData.emailContainer?.borderRadius || "12px"} !important;
        -webkit-border-bottom-left-radius: 0 !important;
        -webkit-border-bottom-right-radius: 0 !important;
      }
    }
    
    /* Gmail mobile app specific fixes */
    u + .body .custom-header {
      border-radius: ${userData.emailContainer?.borderRadius || "12px"} ${userData.emailContainer?.borderRadius || "12px"} 0 0 !important;
    }
    
    /* Outlook mobile app specific fixes */
    .ExternalClass .custom-header {
      border-radius: ${userData.emailContainer?.borderRadius || "12px"} ${userData.emailContainer?.borderRadius || "12px"} 0 0 !important;
    }
  </style>
</head>
<body>
  <div class="email-container">
    <div class="custom-header" style="
      background: ${userData.header?.styling?.backgroundColor || "linear-gradient(135deg, #F51042 0%, #FF5470 100%)"};
      border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")};
      -webkit-border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")};
      -moz-border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")};
      border-top-left-radius: ${userData.emailContainer?.borderRadius || "12px"};
      border-top-right-radius: ${userData.emailContainer?.borderRadius || "12px"};
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      padding: ${userData.header?.styling?.padding || "24px 32px"};
      text-align: ${userData.header?.styling?.textAlign || "center"};
      margin: 0 0 24px 0;
      overflow: hidden;
    ">
      <img 
        src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" 
        alt="Local Cooks" 
        style="max-width: 280px; height: auto; display: block; margin: 0 auto${userData.header?.title ? "; margin-bottom: 16px" : ""}"
      />
      ${userData.header?.title ? `<h1 style="color: ${userData.header?.styling?.titleColor || "#ffffff"}; font-size: ${userData.header?.styling?.titleFontSize || "32px"}; font-weight: 700; margin: 0 0 8px 0; line-height: 1.2;">${userData.header.title}</h1>` : ""}
      ${userData.header?.subtitle ? `<p style="color: ${userData.header?.styling?.subtitleColor || "#ffffff"}; font-size: ${userData.header?.styling?.subtitleFontSize || "18px"}; margin: 0; opacity: 0.9;">${userData.header.subtitle}</p>` : ""}
    </div>
    <div class="content">
      <!-- Enhanced Email Design -->
      <h2 class="greeting">${finalGreeting}</h2>
      
      ${generateDivider()}
      
      <div class="custom-message">
        ${finalMessage}
      </div>
      
      ${generateDivider()}
      
      ${userData.promoCode ? `
        <div style="text-align: center; margin: 32px 0;">
          <div class="promo-label" style="margin-bottom: 12px;">${userData.promoCodeLabel || "Use promo code:"}</div>
          <div class="promo-code-box">
            <div class="promo-code">${userData.promoCode}</div>
          </div>
        </div>
        ${generateDivider()}
      ` : ""}

      <!-- Usage Steps Section (Always Show Unless Explicitly Disabled) -->
      ${userData.usageSteps?.enabled !== false ? generateUsageStepsSection() : ""}

      <!-- Custom Sections (if any) -->
      ${userData.sections && (Array.isArray(userData.sections) ? userData.sections.length > 0 : Object.keys(userData.sections).length > 0) ? generateAdvancedSections(Array.isArray(userData.sections) ? userData.sections : Object.values(userData.sections)) + generateDivider() : ""}
      
      <!-- Call to Action Button -->
      <div class="cta-container">
        <a href="${userData.orderButton?.url || getPromoUrl()}" class="custom-order-button">
          ${userData.orderButton?.text || "\u{1F31F} Start Shopping Now"}
        </a>
      </div>
      
      <div class="divider"></div>
    </div>
    <div class="custom-footer">
      ${userData.footer?.mainText ? `<p class="footer-text"><strong>${userData.footer.mainText}</strong></p>` : `<p class="footer-text">Thank you for being part of the <strong>${organizationName}</strong> community!</p>`}
      
      ${userData.footer?.showContact !== false && userData.footer?.contactText ? `
        <p class="footer-text">
          ${userData.footer.contactText.includes("@") ? userData.footer.contactText.replace(/(\S+@\S+)/g, '<a href="mailto:$1" class="footer-link">$1</a>') : userData.footer.contactText}
        </p>
      ` : userData.footer?.showContact !== false ? `
        <p class="footer-text">Questions? Contact us at <a href="mailto:${supportEmail}" class="footer-link">${supportEmail}</a>.</p>
      ` : ""}
      
      ${userData.footer?.showCopyright !== false ? `
        <div style="height: 1px; background: linear-gradient(90deg, transparent 0%, ${userData.footer?.styling?.borderColor || "#e2e8f0"} 50%, transparent 100%); margin: 16px 0;"></div>
        <p class="footer-text" style="opacity: 0.8; font-size: ${userData.footer?.styling?.fontSize ? parseInt(userData.footer.styling.fontSize) - 2 + "px" : "12px"};">
          ${userData.footer?.copyrightText || `&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} ${organizationName}. All rights reserved.`}
        </p>
      ` : ""}
      
      <!-- Unsubscribe Link -->
      <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid ${userData.footer?.styling?.borderColor || "#e2e8f0"};">
        <p style="text-align: center; font-size: 11px; color: #6b7280; margin: 0;">
          Don't want to receive these emails? 
          <a href="${getWebsiteUrl()}/unsubscribe?email=${encodeURIComponent(userData.email)}" 
             style="color: #F51042; text-decoration: underline;">
            Unsubscribe here
          </a>
        </p>
      </div>
    </div>
  </div>
</body>
</html>`;
      return {
        to: userData.email,
        subject,
        text: generatePlainText(userData.email, userData.promoCode, finalMessage),
        html,
        headers: {
          "X-Priority": "3",
          "X-MSMail-Priority": "Normal",
          "Importance": "Normal",
          "List-Unsubscribe": `<mailto:${getUnsubscribeEmail()}>`
        }
      };
    };
    generateChefAllDocumentsApprovedEmail = (userData) => {
      const subject = "All Documents Approved - Welcome to Local Cooks Community!";
      const generatePlainText = (fullName, approvedDocuments, adminFeedback) => {
        const docList2 = approvedDocuments.join(", ");
        return `Hello ${fullName},

\u{1F389} Congratulations! All your submitted documents have been approved by our verification team.

Approved Documents: ${docList2}

You are now fully verified and can start using Local Cooks Community as a chef.

${adminFeedback ? `Admin Feedback: ${adminFeedback}

` : ""}Access your dashboard: ${getDashboardUrl()}

If you have any questions, please contact us at ${getSupportEmail()}.

Best regards,
Local Cooks Community Team

Visit: ${getWebsiteUrl()}
`;
      };
      const docList = userData.approvedDocuments.join(", ");
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting">Hello ${userData.fullName},</h2>
      <p class="message">
        \u{1F389} <strong>Congratulations!</strong> All your submitted documents have been approved by our verification team.
      </p>
      <p class="message">
        You are now fully verified and can start using Local Cooks Community as a chef.
      </p>
      <div class="status-badge approved">
        \u2705 All Documents Approved
      </div>
      <div class="info-box">
        <strong>\u{1F4C4} Approved Documents:</strong><br>
        ${userData.approvedDocuments.map((doc) => `\u2022 ${doc}`).join("<br>")}
      </div>
      ${userData.adminFeedback ? `
      <div class="info-box">
        <strong>\u{1F4AC} Admin Feedback:</strong><br>
        ${userData.adminFeedback}
      </div>` : ""}
      <a href="${getDashboardUrl()}" class="cta-button" style="color: white !important; text-decoration: none !important;">Access Your Dashboard</a>
      <div class="divider"></div>
    </div>
    <div class="footer">
      <p class="footer-text">Welcome to <a href="${getWebsiteUrl()}" class="footer-links">Local Cooks</a>!</p>
      <p class="footer-text">If you have any questions, contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p>
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: userData.email,
        subject,
        text: generatePlainText(userData.fullName, userData.approvedDocuments, userData.adminFeedback),
        html
      };
    };
    generateManagerMagicLinkEmail = (userData) => {
      const subject = "Set Up Your Manager Account - Local Cooks";
      const baseUrl = process.env.FRONTEND_URL || "http://localhost:5173";
      const resetUrl = `${baseUrl}/password-reset?token=${userData.resetToken}&role=manager`;
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${subject}</title>${getUniformEmailStyles()}</head><body><div class="email-container"><div class="header"><img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" /></div><div class="content"><h2 class="greeting">Hello ${userData.name},</h2><p class="message">Your manager account has been created for the Local Cooks commercial kitchen booking system!</p><p class="message">Click the button below to set up your password and access your manager dashboard:</p><a href="${resetUrl}" class="cta-button" style="color: white !important; text-decoration: none !important;">Set Up Password</a><div class="info-box"><strong>\u{1F510} Account Access:</strong><br>You'll be able to manage kitchen schedules, view bookings, and set up availability for your location.</div><div class="divider"></div></div><div class="footer"><p class="footer-text">If you have any questions, contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p><div class="divider"></div><p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p></div></div></body></html>`;
      return { to: userData.email, subject, text: `Hello ${userData.name}, Your manager account has been created. Click here to set up your password: ${resetUrl}`, html };
    };
    generateManagerCredentialsEmail = (userData) => {
      const subject = "Your Manager Account - Local Cooks Community";
      const baseUrl = getWebsiteUrl();
      const loginUrl = `${baseUrl}/manager/login`;
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${subject}</title>${getUniformEmailStyles()}</head><body><div class="email-container"><div class="header"><img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" /></div><div class="content"><h2 class="greeting">Hello ${userData.name || "Manager"},</h2><p class="message">Your manager account has been created for the Local Cooks kitchen booking system!</p><div class="info-box"><strong>\u{1F510} Your Login Credentials:</strong><table class="credentials-table"><tr><td>Username:</td><td><code>${userData.username}</code></td></tr><tr><td>Password:</td><td><code>${userData.password}</code></td></tr></table></div><div class="warning-box"><p class="warning-text"><strong>\u26A0\uFE0F Important:</strong> Please change your password after your first login for security.</p></div><p class="message">You'll be able to manage kitchen schedules, view bookings, and set up availability for your locations.</p><a href="${loginUrl}" class="cta-button" style="color: white !important; text-decoration: none !important;">Login Now</a><div class="divider"></div></div><div class="footer"><p class="footer-text">Questions? Contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p><div class="divider"></div><p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p></div></div></body></html>`;
      return { to: userData.email, subject, text: `Hello ${userData.name || "Manager"}, Your manager account has been created! Username: ${userData.username}, Password: ${userData.password}. Login at: ${loginUrl}`, html };
    };
    generateBookingNotificationEmail = (bookingData) => {
      const subject = `New Kitchen Booking - ${bookingData.kitchenName}`;
      const timezone = bookingData.timezone || "America/St_Johns";
      const locationName = bookingData.locationName || bookingData.kitchenName;
      const bookingDateObj = bookingData.bookingDate instanceof Date ? bookingData.bookingDate : new Date(bookingData.bookingDate);
      const calendarTitle = `Kitchen Booking - ${bookingData.kitchenName}`;
      const calendarDescription = `Kitchen booking with ${bookingData.chefName} for ${bookingData.kitchenName}.

Chef: ${bookingData.chefName}
Date: ${bookingDateObj.toLocaleDateString()}
Time: ${bookingData.startTime} - ${bookingData.endTime}
Status: Pending Approval${bookingData.specialNotes ? `

Notes: ${bookingData.specialNotes}` : ""}`;
      const calendarUrl = generateCalendarUrl(
        bookingData.managerEmail,
        calendarTitle,
        bookingData.bookingDate,
        bookingData.startTime,
        bookingData.endTime,
        locationName,
        calendarDescription,
        timezone
      );
      const calendarButtonText = detectEmailProvider(bookingData.managerEmail) === "outlook" ? "\u{1F4C5} Add to Outlook Calendar" : detectEmailProvider(bookingData.managerEmail) === "yahoo" ? "\u{1F4C5} Add to Yahoo Calendar" : detectEmailProvider(bookingData.managerEmail) === "apple" ? "\u{1F4C5} Add to Apple Calendar" : "\u{1F4C5} Add to Calendar";
      const bookingDateStr = bookingData.bookingDate instanceof Date ? bookingData.bookingDate.toISOString().split("T")[0] : bookingData.bookingDate.split("T")[0];
      const startDateTime = createBookingDateTime2(bookingDateStr, bookingData.startTime, timezone);
      const endDateTime = createBookingDateTime2(bookingDateStr, bookingData.endTime, timezone);
      const eventUid = generateEventUid(bookingData.bookingDate, bookingData.startTime, locationName);
      const icsContent = generateIcsFile(
        calendarTitle,
        startDateTime,
        endDateTime,
        locationName,
        calendarDescription,
        getSupportEmail(),
        [bookingData.managerEmail],
        // Manager is the primary attendee for this email
        eventUid
        // Use consistent UID for synchronization
      );
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${subject}</title>${getUniformEmailStyles()}</head><body><div class="email-container"><div class="header"><img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" /></div><div class="content"><h2 class="greeting">New Kitchen Booking</h2><p class="message">A chef has made a booking for your kitchen:</p><div class="info-box"><strong>\u{1F468}\u200D\u{1F373} Chef:</strong> ${bookingData.chefName}<br><strong>\u{1F3E2} Kitchen:</strong> ${bookingData.kitchenName}<br><strong>\u{1F4C5} Date:</strong> ${bookingDateObj.toLocaleDateString()}<br><strong>\u23F0 Time:</strong> ${bookingData.startTime} - ${bookingData.endTime}${bookingData.specialNotes ? `<br><br><strong>\u{1F4DD} Notes:</strong> ${bookingData.specialNotes}` : ""}</div><p class="message" style="font-size: 14px; color: #64748b; margin-top: 16px;"><strong>\u{1F4CE} Calendar Invite:</strong> A calendar invite has been attached to this email. You can also <a href="${calendarUrl}" target="_blank" style="color: #4285f4;">click here to add it to your calendar</a>.</p><div style="text-align: center; margin: 24px 0;"><a href="${calendarUrl}" target="_blank" class="cta-button" style="display: inline-block; background: #4285f4; color: white !important; text-decoration: none !important; padding: 12px 24px; border-radius: 6px; font-weight: 600; margin-right: 12px;">${calendarButtonText}</a><a href="${getDashboardUrl()}/manager/bookings" class="cta-button" style="display: inline-block; color: white !important; text-decoration: none !important;">View Bookings</a></div><div class="divider"></div></div><div class="footer"><p class="footer-text">If you have any questions, contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p><div class="divider"></div><p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p></div></div></body></html>`;
      return {
        to: bookingData.managerEmail,
        subject,
        text: `New Kitchen Booking - Chef: ${bookingData.chefName}, Kitchen: ${bookingData.kitchenName}, Date: ${bookingDateObj.toLocaleDateString()}, Time: ${bookingData.startTime} - ${bookingData.endTime}. Add to calendar: ${calendarUrl}`,
        html,
        attachments: [{
          filename: "kitchen-booking.ics",
          content: icsContent,
          contentType: "text/calendar; charset=utf-8; method=REQUEST"
        }]
      };
    };
    generateBookingCancellationNotificationEmail = (bookingData) => {
      const subject = `Booking Cancelled - ${bookingData.kitchenName}`;
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${subject}</title>${getUniformEmailStyles()}</head><body><div class="email-container"><div class="header"><img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" /></div><div class="content"><h2 class="greeting">Booking Cancelled</h2><p class="message">A chef has cancelled their booking:</p><div class="info-box"><strong>\u{1F468}\u200D\u{1F373} Chef:</strong> ${bookingData.chefName}<br><strong>\u{1F3E2} Kitchen:</strong> ${bookingData.kitchenName}<br><strong>\u{1F4C5} Date:</strong> ${new Date(bookingData.bookingDate).toLocaleDateString()}<br><strong>\u23F0 Time:</strong> ${bookingData.startTime} - ${bookingData.endTime}<br><strong>\u{1F4CA} Status:</strong> <span style="color: #dc2626; font-weight: 600;">Cancelled</span>${bookingData.cancellationReason ? `<br><br><strong>\u{1F4DD} Reason:</strong> ${bookingData.cancellationReason}` : ""}</div><a href="${getDashboardUrl()}/manager/bookings" class="cta-button" style="color: white !important; text-decoration: none !important;">View Bookings</a><div class="divider"></div></div><div class="footer"><p class="footer-text">If you have any questions, contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p><div class="divider"></div><p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p></div></div></body></html>`;
      return { to: bookingData.managerEmail, subject, text: `Booking Cancelled - Chef: ${bookingData.chefName}, Kitchen: ${bookingData.kitchenName}, Date: ${new Date(bookingData.bookingDate).toLocaleDateString()}, Time: ${bookingData.startTime} - ${bookingData.endTime}`, html };
    };
    generateBookingStatusChangeNotificationEmail = (bookingData) => {
      const subject = `Booking ${bookingData.status === "confirmed" ? "Confirmed" : "Updated"} - ${bookingData.kitchenName}`;
      const statusColor = bookingData.status === "confirmed" ? "#16a34a" : "#dc2626";
      const statusText = bookingData.status === "confirmed" ? "Confirmed" : "Cancelled";
      const timezone = bookingData.timezone || "America/St_Johns";
      const locationName = bookingData.locationName || bookingData.kitchenName;
      const bookingDateObj = bookingData.bookingDate instanceof Date ? bookingData.bookingDate : new Date(bookingData.bookingDate);
      let calendarUrl = "";
      let calendarButtonText = "\u{1F4C5} Add to Calendar";
      if (bookingData.status === "confirmed") {
        const calendarTitle = `Kitchen Booking - ${bookingData.kitchenName}`;
        const calendarDescription = `Confirmed kitchen booking with ${bookingData.chefName} for ${bookingData.kitchenName}.

Chef: ${bookingData.chefName}
Date: ${bookingDateObj.toLocaleDateString()}
Time: ${bookingData.startTime} - ${bookingData.endTime}
Status: Confirmed`;
        calendarUrl = generateCalendarUrl(
          bookingData.managerEmail,
          calendarTitle,
          bookingData.bookingDate,
          bookingData.startTime,
          bookingData.endTime,
          locationName,
          calendarDescription,
          timezone
        );
        const provider = detectEmailProvider(bookingData.managerEmail);
        calendarButtonText = provider === "outlook" ? "\u{1F4C5} Add to Outlook Calendar" : provider === "yahoo" ? "\u{1F4C5} Add to Yahoo Calendar" : provider === "apple" ? "\u{1F4C5} Add to Apple Calendar" : "\u{1F4C5} Add to Calendar";
      }
      let attachments = [];
      if (bookingData.status === "confirmed" && calendarUrl) {
        const bookingDateStr = bookingData.bookingDate instanceof Date ? bookingData.bookingDate.toISOString().split("T")[0] : bookingData.bookingDate.split("T")[0];
        const startDateTime = createBookingDateTime2(bookingDateStr, bookingData.startTime, timezone);
        const endDateTime = createBookingDateTime2(bookingDateStr, bookingData.endTime, timezone);
        const calendarTitle = `Kitchen Booking - ${bookingData.kitchenName}`;
        const calendarDescription = `Confirmed kitchen booking with ${bookingData.chefName} for ${bookingData.kitchenName}.

Chef: ${bookingData.chefName}
Date: ${bookingDateObj.toLocaleDateString()}
Time: ${bookingData.startTime} - ${bookingData.endTime}
Status: Confirmed`;
        const eventUid = generateEventUid(bookingData.bookingDate, bookingData.startTime, locationName);
        const icsContent = generateIcsFile(
          calendarTitle,
          startDateTime,
          endDateTime,
          locationName,
          calendarDescription,
          getSupportEmail(),
          [bookingData.managerEmail],
          // Manager is the primary attendee for this email
          eventUid
          // Use consistent UID for synchronization
        );
        attachments = [{
          filename: "kitchen-booking.ics",
          content: icsContent,
          contentType: "text/calendar; charset=utf-8; method=REQUEST"
        }];
      }
      const calendarButton = bookingData.status === "confirmed" && calendarUrl ? `<p class="message" style="font-size: 14px; color: #64748b; margin-top: 16px;"><strong>\u{1F4CE} Calendar Invite:</strong> A calendar invite has been attached to this email. You can also <a href="${calendarUrl}" target="_blank" style="color: #4285f4;">click here to add it to your calendar</a>.</p><div style="text-align: center; margin: 24px 0;"><a href="${calendarUrl}" target="_blank" class="cta-button" style="display: inline-block; background: #4285f4; color: white !important; text-decoration: none !important; padding: 12px 24px; border-radius: 6px; font-weight: 600; margin-right: 12px;">${calendarButtonText}</a><a href="${getDashboardUrl()}/manager/bookings" class="cta-button" style="display: inline-block; color: white !important; text-decoration: none !important;">View Bookings</a></div>` : `<a href="${getDashboardUrl()}/manager/bookings" class="cta-button" style="color: white !important; text-decoration: none !important;">View Bookings</a>`;
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${subject}</title>${getUniformEmailStyles()}</head><body><div class="email-container"><div class="header"><img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" /></div><div class="content"><h2 class="greeting">Booking ${statusText}</h2><p class="message">The booking status has been updated:</p><div class="info-box"><strong>\u{1F468}\u200D\u{1F373} Chef:</strong> ${bookingData.chefName}<br><strong>\u{1F3E2} Kitchen:</strong> ${bookingData.kitchenName}<br><strong>\u{1F4C5} Date:</strong> ${bookingDateObj.toLocaleDateString()}<br><strong>\u23F0 Time:</strong> ${bookingData.startTime} - ${bookingData.endTime}<br><strong>\u{1F4CA} Status:</strong> <span style="color: ${statusColor}; font-weight: 600;">${statusText}</span></div>${calendarButton}<div class="divider"></div></div><div class="footer"><p class="footer-text">If you have any questions, contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p><div class="divider"></div><p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p></div></div></body></html>`;
      const textCalendar = bookingData.status === "confirmed" && calendarUrl ? ` Add to calendar: ${calendarUrl}` : "";
      return {
        to: bookingData.managerEmail,
        subject,
        text: `Booking ${statusText} - Chef: ${bookingData.chefName}, Kitchen: ${bookingData.kitchenName}, Date: ${bookingDateObj.toLocaleDateString()}, Time: ${bookingData.startTime} - ${bookingData.endTime}, Status: ${statusText}${textCalendar}`,
        html,
        attachments
      };
    };
    generateBookingRequestEmail = (bookingData) => {
      const subject = `Booking Request Received - ${bookingData.kitchenName}`;
      const timezone = bookingData.timezone || "America/St_Johns";
      const locationName = bookingData.locationName || bookingData.kitchenName;
      const bookingDateObj = bookingData.bookingDate instanceof Date ? bookingData.bookingDate : new Date(bookingData.bookingDate);
      const calendarTitle = `Kitchen Booking - ${bookingData.kitchenName}`;
      const calendarDescription = `Kitchen booking request for ${bookingData.kitchenName}.

Date: ${bookingDateObj.toLocaleDateString()}
Time: ${bookingData.startTime} - ${bookingData.endTime}
Status: Pending Approval${bookingData.specialNotes ? `

Notes: ${bookingData.specialNotes}` : ""}`;
      const calendarUrl = generateCalendarUrl(
        bookingData.chefEmail,
        calendarTitle,
        bookingData.bookingDate,
        bookingData.startTime,
        bookingData.endTime,
        locationName,
        calendarDescription,
        timezone
      );
      const provider = detectEmailProvider(bookingData.chefEmail);
      const calendarButtonText = provider === "outlook" ? "\u{1F4C5} Add to Outlook Calendar" : provider === "yahoo" ? "\u{1F4C5} Add to Yahoo Calendar" : provider === "apple" ? "\u{1F4C5} Add to Apple Calendar" : "\u{1F4C5} Add to Calendar";
      const bookingDateStr = bookingData.bookingDate instanceof Date ? bookingData.bookingDate.toISOString().split("T")[0] : bookingData.bookingDate.split("T")[0];
      const startDateTime = createBookingDateTime2(bookingDateStr, bookingData.startTime, timezone);
      const endDateTime = createBookingDateTime2(bookingDateStr, bookingData.endTime, timezone);
      const eventUid = generateEventUid(bookingData.bookingDate, bookingData.startTime, locationName);
      const icsContent = generateIcsFile(
        calendarTitle,
        startDateTime,
        endDateTime,
        locationName,
        calendarDescription,
        getSupportEmail(),
        [bookingData.chefEmail],
        // Chef is the primary attendee
        eventUid
        // Use consistent UID for synchronization
      );
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${subject}</title>${getUniformEmailStyles()}</head><body><div class="email-container"><div class="header"><img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" /></div><div class="content"><h2 class="greeting">Hello ${bookingData.chefName},</h2><p class="message">We've received your kitchen booking request! The manager has been notified and will review it shortly.</p><div class="info-box"><strong>\u{1F3E2} Kitchen:</strong> ${bookingData.kitchenName}<br><strong>\u{1F4C5} Date:</strong> ${bookingDateObj.toLocaleDateString()}<br><strong>\u23F0 Time:</strong> ${bookingData.startTime} - ${bookingData.endTime}<br><strong>\u{1F4CA} Status:</strong> <span style="color: #f59e0b; font-weight: 600;">Pending Approval</span>${bookingData.specialNotes ? `<br><br><strong>\u{1F4DD} Notes:</strong> ${bookingData.specialNotes}` : ""}</div><p class="message">You'll receive a confirmation email once the manager approves your booking.</p><p class="message" style="font-size: 14px; color: #64748b; margin-top: 16px;"><strong>\u{1F4CE} Calendar Invite:</strong> A calendar invite has been attached to this email. You can also <a href="${calendarUrl}" target="_blank" style="color: #4285f4;">click here to add it to your calendar</a>.</p><div style="text-align: center; margin: 24px 0;"><a href="${calendarUrl}" target="_blank" class="cta-button" style="display: inline-block; background: #4285f4; color: white !important; text-decoration: none !important; padding: 12px 24px; border-radius: 6px; font-weight: 600; margin-right: 12px;">${calendarButtonText}</a><a href="${getDashboardUrl()}/bookings" class="cta-button" style="display: inline-block; color: white !important; text-decoration: none !important;">View My Bookings</a></div><div class="divider"></div></div><div class="footer"><p class="footer-text">Questions? Contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p><div class="divider"></div><p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p></div></div></body></html>`;
      return {
        to: bookingData.chefEmail,
        subject,
        text: `Hello ${bookingData.chefName}, We've received your kitchen booking request! Kitchen: ${bookingData.kitchenName}, Date: ${bookingDateObj.toLocaleDateString()}, Time: ${bookingData.startTime} - ${bookingData.endTime}. Status: Pending Approval. You'll receive a confirmation email once approved. Add to calendar: ${calendarUrl}`,
        html,
        attachments: [{
          filename: "kitchen-booking.ics",
          content: icsContent,
          contentType: "text/calendar; charset=utf-8; method=REQUEST"
        }]
      };
    };
    generateBookingConfirmationEmail = (bookingData) => {
      const subject = `Booking Confirmed - ${bookingData.kitchenName}`;
      const timezone = bookingData.timezone || "America/St_Johns";
      const locationName = bookingData.locationName || bookingData.kitchenName;
      const bookingDateObj = bookingData.bookingDate instanceof Date ? bookingData.bookingDate : new Date(bookingData.bookingDate);
      const calendarTitle = `Kitchen Booking - ${bookingData.kitchenName}`;
      const calendarDescription = `Confirmed kitchen booking for ${bookingData.kitchenName}.

Date: ${bookingDateObj.toLocaleDateString()}
Time: ${bookingData.startTime} - ${bookingData.endTime}
Status: Confirmed${bookingData.specialNotes ? `

Notes: ${bookingData.specialNotes}` : ""}`;
      const calendarUrl = generateCalendarUrl(
        bookingData.chefEmail,
        calendarTitle,
        bookingData.bookingDate,
        bookingData.startTime,
        bookingData.endTime,
        locationName,
        calendarDescription,
        timezone
      );
      const provider = detectEmailProvider(bookingData.chefEmail);
      const calendarButtonText = provider === "outlook" ? "\u{1F4C5} Add to Outlook Calendar" : provider === "yahoo" ? "\u{1F4C5} Add to Yahoo Calendar" : provider === "apple" ? "\u{1F4C5} Add to Apple Calendar" : "\u{1F4C5} Add to Calendar";
      const bookingDateStr = bookingData.bookingDate instanceof Date ? bookingData.bookingDate.toISOString().split("T")[0] : bookingData.bookingDate.split("T")[0];
      const startDateTime = createBookingDateTime2(bookingDateStr, bookingData.startTime, timezone);
      const endDateTime = createBookingDateTime2(bookingDateStr, bookingData.endTime, timezone);
      const eventUid = generateEventUid(bookingData.bookingDate, bookingData.startTime, locationName);
      const icsContent = generateIcsFile(
        calendarTitle,
        startDateTime,
        endDateTime,
        locationName,
        calendarDescription,
        getSupportEmail(),
        [bookingData.chefEmail],
        // Chef is the primary attendee
        eventUid
        // Use consistent UID for synchronization
      );
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${subject}</title>${getUniformEmailStyles()}</head><body><div class="email-container"><div class="header"><img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" /></div><div class="content"><h2 class="greeting">Hello ${bookingData.chefName},</h2><p class="message">Great news! Your kitchen booking has been <strong style="color: #16a34a;">CONFIRMED</strong> \u2705</p><div class="info-box"><strong>\u{1F3E2} Kitchen:</strong> ${bookingData.kitchenName}<br><strong>\u{1F4C5} Date:</strong> ${bookingDateObj.toLocaleDateString()}<br><strong>\u23F0 Time:</strong> ${bookingData.startTime} - ${bookingData.endTime}<br><strong>\u{1F4CA} Status:</strong> <span style="color: #16a34a; font-weight: 600;">Confirmed</span>${bookingData.specialNotes ? `<br><br><strong>\u{1F4DD} Notes:</strong> ${bookingData.specialNotes}` : ""}</div><p class="message" style="font-size: 14px; color: #64748b; margin-top: 16px;"><strong>\u{1F4CE} Calendar Invite:</strong> A calendar invite has been attached to this email. You can also <a href="${calendarUrl}" target="_blank" style="color: #4285f4;">click here to add it to your calendar</a>.</p><div style="text-align: center; margin: 24px 0;"><a href="${calendarUrl}" target="_blank" class="cta-button" style="display: inline-block; background: #4285f4; color: white !important; text-decoration: none !important; padding: 12px 24px; border-radius: 6px; font-weight: 600; margin-right: 12px;">${calendarButtonText}</a><a href="${getDashboardUrl()}/bookings" class="cta-button" style="display: inline-block; color: white !important; text-decoration: none !important;">View My Bookings</a></div><div class="divider"></div></div><div class="footer"><p class="footer-text">If you need to make changes, contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p><div class="divider"></div><p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p></div></div></body></html>`;
      return {
        to: bookingData.chefEmail,
        subject,
        text: `Hello ${bookingData.chefName}, Great news! Your kitchen booking has been CONFIRMED! Kitchen: ${bookingData.kitchenName}, Date: ${bookingDateObj.toLocaleDateString()}, Time: ${bookingData.startTime} - ${bookingData.endTime}. Add to calendar: ${calendarUrl}`,
        html,
        attachments: [{
          filename: "kitchen-booking.ics",
          content: icsContent,
          contentType: "text/calendar; charset=utf-8; method=REQUEST"
        }]
      };
    };
    generateBookingCancellationEmail = (bookingData) => {
      const subject = `Booking Cancelled - ${bookingData.kitchenName}`;
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${subject}</title>${getUniformEmailStyles()}</head><body><div class="email-container"><div class="header"><img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" /></div><div class="content"><h2 class="greeting">Hello ${bookingData.chefName},</h2><p class="message">Your kitchen booking has been cancelled.</p><div class="info-box"><strong>\u{1F3E2} Kitchen:</strong> ${bookingData.kitchenName}<br><strong>\u{1F4C5} Date:</strong> ${new Date(bookingData.bookingDate).toLocaleDateString()}<br><strong>\u23F0 Time:</strong> ${bookingData.startTime} - ${bookingData.endTime}<br><strong>\u{1F4CA} Status:</strong> <span style="color: #dc2626; font-weight: 600;">Cancelled</span>${bookingData.cancellationReason ? `<br><br><strong>\u{1F4DD} Reason:</strong> ${bookingData.cancellationReason}` : ""}</div><p class="message">You can make a new booking anytime from your dashboard.</p><a href="${getDashboardUrl()}/bookings" class="cta-button" style="color: white !important; text-decoration: none !important;">Browse Available Kitchens</a><div class="divider"></div></div><div class="footer"><p class="footer-text">Questions? Contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p><div class="divider"></div><p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p></div></div></body></html>`;
      return { to: bookingData.chefEmail, subject, text: `Hello ${bookingData.chefName}, Your kitchen booking has been cancelled. Kitchen: ${bookingData.kitchenName}, Date: ${new Date(bookingData.bookingDate).toLocaleDateString()}, Time: ${bookingData.startTime} - ${bookingData.endTime}${bookingData.cancellationReason ? `. Reason: ${bookingData.cancellationReason}` : ""}`, html };
    };
    generateKitchenAvailabilityChangeEmail = (data) => {
      const subject = `Kitchen Availability Update - ${data.kitchenName}`;
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${subject}</title>${getUniformEmailStyles()}</head><body><div class="email-container"><div class="header"><img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" /></div><div class="content"><h2 class="greeting">Hello ${data.chefName},</h2><p class="message">The availability for <strong>${data.kitchenName}</strong> has been updated.</p><div class="info-box"><strong>\u{1F3E2} Kitchen:</strong> ${data.kitchenName}<br><strong>\u{1F4CB} Change Type:</strong> ${data.changeType}<br><strong>\u{1F4DD} Details:</strong> ${data.details}</div><p class="message">Please check the updated availability before making your next booking.</p><a href="${getDashboardUrl()}/bookings" class="cta-button" style="color: white !important; text-decoration: none !important;">View Kitchen Availability</a><div class="divider"></div></div><div class="footer"><p class="footer-text">Questions? Contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p><div class="divider"></div><p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p></div></div></body></html>`;
      return { to: data.chefEmail, subject, text: `Hello ${data.chefName}, The availability for ${data.kitchenName} has been updated. Change Type: ${data.changeType}. Details: ${data.details}`, html };
    };
    generateKitchenSettingsChangeEmail = (data) => {
      const subject = `Kitchen Settings Updated - ${data.kitchenName}`;
      const greeting = data.isChef ? `Hello ${data.name},` : `Hello ${data.name},`;
      const message = data.isChef ? `The settings for <strong>${data.kitchenName}</strong> have been updated. This may affect your existing or future bookings.` : `The settings for <strong>${data.kitchenName}</strong> have been updated.`;
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${subject}</title>${getUniformEmailStyles()}</head><body><div class="email-container"><div class="header"><img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" /></div><div class="content"><h2 class="greeting">${greeting}</h2><p class="message">${message}</p><div class="info-box"><strong>\u{1F3E2} Kitchen:</strong> ${data.kitchenName}<br><strong>\u{1F4DD} Changes:</strong> ${data.changes}</div>${data.isChef ? `<p class="message">Please review the updated settings before making your next booking.</p><a href="${getDashboardUrl()}/bookings" class="cta-button" style="color: white !important; text-decoration: none !important;">View Kitchen Details</a>` : `<a href="${getDashboardUrl()}/manager/booking-dashboard" class="cta-button" style="color: white !important; text-decoration: none !important;">View Kitchen Settings</a>`}<div class="divider"></div></div><div class="footer"><p class="footer-text">Questions? Contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p><div class="divider"></div><p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p></div></div></body></html>`;
      return { to: data.email, subject, text: `${greeting} ${message} Kitchen: ${data.kitchenName}. Changes: ${data.changes}`, html };
    };
    generateChefProfileRequestEmail = (data) => {
      const subject = `Chef Access Request - ${data.locationName}`;
      const baseUrl = getWebsiteUrl();
      const reviewUrl = `${baseUrl}/manager/chefs?locationId=${data.locationId}`;
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${subject}</title>${getUniformEmailStyles()}</head><body><div class="email-container"><div class="header"><img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" /></div><div class="content"><h2 class="greeting">New Chef Access Request</h2><p class="message">A chef has requested access to your location and kitchen facilities:</p><div class="info-box"><strong>\u{1F468}\u200D\u{1F373} Chef Name:</strong> ${data.chefName}<br><strong>\u{1F4E7} Chef Email:</strong> ${data.chefEmail}<br><strong>\u{1F4CD} Location:</strong> ${data.locationName}<br><strong>\u{1F4CA} Status:</strong> <span style="color: #f59e0b; font-weight: 600;">Pending Review</span></div><p class="message">Please review the chef's profile and approve or reject their request from your manager dashboard.</p><a href="${reviewUrl}" class="cta-button" style="color: white !important; text-decoration: none !important;">Review Chef Request</a><div class="divider"></div></div><div class="footer"><p class="footer-text">Questions? Contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p><div class="divider"></div><p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p></div></div></body></html>`;
      return { to: data.managerEmail, subject, text: `New Chef Access Request - Chef: ${data.chefName} (${data.chefEmail}) has requested access to location: ${data.locationName}. Status: Pending Review. Please review from your manager dashboard.`, html };
    };
    generateChefLocationAccessApprovedEmail = (data) => {
      const subject = `Kitchen Access Approved - ${data.locationName}`;
      const baseUrl = getWebsiteUrl();
      const bookingsUrl = `${baseUrl}/bookings`;
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${subject}</title>${getUniformEmailStyles()}</head><body><div class="email-container"><div class="header"><img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" /></div><div class="content"><h2 class="greeting">Hello ${data.chefName},</h2><p class="message">Great news! The manager has <strong style="color: #16a34a;">APPROVED</strong> your chef profile for kitchen access at <strong>${data.locationName}</strong> \u2705</p><div class="info-box"><strong>\u{1F3E2} Location:</strong> ${data.locationName}<br><strong>\u{1F4CA} Status:</strong> <span style="color: #16a34a; font-weight: 600;">Approved</span></div><p class="message">You can now book kitchen facilities at this location. Start making your bookings from your dashboard!</p><a href="${bookingsUrl}" class="cta-button" style="color: white !important; text-decoration: none !important;">View Available Kitchens</a><div class="divider"></div></div><div class="footer"><p class="footer-text">Questions? Contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p><div class="divider"></div><p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p></div></div></body></html>`;
      return { to: data.chefEmail, subject, text: `Hello ${data.chefName}, Great news! The manager has approved your chef profile for kitchen access at ${data.locationName}. You can now book kitchen facilities at this location.`, html };
    };
    generateChefKitchenAccessApprovedEmail = (data) => {
      const subject = `Kitchen Access Approved - ${data.kitchenName}`;
      const baseUrl = getWebsiteUrl();
      const bookingsUrl = `${baseUrl}/bookings`;
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${subject}</title>${getUniformEmailStyles()}</head><body><div class="email-container"><div class="header"><img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" /></div><div class="content"><h2 class="greeting">Hello ${data.chefName},</h2><p class="message">Great news! The manager has <strong style="color: #16a34a;">APPROVED</strong> your chef profile for kitchen access at <strong>${data.kitchenName}</strong> \u2705</p><div class="info-box"><strong>\u{1F3E2} Kitchen:</strong> ${data.kitchenName}<br><strong>\u{1F4CA} Status:</strong> <span style="color: #16a34a; font-weight: 600;">Approved</span></div><p class="message">You can now book this kitchen. Start making your bookings from your dashboard!</p><a href="${bookingsUrl}" class="cta-button" style="color: white !important; text-decoration: none !important;">View Available Kitchens</a><div class="divider"></div></div><div class="footer"><p class="footer-text">Questions? Contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p><div class="divider"></div><p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p></div></div></body></html>`;
      return { to: data.chefEmail, subject, text: `Hello ${data.chefName}, Great news! The manager has approved your chef profile for kitchen access at ${data.kitchenName}. You can now book this kitchen.`, html };
    };
    generateLocationEmailChangedEmail = (data) => {
      const subject = `Location Notification Email Updated - ${data.locationName}`;
      const baseUrl = getWebsiteUrl();
      const dashboardUrl = `${baseUrl}/manager/dashboard`;
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${subject}</title>${getUniformEmailStyles()}</head><body><div class="email-container"><div class="header"><img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" /></div><div class="content"><h2 class="greeting">Location Notification Email Updated</h2><p class="message">This email address has been set as the notification email for <strong>${data.locationName}</strong>.</p><div class="info-box"><strong>\u{1F4CD} Location:</strong> ${data.locationName}<br><strong>\u{1F4E7} Notification Email:</strong> ${data.email}</div><p class="message">You will now receive email notifications for bookings, cancellations, and other important updates for this location.</p><a href="${dashboardUrl}" class="cta-button" style="color: white !important; text-decoration: none !important;">View Dashboard</a><div class="divider"></div></div><div class="footer"><p class="footer-text">If you didn't make this change, please contact us at <a href="mailto:${getSupportEmail()}" class="footer-links">${getSupportEmail()}</a>.</p><div class="divider"></div><p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks Community</p></div></div></body></html>`;
      return { to: data.email, subject, text: `Location Notification Email Updated - This email address has been set as the notification email for ${data.locationName}. You will now receive email notifications for bookings, cancellations, and other important updates for this location.`, html };
    };
  }
});

// client/src/lib/firebase.ts
var firebase_exports = {};
__export(firebase_exports, {
  auth: () => auth,
  db: () => db2
});
import { getApp, getApps, initializeApp } from "firebase/app";
import { getAuth } from "firebase/auth";
import { getFirestore } from "firebase/firestore";
var firebaseConfig, isFirebaseConfigured, app, auth, db2;
var init_firebase = __esm({
  "client/src/lib/firebase.ts"() {
    "use strict";
    firebaseConfig = {
      apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
      authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
      projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
      storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
      messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
      appId: import.meta.env.VITE_FIREBASE_APP_ID
    };
    isFirebaseConfigured = firebaseConfig.apiKey && firebaseConfig.authDomain && firebaseConfig.projectId;
    app = null;
    auth = null;
    db2 = null;
    if (isFirebaseConfigured) {
      app = getApps().length ? getApp() : initializeApp(firebaseConfig);
      auth = getAuth(app);
      db2 = getFirestore(app);
    } else {
      console.warn("Firebase is not configured. Google authentication will be disabled.");
    }
  }
});

// server/services/stripe-connect-service.ts
var stripe_connect_service_exports = {};
__export(stripe_connect_service_exports, {
  createAccountLink: () => createAccountLink,
  createAccountUpdateLink: () => createAccountUpdateLink,
  createConnectAccount: () => createConnectAccount,
  createDashboardLoginLink: () => createDashboardLoginLink,
  getAccount: () => getAccount,
  getAccountBalance: () => getAccountBalance,
  getAccountStatus: () => getAccountStatus,
  getBalanceTransactions: () => getBalanceTransactions,
  getPayout: () => getPayout,
  getPayouts: () => getPayouts,
  isAccountReady: () => isAccountReady
});
import Stripe from "stripe";
async function createConnectAccount(params) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  const {
    managerId,
    email,
    country = "CA"
    // Default to Canada
  } = params;
  try {
    const account = await stripe.accounts.create({
      type: "express",
      country,
      email,
      capabilities: {
        card_payments: { requested: true },
        transfers: { requested: true }
      },
      // Metadata to track which manager this belongs to
      metadata: {
        manager_id: managerId.toString(),
        platform: "localcooks"
      }
    });
    return { accountId: account.id };
  } catch (error) {
    console.error("Error creating Stripe Connect account:", error);
    throw new Error(`Failed to create Connect account: ${error.message}`);
  }
}
async function createAccountLink(accountId, refreshUrl, returnUrl) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const accountLink = await stripe.accountLinks.create({
      account: accountId,
      refresh_url: refreshUrl,
      return_url: returnUrl,
      type: "account_onboarding"
    });
    return { url: accountLink.url };
  } catch (error) {
    console.error("Error creating account link:", error);
    throw new Error(`Failed to create account link: ${error.message}`);
  }
}
async function createAccountUpdateLink(accountId, refreshUrl, returnUrl) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const accountLink = await stripe.accountLinks.create({
      account: accountId,
      refresh_url: refreshUrl,
      return_url: returnUrl,
      type: "account_update"
    });
    return { url: accountLink.url };
  } catch (error) {
    console.error("Error creating account update link:", error);
    throw new Error(`Failed to create account update link: ${error.message}`);
  }
}
async function isAccountReady(accountId) {
  if (!stripe) {
    return false;
  }
  try {
    const account = await stripe.accounts.retrieve(accountId);
    return account.charges_enabled === true && account.payouts_enabled === true;
  } catch (error) {
    console.error("Error checking account readiness:", error);
    return false;
  }
}
async function getAccountStatus(accountId) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const account = await stripe.accounts.retrieve(accountId);
    return {
      accountId: account.id,
      chargesEnabled: account.charges_enabled || false,
      payoutsEnabled: account.payouts_enabled || false,
      detailsSubmitted: account.details_submitted || false,
      isReady: account.charges_enabled && account.payouts_enabled || false
    };
  } catch (error) {
    console.error("Error retrieving account status:", error);
    throw new Error(`Failed to retrieve account status: ${error.message}`);
  }
}
async function getAccount(accountId) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const account = await stripe.accounts.retrieve(accountId);
    return account;
  } catch (error) {
    if (error.code === "resource_missing") {
      return null;
    }
    console.error("Error retrieving account:", error);
    throw new Error(`Failed to retrieve account: ${error.message}`);
  }
}
async function getPayouts(accountId, limit = 100) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const payouts = await stripe.payouts.list(
      {
        limit
      },
      {
        stripeAccount: accountId
      }
    );
    return payouts.data;
  } catch (error) {
    console.error("Error retrieving payouts:", error);
    throw new Error(`Failed to retrieve payouts: ${error.message}`);
  }
}
async function getPayout(accountId, payoutId) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const payout = await stripe.payouts.retrieve(
      payoutId,
      {
        stripeAccount: accountId
      }
    );
    return payout;
  } catch (error) {
    if (error.code === "resource_missing") {
      return null;
    }
    console.error("Error retrieving payout:", error);
    throw new Error(`Failed to retrieve payout: ${error.message}`);
  }
}
async function getBalanceTransactions(accountId, startDate, endDate, limit = 100) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const params = {
      limit
    };
    if (startDate) {
      params.created = {
        gte: Math.floor(startDate.getTime() / 1e3)
      };
    }
    if (endDate) {
      if (params.created && typeof params.created === "object" && "gte" in params.created) {
        params.created = {
          ...params.created,
          lte: Math.floor(endDate.getTime() / 1e3)
        };
      } else {
        params.created = {
          lte: Math.floor(endDate.getTime() / 1e3)
        };
      }
    }
    const transactions = await stripe.balanceTransactions.list(
      params,
      {
        stripeAccount: accountId
      }
    );
    return transactions.data;
  } catch (error) {
    console.error("Error retrieving balance transactions:", error);
    throw new Error(`Failed to retrieve balance transactions: ${error.message}`);
  }
}
async function getAccountBalance(accountId) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const balance = await stripe.balance.retrieve({
      stripeAccount: accountId
    });
    return balance;
  } catch (error) {
    console.error("Error retrieving balance:", error);
    throw new Error(`Failed to retrieve balance: ${error.message}`);
  }
}
async function createDashboardLoginLink(accountId) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const loginLink = await stripe.accounts.createLoginLink(accountId);
    return { url: loginLink.url };
  } catch (error) {
    console.error("Error creating dashboard login link:", error);
    throw new Error(`Failed to create dashboard login link: ${error.message}`);
  }
}
var stripeSecretKey, stripe;
var init_stripe_connect_service = __esm({
  "server/services/stripe-connect-service.ts"() {
    "use strict";
    stripeSecretKey = process.env.STRIPE_SECRET_KEY;
    if (!stripeSecretKey) {
      console.warn("\u26A0\uFE0F STRIPE_SECRET_KEY not found in environment variables");
    }
    stripe = stripeSecretKey ? new Stripe(stripeSecretKey, {
      apiVersion: "2025-12-15.clover"
    }) : null;
  }
});

// server/services/stripe-checkout-transactions-service.ts
var stripe_checkout_transactions_service_exports = {};
__export(stripe_checkout_transactions_service_exports, {
  createTransaction: () => createTransaction,
  getTransactionBySessionId: () => getTransactionBySessionId,
  updateTransactionBySessionId: () => updateTransactionBySessionId
});
async function createTransaction(params, dbPool) {
  const {
    bookingId,
    stripeSessionId,
    customerEmail,
    bookingAmountCents,
    platformFeePercentageCents,
    platformFeeFlatCents,
    totalPlatformFeeCents,
    totalCustomerChargedCents,
    managerReceivesCents,
    metadata = {}
  } = params;
  const result = await dbPool.query(
    `INSERT INTO transactions (
      booking_id,
      stripe_session_id,
      customer_email,
      booking_amount_cents,
      platform_fee_percentage_cents,
      platform_fee_flat_cents,
      total_platform_fee_cents,
      total_customer_charged_cents,
      manager_receives_cents,
      status,
      metadata
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
    RETURNING *`,
    [
      bookingId,
      stripeSessionId,
      customerEmail,
      bookingAmountCents,
      platformFeePercentageCents,
      platformFeeFlatCents,
      totalPlatformFeeCents,
      totalCustomerChargedCents,
      managerReceivesCents,
      "pending",
      JSON.stringify(metadata)
    ]
  );
  if (result.rows.length === 0) {
    throw new Error("Failed to create transaction record");
  }
  return mapRowToTransaction(result.rows[0]);
}
async function updateTransactionBySessionId(sessionId, params, dbPool) {
  const updates = [];
  const values = [];
  let paramIndex = 1;
  if (params.status !== void 0) {
    updates.push(`status = $${paramIndex}`);
    values.push(params.status);
    paramIndex++;
  }
  if (params.stripePaymentIntentId !== void 0) {
    updates.push(`stripe_payment_intent_id = $${paramIndex}`);
    values.push(params.stripePaymentIntentId);
    paramIndex++;
  }
  if (params.stripeChargeId !== void 0) {
    updates.push(`stripe_charge_id = $${paramIndex}`);
    values.push(params.stripeChargeId);
    paramIndex++;
  }
  if (params.completedAt !== void 0) {
    updates.push(`completed_at = $${paramIndex}`);
    values.push(params.completedAt);
    paramIndex++;
  }
  if (params.refundedAt !== void 0) {
    updates.push(`refunded_at = $${paramIndex}`);
    values.push(params.refundedAt);
    paramIndex++;
  }
  if (params.metadata !== void 0) {
    updates.push(`metadata = $${paramIndex}`);
    values.push(JSON.stringify(params.metadata));
    paramIndex++;
  }
  if (updates.length === 0) {
    return getTransactionBySessionId(sessionId, dbPool);
  }
  values.push(sessionId);
  const query = `
    UPDATE transactions
    SET ${updates.join(", ")}
    WHERE stripe_session_id = $${paramIndex}
    RETURNING *
  `;
  const result = await dbPool.query(query, values);
  if (result.rows.length === 0) {
    return null;
  }
  return mapRowToTransaction(result.rows[0]);
}
async function getTransactionBySessionId(sessionId, dbPool) {
  const result = await dbPool.query(
    `SELECT * FROM transactions WHERE stripe_session_id = $1`,
    [sessionId]
  );
  if (result.rows.length === 0) {
    return null;
  }
  return mapRowToTransaction(result.rows[0]);
}
function mapRowToTransaction(row) {
  return {
    id: row.id,
    booking_id: row.booking_id,
    stripe_session_id: row.stripe_session_id,
    stripe_payment_intent_id: row.stripe_payment_intent_id,
    stripe_charge_id: row.stripe_charge_id,
    customer_email: row.customer_email,
    booking_amount_cents: row.booking_amount_cents,
    platform_fee_percentage_cents: row.platform_fee_percentage_cents,
    platform_fee_flat_cents: row.platform_fee_flat_cents,
    total_platform_fee_cents: row.total_platform_fee_cents,
    total_customer_charged_cents: row.total_customer_charged_cents,
    manager_receives_cents: row.manager_receives_cents,
    status: row.status,
    created_at: row.created_at,
    completed_at: row.completed_at,
    refunded_at: row.refunded_at,
    metadata: typeof row.metadata === "string" ? JSON.parse(row.metadata) : row.metadata || {}
  };
}
var init_stripe_checkout_transactions_service = __esm({
  "server/services/stripe-checkout-transactions-service.ts"() {
    "use strict";
  }
});

// server/services/payment-transactions-service.ts
var payment_transactions_service_exports = {};
__export(payment_transactions_service_exports, {
  addPaymentHistory: () => addPaymentHistory,
  createPaymentTransaction: () => createPaymentTransaction,
  findPaymentTransactionByBooking: () => findPaymentTransactionByBooking,
  findPaymentTransactionByIntentId: () => findPaymentTransactionByIntentId,
  getManagerPaymentTransactions: () => getManagerPaymentTransactions,
  getPaymentHistory: () => getPaymentHistory,
  syncExistingPaymentTransactionsFromStripe: () => syncExistingPaymentTransactionsFromStripe,
  syncStripeAmountsToBookings: () => syncStripeAmountsToBookings,
  updatePaymentTransaction: () => updatePaymentTransaction
});
async function createPaymentTransaction(params, dbPool) {
  const {
    bookingId,
    bookingType,
    chefId,
    managerId,
    amount,
    baseAmount,
    serviceFee,
    managerRevenue,
    currency = "CAD",
    paymentIntentId,
    paymentMethodId,
    status = "pending",
    stripeStatus,
    metadata = {}
  } = params;
  const netAmount = amount;
  const result = await dbPool.query(`
    INSERT INTO payment_transactions (
      booking_id,
      booking_type,
      chef_id,
      manager_id,
      amount,
      base_amount,
      service_fee,
      manager_revenue,
      refund_amount,
      net_amount,
      currency,
      payment_intent_id,
      payment_method_id,
      status,
      stripe_status,
      metadata
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
    RETURNING *
  `, [
    bookingId,
    bookingType,
    chefId,
    managerId,
    amount.toString(),
    baseAmount.toString(),
    serviceFee.toString(),
    managerRevenue.toString(),
    "0",
    // refund_amount
    netAmount.toString(),
    currency,
    paymentIntentId || null,
    paymentMethodId || null,
    status,
    stripeStatus || null,
    JSON.stringify(metadata)
  ]);
  const record = result.rows[0];
  await addPaymentHistory(
    record.id,
    {
      previousStatus: null,
      newStatus: status,
      eventType: "created",
      eventSource: "system",
      description: `Payment transaction created for ${bookingType} booking ${bookingId}`,
      metadata: { initialAmount: amount, baseAmount, serviceFee, managerRevenue }
    },
    dbPool
  );
  return record;
}
async function updatePaymentTransaction(transactionId, params, dbPool) {
  const currentResult = await dbPool.query(`
    SELECT status, refund_amount, amount
    FROM payment_transactions
    WHERE id = $1
  `, [transactionId]);
  if (currentResult.rows.length === 0) {
    return null;
  }
  const current = currentResult.rows[0];
  const previousStatus = current.status;
  const currentRefundAmount = parseFloat(current.refund_amount || "0");
  const currentAmount = parseFloat(current.amount || "0");
  const updates = [];
  const values = [];
  let paramIndex = 1;
  if (params.status !== void 0) {
    updates.push(`status = $${paramIndex}`);
    values.push(params.status);
    paramIndex++;
  }
  if (params.stripeStatus !== void 0) {
    updates.push(`stripe_status = $${paramIndex}`);
    values.push(params.stripeStatus);
    paramIndex++;
  }
  if (params.chargeId !== void 0) {
    updates.push(`charge_id = $${paramIndex}`);
    values.push(params.chargeId);
    paramIndex++;
  }
  if (params.refundId !== void 0) {
    updates.push(`refund_id = $${paramIndex}`);
    values.push(params.refundId);
    paramIndex++;
  }
  if (params.refundAmount !== void 0) {
    updates.push(`refund_amount = $${paramIndex}`);
    values.push(params.refundAmount.toString());
    paramIndex++;
    const newRefundAmount = params.refundAmount;
    const netAmount = currentAmount - newRefundAmount;
    updates.push(`net_amount = $${paramIndex}`);
    values.push(netAmount.toString());
    paramIndex++;
  }
  if (params.refundReason !== void 0) {
    updates.push(`refund_reason = $${paramIndex}`);
    values.push(params.refundReason);
    paramIndex++;
  }
  if (params.failureReason !== void 0) {
    updates.push(`failure_reason = $${paramIndex}`);
    values.push(params.failureReason);
    paramIndex++;
  }
  if (params.paidAt !== void 0) {
    updates.push(`paid_at = $${paramIndex}`);
    values.push(params.paidAt);
    paramIndex++;
  }
  if (params.refundedAt !== void 0) {
    updates.push(`refunded_at = $${paramIndex}`);
    values.push(params.refundedAt);
    paramIndex++;
  }
  if (params.lastSyncedAt !== void 0) {
    updates.push(`last_synced_at = $${paramIndex}`);
    values.push(params.lastSyncedAt);
    paramIndex++;
  }
  if (params.webhookEventId !== void 0) {
    updates.push(`webhook_event_id = $${paramIndex}`);
    values.push(params.webhookEventId);
    paramIndex++;
  }
  if (params.stripeAmount !== void 0 || params.stripeNetAmount !== void 0) {
    if (params.stripeAmount !== void 0) {
      updates.push(`amount = $${paramIndex}`);
      values.push(params.stripeAmount.toString());
      paramIndex++;
    }
    if (params.stripeNetAmount !== void 0) {
      updates.push(`net_amount = $${paramIndex}`);
      values.push(params.stripeNetAmount.toString());
      paramIndex++;
      updates.push(`manager_revenue = $${paramIndex}`);
      values.push(params.stripeNetAmount.toString());
      paramIndex++;
    }
    if (params.stripePlatformFee !== void 0 && params.stripePlatformFee > 0) {
      updates.push(`service_fee = $${paramIndex}`);
      values.push(params.stripePlatformFee.toString());
      paramIndex++;
    } else if (params.stripeAmount !== void 0 && params.stripeNetAmount !== void 0) {
      const totalFees = params.stripeAmount - params.stripeNetAmount;
      const processingFee = params.stripeProcessingFee || 0;
      const actualPlatformFee = Math.max(0, totalFees - processingFee);
      updates.push(`service_fee = $${paramIndex}`);
      values.push(actualPlatformFee.toString());
      paramIndex++;
    }
    if (params.stripeAmount !== void 0) {
      const platformFee = params.stripePlatformFee || (params.stripeAmount !== void 0 && params.stripeNetAmount !== void 0 ? Math.max(0, params.stripeAmount - params.stripeNetAmount - (params.stripeProcessingFee || 0)) : 0);
      const baseAmount = params.stripeAmount - platformFee;
      updates.push(`base_amount = $${paramIndex}`);
      values.push(baseAmount.toString());
      paramIndex++;
    }
    const currentMetadataResult = await dbPool.query(`
      SELECT metadata FROM payment_transactions WHERE id = $1
    `, [transactionId]);
    const currentMetadata = currentMetadataResult.rows[0]?.metadata ? typeof currentMetadataResult.rows[0].metadata === "string" ? JSON.parse(currentMetadataResult.rows[0].metadata) : currentMetadataResult.rows[0].metadata : {};
    const stripeFees = {
      processingFee: params.stripeProcessingFee || 0,
      platformFee: params.stripePlatformFee || 0,
      syncedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    const updatedMetadata = {
      ...currentMetadata,
      stripeFees
    };
    updates.push(`metadata = $${paramIndex}`);
    values.push(JSON.stringify(updatedMetadata));
    paramIndex++;
  } else if (params.metadata !== void 0) {
    updates.push(`metadata = $${paramIndex}`);
    values.push(JSON.stringify(params.metadata));
    paramIndex++;
  }
  if (updates.length === 0) {
    const result2 = await dbPool.query(`
      SELECT * FROM payment_transactions WHERE id = $1
    `, [transactionId]);
    return result2.rows[0];
  }
  values.push(transactionId);
  const updateQuery = `
    UPDATE payment_transactions
    SET ${updates.join(", ")}, updated_at = NOW()
    WHERE id = $${paramIndex}
    RETURNING *
  `;
  const result = await dbPool.query(updateQuery, values);
  const updated = result.rows[0];
  if (params.status !== void 0 && params.status !== previousStatus) {
    const historyMetadata = { ...params.metadata || {} };
    if (params.stripeAmount !== void 0 || params.stripeNetAmount !== void 0) {
      historyMetadata.stripeAmounts = {
        amount: params.stripeAmount,
        netAmount: params.stripeNetAmount,
        processingFee: params.stripeProcessingFee,
        platformFee: params.stripePlatformFee,
        syncedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    await addPaymentHistory(
      transactionId,
      {
        previousStatus,
        newStatus: params.status,
        eventType: "status_change",
        eventSource: params.webhookEventId ? "stripe_webhook" : "system",
        description: `Status changed from ${previousStatus} to ${params.status}${params.stripeAmount !== void 0 ? " (Stripe amounts synced)" : ""}`,
        stripeEventId: params.webhookEventId,
        metadata: historyMetadata
      },
      dbPool
    );
  }
  if ((params.stripeAmount !== void 0 || params.stripeNetAmount !== void 0) && params.status === void 0) {
    await addPaymentHistory(
      transactionId,
      {
        previousStatus: updated.status,
        newStatus: updated.status,
        eventType: "stripe_sync",
        eventSource: params.webhookEventId ? "stripe_webhook" : "system",
        description: `Stripe amounts synced: Amount $${((params.stripeAmount || parseFloat(updated.amount || "0")) / 100).toFixed(2)}, Net $${((params.stripeNetAmount || parseFloat(updated.net_amount || "0")) / 100).toFixed(2)}`,
        stripeEventId: params.webhookEventId,
        metadata: {
          stripeAmounts: {
            amount: params.stripeAmount,
            netAmount: params.stripeNetAmount,
            processingFee: params.stripeProcessingFee,
            platformFee: params.stripePlatformFee,
            syncedAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      },
      dbPool
    );
  }
  if (params.refundAmount !== void 0 && params.refundAmount > currentRefundAmount) {
    await addPaymentHistory(
      transactionId,
      {
        previousStatus,
        newStatus: updated.status,
        eventType: params.refundAmount === parseFloat(updated.amount || "0") ? "refund" : "partial_refund",
        eventSource: params.webhookEventId ? "stripe_webhook" : "system",
        description: `Refund of ${params.refundAmount / 100} ${updated.currency}${params.refundReason ? `: ${params.refundReason}` : ""}`,
        stripeEventId: params.webhookEventId,
        metadata: {
          refundAmount: params.refundAmount,
          refundReason: params.refundReason,
          refundId: params.refundId
        }
      },
      dbPool
    );
  }
  return updated;
}
async function syncStripeAmountsToBookings(paymentIntentId, stripeAmounts, dbPool) {
  try {
    const transactionResult = await dbPool.query(`
      SELECT 
        pt.id,
        pt.booking_id,
        pt.booking_type,
        pt.base_amount,
        pt.service_fee,
        pt.amount as current_amount,
        pt.manager_revenue as current_manager_revenue
      FROM payment_transactions pt
      WHERE pt.payment_intent_id = $1
    `, [paymentIntentId]);
    if (transactionResult.rows.length === 0) {
      console.warn(`[Stripe Sync] No payment transaction found for PaymentIntent ${paymentIntentId}`);
      return;
    }
    const transaction = transactionResult.rows[0];
    const bookingId = transaction.booking_id;
    const bookingType = transaction.booking_type;
    if (bookingType === "bundle") {
      const kitchenBooking = await dbPool.query(`
        SELECT id, total_price, service_fee
        FROM kitchen_bookings
        WHERE id = $1
      `, [bookingId]);
      const storageBookings2 = await dbPool.query(`
        SELECT id, total_price, service_fee
        FROM storage_bookings
        WHERE kitchen_booking_id = $1
      `, [bookingId]);
      const equipmentBookings2 = await dbPool.query(`
        SELECT id, total_price, service_fee
        FROM equipment_bookings
        WHERE kitchen_booking_id = $1
      `, [bookingId]);
      let totalBaseAmount = parseFloat(transaction.base_amount || "0");
      if (totalBaseAmount === 0) {
        const kbAmount = parseFloat(kitchenBooking.rows[0]?.total_price || "0");
        const sbAmount = storageBookings2.rows.reduce((sum, sb) => sum + parseFloat(sb.total_price || "0"), 0);
        const ebAmount = equipmentBookings2.rows.reduce((sum, eb) => sum + parseFloat(eb.total_price || "0"), 0);
        totalBaseAmount = kbAmount + sbAmount + ebAmount;
      }
      if (kitchenBooking.rows.length > 0 && totalBaseAmount > 0) {
        const kbBase = parseFloat(kitchenBooking.rows[0].total_price || "0");
        const kbProportion = kbBase / totalBaseAmount;
        const kbStripeAmount = Math.round(stripeAmounts.stripeAmount * kbProportion);
        const kbStripeNet = Math.round(stripeAmounts.stripeNetAmount * kbProportion);
        const kbServiceFee = stripeAmounts.stripePlatformFee > 0 ? Math.round(stripeAmounts.stripePlatformFee * kbProportion) : Math.round((kbStripeAmount - kbStripeNet) * 0.5);
        await dbPool.query(`
          UPDATE kitchen_bookings
          SET 
            total_price = $1,
            service_fee = $2,
            updated_at = NOW()
          WHERE id = $3
        `, [
          kbStripeAmount.toString(),
          kbServiceFee.toString(),
          bookingId
        ]);
      }
      for (const sb of storageBookings2.rows) {
        const sbBase = parseFloat(sb.total_price || "0");
        if (totalBaseAmount > 0 && sbBase > 0) {
          const sbProportion = sbBase / totalBaseAmount;
          const sbStripeAmount = Math.round(stripeAmounts.stripeAmount * sbProportion);
          const sbStripeNet = Math.round(stripeAmounts.stripeNetAmount * sbProportion);
          const sbServiceFee = stripeAmounts.stripePlatformFee > 0 ? Math.round(stripeAmounts.stripePlatformFee * sbProportion) : Math.round((sbStripeAmount - sbStripeNet) * 0.5);
          await dbPool.query(`
            UPDATE storage_bookings
            SET 
              total_price = $1,
              service_fee = $2,
              updated_at = NOW()
            WHERE id = $3
          `, [
            sbStripeAmount.toString(),
            sbServiceFee.toString(),
            sb.id
          ]);
        }
      }
      for (const eb of equipmentBookings2.rows) {
        const ebBase = parseFloat(eb.total_price || "0");
        if (totalBaseAmount > 0 && ebBase > 0) {
          const ebProportion = ebBase / totalBaseAmount;
          const ebStripeAmount = Math.round(stripeAmounts.stripeAmount * ebProportion);
          const ebStripeNet = Math.round(stripeAmounts.stripeNetAmount * ebProportion);
          const ebServiceFee = stripeAmounts.stripePlatformFee > 0 ? Math.round(stripeAmounts.stripePlatformFee * ebProportion) : Math.round((ebStripeAmount - ebStripeNet) * 0.5);
          await dbPool.query(`
            UPDATE equipment_bookings
            SET 
              total_price = $1,
              service_fee = $2,
              updated_at = NOW()
            WHERE id = $3
          `, [
            ebStripeAmount.toString(),
            ebServiceFee.toString(),
            eb.id
          ]);
        }
      }
    } else {
      const serviceFee = stripeAmounts.stripePlatformFee > 0 ? stripeAmounts.stripePlatformFee : Math.max(0, stripeAmounts.stripeAmount - stripeAmounts.stripeNetAmount - stripeAmounts.stripeProcessingFee);
      if (bookingType === "kitchen") {
        await dbPool.query(`
          UPDATE kitchen_bookings
          SET 
            total_price = $1,
            service_fee = $2,
            updated_at = NOW()
          WHERE id = $3
        `, [
          stripeAmounts.stripeAmount.toString(),
          serviceFee.toString(),
          bookingId
        ]);
      } else if (bookingType === "storage") {
        await dbPool.query(`
          UPDATE storage_bookings
          SET 
            total_price = $1,
            service_fee = $2,
            updated_at = NOW()
          WHERE id = $3
        `, [
          stripeAmounts.stripeAmount.toString(),
          serviceFee.toString(),
          bookingId
        ]);
      } else if (bookingType === "equipment") {
        await dbPool.query(`
          UPDATE equipment_bookings
          SET 
            total_price = $1,
            service_fee = $2,
            updated_at = NOW()
          WHERE id = $3
        `, [
          stripeAmounts.stripeAmount.toString(),
          serviceFee.toString(),
          bookingId
        ]);
      }
    }
    console.log(`[Stripe Sync] Synced Stripe amounts to ${bookingType} booking(s) for PaymentIntent ${paymentIntentId}`);
  } catch (error) {
    console.error(`[Stripe Sync] Error syncing Stripe amounts to bookings for ${paymentIntentId}:`, error);
  }
}
async function syncExistingPaymentTransactionsFromStripe(managerId, dbPool, options) {
  let getStripePaymentAmounts2;
  const importPaths = [
    "./stripe-service",
    // Path 1: Relative without extension (works in some builds)
    "./stripe-service.js",
    // Path 2: Relative with .js extension (standard)
    "../server/services/stripe-service.js"
    // Path 3: From api/ perspective
  ];
  let lastError = null;
  for (const importPath of importPaths) {
    try {
      const mod = await import(importPath);
      if (mod.getStripePaymentAmounts) {
        getStripePaymentAmounts2 = mod.getStripePaymentAmounts;
        break;
      }
    } catch (e) {
      lastError = e;
      continue;
    }
  }
  if (!getStripePaymentAmounts2) {
    console.error("[Stripe Sync] Failed to import stripe-service from all paths:", importPaths);
    throw new Error(`Cannot import stripe-service from any path. Last error: ${lastError?.message || "Unknown"}`);
  }
  const limit = options?.limit || 1e3;
  const onlyUnsynced = options?.onlyUnsynced !== false;
  try {
    let query = `
      SELECT 
        pt.id,
        pt.payment_intent_id,
        pt.manager_id,
        pt.booking_id,
        pt.booking_type,
        pt.amount as current_amount,
        pt.manager_revenue as current_manager_revenue,
        pt.last_synced_at
      FROM payment_transactions pt
      WHERE pt.payment_intent_id IS NOT NULL
        AND pt.status IN ('succeeded', 'processing')
        AND (
          pt.manager_id = $1 
          OR EXISTS (
            SELECT 1 FROM kitchen_bookings kb
            JOIN kitchens k ON kb.kitchen_id = k.id
            JOIN locations l ON k.location_id = l.id
            WHERE kb.id = pt.booking_id 
              AND l.manager_id = $1
          )
        )
    `;
    const params = [managerId];
    if (onlyUnsynced) {
      query += ` AND (pt.last_synced_at IS NULL OR pt.metadata->>'stripeFees' IS NULL)`;
    }
    query += ` ORDER BY pt.created_at DESC LIMIT $${params.length + 1}`;
    params.push(limit);
    const result = await dbPool.query(query, params);
    const transactions = result.rows;
    console.log(`[Stripe Sync] Found ${transactions.length} payment transactions to sync for manager ${managerId}`);
    let synced = 0;
    let failed = 0;
    const errors = [];
    for (const transaction of transactions) {
      const paymentIntentId = transaction.payment_intent_id;
      if (!paymentIntentId) continue;
      try {
        let managerConnectAccountId;
        try {
          const managerResult = await dbPool.query(`
            SELECT stripe_connect_account_id 
            FROM users 
            WHERE id = $1 AND stripe_connect_account_id IS NOT NULL
          `, [transaction.manager_id || managerId]);
          if (managerResult.rows.length > 0) {
            managerConnectAccountId = managerResult.rows[0].stripe_connect_account_id;
          }
        } catch (error) {
          console.warn(`[Stripe Sync] Could not fetch manager Connect account:`, error);
        }
        const stripeAmounts = await getStripePaymentAmounts2(paymentIntentId, managerConnectAccountId);
        if (!stripeAmounts) {
          console.warn(`[Stripe Sync] Could not fetch Stripe amounts for ${paymentIntentId}`);
          failed++;
          errors.push({ paymentIntentId, error: "Could not fetch Stripe amounts" });
          continue;
        }
        await updatePaymentTransaction(transaction.id, {
          stripeAmount: stripeAmounts.stripeAmount,
          stripeNetAmount: stripeAmounts.stripeNetAmount,
          stripeProcessingFee: stripeAmounts.stripeProcessingFee,
          stripePlatformFee: stripeAmounts.stripePlatformFee,
          lastSyncedAt: /* @__PURE__ */ new Date()
        }, dbPool);
        await syncStripeAmountsToBookings(paymentIntentId, stripeAmounts, dbPool);
        synced++;
        console.log(`[Stripe Sync] Synced transaction ${transaction.id} (PaymentIntent: ${paymentIntentId})`);
      } catch (error) {
        console.error(`[Stripe Sync] Error syncing transaction ${transaction.id} (${paymentIntentId}):`, error);
        failed++;
        errors.push({ paymentIntentId, error: error.message || "Unknown error" });
      }
    }
    console.log(`[Stripe Sync] Completed: ${synced} synced, ${failed} failed`);
    return { synced, failed, errors };
  } catch (error) {
    console.error(`[Stripe Sync] Error syncing existing transactions:`, error);
    throw error;
  }
}
async function findPaymentTransactionByIntentId(paymentIntentId, dbPool) {
  const result = await dbPool.query(`
    SELECT * FROM payment_transactions
    WHERE payment_intent_id = $1
    LIMIT 1
  `, [paymentIntentId]);
  return result.rows[0];
}
async function findPaymentTransactionByBooking(bookingId, bookingType, dbPool) {
  const result = await dbPool.query(`
    SELECT * FROM payment_transactions
    WHERE booking_id = $1 AND booking_type = $2
    ORDER BY created_at DESC
    LIMIT 1
  `, [bookingId, bookingType]);
  return result.rows[0];
}
async function addPaymentHistory(transactionId, history, dbPool) {
  await dbPool.query(`
    INSERT INTO payment_history (
      transaction_id,
      previous_status,
      new_status,
      event_type,
      event_source,
      stripe_event_id,
      description,
      metadata,
      created_by
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
  `, [
    transactionId,
    history.previousStatus,
    history.newStatus,
    history.eventType,
    history.eventSource || "system",
    history.stripeEventId || null,
    history.description || null,
    JSON.stringify(history.metadata || {}),
    history.createdBy || null
  ]);
}
async function getPaymentHistory(transactionId, dbPool) {
  const result = await dbPool.query(`
    SELECT * FROM payment_history
    WHERE transaction_id = $1
    ORDER BY created_at ASC
  `, [transactionId]);
  return result.rows;
}
async function getManagerPaymentTransactions(managerId, dbPool, filters) {
  let whereClause = "WHERE manager_id = $1";
  const params = [managerId];
  let paramIndex = 2;
  if (filters?.status) {
    whereClause += ` AND status = $${paramIndex}`;
    params.push(filters.status);
    paramIndex++;
  }
  if (filters?.startDate) {
    whereClause += ` AND (
      (status = 'succeeded' AND paid_at IS NOT NULL AND paid_at >= $${paramIndex})
      OR (status != 'succeeded' AND created_at >= $${paramIndex})
    )`;
    params.push(filters.startDate);
    paramIndex++;
  }
  if (filters?.endDate) {
    whereClause += ` AND (
      (status = 'succeeded' AND paid_at IS NOT NULL AND paid_at <= $${paramIndex})
      OR (status != 'succeeded' AND created_at <= $${paramIndex})
    )`;
    params.push(filters.endDate);
    paramIndex++;
  }
  const countResult = await dbPool.query(`
    SELECT COUNT(*) as total FROM payment_transactions ${whereClause}
  `, params);
  const total = parseInt(countResult.rows[0].total);
  const limit = filters?.limit || 50;
  const offset = filters?.offset || 0;
  params.push(limit, offset);
  const result = await dbPool.query(`
    SELECT * FROM payment_transactions
    ${whereClause}
    ORDER BY 
      CASE 
        WHEN status = 'succeeded' AND paid_at IS NOT NULL 
        THEN paid_at 
        ELSE created_at 
      END DESC
    LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
  `, params);
  return {
    transactions: result.rows,
    total
  };
}
var init_payment_transactions_service = __esm({
  "server/services/payment-transactions-service.ts"() {
    "use strict";
  }
});

// server/services/stripe-service.ts
var stripe_service_exports = {};
__export(stripe_service_exports, {
  cancelPaymentIntent: () => cancelPaymentIntent,
  capturePaymentIntent: () => capturePaymentIntent,
  confirmPaymentIntent: () => confirmPaymentIntent,
  createPaymentIntent: () => createPaymentIntent,
  createRefund: () => createRefund,
  getPaymentIntent: () => getPaymentIntent,
  getStripePaymentAmounts: () => getStripePaymentAmounts,
  verifyPaymentIntentForBooking: () => verifyPaymentIntentForBooking
});
import Stripe2 from "stripe";
async function createPaymentIntent(params) {
  if (!stripe2) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  const {
    amount,
    currency = "cad",
    chefId,
    kitchenId,
    metadata = {},
    statementDescriptor = "LOCALCOOKS",
    managerConnectAccountId,
    applicationFeeAmount,
    enableACSS = true,
    // Default to true for ACSS debit support
    enableCards = true,
    // Default to true for standard card payments
    useAuthorizationHold = true,
    // DEPRECATED: No longer used - always uses automatic capture
    saveCardForFuture = true,
    // Default to true to save cards for future use
    customerId
  } = params;
  if (amount <= 0) {
    throw new Error("Payment amount must be greater than 0");
  }
  if (managerConnectAccountId && !applicationFeeAmount) {
    throw new Error("applicationFeeAmount is required when managerConnectAccountId is provided");
  }
  if (applicationFeeAmount && !managerConnectAccountId) {
    throw new Error("managerConnectAccountId is required when applicationFeeAmount is provided");
  }
  if (applicationFeeAmount && applicationFeeAmount >= amount) {
    throw new Error("Application fee must be less than total amount");
  }
  if (!enableACSS && !enableCards) {
    throw new Error("At least one payment method must be enabled");
  }
  const cleanDescriptor = statementDescriptor.replace(/[<>'"]/g, "").substring(0, 15).toUpperCase();
  try {
    const paymentMethodTypes = [];
    if (enableCards) {
      paymentMethodTypes.push("card");
    }
    if (enableACSS) {
      paymentMethodTypes.push("acss_debit");
    }
    const paymentIntentParams = {
      amount,
      currency,
      payment_method_types: paymentMethodTypes,
      // Don't auto-confirm - we'll confirm after collecting payment method
      confirm: false,
      // Use automatic capture: payments are immediately processed when confirmed
      capture_method: "automatic",
      metadata: {
        booking_type: "kitchen",
        kitchen_id: kitchenId.toString(),
        chef_id: chefId.toString(),
        expected_amount: amount.toString(),
        // Store expected amount for verification
        ...metadata
      }
    };
    if (enableCards) {
      paymentIntentParams.statement_descriptor_suffix = cleanDescriptor.substring(0, 22);
    } else if (enableACSS) {
      paymentIntentParams.statement_descriptor = cleanDescriptor;
    }
    paymentIntentParams.payment_method_options = {};
    if (enableACSS) {
      paymentIntentParams.payment_method_options.acss_debit = {
        mandate_options: {
          payment_schedule: "combined",
          // Creates a mandate for future debits
          transaction_type: "personal",
          // Default to personal, can be made configurable
          interval_description: "Payment for kitchen booking and future bookings as authorized"
          // Required for 'combined' or 'interval' payment schedules
        }
      };
    }
    if (saveCardForFuture && enableCards) {
      paymentIntentParams.setup_future_usage = "off_session";
    }
    if (customerId) {
      paymentIntentParams.customer = customerId;
    }
    if (managerConnectAccountId && applicationFeeAmount) {
      paymentIntentParams.application_fee_amount = applicationFeeAmount;
      paymentIntentParams.transfer_data = {
        destination: managerConnectAccountId
      };
      paymentIntentParams.metadata.manager_connect_account_id = managerConnectAccountId;
      paymentIntentParams.metadata.platform_fee = applicationFeeAmount.toString();
    }
    const paymentIntent = await stripe2.paymentIntents.create(paymentIntentParams);
    return {
      id: paymentIntent.id,
      clientSecret: paymentIntent.client_secret,
      status: paymentIntent.status,
      amount: paymentIntent.amount
    };
  } catch (error) {
    console.error("Error creating PaymentIntent:", error);
    throw new Error(`Failed to create payment intent: ${error.message}`);
  }
}
async function confirmPaymentIntent(paymentIntentId, paymentMethodId) {
  if (!stripe2) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const paymentIntent = await stripe2.paymentIntents.confirm(paymentIntentId, {
      payment_method: paymentMethodId
    });
    return {
      id: paymentIntent.id,
      clientSecret: paymentIntent.client_secret || "",
      status: paymentIntent.status,
      amount: paymentIntent.amount
    };
  } catch (error) {
    console.error("Error confirming PaymentIntent:", error);
    throw new Error(`Failed to confirm payment intent: ${error.message}`);
  }
}
async function getPaymentIntent(paymentIntentId) {
  if (!stripe2) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const paymentIntent = await stripe2.paymentIntents.retrieve(paymentIntentId);
    return {
      id: paymentIntent.id,
      clientSecret: paymentIntent.client_secret || "",
      status: paymentIntent.status,
      amount: paymentIntent.amount
    };
  } catch (error) {
    if (error.code === "resource_missing") {
      return null;
    }
    console.error("Error retrieving PaymentIntent:", error);
    throw new Error(`Failed to retrieve payment intent: ${error.message}`);
  }
}
async function getStripePaymentAmounts(paymentIntentId, managerConnectAccountId) {
  if (!stripe2) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const paymentIntent = await stripe2.paymentIntents.retrieve(paymentIntentId, {
      expand: ["latest_charge"]
    });
    if (!paymentIntent.latest_charge) {
      console.warn(`[Stripe] No charge found for PaymentIntent ${paymentIntentId}`);
      return null;
    }
    const chargeId = typeof paymentIntent.latest_charge === "string" ? paymentIntent.latest_charge : paymentIntent.latest_charge.id;
    const charge = typeof paymentIntent.latest_charge === "string" ? await stripe2.charges.retrieve(paymentIntent.latest_charge) : paymentIntent.latest_charge;
    let balanceTransaction = null;
    if (charge.balance_transaction) {
      const balanceTransactionId = typeof charge.balance_transaction === "string" ? charge.balance_transaction : charge.balance_transaction.id;
      balanceTransaction = await stripe2.balanceTransactions.retrieve(balanceTransactionId);
    }
    const stripeAmount = paymentIntent.amount;
    let stripeNetAmount = stripeAmount;
    let stripeProcessingFee = 0;
    let stripePlatformFee = 0;
    if (balanceTransaction) {
      stripeNetAmount = balanceTransaction.net;
      if (managerConnectAccountId && paymentIntent.application_fee_amount) {
        stripePlatformFee = paymentIntent.application_fee_amount;
        stripeProcessingFee = stripeAmount - stripePlatformFee - stripeNetAmount;
      } else {
        stripeProcessingFee = balanceTransaction.fee;
        stripeNetAmount = stripeAmount - stripeProcessingFee;
      }
    } else {
      stripeProcessingFee = Math.round(stripeAmount * 0.029 + 30);
      if (managerConnectAccountId && paymentIntent.application_fee_amount) {
        stripePlatformFee = paymentIntent.application_fee_amount;
        stripeNetAmount = stripeAmount - stripePlatformFee - stripeProcessingFee;
      } else {
        stripeNetAmount = stripeAmount - stripeProcessingFee;
      }
    }
    return {
      stripeAmount,
      stripeNetAmount,
      stripeProcessingFee,
      stripePlatformFee,
      chargeId
    };
  } catch (error) {
    console.error(`[Stripe] Error fetching payment amounts for ${paymentIntentId}:`, error);
    return null;
  }
}
async function capturePaymentIntent(paymentIntentId, amountToCapture) {
  if (!stripe2) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const captureParams = {};
    if (amountToCapture !== void 0) {
      captureParams.amount_to_capture = amountToCapture;
    }
    const paymentIntent = await stripe2.paymentIntents.capture(paymentIntentId, captureParams);
    return {
      id: paymentIntent.id,
      clientSecret: paymentIntent.client_secret || "",
      status: paymentIntent.status,
      amount: paymentIntent.amount
    };
  } catch (error) {
    console.error("Error capturing PaymentIntent:", error);
    throw new Error(`Failed to capture payment intent: ${error.message}`);
  }
}
async function cancelPaymentIntent(paymentIntentId) {
  if (!stripe2) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const paymentIntent = await stripe2.paymentIntents.cancel(paymentIntentId);
    return {
      id: paymentIntent.id,
      clientSecret: paymentIntent.client_secret || "",
      status: paymentIntent.status,
      amount: paymentIntent.amount
    };
  } catch (error) {
    console.error("Error canceling PaymentIntent:", error);
    throw new Error(`Failed to cancel payment intent: ${error.message}`);
  }
}
async function createRefund(paymentIntentId, amount, reason = "requested_by_customer") {
  if (!stripe2) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const paymentIntent = await stripe2.paymentIntents.retrieve(paymentIntentId);
    if (!paymentIntent.latest_charge) {
      throw new Error("Payment intent has no charge to refund");
    }
    const chargeId = typeof paymentIntent.latest_charge === "string" ? paymentIntent.latest_charge : paymentIntent.latest_charge.id;
    const refundParams = {
      charge: chargeId,
      reason
    };
    if (amount !== void 0 && amount > 0) {
      refundParams.amount = amount;
    }
    const refund = await stripe2.refunds.create(refundParams);
    if (!refund.charge || typeof refund.charge !== "string") {
      throw new Error("Refund created but charge ID is missing");
    }
    if (!refund.status || typeof refund.status !== "string") {
      throw new Error("Refund created but status is missing");
    }
    const refundChargeId = refund.charge;
    const refundStatus = refund.status;
    return {
      id: refund.id,
      amount: refund.amount,
      status: refundStatus,
      charge: refundChargeId
    };
  } catch (error) {
    console.error("Error creating refund:", error);
    throw new Error(`Failed to create refund: ${error.message}`);
  }
}
async function verifyPaymentIntentForBooking(paymentIntentId, chefId, expectedAmount) {
  try {
    if (!stripe2) {
      return { valid: false, status: "error", error: "Stripe is not configured" };
    }
    const paymentIntent = await stripe2.paymentIntents.retrieve(paymentIntentId);
    if (!paymentIntent) {
      return { valid: false, status: "not_found", error: "Payment intent not found" };
    }
    if (paymentIntent.metadata?.chef_id !== chefId.toString()) {
      return { valid: false, status: paymentIntent.status, error: "Payment intent does not belong to this chef" };
    }
    const storedExpectedAmount = paymentIntent.metadata?.expected_amount ? parseInt(paymentIntent.metadata.expected_amount) : null;
    const amountToCompare = storedExpectedAmount !== null ? storedExpectedAmount : expectedAmount;
    const amountDifference = Math.abs(paymentIntent.amount - amountToCompare);
    if (amountDifference > 5) {
      console.error("Payment amount mismatch:", {
        paymentIntentAmount: paymentIntent.amount,
        expectedAmount: amountToCompare,
        storedExpectedAmount,
        calculatedExpectedAmount: expectedAmount,
        difference: amountDifference,
        differenceDollars: (amountDifference / 100).toFixed(2)
      });
      return { valid: false, status: paymentIntent.status, error: "Payment amount does not match booking amount" };
    }
    const validStatuses = ["succeeded", "processing"];
    if (!validStatuses.includes(paymentIntent.status)) {
      return {
        valid: false,
        status: paymentIntent.status,
        error: `Payment is not in a valid state: ${paymentIntent.status}`
      };
    }
    return { valid: true, status: paymentIntent.status };
  } catch (error) {
    console.error("Error verifying PaymentIntent:", error);
    if (error.code === "resource_missing") {
      return { valid: false, status: "not_found", error: "Payment intent not found" };
    }
    return { valid: false, status: "error", error: error.message };
  }
}
var stripeSecretKey2, stripe2;
var init_stripe_service = __esm({
  "server/services/stripe-service.ts"() {
    "use strict";
    stripeSecretKey2 = process.env.STRIPE_SECRET_KEY;
    if (!stripeSecretKey2) {
      console.warn("\u26A0\uFE0F STRIPE_SECRET_KEY not found in environment variables");
    }
    stripe2 = stripeSecretKey2 ? new Stripe2(stripeSecretKey2, {
      apiVersion: "2025-12-15.clover"
    }) : null;
  }
});

// server/services/payment-tracking-service.ts
var payment_tracking_service_exports = {};
__export(payment_tracking_service_exports, {
  getPaymentStatus: () => getPaymentStatus,
  mapStripeStatusToPaymentStatus: () => mapStripeStatusToPaymentStatus,
  recoverMissingPaymentData: () => recoverMissingPaymentData,
  syncManagerPayments: () => syncManagerPayments,
  syncPaymentStatusFromStripe: () => syncPaymentStatusFromStripe,
  trackRefund: () => trackRefund
});
function mapStripeStatusToPaymentStatus(stripeStatus) {
  switch (stripeStatus) {
    case "succeeded":
      return "paid";
    case "processing":
    case "requires_confirmation":
      return "processing";
    // Payment is being processed
    case "canceled":
      return "canceled";
    case "payment_failed":
    case "requires_payment_method":
      return "failed";
    default:
      if (stripeStatus.includes("refund")) {
        return "refunded";
      }
      return "pending";
  }
}
async function syncPaymentStatusFromStripe(bookingId, dbPool) {
  try {
    const bookingResult = await dbPool.query(`
      SELECT 
        id,
        payment_intent_id,
        payment_status,
        total_price,
        chef_id,
        kitchen_id
      FROM kitchen_bookings
      WHERE id = $1
    `, [bookingId]);
    if (bookingResult.rows.length === 0) {
      return {
        success: false,
        paymentStatus: "pending",
        stripeStatus: "not_found",
        error: "Booking not found"
      };
    }
    const booking = bookingResult.rows[0];
    if (!booking.payment_intent_id) {
      return {
        success: true,
        bookingId,
        paymentStatus: booking.payment_status || "pending",
        stripeStatus: "no_payment_intent",
        updated: false
      };
    }
    const paymentIntent = await getPaymentIntent(booking.payment_intent_id);
    if (!paymentIntent) {
      return {
        success: false,
        bookingId,
        paymentStatus: booking.payment_status || "pending",
        stripeStatus: "not_found",
        error: "Payment intent not found in Stripe"
      };
    }
    const newPaymentStatus = mapStripeStatusToPaymentStatus(paymentIntent.status);
    const currentStatus = booking.payment_status;
    if (newPaymentStatus !== currentStatus) {
      await dbPool.query(`
        UPDATE kitchen_bookings
        SET 
          payment_status = $1,
          updated_at = NOW()
        WHERE id = $2
      `, [newPaymentStatus, bookingId]);
      console.log(`[Payment Tracking] Updated booking ${bookingId} payment status: ${currentStatus} -> ${newPaymentStatus} (Stripe: ${paymentIntent.status})`);
      return {
        success: true,
        bookingId,
        paymentStatus: newPaymentStatus,
        stripeStatus: paymentIntent.status,
        amount: booking.total_price ? parseInt(String(booking.total_price)) : void 0,
        updated: true
      };
    }
    return {
      success: true,
      bookingId,
      paymentStatus: currentStatus,
      stripeStatus: paymentIntent.status,
      amount: booking.total_price ? parseInt(String(booking.total_price)) : void 0,
      updated: false
    };
  } catch (error) {
    console.error(`[Payment Tracking] Error syncing payment status for booking ${bookingId}:`, error);
    return {
      success: false,
      paymentStatus: "pending",
      stripeStatus: "error",
      error: error.message
    };
  }
}
async function syncManagerPayments(managerId, dbPool) {
  try {
    const bookingsResult = await dbPool.query(`
      SELECT 
        kb.id,
        kb.payment_intent_id,
        kb.payment_status
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      WHERE l.manager_id = $1
        AND kb.status != 'cancelled'
        AND kb.payment_intent_id IS NOT NULL
        AND kb.payment_status IN ('pending', 'processing')
    `, [managerId]);
    let synced = 0;
    let updated = 0;
    let errors = 0;
    for (const booking of bookingsResult.rows) {
      synced++;
      const result = await syncPaymentStatusFromStripe(booking.id, dbPool);
      if (result.success && result.updated) {
        updated++;
      } else if (!result.success) {
        errors++;
      }
    }
    console.log(`[Payment Tracking] Synced ${synced} payments for manager ${managerId}: ${updated} updated, ${errors} errors`);
    return { synced, updated, errors };
  } catch (error) {
    console.error(`[Payment Tracking] Error syncing manager payments:`, error);
    throw error;
  }
}
async function recoverMissingPaymentData(bookingId, dbPool) {
  try {
    const bookingResult = await dbPool.query(`
      SELECT 
        id,
        payment_intent_id,
        payment_status,
        total_price,
        service_fee,
        currency
      FROM kitchen_bookings
      WHERE id = $1
    `, [bookingId]);
    if (bookingResult.rows.length === 0) {
      return {
        success: false,
        paymentStatus: "pending",
        stripeStatus: "not_found",
        error: "Booking not found"
      };
    }
    const booking = bookingResult.rows[0];
    if (!booking.payment_intent_id) {
      return {
        success: true,
        bookingId,
        paymentStatus: booking.payment_status || "pending",
        stripeStatus: "no_payment_intent",
        updated: false
      };
    }
    const paymentIntent = await getPaymentIntent(booking.payment_intent_id);
    if (!paymentIntent) {
      return {
        success: false,
        bookingId,
        paymentStatus: booking.payment_status || "pending",
        stripeStatus: "not_found",
        error: "Payment intent not found in Stripe"
      };
    }
    const updates = [];
    const params = [];
    let paramIndex = 1;
    const newPaymentStatus = mapStripeStatusToPaymentStatus(paymentIntent.status);
    if (!booking.payment_status || booking.payment_status !== newPaymentStatus) {
      updates.push(`payment_status = $${paramIndex}`);
      params.push(newPaymentStatus);
      paramIndex++;
    }
    if (!booking.total_price && paymentIntent.amount) {
      updates.push(`total_price = $${paramIndex}`);
      params.push(paymentIntent.amount.toString());
      paramIndex++;
    }
    if (updates.length > 0) {
      params.push(bookingId);
      await dbPool.query(`
        UPDATE kitchen_bookings
        SET 
          ${updates.join(", ")},
          updated_at = NOW()
        WHERE id = $${paramIndex}
      `, params);
      console.log(`[Payment Tracking] Recovered payment data for booking ${bookingId}:`, {
        status: newPaymentStatus,
        amount: paymentIntent.amount
      });
      return {
        success: true,
        bookingId,
        paymentStatus: newPaymentStatus,
        stripeStatus: paymentIntent.status,
        amount: paymentIntent.amount,
        updated: true
      };
    }
    return {
      success: true,
      bookingId,
      paymentStatus: newPaymentStatus,
      stripeStatus: paymentIntent.status,
      amount: booking.total_price ? parseInt(String(booking.total_price)) : paymentIntent.amount,
      updated: false
    };
  } catch (error) {
    console.error(`[Payment Tracking] Error recovering payment data for booking ${bookingId}:`, error);
    return {
      success: false,
      paymentStatus: "pending",
      stripeStatus: "error",
      error: error.message
    };
  }
}
async function trackRefund(bookingId, refundAmount, isPartial, dbPool) {
  try {
    const newStatus = isPartial ? "partially_refunded" : "refunded";
    await dbPool.query(`
      UPDATE kitchen_bookings
      SET 
        payment_status = $1,
        updated_at = NOW()
      WHERE id = $2
    `, [newStatus, bookingId]);
    console.log(`[Payment Tracking] Tracked ${isPartial ? "partial" : "full"} refund for booking ${bookingId}: ${refundAmount} cents`);
    return {
      success: true,
      bookingId,
      paymentStatus: newStatus,
      stripeStatus: isPartial ? "partially_refunded" : "refunded",
      amount: refundAmount,
      updated: true
    };
  } catch (error) {
    console.error(`[Payment Tracking] Error tracking refund for booking ${bookingId}:`, error);
    return {
      success: false,
      paymentStatus: "pending",
      stripeStatus: "error",
      error: error.message
    };
  }
}
async function getPaymentStatus(bookingId, dbPool) {
  try {
    const bookingResult = await dbPool.query(`
      SELECT 
        id,
        payment_intent_id,
        payment_status,
        total_price
      FROM kitchen_bookings
      WHERE id = $1
    `, [bookingId]);
    if (bookingResult.rows.length === 0) {
      return {
        bookingId,
        dbStatus: null,
        stripeStatus: null,
        inSync: false,
        totalPrice: null,
        paymentIntentId: null,
        needsSync: false
      };
    }
    const booking = bookingResult.rows[0];
    const dbStatus = booking.payment_status;
    let stripeStatus = null;
    let inSync = true;
    let needsSync = false;
    if (booking.payment_intent_id) {
      const paymentIntent = await getPaymentIntent(booking.payment_intent_id);
      if (paymentIntent) {
        stripeStatus = paymentIntent.status;
        const expectedStatus = mapStripeStatusToPaymentStatus(paymentIntent.status);
        inSync = dbStatus === expectedStatus;
        needsSync = !inSync && (dbStatus === "pending" || dbStatus === "processing");
      }
    }
    return {
      bookingId,
      dbStatus,
      stripeStatus,
      inSync,
      totalPrice: booking.total_price ? parseInt(String(booking.total_price)) : null,
      paymentIntentId: booking.payment_intent_id,
      needsSync
    };
  } catch (error) {
    console.error(`[Payment Tracking] Error getting payment status for booking ${bookingId}:`, error);
    throw error;
  }
}
var init_payment_tracking_service = __esm({
  "server/services/payment-tracking-service.ts"() {
    "use strict";
    init_stripe_service();
  }
});

// server/services/revenue-service-v2.ts
var revenue_service_v2_exports = {};
__export(revenue_service_v2_exports, {
  getRevenueByDateFromTransactions: () => getRevenueByDateFromTransactions,
  getRevenueByLocationFromTransactions: () => getRevenueByLocationFromTransactions,
  getRevenueMetricsFromTransactions: () => getRevenueMetricsFromTransactions
});
async function getRevenueMetricsFromTransactions(managerId, dbPool, startDate, endDate, locationId) {
  try {
    const params = [managerId];
    let paramIndex = 2;
    if (locationId) {
      params.push(locationId);
      paramIndex++;
    }
    const tableCheck = await dbPool.query(`
      SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'payment_transactions'
      ) as table_exists
    `);
    const tableExists = tableCheck.rows[0]?.table_exists;
    if (!tableExists) {
      console.log("[Revenue Service V2] payment_transactions table does not exist, will fallback to legacy method");
      throw new Error("payment_transactions table does not exist");
    }
    const countCheck = await dbPool.query(`
      SELECT COUNT(*) as count
      FROM payment_transactions pt
      LEFT JOIN kitchen_bookings kb ON pt.booking_id = kb.id AND pt.booking_type IN ('kitchen', 'bundle')
      LEFT JOIN kitchens k ON kb.kitchen_id = k.id
      LEFT JOIN locations l ON k.location_id = l.id
      WHERE (
        pt.manager_id = $1 
        OR (pt.manager_id IS NULL AND l.manager_id = $1)
      )
        AND pt.booking_type IN ('kitchen', 'bundle')
    `, [managerId]);
    const transactionCount = parseInt(countCheck.rows[0]?.count || "0");
    console.log(`[Revenue Service V2] Found ${transactionCount} payment_transactions for manager ${managerId}`);
    const bookingCountCheck = await dbPool.query(`
      SELECT 
        COUNT(DISTINCT kb.id) as total_bookings,
        COUNT(DISTINCT CASE WHEN pt_kitchen.id IS NOT NULL OR pt_bundle.id IS NOT NULL THEN kb.id END) as bookings_with_transactions
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      LEFT JOIN payment_transactions pt_kitchen ON pt_kitchen.booking_id = kb.id 
        AND pt_kitchen.booking_type = 'kitchen'
        AND (pt_kitchen.manager_id = $1 OR (pt_kitchen.manager_id IS NULL AND l.manager_id = $1))
      LEFT JOIN payment_transactions pt_bundle ON pt_bundle.booking_id = kb.id 
        AND pt_bundle.booking_type = 'bundle'
        AND (pt_bundle.manager_id = $1 OR (pt_bundle.manager_id IS NULL AND l.manager_id = $1))
      WHERE l.manager_id = $1
        AND kb.status != 'cancelled'
        AND (kb.payment_intent_id IS NOT NULL OR kb.total_price IS NOT NULL)
    `, [managerId]);
    const totalBookings = parseInt(bookingCountCheck.rows[0]?.total_bookings || "0");
    const bookingsWithTransactions = parseInt(bookingCountCheck.rows[0]?.bookings_with_transactions || "0");
    console.log(`[Revenue Service V2] Booking coverage: ${bookingsWithTransactions}/${totalBookings} bookings have payment_transactions`);
    if (transactionCount === 0) {
      console.log("[Revenue Service V2] No payment_transactions found, falling back to legacy method");
      throw new Error("No payment_transactions found for manager");
    }
    if (totalBookings > 0 && bookingsWithTransactions < totalBookings) {
      console.log(`[Revenue Service V2] Incomplete payment_transactions coverage (${bookingsWithTransactions}/${totalBookings}), falling back to legacy method`);
      throw new Error("Incomplete payment_transactions coverage");
    }
    let locationFilter = "";
    if (locationId) {
      locationFilter = `AND l.id = $${paramIndex}`;
      paramIndex++;
    }
    let dateFilter = "";
    if (startDate || endDate) {
      const start = startDate ? typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0] : null;
      const end = endDate ? typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0] : null;
      console.log("[Revenue Service V2] Applying date filter:", { startDate: start, endDate: end, managerId });
      if (start && end) {
        dateFilter = `AND (
          (pt.status = 'succeeded' AND (
            (pt.paid_at IS NOT NULL AND DATE(pt.paid_at) >= $${paramIndex}::date AND DATE(pt.paid_at) <= $${paramIndex + 1}::date)
            OR (pt.paid_at IS NULL AND DATE(pt.created_at) >= $${paramIndex}::date AND DATE(pt.created_at) <= $${paramIndex + 1}::date)
          ))
          OR (pt.status != 'succeeded' AND DATE(pt.created_at) >= $${paramIndex}::date AND DATE(pt.created_at) <= $${paramIndex + 1}::date)
        )`;
        params.push(start, end);
        paramIndex += 2;
      } else if (start) {
        dateFilter = `AND (
          (pt.status = 'succeeded' AND (
            (pt.paid_at IS NOT NULL AND DATE(pt.paid_at) >= $${paramIndex}::date)
            OR (pt.paid_at IS NULL AND DATE(pt.created_at) >= $${paramIndex}::date)
          ))
          OR (pt.status != 'succeeded' AND DATE(pt.created_at) >= $${paramIndex}::date)
        )`;
        params.push(start);
        paramIndex++;
      } else if (end) {
        dateFilter = `AND (
          (pt.status = 'succeeded' AND (
            (pt.paid_at IS NOT NULL AND DATE(pt.paid_at) <= $${paramIndex}::date)
            OR (pt.paid_at IS NULL AND DATE(pt.created_at) <= $${paramIndex}::date)
          ))
          OR (pt.status != 'succeeded' AND DATE(pt.created_at) <= $${paramIndex}::date)
        )`;
        params.push(end);
        paramIndex++;
      }
    }
    const result = await dbPool.query(`
      SELECT 
        COALESCE(SUM(pt.amount::numeric), 0)::bigint as total_revenue,
        -- Platform fee: use service_fee if available, otherwise calculate as amount - manager_revenue
        -- This ensures we use Stripe-synced amounts when available
        COALESCE(
          SUM(
            CASE 
              WHEN pt.service_fee::numeric > 0 THEN pt.service_fee::numeric
              ELSE (pt.amount::numeric - pt.manager_revenue::numeric)
            END
          ), 
          0
        )::bigint as platform_fee,
        COALESCE(SUM(pt.manager_revenue::numeric), 0)::bigint as manager_revenue,
        COALESCE(SUM(CASE WHEN pt.status = 'succeeded' THEN pt.manager_revenue::numeric ELSE 0 END), 0)::bigint as deposited_manager_revenue,
        COUNT(DISTINCT pt.booking_id) as booking_count,
        COUNT(DISTINCT CASE WHEN pt.status = 'succeeded' THEN pt.booking_id END) as paid_booking_count,
        COUNT(DISTINCT CASE WHEN pt.status = 'processing' THEN pt.booking_id END) as processing_booking_count,
        COALESCE(SUM(CASE WHEN pt.status = 'succeeded' THEN pt.amount::numeric ELSE 0 END), 0)::bigint as completed_payments,
        COALESCE(SUM(CASE WHEN pt.status = 'processing' THEN pt.amount::numeric ELSE 0 END), 0)::bigint as processing_payments,
        COALESCE(SUM(CASE WHEN pt.status IN ('refunded', 'partially_refunded') THEN pt.refund_amount::numeric ELSE 0 END), 0)::bigint as refunded_amount,
        COALESCE(AVG(pt.amount::numeric), 0)::numeric as avg_booking_value
      FROM payment_transactions pt
      LEFT JOIN kitchen_bookings kb ON pt.booking_id = kb.id AND pt.booking_type IN ('kitchen', 'bundle')
      LEFT JOIN kitchens k ON kb.kitchen_id = k.id
      LEFT JOIN locations l ON k.location_id = l.id
      WHERE (
        pt.manager_id = $1 
        OR (pt.manager_id IS NULL AND l.manager_id = $1)
      )
        AND (pt.status = 'succeeded' OR pt.status = 'processing')
        AND pt.booking_type IN ('kitchen', 'bundle')
        ${locationFilter}
        ${dateFilter}
        -- Exclude kitchen transactions that are part of a bundle (to avoid double counting)
        AND NOT (
          pt.booking_type = 'kitchen' 
          AND EXISTS (
            SELECT 1 FROM payment_transactions pt2
            LEFT JOIN kitchen_bookings kb2 ON pt2.booking_id = kb2.id AND pt2.booking_type IN ('kitchen', 'bundle')
            LEFT JOIN kitchens k2 ON kb2.kitchen_id = k2.id
            LEFT JOIN locations l2 ON k2.location_id = l2.id
            WHERE pt2.booking_id = pt.booking_id
              AND pt2.booking_type = 'bundle'
              AND (pt2.manager_id = $1 OR (pt2.manager_id IS NULL AND l2.manager_id = $1))
          )
        )
    `, params);
    const row = result.rows[0] || {};
    console.log("[Revenue Service V2] Query result:", {
      managerId,
      startDate: startDate ? typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0] : "none",
      endDate: endDate ? typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0] : "none",
      locationId: locationId || "none",
      total_revenue: row.total_revenue,
      platform_fee: row.platform_fee,
      manager_revenue: row.manager_revenue,
      deposited_manager_revenue: row.deposited_manager_revenue,
      booking_count: row.booking_count,
      completed_payments: row.completed_payments,
      processing_payments: row.processing_payments
    });
    const parseNumeric = (value) => {
      if (!value) return 0;
      if (typeof value === "string") return parseInt(value) || 0;
      return parseInt(String(value)) || 0;
    };
    const completedPayments = parseNumeric(row.completed_payments);
    const pendingPayments = parseNumeric(row.pending_payments);
    const platformFee = parseNumeric(row.platform_fee);
    const managerRevenue = parseNumeric(row.manager_revenue);
    const depositedManagerRevenue = parseNumeric(row.deposited_manager_revenue);
    const refundedAmount = parseNumeric(row.refunded_amount);
    const bookingCount = parseInt(row.booking_count) || 0;
    const paidBookingCount = parseInt(row.paid_booking_count) || 0;
    const cancelledBookingCount = 0;
    const averageBookingValue = row.avg_booking_value ? Math.round(parseFloat(String(row.avg_booking_value))) : 0;
    const totalRevenue = parseNumeric(row.total_revenue);
    const finalManagerRevenue = managerRevenue;
    const metrics = {
      totalRevenue: isNaN(totalRevenue) ? 0 : totalRevenue,
      platformFee: isNaN(platformFee) ? 0 : platformFee,
      managerRevenue: isNaN(finalManagerRevenue) ? 0 : finalManagerRevenue,
      // Use database value from Stripe (includes processing)
      depositedManagerRevenue: isNaN(depositedManagerRevenue) ? 0 : depositedManagerRevenue,
      // Only succeeded transactions (what's in bank)
      pendingPayments: isNaN(pendingPayments) ? 0 : pendingPayments,
      completedPayments: isNaN(completedPayments) ? 0 : completedPayments,
      averageBookingValue: isNaN(averageBookingValue) ? 0 : averageBookingValue,
      bookingCount: isNaN(bookingCount) ? 0 : bookingCount,
      paidBookingCount: isNaN(paidBookingCount) ? 0 : paidBookingCount,
      cancelledBookingCount: isNaN(cancelledBookingCount) ? 0 : cancelledBookingCount,
      refundedAmount: isNaN(refundedAmount) ? 0 : refundedAmount
    };
    console.log("[Revenue Service V2] Final metrics:", metrics);
    return metrics;
  } catch (error) {
    console.error("Error getting revenue metrics from transactions:", error);
    throw error;
  }
}
async function getRevenueByLocationFromTransactions(managerId, dbPool, startDate, endDate) {
  try {
    const tableCheck = await dbPool.query(`
      SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'payment_transactions'
      ) as table_exists
    `);
    if (!tableCheck.rows[0]?.table_exists) {
      throw new Error("payment_transactions table does not exist");
    }
    const params = [managerId];
    const result = await dbPool.query(`
      SELECT 
        l.id as location_id,
        l.name as location_name,
        COALESCE(SUM(pt.amount::numeric), 0)::bigint as total_revenue,
        -- Platform fee: use service_fee if available, otherwise calculate as amount - manager_revenue
        COALESCE(
          SUM(
            CASE 
              WHEN pt.service_fee::numeric > 0 THEN pt.service_fee::numeric
              ELSE (pt.amount::numeric - pt.manager_revenue::numeric)
            END
          ), 
          0
        )::bigint as platform_fee,
        COALESCE(SUM(pt.manager_revenue::numeric), 0)::bigint as manager_revenue,
        COUNT(DISTINCT pt.booking_id) as booking_count,
        COUNT(DISTINCT CASE WHEN pt.status = 'succeeded' THEN pt.booking_id END) as paid_count
      FROM payment_transactions pt
      JOIN kitchens k ON (
        (pt.booking_type = 'kitchen' AND pt.booking_id IN (SELECT id FROM kitchen_bookings WHERE kitchen_id = k.id))
        OR (pt.booking_type = 'bundle' AND pt.booking_id IN (SELECT id FROM kitchen_bookings WHERE kitchen_id = k.id))
        OR (pt.booking_type = 'storage' AND pt.booking_id IN (
          SELECT sb.id FROM storage_bookings sb
          JOIN storage_listings sl ON sb.storage_listing_id = sl.id
          WHERE sl.kitchen_id = k.id
        ))
        OR (pt.booking_type = 'equipment' AND pt.booking_id IN (
          SELECT eb.id FROM equipment_bookings eb
          JOIN equipment_listings el ON eb.equipment_listing_id = el.id
          WHERE el.kitchen_id = k.id
        ))
      )
      JOIN locations l ON k.location_id = l.id
      WHERE pt.manager_id = $1
        AND pt.booking_type IN ('kitchen', 'bundle')
        AND (pt.status = 'succeeded' OR pt.status = 'processing')
        -- Exclude kitchen transactions that are part of a bundle
        AND NOT (
          pt.booking_type = 'kitchen' 
          AND EXISTS (
            SELECT 1 FROM payment_transactions pt2
            WHERE pt2.booking_id = pt.booking_id
              AND pt2.booking_type = 'bundle'
              AND pt2.manager_id = pt.manager_id
          )
        )
      GROUP BY l.id, l.name
      ORDER BY total_revenue DESC
    `, params);
    console.log(`[Revenue Service V2] Revenue by location: ${result.rows.length} locations found`);
    return result.rows.map((row) => {
      const parseNumeric = (value) => {
        if (!value) return 0;
        if (typeof value === "string") return parseInt(value) || 0;
        return parseInt(String(value)) || 0;
      };
      const locTotalRevenue = parseNumeric(row.total_revenue);
      const locPlatformFee = parseNumeric(row.platform_fee);
      const locManagerRevenue = Math.max(0, locTotalRevenue - locPlatformFee);
      return {
        locationId: parseInt(row.location_id),
        locationName: row.location_name,
        totalRevenue: locTotalRevenue,
        platformFee: locPlatformFee,
        managerRevenue: locManagerRevenue,
        // Calculated as total - platform fee
        bookingCount: parseInt(row.booking_count) || 0,
        paidBookingCount: parseInt(row.paid_count) || 0
      };
    });
  } catch (error) {
    console.error("Error getting revenue by location from transactions:", error);
    throw error;
  }
}
async function getRevenueByDateFromTransactions(managerId, dbPool, startDate, endDate) {
  try {
    const tableCheck = await dbPool.query(`
      SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'payment_transactions'
      ) as table_exists
    `);
    if (!tableCheck.rows[0]?.table_exists) {
      throw new Error("payment_transactions table does not exist");
    }
    const start = typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0];
    const end = typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0];
    const result = await dbPool.query(`
      SELECT 
        DATE(
          CASE 
            WHEN pt.status = 'succeeded' AND pt.paid_at IS NOT NULL 
            THEN pt.paid_at
            ELSE pt.created_at
          END
        )::text as date,
        COALESCE(SUM(pt.amount::numeric), 0)::bigint as total_revenue,
        -- Platform fee: use service_fee if available, otherwise calculate as amount - manager_revenue
        COALESCE(
          SUM(
            CASE 
              WHEN pt.service_fee::numeric > 0 THEN pt.service_fee::numeric
              ELSE (pt.amount::numeric - pt.manager_revenue::numeric)
            END
          ), 
          0
        )::bigint as platform_fee,
        COALESCE(SUM(pt.manager_revenue::numeric), 0)::bigint as manager_revenue,
        COUNT(DISTINCT pt.booking_id) as booking_count
      FROM payment_transactions pt
      WHERE pt.manager_id = $1
        AND pt.booking_type IN ('kitchen', 'bundle')
        -- Exclude kitchen transactions that are part of a bundle
        AND NOT (
          pt.booking_type = 'kitchen' 
          AND EXISTS (
            SELECT 1 FROM payment_transactions pt2
            WHERE pt2.booking_id = pt.booking_id
              AND pt2.booking_type = 'bundle'
              AND pt2.manager_id = pt.manager_id
          )
        )
        AND (
          (pt.status = 'succeeded' AND pt.paid_at IS NOT NULL AND DATE(pt.paid_at) >= $2::date AND DATE(pt.paid_at) <= $3::date)
          OR (pt.status != 'succeeded' AND DATE(pt.created_at) >= $2::date AND DATE(pt.created_at) <= $3::date)
        )
      GROUP BY DATE(
        CASE 
          WHEN pt.status = 'succeeded' AND pt.paid_at IS NOT NULL 
          THEN pt.paid_at
          ELSE pt.created_at
        END
      )
      ORDER BY date ASC
    `, [managerId, start, end]);
    console.log(`[Revenue Service V2] Revenue by date: ${result.rows.length} dates found`);
    return result.rows.map((row) => {
      const parseNumeric = (value) => {
        if (!value) return 0;
        if (typeof value === "string") return parseInt(value) || 0;
        return parseInt(String(value)) || 0;
      };
      return {
        date: row.date,
        totalRevenue: parseNumeric(row.total_revenue),
        platformFee: parseNumeric(row.platform_fee),
        managerRevenue: Math.max(0, parseNumeric(row.total_revenue) - parseNumeric(row.platform_fee)),
        // Calculate as total - platform fee
        bookingCount: parseInt(row.booking_count) || 0
      };
    });
  } catch (error) {
    console.error("Error getting revenue by date from transactions:", error);
    throw error;
  }
}
var init_revenue_service_v2 = __esm({
  "server/services/revenue-service-v2.ts"() {
    "use strict";
  }
});

// server/services/revenue-service.ts
var revenue_service_exports = {};
__export(revenue_service_exports, {
  calculateManagerRevenue: () => calculateManagerRevenue,
  getCompleteRevenueMetrics: () => getCompleteRevenueMetrics,
  getRevenueByDate: () => getRevenueByDate,
  getRevenueByLocation: () => getRevenueByLocation,
  getRevenueMetrics: () => getRevenueMetrics,
  getTransactionHistory: () => getTransactionHistory
});
function calculateManagerRevenue(totalRevenue, serviceFeeRate) {
  if (serviceFeeRate < 0 || serviceFeeRate > 1) {
    console.warn(`Invalid service fee rate: ${serviceFeeRate}, using 0`);
    return totalRevenue;
  }
  const managerRate = 1 - serviceFeeRate;
  return Math.round(totalRevenue * managerRate);
}
async function getRevenueMetrics(managerId, dbPool, startDate, endDate, locationId) {
  try {
    let whereClause = `
      WHERE l.manager_id = $1
        AND kb.status != 'cancelled'
    `;
    const params = [managerId];
    let paramIndex = 2;
    if (locationId) {
      whereClause += ` AND l.id = $${paramIndex}`;
      params.push(locationId);
      paramIndex++;
    }
    const { getServiceFeeRate: getServiceFeeRate2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
    const serviceFeeRate = await getServiceFeeRate2(dbPool);
    const debugQuery = await dbPool.query(`
      SELECT 
        COUNT(*) as total_bookings,
        COUNT(CASE WHEN kb.total_price IS NOT NULL THEN 1 END) as bookings_with_price,
        COUNT(CASE WHEN kb.total_price IS NULL THEN 1 END) as bookings_without_price,
        COUNT(CASE WHEN kb.status = 'cancelled' THEN 1 END) as cancelled_count,
        COUNT(CASE WHEN kb.payment_status = 'processing' THEN 1 END) as processing_count,
        COUNT(CASE WHEN kb.payment_status = 'processing' THEN 1 END) as processing_count,
        COUNT(CASE WHEN kb.payment_status = 'paid' THEN 1 END) as paid_count,
        COUNT(CASE WHEN kb.payment_intent_id IS NOT NULL THEN 1 END) as with_payment_intent,
        COUNT(CASE WHEN kb.payment_status IS NULL THEN 1 END) as null_payment_status
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      WHERE l.manager_id = $1
    `, [managerId]);
    console.log("[Revenue Service] Debug - Manager bookings:", {
      managerId,
      debug: debugQuery.rows[0],
      whereClause,
      params,
      startDate,
      endDate
    });
    const result = await dbPool.query(`
      SELECT 
        COALESCE(SUM(
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric
        ), 0)::bigint as total_revenue,
        COALESCE(SUM(COALESCE(kb.service_fee, 0)::numeric), 0)::bigint as platform_fee,
        COUNT(*)::int as booking_count,
        COUNT(CASE WHEN kb.payment_status = 'paid' THEN 1 END)::int as paid_count,
        COUNT(CASE WHEN kb.payment_status = 'processing' THEN 1 END)::int as processing_count,
        COUNT(CASE WHEN kb.status = 'cancelled' THEN 1 END)::int as cancelled_count,
        COUNT(CASE WHEN kb.payment_status = 'refunded' OR kb.payment_status = 'partially_refunded' THEN 1 END)::int as refunded_count,
        COALESCE(SUM(CASE WHEN kb.payment_status = 'paid' THEN 
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric ELSE 0 END), 0)::bigint as completed_payments,
        COALESCE(SUM(CASE WHEN kb.payment_status = 'processing' THEN 
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric ELSE 0 END), 0)::bigint as pending_payments,
        COALESCE(SUM(CASE WHEN kb.payment_status = 'refunded' OR kb.payment_status = 'partially_refunded' THEN 
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric ELSE 0 END), 0)::bigint as refunded_amount,
        COALESCE(AVG(
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric
        ), 0)::numeric as avg_booking_value
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${whereClause}
    `, params);
    let pendingWhereClause = `
      WHERE l.manager_id = $1
        AND kb.status != 'cancelled'
        AND kb.payment_status = 'processing'
    `;
    const pendingParams = [managerId];
    let pendingParamIndex = 2;
    if (locationId) {
      pendingWhereClause += ` AND l.id = $${pendingParamIndex}`;
      pendingParams.push(locationId);
      pendingParamIndex++;
    }
    const pendingResult = await dbPool.query(`
      SELECT 
        COALESCE(SUM(
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric
        ), 0)::bigint as pending_payments_all,
        COUNT(*)::int as pending_count_all
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${pendingWhereClause}
    `, pendingParams);
    console.log("[Revenue Service] Pending payments query:", {
      managerId,
      locationId,
      pendingCount: pendingResult.rows[0]?.pending_count_all || 0,
      pendingAmount: pendingResult.rows[0]?.pending_payments_all || 0,
      whereClause: pendingWhereClause,
      params: pendingParams
    });
    let completedWhereClause = `
      WHERE l.manager_id = $1
        AND kb.status != 'cancelled'
        AND kb.payment_status = 'paid'
    `;
    const completedParams = [managerId];
    let completedParamIndex = 2;
    if (locationId) {
      completedWhereClause += ` AND l.id = $${completedParamIndex}`;
      completedParams.push(locationId);
      completedParamIndex++;
    }
    const completedResult = await dbPool.query(`
      SELECT 
        COALESCE(SUM(
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric
        ), 0)::bigint as completed_payments_all,
        COUNT(*)::int as completed_count_all
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${completedWhereClause}
    `, completedParams);
    const pendingRow = pendingResult.rows[0] || {};
    const allPendingPayments = typeof pendingRow.pending_payments_all === "string" ? parseInt(pendingRow.pending_payments_all) || 0 : pendingRow.pending_payments_all ? parseInt(String(pendingRow.pending_payments_all)) : 0;
    console.log("[Revenue Service] Pending payments result:", {
      allPendingPayments,
      pendingCount: pendingRow.pending_count_all || 0,
      rawValue: pendingRow.pending_payments_all
    });
    const completedRow = completedResult.rows[0] || {};
    const allCompletedPayments = typeof completedRow.completed_payments_all === "string" ? parseInt(completedRow.completed_payments_all) || 0 : completedRow.completed_payments_all ? parseInt(String(completedRow.completed_payments_all)) : 0;
    console.log("[Revenue Service] Main query result count:", result.rows.length);
    if (result.rows.length > 0) {
      console.log("[Revenue Service] Main query result:", {
        total_revenue: result.rows[0].total_revenue,
        platform_fee: result.rows[0].platform_fee,
        booking_count: result.rows[0].booking_count
      });
    }
    if (result.rows.length === 0) {
      console.log("[Revenue Service] No bookings in date range, checking for payments outside date range...");
      const pendingServiceFeeResult2 = await dbPool.query(`
        SELECT 
          COALESCE(SUM(
            COALESCE(kb.service_fee, 0)::numeric
          ), 0)::bigint as pending_service_fee
        FROM kitchen_bookings kb
        JOIN kitchens k ON kb.kitchen_id = k.id
        JOIN locations l ON k.location_id = l.id
        ${pendingWhereClause}
      `, pendingParams);
      const completedServiceFeeResult2 = await dbPool.query(`
        SELECT 
          COALESCE(SUM(
            COALESCE(kb.service_fee, 0)::numeric
          ), 0)::bigint as completed_service_fee
        FROM kitchen_bookings kb
        JOIN kitchens k ON kb.kitchen_id = k.id
        JOIN locations l ON k.location_id = l.id
        ${completedWhereClause}
      `, completedParams);
      const pendingServiceFee2 = typeof pendingServiceFeeResult2.rows[0]?.pending_service_fee === "string" ? parseInt(pendingServiceFeeResult2.rows[0].pending_service_fee) || 0 : pendingServiceFeeResult2.rows[0]?.pending_service_fee ? parseInt(String(pendingServiceFeeResult2.rows[0].pending_service_fee)) : 0;
      const completedServiceFee2 = typeof completedServiceFeeResult2.rows[0]?.completed_service_fee === "string" ? parseInt(completedServiceFeeResult2.rows[0].completed_service_fee) || 0 : completedServiceFeeResult2.rows[0]?.completed_service_fee ? parseInt(String(completedServiceFeeResult2.rows[0].completed_service_fee)) : 0;
      const totalRevenueWithAllPayments2 = allCompletedPayments + allPendingPayments;
      const totalServiceFee2 = pendingServiceFee2 + completedServiceFee2;
      const managerRevenue2 = totalRevenueWithAllPayments2 - totalServiceFee2;
      const depositedManagerRevenue2 = allCompletedPayments - completedServiceFee2;
      return {
        totalRevenue: totalRevenueWithAllPayments2 || 0,
        platformFee: totalServiceFee2 || 0,
        managerRevenue: managerRevenue2 || 0,
        depositedManagerRevenue: depositedManagerRevenue2 || 0,
        pendingPayments: allPendingPayments,
        completedPayments: allCompletedPayments,
        // Show ALL completed payments, not just in date range
        averageBookingValue: 0,
        bookingCount: 0,
        paidBookingCount: parseInt(completedRow.completed_count_all) || 0,
        cancelledBookingCount: 0,
        refundedAmount: 0
      };
    }
    const row = result.rows[0];
    console.log("[Revenue Service] Query result:", {
      total_revenue: row.total_revenue,
      platform_fee: row.platform_fee,
      booking_count: row.booking_count,
      paid_count: row.paid_count,
      serviceFeeRate,
      rowData: row
    });
    const totalRevenue = typeof row.total_revenue === "string" ? parseInt(row.total_revenue) : row.total_revenue ? parseInt(String(row.total_revenue)) : 0;
    const platformFee = typeof row.platform_fee === "string" ? parseInt(row.platform_fee) : row.platform_fee ? parseInt(String(row.platform_fee)) : 0;
    const totalRevenueWithAllPayments = allCompletedPayments + allPendingPayments;
    const pendingServiceFeeResult = await dbPool.query(`
      SELECT 
        COALESCE(SUM(
          COALESCE(kb.service_fee, 0)::numeric
        ), 0)::bigint as pending_service_fee
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${pendingWhereClause}
    `, pendingParams);
    const completedServiceFeeResult = await dbPool.query(`
      SELECT 
        COALESCE(SUM(
          COALESCE(kb.service_fee, 0)::numeric
        ), 0)::bigint as completed_service_fee
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${completedWhereClause}
    `, completedParams);
    const pendingServiceFee = typeof pendingServiceFeeResult.rows[0]?.pending_service_fee === "string" ? parseInt(pendingServiceFeeResult.rows[0].pending_service_fee) || 0 : pendingServiceFeeResult.rows[0]?.pending_service_fee ? parseInt(String(pendingServiceFeeResult.rows[0].pending_service_fee)) : 0;
    const completedServiceFee = typeof completedServiceFeeResult.rows[0]?.completed_service_fee === "string" ? parseInt(completedServiceFeeResult.rows[0].completed_service_fee) || 0 : completedServiceFeeResult.rows[0]?.completed_service_fee ? parseInt(String(completedServiceFeeResult.rows[0].completed_service_fee)) : 0;
    const totalServiceFee = pendingServiceFee + completedServiceFee;
    const managerRevenue = totalRevenueWithAllPayments - totalServiceFee;
    const depositedManagerRevenue = allCompletedPayments - completedServiceFee;
    return {
      totalRevenue: isNaN(totalRevenueWithAllPayments) ? 0 : totalRevenueWithAllPayments || 0,
      platformFee: isNaN(totalServiceFee) ? 0 : totalServiceFee || 0,
      managerRevenue: isNaN(managerRevenue) ? 0 : managerRevenue || 0,
      depositedManagerRevenue: isNaN(depositedManagerRevenue) ? 0 : depositedManagerRevenue || 0,
      pendingPayments: allPendingPayments,
      // Use ALL pending payments, not just those in date range
      completedPayments: allCompletedPayments,
      // Use ALL completed payments, not just those in date range
      averageBookingValue: row.avg_booking_value ? isNaN(Math.round(parseFloat(String(row.avg_booking_value)))) ? 0 : Math.round(parseFloat(String(row.avg_booking_value))) : 0,
      bookingCount: isNaN(parseInt(row.booking_count)) ? 0 : parseInt(row.booking_count) || 0,
      paidBookingCount: isNaN(parseInt(completedRow.completed_count_all)) ? 0 : parseInt(completedRow.completed_count_all) || 0,
      // Use count from all completed payments query
      cancelledBookingCount: isNaN(parseInt(row.cancelled_count)) ? 0 : parseInt(row.cancelled_count) || 0,
      refundedAmount: typeof row.refunded_amount === "string" ? isNaN(parseInt(row.refunded_amount)) ? 0 : parseInt(row.refunded_amount) || 0 : row.refunded_amount ? isNaN(parseInt(String(row.refunded_amount))) ? 0 : parseInt(String(row.refunded_amount)) : 0
    };
  } catch (error) {
    console.error("Error getting revenue metrics:", error);
    throw error;
  }
}
async function getRevenueByLocation(managerId, dbPool, startDate, endDate) {
  try {
    let whereClause = `
      WHERE l.manager_id = $1
        AND kb.status != 'cancelled'
    `;
    const params = [managerId];
    let paramIndex = 2;
    if (startDate) {
      const start = typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0];
      whereClause += ` AND DATE(kb.booking_date) >= $${paramIndex}::date`;
      params.push(start);
      paramIndex++;
    }
    if (endDate) {
      const end = typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0];
      whereClause += ` AND DATE(kb.booking_date) <= $${paramIndex}::date`;
      params.push(end);
      paramIndex++;
    }
    const { getServiceFeeRate: getServiceFeeRate2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
    const serviceFeeRate = await getServiceFeeRate2(dbPool);
    const result = await dbPool.query(`
      SELECT 
        l.id as location_id,
        l.name as location_name,
        COALESCE(SUM(
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric
        ), 0)::bigint as total_revenue,
        COALESCE(SUM(COALESCE(kb.service_fee, 0)::numeric), 0)::bigint as platform_fee,
        COUNT(*)::int as booking_count,
        COUNT(CASE WHEN kb.payment_status = 'paid' THEN 1 END)::int as paid_count
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${whereClause}
      GROUP BY l.id, l.name
      ORDER BY total_revenue DESC
    `, params);
    return result.rows.map((row) => {
      const totalRevenue = typeof row.total_revenue === "string" ? parseInt(row.total_revenue) || 0 : row.total_revenue ? parseInt(String(row.total_revenue)) : 0;
      const platformFee = typeof row.platform_fee === "string" ? parseInt(row.platform_fee) || 0 : row.platform_fee ? parseInt(String(row.platform_fee)) : 0;
      const managerRevenue = totalRevenue - platformFee;
      return {
        locationId: parseInt(row.location_id),
        locationName: row.location_name,
        totalRevenue,
        platformFee,
        managerRevenue: managerRevenue || 0,
        bookingCount: parseInt(row.booking_count) || 0,
        paidBookingCount: parseInt(row.paid_count) || 0
      };
    });
  } catch (error) {
    console.error("Error getting revenue by location:", error);
    throw error;
  }
}
async function getRevenueByDate(managerId, dbPool, startDate, endDate) {
  try {
    const start = typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0];
    const end = typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0];
    const { getServiceFeeRate: getServiceFeeRate2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
    const serviceFeeRate = await getServiceFeeRate2(dbPool);
    const result = await dbPool.query(`
      SELECT 
        DATE(kb.booking_date)::text as date,
        COALESCE(SUM(
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric
        ), 0)::bigint as total_revenue,
        COALESCE(SUM(COALESCE(kb.service_fee, 0)::numeric), 0)::bigint as platform_fee,
        COUNT(*)::int as booking_count
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      WHERE l.manager_id = $1
        AND kb.status != 'cancelled'
        AND DATE(kb.booking_date) >= $2::date
        AND DATE(kb.booking_date) <= $3::date
      GROUP BY DATE(kb.booking_date)
      ORDER BY date ASC
    `, [managerId, start, end]);
    console.log("[Revenue Service] Revenue by date query:", {
      managerId,
      start,
      end,
      resultCount: result.rows.length
    });
    return result.rows.map((row) => {
      const totalRevenue = typeof row.total_revenue === "string" ? parseInt(row.total_revenue) || 0 : row.total_revenue ? parseInt(String(row.total_revenue)) : 0;
      const platformFee = typeof row.platform_fee === "string" ? parseInt(row.platform_fee) || 0 : row.platform_fee ? parseInt(String(row.platform_fee)) : 0;
      const managerRevenue = totalRevenue - platformFee;
      return {
        date: row.date,
        totalRevenue,
        platformFee,
        managerRevenue: managerRevenue || 0,
        bookingCount: parseInt(row.booking_count) || 0
      };
    });
  } catch (error) {
    console.error("Error getting revenue by date:", error);
    throw error;
  }
}
async function getTransactionHistory(managerId, dbPool, startDate, endDate, locationId, limit = 100, offset = 0) {
  try {
    let whereClause = `
      WHERE l.manager_id = $1
        AND kb.status != 'cancelled'
    `;
    const params = [managerId];
    let paramIndex = 2;
    if (startDate) {
      const start = typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0];
      whereClause += ` AND (DATE(kb.booking_date) >= $${paramIndex}::date OR DATE(kb.created_at) >= $${paramIndex}::date)`;
      params.push(start);
      paramIndex++;
    }
    if (endDate) {
      const end = typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0];
      whereClause += ` AND (DATE(kb.booking_date) <= $${paramIndex}::date OR DATE(kb.created_at) <= $${paramIndex}::date)`;
      params.push(end);
      paramIndex++;
    }
    if (locationId) {
      whereClause += ` AND l.id = $${paramIndex}`;
      params.push(locationId);
      paramIndex++;
    }
    const { getServiceFeeRate: getServiceFeeRate2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
    const serviceFeeRate = await getServiceFeeRate2(dbPool);
    const result = await dbPool.query(`
      SELECT 
        kb.id,
        kb.booking_date,
        kb.start_time,
        kb.end_time,
        COALESCE(
          kb.total_price,
          CASE 
            WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
            THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
            ELSE 0
          END
        )::bigint as total_price,
        COALESCE(kb.service_fee, 0)::bigint as service_fee,
        kb.payment_status,
        kb.payment_intent_id,
        kb.status,
        kb.currency,
        k.name as kitchen_name,
        l.id as location_id,
        l.name as location_name,
        u.username as chef_name,
        u.username as chef_email,
        kb.created_at
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      LEFT JOIN users u ON kb.chef_id = u.id
      ${whereClause}
      ORDER BY kb.booking_date DESC, kb.created_at DESC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `, [...params, limit, offset]);
    return result.rows.map((row) => {
      const totalPriceCents = row.total_price != null ? parseInt(String(row.total_price)) : 0;
      const serviceFeeCents = row.service_fee != null ? parseInt(String(row.service_fee)) : 0;
      const managerRevenue = totalPriceCents - serviceFeeCents;
      return {
        id: row.id,
        bookingDate: row.booking_date,
        startTime: row.start_time,
        endTime: row.end_time,
        totalPrice: totalPriceCents,
        serviceFee: serviceFeeCents,
        managerRevenue: managerRevenue || 0,
        paymentStatus: row.payment_status,
        paymentIntentId: row.payment_intent_id,
        status: row.status,
        currency: row.currency || "CAD",
        kitchenName: row.kitchen_name,
        locationId: parseInt(row.location_id),
        locationName: row.location_name,
        chefName: row.chef_name || "Guest",
        chefEmail: row.chef_email,
        createdAt: row.created_at
      };
    });
  } catch (error) {
    console.error("Error getting transaction history:", error);
    throw error;
  }
}
async function getCompleteRevenueMetrics(managerId, dbPool, startDate, endDate, locationId) {
  try {
    console.log("[Revenue Service] getCompleteRevenueMetrics called:", {
      managerId,
      startDate,
      endDate,
      locationId
    });
    try {
      const { getRevenueMetricsFromTransactions: getRevenueMetricsFromTransactions2 } = await Promise.resolve().then(() => (init_revenue_service_v2(), revenue_service_v2_exports));
      const metrics = await getRevenueMetricsFromTransactions2(managerId, dbPool, startDate, endDate, locationId);
      console.log("[Revenue Service] Using payment_transactions for revenue metrics");
      return metrics;
    } catch (error) {
      console.warn("[Revenue Service] Failed to use payment_transactions, falling back to booking tables:", error);
    }
    const kitchenMetrics = await getRevenueMetrics(managerId, dbPool, startDate, endDate, locationId);
    console.log("[Revenue Service] Kitchen metrics:", kitchenMetrics);
    let whereClause = `
      WHERE l.manager_id = $1
    `;
    const params = [managerId];
    let paramIndex = 2;
    if (startDate) {
      const start = typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0];
      whereClause += ` AND DATE(sb.start_date) >= $${paramIndex}::date`;
      params.push(start);
      paramIndex++;
    }
    if (endDate) {
      const end = typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0];
      whereClause += ` AND DATE(sb.start_date) <= $${paramIndex}::date`;
      params.push(end);
      paramIndex++;
    }
    if (locationId) {
      whereClause += ` AND l.id = $${paramIndex}`;
      params.push(locationId);
      paramIndex++;
    }
    const { getServiceFeeRate: getServiceFeeRate2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
    const serviceFeeRate = await getServiceFeeRate2(dbPool);
    const storageResult = await dbPool.query(`
      SELECT 
        COALESCE(SUM(COALESCE(sb.total_price, 0)::numeric), 0)::bigint as total_revenue,
        COALESCE(SUM(COALESCE(sb.service_fee, 0)::numeric), 0)::bigint as platform_fee,
        COUNT(*)::int as booking_count,
        COUNT(CASE WHEN sb.payment_status = 'paid' THEN 1 END)::int as paid_count,
        COALESCE(SUM(CASE WHEN sb.payment_status = 'paid' THEN COALESCE(sb.total_price, 0)::numeric ELSE 0 END), 0)::bigint as completed_payments,
        COALESCE(SUM(CASE WHEN sb.payment_status = 'processing' THEN COALESCE(sb.total_price, 0)::numeric ELSE 0 END), 0)::bigint as processing_payments
      FROM storage_bookings sb
      JOIN storage_listings sl ON sb.storage_listing_id = sl.id
      JOIN kitchens k ON sl.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${whereClause}
        AND sb.status != 'cancelled'
    `, params);
    let equipmentWhereClause = `
      WHERE l.manager_id = $1
    `;
    const equipmentParams = [managerId];
    let equipmentParamIndex = 2;
    if (startDate) {
      const start = typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0];
      equipmentWhereClause += ` AND DATE(eb.start_date) >= $${equipmentParamIndex}::date`;
      equipmentParams.push(start);
      equipmentParamIndex++;
    }
    if (endDate) {
      const end = typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0];
      equipmentWhereClause += ` AND DATE(eb.start_date) <= $${equipmentParamIndex}::date`;
      equipmentParams.push(end);
      equipmentParamIndex++;
    }
    if (locationId) {
      equipmentWhereClause += ` AND l.id = $${equipmentParamIndex}`;
      equipmentParams.push(locationId);
      equipmentParamIndex++;
    }
    const equipmentResult = await dbPool.query(`
      SELECT 
        COALESCE(SUM(COALESCE(eb.total_price, 0)::numeric), 0)::bigint as total_revenue,
        COALESCE(SUM(COALESCE(eb.service_fee, 0)::numeric), 0)::bigint as platform_fee,
        COUNT(*)::int as booking_count,
        COUNT(CASE WHEN eb.payment_status = 'paid' THEN 1 END)::int as paid_count,
        COALESCE(SUM(CASE WHEN eb.payment_status = 'paid' THEN COALESCE(eb.total_price, 0)::numeric ELSE 0 END), 0)::bigint as completed_payments,
        COALESCE(SUM(CASE WHEN eb.payment_status = 'processing' THEN COALESCE(eb.total_price, 0)::numeric ELSE 0 END), 0)::bigint as processing_payments
      FROM equipment_bookings eb
      JOIN equipment_listings el ON eb.equipment_listing_id = el.id
      JOIN kitchens k ON el.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${equipmentWhereClause}
        AND eb.status != 'cancelled'
    `, equipmentParams);
    const storageRow = storageResult.rows[0] || {};
    const equipmentRow = equipmentResult.rows[0] || {};
    const parseNumeric = (value) => {
      if (!value) return 0;
      if (typeof value === "string") return parseInt(value) || 0;
      return parseInt(String(value)) || 0;
    };
    const totalRevenue = kitchenMetrics.totalRevenue + parseNumeric(storageRow.total_revenue) + parseNumeric(equipmentRow.total_revenue);
    const platformFee = kitchenMetrics.platformFee + parseNumeric(storageRow.platform_fee) + parseNumeric(equipmentRow.platform_fee);
    const managerRevenue = totalRevenue - platformFee;
    const pendingPaymentsTotal = kitchenMetrics.pendingPayments + parseNumeric(storageRow.processing_payments) + parseNumeric(equipmentRow.processing_payments);
    const completedPaymentsTotal = kitchenMetrics.completedPayments + parseNumeric(storageRow.completed_payments) + parseNumeric(equipmentRow.completed_payments);
    const completedPlatformFee = kitchenMetrics.platformFee * (kitchenMetrics.completedPayments / (kitchenMetrics.totalRevenue || 1));
    const storageCompletedPlatformFee = parseNumeric(storageRow.platform_fee) * (parseNumeric(storageRow.completed_payments) / (parseNumeric(storageRow.total_revenue) || 1));
    const equipmentCompletedPlatformFee = parseNumeric(equipmentRow.platform_fee) * (parseNumeric(equipmentRow.completed_payments) / (parseNumeric(equipmentRow.total_revenue) || 1));
    const depositedManagerRevenue = completedPaymentsTotal - (completedPlatformFee + storageCompletedPlatformFee + equipmentCompletedPlatformFee);
    const totalBookingCount = kitchenMetrics.bookingCount + parseNumeric(storageRow.booking_count) + parseNumeric(equipmentRow.booking_count);
    const totalPaidCount = kitchenMetrics.paidBookingCount + parseNumeric(storageRow.paid_count) + parseNumeric(equipmentRow.paid_count);
    const finalMetrics = {
      totalRevenue: isNaN(totalRevenue) ? 0 : totalRevenue,
      platformFee: isNaN(platformFee) ? 0 : platformFee,
      managerRevenue: isNaN(managerRevenue) ? 0 : managerRevenue || 0,
      depositedManagerRevenue: isNaN(depositedManagerRevenue) ? 0 : depositedManagerRevenue,
      pendingPayments: isNaN(pendingPaymentsTotal) ? 0 : pendingPaymentsTotal,
      completedPayments: isNaN(completedPaymentsTotal) ? 0 : completedPaymentsTotal,
      averageBookingValue: totalRevenue > 0 && totalBookingCount > 0 ? isNaN(Math.round(totalRevenue / totalBookingCount)) ? 0 : Math.round(totalRevenue / totalBookingCount) : 0,
      bookingCount: isNaN(totalBookingCount) ? 0 : totalBookingCount,
      paidBookingCount: isNaN(totalPaidCount) ? 0 : totalPaidCount,
      cancelledBookingCount: isNaN(kitchenMetrics.cancelledBookingCount) ? 0 : kitchenMetrics.cancelledBookingCount,
      refundedAmount: isNaN(kitchenMetrics.refundedAmount) ? 0 : kitchenMetrics.refundedAmount
    };
    console.log("[Revenue Service] Final complete metrics:", finalMetrics);
    return finalMetrics;
  } catch (error) {
    console.error("Error getting complete revenue metrics:", error);
    throw error;
  }
}
var init_revenue_service = __esm({
  "server/services/revenue-service.ts"() {
    "use strict";
  }
});

// server/services/invoice-service.ts
var invoice_service_exports = {};
__export(invoice_service_exports, {
  generateInvoicePDF: () => generateInvoicePDF
});
import PDFDocument from "pdfkit";
async function generateInvoicePDF(booking, chef, kitchen, location, storageBookings2, equipmentBookings2, paymentIntentId, dbPool) {
  let stripePlatformFee = 0;
  let stripeTotalAmount = 0;
  let stripeBaseAmount = 0;
  let stripeStorageBaseAmounts = /* @__PURE__ */ new Map();
  let stripeEquipmentBaseAmounts = /* @__PURE__ */ new Map();
  if (dbPool && paymentIntentId) {
    try {
      const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
      const paymentTransaction = await findPaymentTransactionByIntentId2(paymentIntentId, dbPool);
      if (paymentTransaction) {
        stripeTotalAmount = parseInt(paymentTransaction.amount) || 0;
        stripePlatformFee = parseInt(paymentTransaction.service_fee) || 0;
        stripeBaseAmount = parseInt(paymentTransaction.base_amount) || 0;
        console.log(`[Invoice] Using Stripe-synced amounts: total=${stripeTotalAmount}, base=${stripeBaseAmount}, platformFee=${stripePlatformFee}`);
      }
    } catch (error) {
      console.warn("[Invoice] Could not fetch payment transaction, will calculate fees:", error);
    }
  }
  let totalAmount = 0;
  const items = [];
  const kitchenId = booking.kitchenId || booking.kitchen_id;
  const startTime = booking.startTime || booking.start_time;
  const endTime = booking.endTime || booking.end_time;
  if (kitchenId) {
    try {
      let kitchenAmount = 0;
      let durationHours = 0;
      let hourlyRate = 0;
      if ((booking.hourly_rate || booking.hourlyRate) && (booking.duration_hours || booking.durationHours)) {
        const hourlyRateCents = parseFloat(String(booking.hourly_rate || booking.hourlyRate));
        durationHours = parseFloat(String(booking.duration_hours || booking.durationHours));
        hourlyRate = hourlyRateCents / 100;
        kitchenAmount = hourlyRateCents * durationHours / 100;
      } else if (stripeBaseAmount > 0) {
        kitchenAmount = stripeBaseAmount / 100;
        if (booking.duration_hours || booking.durationHours) {
          durationHours = parseFloat(String(booking.duration_hours || booking.durationHours));
        }
        if (booking.hourly_rate || booking.hourlyRate) {
          hourlyRate = parseFloat(String(booking.hourly_rate || booking.hourlyRate)) / 100;
        } else if (durationHours > 0) {
          hourlyRate = kitchenAmount / durationHours;
        }
      } else if (booking.total_price || booking.totalPrice) {
        const totalPriceCents = booking.total_price ? parseFloat(String(booking.total_price)) : parseFloat(String(booking.totalPrice));
        const hasPaymentTransaction = stripeBaseAmount > 0 || stripeTotalAmount > 0;
        const serviceFeeCents = hasPaymentTransaction || booking.service_fee !== void 0 && booking.service_fee !== null || booking.serviceFee !== void 0 && booking.serviceFee !== null ? parseFloat(String(booking.service_fee || booking.serviceFee || "0")) : 0;
        const basePriceCents = hasPaymentTransaction || serviceFeeCents > 0 ? totalPriceCents - serviceFeeCents : totalPriceCents;
        kitchenAmount = basePriceCents / 100;
        if (booking.duration_hours || booking.durationHours) {
          durationHours = parseFloat(String(booking.duration_hours || booking.durationHours));
        }
        if (booking.hourly_rate || booking.hourlyRate) {
          hourlyRate = parseFloat(String(booking.hourly_rate || booking.hourlyRate)) / 100;
        }
      } else if (dbPool && startTime && endTime) {
        const { calculateKitchenBookingPrice: calculateKitchenBookingPrice2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
        const kitchenPricing = await calculateKitchenBookingPrice2(
          kitchenId,
          startTime,
          endTime,
          dbPool
        );
        if (kitchenPricing.totalPriceCents > 0) {
          durationHours = kitchenPricing.durationHours;
          hourlyRate = kitchenPricing.hourlyRateCents / 100;
          kitchenAmount = kitchenPricing.totalPriceCents / 100;
        }
      }
      if (kitchenAmount > 0) {
        if (!durationHours && startTime && endTime) {
          const start = startTime.split(":").map(Number);
          const end = endTime.split(":").map(Number);
          const startMinutes = start[0] * 60 + start[1];
          const endMinutes = end[0] * 60 + end[1];
          durationHours = Math.max(1, (endMinutes - startMinutes) / 60);
        }
        if (!hourlyRate && durationHours > 0) {
          hourlyRate = kitchenAmount / durationHours;
        }
        totalAmount += kitchenAmount;
        items.push({
          description: `Kitchen Booking (${durationHours.toFixed(1)} hour${durationHours !== 1 ? "s" : ""})`,
          quantity: durationHours,
          rate: hourlyRate,
          amount: kitchenAmount
        });
      }
    } catch (error) {
      console.error("Error calculating kitchen price:", error);
    }
  }
  if (storageBookings2 && storageBookings2.length > 0) {
    for (const storageBooking of storageBookings2) {
      try {
        let storageAmount = 0;
        let basePrice = 0;
        let days = 0;
        const startDate = new Date(storageBooking.startDate || storageBooking.start_date);
        const endDate = new Date(storageBooking.endDate || storageBooking.end_date);
        days = Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24));
        if (dbPool) {
          const storageListingId = storageBooking.storageListingId || storageBooking.storage_listing_id;
          if (storageListingId) {
            const result = await dbPool.query(
              "SELECT base_price, pricing_model, minimum_booking_duration FROM storage_listings WHERE id = $1",
              [storageListingId]
            );
            if (result.rows.length > 0) {
              const listing = result.rows[0];
              const listingBasePriceCents = parseFloat(String(listing.base_price)) || 0;
              const pricingModel = listing.pricing_model || "daily";
              const minDays = listing.minimum_booking_duration || 1;
              const effectiveDays = Math.max(days, minDays);
              if (pricingModel === "hourly") {
                const hours = Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60));
                const minHours = minDays * 24;
                const effectiveHours = Math.max(hours, minHours);
                basePrice = listingBasePriceCents / 100;
                storageAmount = listingBasePriceCents * effectiveHours / 100;
              } else if (pricingModel === "monthly-flat") {
                basePrice = listingBasePriceCents / 100;
                storageAmount = basePrice;
              } else {
                basePrice = listingBasePriceCents / 100;
                storageAmount = listingBasePriceCents * effectiveDays / 100;
              }
            }
          }
        }
        if (storageAmount === 0 && (storageBooking.total_price || storageBooking.totalPrice)) {
          const totalPriceCents = parseFloat(String(storageBooking.total_price || storageBooking.totalPrice));
          const serviceFeeCents = parseFloat(String(storageBooking.service_fee || storageBooking.serviceFee || "0"));
          const basePriceCents = totalPriceCents - serviceFeeCents;
          storageAmount = basePriceCents / 100;
          basePrice = days > 0 ? storageAmount / days : 0;
        }
        if (storageAmount > 0) {
          totalAmount += storageAmount;
          items.push({
            description: `Storage Booking (${days} day${days !== 1 ? "s" : ""})`,
            quantity: days,
            rate: basePrice,
            amount: storageAmount
          });
        }
      } catch (error) {
        console.error("Error calculating storage price:", error);
      }
    }
  }
  if (equipmentBookings2 && equipmentBookings2.length > 0) {
    for (const equipmentBooking of equipmentBookings2) {
      try {
        let sessionRate = 0;
        if (dbPool) {
          const equipmentListingId = equipmentBooking.equipmentListingId || equipmentBooking.equipment_listing_id;
          if (equipmentListingId) {
            const result = await dbPool.query(
              "SELECT session_rate FROM equipment_listings WHERE id = $1",
              [equipmentListingId]
            );
            if (result.rows.length > 0) {
              const listingSessionRateCents = parseFloat(String(result.rows[0].session_rate)) || 0;
              sessionRate = listingSessionRateCents / 100;
            }
          }
        }
        if (sessionRate === 0 && (equipmentBooking.total_price || equipmentBooking.totalPrice)) {
          const totalPriceCents = parseFloat(String(equipmentBooking.total_price || equipmentBooking.totalPrice));
          const serviceFeeCents = parseFloat(String(equipmentBooking.service_fee || equipmentBooking.serviceFee || "0"));
          const basePriceCents = totalPriceCents - serviceFeeCents;
          sessionRate = basePriceCents / 100;
        }
        if (sessionRate > 0) {
          totalAmount += sessionRate;
          items.push({
            description: "Equipment Rental",
            quantity: 1,
            rate: sessionRate,
            amount: sessionRate
          });
        }
      } catch (error) {
        console.error("Error calculating equipment price:", error);
      }
    }
  }
  let platformFee = 0;
  if (stripePlatformFee > 0) {
    platformFee = stripePlatformFee / 100;
    console.log(`[Invoice] Using Stripe platform fee: $${platformFee.toFixed(2)}`);
  } else if (booking.service_fee || booking.serviceFee) {
    const storedServiceFeeCents = parseFloat(String(booking.service_fee || booking.serviceFee));
    platformFee = storedServiceFeeCents / 100;
    console.log(`[Invoice] Using stored service_fee from booking: $${platformFee.toFixed(2)}`);
  } else {
    let serviceFeeRate = 0.05;
    if (dbPool) {
      try {
        const { getServiceFeeRate: getServiceFeeRate2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
        serviceFeeRate = await getServiceFeeRate2(dbPool);
      } catch (error) {
        console.warn("[Invoice] Could not get service fee rate, using default 5%:", error);
      }
    }
    if (totalAmount > 0) {
      platformFee = totalAmount * serviceFeeRate;
      console.log(`[Invoice] Calculated platform fee (fallback): $${platformFee.toFixed(2)}`);
    }
  }
  const stripeProcessingFee = 0.3;
  const serviceFee = platformFee + stripeProcessingFee;
  const grandTotal = stripeTotalAmount > 0 ? stripeTotalAmount / 100 : totalAmount + serviceFee;
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        margin: 50,
        size: "LETTER"
      });
      const buffers = [];
      doc.on("data", buffers.push.bind(buffers));
      doc.on("end", () => {
        const pdfBuffer = Buffer.concat(buffers);
        resolve(pdfBuffer);
      });
      doc.on("error", reject);
      doc.fontSize(28).font("Helvetica-Bold").text("INVOICE", 50, 50);
      doc.fontSize(10).font("Helvetica");
      const invoiceDate = (/* @__PURE__ */ new Date()).toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric"
      });
      const invoiceNumber = `LC-${booking.id}-${(/* @__PURE__ */ new Date()).getFullYear()}`;
      const pageWidth = doc.page.width;
      const rightMargin = pageWidth - 50;
      const labelWidth = 80;
      const valueStartX = rightMargin - 200;
      let rightY = 50;
      doc.fontSize(10).font("Helvetica-Bold");
      doc.text("Invoice #:", valueStartX, rightY, { width: labelWidth, align: "right" });
      doc.font("Helvetica");
      doc.text(invoiceNumber, valueStartX + labelWidth + 5, rightY);
      rightY += 15;
      doc.font("Helvetica-Bold");
      doc.text("Date:", valueStartX, rightY, { width: labelWidth, align: "right" });
      doc.font("Helvetica");
      doc.text(invoiceDate, valueStartX + labelWidth + 5, rightY);
      rightY += 15;
      if (paymentIntentId) {
        doc.font("Helvetica-Bold");
        doc.text("Payment ID:", valueStartX, rightY, { width: labelWidth, align: "right" });
        doc.font("Helvetica");
        const paymentIdDisplay = paymentIntentId.length > 20 ? paymentIntentId.substring(0, 20) + "..." : paymentIntentId;
        doc.text(paymentIdDisplay, valueStartX + labelWidth + 5, rightY);
      }
      let leftY = 120;
      doc.fontSize(14).font("Helvetica-Bold").text("Local Cooks Community", 50, leftY);
      leftY += 18;
      doc.fontSize(10).font("Helvetica").text("support@localcooks.ca", 50, leftY);
      leftY += 30;
      doc.fontSize(12).font("Helvetica-Bold").text("Bill To:", 50, leftY);
      leftY += 18;
      doc.fontSize(10).font("Helvetica");
      if (chef) {
        doc.text(chef.username || chef.email || "Chef", 50, leftY);
        leftY += 15;
        if (chef.email) {
          doc.text(chef.email, 50, leftY);
          leftY += 15;
        }
      }
      leftY += 20;
      doc.fontSize(12).font("Helvetica-Bold").text("Booking Details:", 50, leftY);
      leftY += 18;
      doc.fontSize(10).font("Helvetica");
      const bookingDateStr = booking.bookingDate ? new Date(booking.bookingDate).toLocaleDateString("en-US", {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      }) : "N/A";
      doc.text(`Kitchen: ${kitchen?.name || "Kitchen"}`, 50, leftY);
      leftY += 15;
      if (location?.name) {
        doc.text(`Location: ${location.name}`, 50, leftY);
        leftY += 15;
      }
      doc.text(`Date: ${bookingDateStr}`, 50, leftY);
      leftY += 15;
      doc.text(`Time: ${booking.startTime || booking.start_time || "N/A"} - ${booking.endTime || booking.end_time || "N/A"}`, 50, leftY);
      leftY += 30;
      const tableTop = leftY;
      doc.rect(50, tableTop, 500, 25).fill("#f3f4f6");
      doc.fontSize(10).font("Helvetica-Bold");
      doc.fillColor("#000000");
      doc.text("Description", 60, tableTop + 8, { width: 250 });
      doc.text("Qty", 320, tableTop + 8, { width: 50 });
      doc.text("Rate", 380, tableTop + 8, { width: 110, align: "right" });
      doc.text("Amount", 500, tableTop + 8, { width: 50, align: "right" });
      doc.moveTo(50, tableTop + 25).lineTo(550, tableTop + 25).stroke();
      let currentY = tableTop + 35;
      items.forEach((item, index) => {
        if (index % 2 === 0) {
          doc.rect(50, currentY - 5, 500, 20).fill("#fafafa");
        }
        doc.fontSize(10).font("Helvetica").fillColor("#000000");
        doc.text(item.description, 60, currentY, { width: 250 });
        doc.text(item.quantity.toString(), 320, currentY);
        doc.text(`$${item.rate.toFixed(2)}`, 380, currentY, { align: "right", width: 110 });
        doc.text(`$${item.amount.toFixed(2)}`, 500, currentY, { align: "right", width: 50 });
        currentY += 20;
      });
      currentY += 10;
      doc.moveTo(50, currentY).lineTo(550, currentY).stroke();
      currentY += 15;
      doc.fontSize(10).font("Helvetica");
      doc.text("Subtotal:", 380, currentY, { width: 110, align: "right" });
      doc.text(`$${totalAmount.toFixed(2)}`, 500, currentY, { align: "right", width: 50 });
      currentY += 20;
      doc.text("Platform Fee:", 380, currentY, { width: 110, align: "right" });
      doc.text(`$${serviceFee.toFixed(2)}`, 500, currentY, { align: "right", width: 50 });
      currentY += 20;
      doc.moveTo(50, currentY - 5).lineTo(550, currentY - 5).stroke();
      currentY += 10;
      doc.fontSize(12).font("Helvetica-Bold");
      doc.text("Total:", 380, currentY, { align: "right", width: 110 });
      doc.text(`$${grandTotal.toFixed(2)}`, 500, currentY, { align: "right", width: 50 });
      doc.font("Helvetica").fontSize(10);
      currentY += 40;
      doc.rect(50, currentY, 500, 60).stroke("#e5e7eb");
      doc.rect(50, currentY, 500, 60).fill("#f9fafb");
      currentY += 15;
      doc.fontSize(10).font("Helvetica-Bold").text("Payment Information", 60, currentY);
      currentY += 18;
      doc.font("Helvetica");
      doc.text("Payment Method: Credit/Debit Card", 60, currentY);
      currentY += 15;
      doc.text("Payment Status: Paid", 60, currentY);
      currentY += 15;
      doc.fontSize(9).fillColor("#6b7280").text("Note: Payment has been processed successfully.", 60, currentY);
      doc.fillColor("#000000");
      const pageHeight = doc.page.height;
      const footerY = pageHeight - 80;
      doc.moveTo(50, footerY).lineTo(550, footerY).stroke("#e5e7eb");
      doc.fontSize(9).fillColor("#6b7280").text("Thank you for your business!", 50, footerY + 15, { align: "center", width: 500 });
      doc.text("For questions, contact support@localcooks.ca", 50, footerY + 30, { align: "center", width: 500 });
      doc.fillColor("#000000");
      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}
var init_invoice_service = __esm({
  "server/services/invoice-service.ts"() {
    "use strict";
  }
});

// server/services/payout-statement-service.ts
var payout_statement_service_exports = {};
__export(payout_statement_service_exports, {
  generatePayoutStatementPDF: () => generatePayoutStatementPDF
});
import PDFDocument2 from "pdfkit";
async function generatePayoutStatementPDF(managerId, managerName, managerEmail, payout, balanceTransactions, bookings, dbPool) {
  let totalEarnings = 0;
  let totalPlatformFees = 0;
  let totalBookings = bookings.length;
  let serviceFeeRate = 0.05;
  if (dbPool) {
    try {
      const { getServiceFeeRate: getServiceFeeRate2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
      serviceFeeRate = await getServiceFeeRate2(dbPool);
    } catch (error) {
      console.error("Error getting service fee rate for payout statement:", error);
    }
  }
  bookings.forEach((booking) => {
    const totalPrice = (booking.total_price || 0) / 100;
    const serviceFee = (booking.service_fee || 0) / 100;
    const managerRevenue = totalPrice * (1 - serviceFeeRate);
    totalEarnings += managerRevenue;
    totalPlatformFees += serviceFee;
  });
  const payoutAmount = payout.amount / 100;
  const payoutDate = new Date(payout.created * 1e3);
  const payoutStatus = payout.status;
  const periodStart = bookings.length > 0 ? new Date(Math.min(...bookings.map((b) => new Date(b.booking_date || b.created_at).getTime()))) : payoutDate;
  const periodEnd = payoutDate;
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument2({
        margin: 50,
        size: "LETTER"
      });
      const buffers = [];
      doc.on("data", buffers.push.bind(buffers));
      doc.on("end", () => {
        const pdfBuffer = Buffer.concat(buffers);
        resolve(pdfBuffer);
      });
      doc.on("error", reject);
      doc.fontSize(28).font("Helvetica-Bold").text("PAYOUT STATEMENT", 50, 50);
      doc.fontSize(10).font("Helvetica");
      const statementDate = (/* @__PURE__ */ new Date()).toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric"
      });
      const statementNumber = `PS-${payout.id.substring(3)}-${payoutDate.getFullYear()}`;
      const pageWidth = doc.page.width;
      const rightMargin = pageWidth - 50;
      const labelWidth = 100;
      const valueStartX = rightMargin - 200;
      let rightY = 50;
      doc.fontSize(10).font("Helvetica-Bold");
      doc.text("Statement #:", valueStartX, rightY, { width: labelWidth, align: "right" });
      doc.font("Helvetica");
      doc.text(statementNumber, valueStartX + labelWidth + 5, rightY);
      rightY += 15;
      doc.font("Helvetica-Bold");
      doc.text("Date:", valueStartX, rightY, { width: labelWidth, align: "right" });
      doc.font("Helvetica");
      doc.text(statementDate, valueStartX + labelWidth + 5, rightY);
      rightY += 15;
      doc.font("Helvetica-Bold");
      doc.text("Payout ID:", valueStartX, rightY, { width: labelWidth, align: "right" });
      doc.font("Helvetica");
      const payoutIdDisplay = payout.id.length > 20 ? payout.id.substring(0, 20) + "..." : payout.id;
      doc.text(payoutIdDisplay, valueStartX + labelWidth + 5, rightY);
      rightY += 15;
      doc.font("Helvetica-Bold");
      doc.text("Status:", valueStartX, rightY, { width: labelWidth, align: "right" });
      doc.font("Helvetica");
      doc.text(payoutStatus.charAt(0).toUpperCase() + payoutStatus.slice(1), valueStartX + labelWidth + 5, rightY);
      rightY += 15;
      doc.font("Helvetica-Bold");
      doc.text("Payout Date:", valueStartX, rightY, { width: labelWidth, align: "right" });
      doc.font("Helvetica");
      doc.text(payoutDate.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric"
      }), valueStartX + labelWidth + 5, rightY);
      let leftY = 120;
      doc.fontSize(14).font("Helvetica-Bold").text("Local Cooks Community", 50, leftY);
      leftY += 18;
      doc.fontSize(10).font("Helvetica").text("support@localcooks.ca", 50, leftY);
      leftY += 30;
      doc.fontSize(12).font("Helvetica-Bold").text("Pay To:", 50, leftY);
      leftY += 18;
      doc.fontSize(10).font("Helvetica");
      doc.text(managerName || "Manager", 50, leftY);
      leftY += 15;
      if (managerEmail) {
        doc.text(managerEmail, 50, leftY);
        leftY += 15;
      }
      leftY += 20;
      doc.fontSize(12).font("Helvetica-Bold").text("Period:", 50, leftY);
      leftY += 18;
      doc.fontSize(10).font("Helvetica");
      doc.text(
        `${periodStart.toLocaleDateString("en-US", { month: "long", day: "numeric", year: "numeric" })} - ${periodEnd.toLocaleDateString("en-US", { month: "long", day: "numeric", year: "numeric" })}`,
        50,
        leftY
      );
      leftY += 40;
      doc.fontSize(14).font("Helvetica-Bold").text("Summary", 50, leftY);
      leftY += 25;
      const summaryItems = [
        { label: "Total Bookings", value: totalBookings.toString() },
        { label: "Total Revenue", value: `$${totalEarnings.toFixed(2)}` },
        { label: "Platform Fees", value: `-$${totalPlatformFees.toFixed(2)}` },
        { label: "Net Earnings", value: `$${totalEarnings.toFixed(2)}` },
        { label: "Payout Amount", value: `$${payoutAmount.toFixed(2)}` }
      ];
      summaryItems.forEach((item) => {
        doc.fontSize(10).font("Helvetica");
        doc.text(item.label + ":", 50, leftY, { width: 200 });
        doc.font("Helvetica-Bold");
        doc.text(item.value, 250, leftY);
        leftY += 20;
      });
      if (bookings.length > 0) {
        leftY += 20;
        doc.fontSize(14).font("Helvetica-Bold").text("Booking Details", 50, leftY);
        leftY += 25;
        doc.fontSize(9).font("Helvetica-Bold");
        doc.text("Date", 50, leftY);
        doc.text("Kitchen", 120, leftY);
        doc.text("Chef", 250, leftY);
        doc.text("Amount", 350, leftY, { width: 100, align: "right" });
        leftY += 15;
        doc.moveTo(50, leftY).lineTo(550, leftY).stroke();
        leftY += 10;
        doc.fontSize(8).font("Helvetica");
        bookings.slice(0, 30).forEach((booking) => {
          if (leftY > 700) {
            doc.addPage();
            leftY = 50;
          }
          const bookingDate = new Date(booking.booking_date || booking.created_at);
          const dateStr = bookingDate.toLocaleDateString("en-US", { month: "short", day: "numeric" });
          const kitchenName = (booking.kitchen_name || "Kitchen").substring(0, 20);
          const chefName = (booking.chef_name || "Guest").substring(0, 20);
          const amount = (booking.total_price || 0) / 100 * (1 - serviceFeeRate);
          doc.text(dateStr, 50, leftY);
          doc.text(kitchenName, 120, leftY, { width: 120 });
          doc.text(chefName, 250, leftY, { width: 90 });
          doc.text(`$${amount.toFixed(2)}`, 350, leftY, { width: 100, align: "right" });
          leftY += 15;
        });
        if (bookings.length > 30) {
          leftY += 5;
          doc.fontSize(8).font("Helvetica").text(`... and ${bookings.length - 30} more bookings`, 50, leftY);
        }
      }
      const footerY = doc.page.height - 100;
      doc.fontSize(8).font("Helvetica");
      doc.text(
        "This is an automated payout statement from Local Cooks Community.",
        50,
        footerY,
        { align: "center", width: doc.page.width - 100 }
      );
      doc.text(
        "For questions, contact support@localcooks.ca",
        50,
        footerY + 15,
        { align: "center", width: doc.page.width - 100 }
      );
      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}
var init_payout_statement_service = __esm({
  "server/services/payout-statement-service.ts"() {
    "use strict";
  }
});

// server/services/stripe-checkout-fee-service.ts
var stripe_checkout_fee_service_exports = {};
__export(stripe_checkout_fee_service_exports, {
  calculateCheckoutFees: () => calculateCheckoutFees
});
function calculateCheckoutFees(bookingPrice) {
  if (bookingPrice <= 0) {
    throw new Error("Booking price must be greater than 0");
  }
  const bookingPriceInCents = Math.round(bookingPrice * 100);
  const percentageFeeInCents = Math.round(bookingPrice * 0.029 * 100);
  const flatFeeInCents = 30;
  const totalPlatformFeeInCents = percentageFeeInCents + flatFeeInCents;
  const totalChargeInCents = bookingPriceInCents + totalPlatformFeeInCents;
  return {
    bookingPriceInCents,
    percentageFeeInCents,
    flatFeeInCents,
    totalPlatformFeeInCents,
    totalChargeInCents
  };
}
var init_stripe_checkout_fee_service = __esm({
  "server/services/stripe-checkout-fee-service.ts"() {
    "use strict";
  }
});

// server/services/stripe-checkout-service.ts
var stripe_checkout_service_exports = {};
__export(stripe_checkout_service_exports, {
  createCheckoutSession: () => createCheckoutSession
});
import Stripe3 from "stripe";
async function createCheckoutSession(params) {
  if (!stripe3) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  const {
    bookingPriceInCents,
    platformFeeInCents,
    managerStripeAccountId,
    customerEmail,
    bookingId,
    currency = "cad",
    successUrl,
    cancelUrl,
    metadata = {}
  } = params;
  if (bookingPriceInCents <= 0) {
    throw new Error("Booking price must be greater than 0");
  }
  if (platformFeeInCents <= 0) {
    throw new Error("Platform fee must be greater than 0");
  }
  if (platformFeeInCents >= bookingPriceInCents + platformFeeInCents) {
    throw new Error("Platform fee must be less than total charge amount");
  }
  if (!managerStripeAccountId) {
    throw new Error("Manager Stripe account ID is required");
  }
  if (!customerEmail) {
    throw new Error("Customer email is required");
  }
  const totalAmountInCents = bookingPriceInCents + platformFeeInCents;
  try {
    const session2 = await stripe3.checkout.sessions.create({
      mode: "payment",
      customer_email: customerEmail,
      line_items: [
        {
          price_data: {
            currency: currency.toLowerCase(),
            product_data: {
              name: "Kitchen Session Booking"
            },
            unit_amount: bookingPriceInCents
          },
          quantity: 1
        },
        {
          price_data: {
            currency: currency.toLowerCase(),
            product_data: {
              name: "Platform Service Fee"
            },
            unit_amount: platformFeeInCents
          },
          quantity: 1
        }
      ],
      payment_intent_data: {
        application_fee_amount: platformFeeInCents,
        transfer_data: {
          destination: managerStripeAccountId
        },
        metadata: {
          booking_id: bookingId.toString(),
          ...metadata
        }
      },
      success_url: successUrl,
      cancel_url: cancelUrl,
      metadata: {
        booking_id: bookingId.toString(),
        booking_price_cents: bookingPriceInCents.toString(),
        platform_fee_cents: platformFeeInCents.toString(),
        total_cents: totalAmountInCents.toString(),
        manager_account_id: managerStripeAccountId,
        ...metadata
      }
    });
    if (!session2.url) {
      throw new Error("Failed to create checkout session URL");
    }
    return {
      sessionId: session2.id,
      sessionUrl: session2.url
    };
  } catch (error) {
    console.error("Error creating Stripe Checkout session:", error);
    throw new Error(`Failed to create checkout session: ${error.message}`);
  }
}
var stripeSecretKey3, stripe3;
var init_stripe_checkout_service = __esm({
  "server/services/stripe-checkout-service.ts"() {
    "use strict";
    stripeSecretKey3 = process.env.STRIPE_SECRET_KEY;
    if (!stripeSecretKey3) {
      console.warn("\u26A0\uFE0F STRIPE_SECRET_KEY not found in environment variables");
    }
    stripe3 = stripeSecretKey3 ? new Stripe3(stripeSecretKey3, {
      apiVersion: "2025-12-15.clover"
    }) : null;
  }
});

// server/services/payout-processing-service.ts
var payout_processing_service_exports = {};
__export(payout_processing_service_exports, {
  getPayoutSummary: () => getPayoutSummary,
  processManagerPayout: () => processManagerPayout,
  processWeeklyPayouts: () => processWeeklyPayouts
});
import Stripe4 from "stripe";
async function processManagerPayout(managerId, dbPool, dryRun = false) {
  if (!stripe4) {
    return {
      managerId,
      accountId: "",
      success: false,
      error: "Stripe is not configured"
    };
  }
  try {
    const userResult = await dbPool.query(
      "SELECT id, email, stripe_connect_account_id, stripe_connect_onboarding_status FROM users WHERE id = $1 AND role = $2",
      [managerId, "manager"]
    );
    if (userResult.rows.length === 0) {
      return {
        managerId,
        accountId: "",
        success: false,
        error: "Manager not found"
      };
    }
    const manager = userResult.rows[0];
    const accountId = manager.stripe_connect_account_id;
    if (!accountId) {
      return {
        managerId,
        accountId: "",
        success: false,
        error: "No Stripe Connect account linked"
      };
    }
    if (manager.stripe_connect_onboarding_status !== "complete") {
      return {
        managerId,
        accountId,
        success: false,
        error: "Stripe Connect account not fully onboarded"
      };
    }
    const { getAccountBalance: getAccountBalance2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
    const balance = await getAccountBalance2(accountId);
    const availableBalance = balance.available[0]?.amount || 0;
    if (availableBalance <= 0) {
      return {
        managerId,
        accountId,
        success: true,
        amount: 0,
        error: "No funds available for payout"
      };
    }
    const minimumPayoutAmount = 100;
    if (availableBalance < minimumPayoutAmount) {
      return {
        managerId,
        accountId,
        success: true,
        amount: availableBalance / 100,
        error: `Balance below minimum payout amount ($${minimumPayoutAmount / 100})`
      };
    }
    if (dryRun) {
      return {
        managerId,
        accountId,
        success: true,
        amount: availableBalance / 100
      };
    }
    const pendingBalance = balance.pending[0]?.amount || 0;
    console.log(`Manager ${managerId} has $${availableBalance / 100} available for payout`);
    return {
      managerId,
      accountId,
      success: true,
      amount: availableBalance / 100
    };
  } catch (error) {
    console.error(`Error processing payout for manager ${managerId}:`, error);
    return {
      managerId,
      accountId: "",
      success: false,
      error: error.message || "Failed to process payout"
    };
  }
}
async function processWeeklyPayouts(dbPool, dryRun = false) {
  try {
    const managersResult = await dbPool.query(`
      SELECT id, email, stripe_connect_account_id
      FROM users
      WHERE role = 'manager'
        AND stripe_connect_account_id IS NOT NULL
        AND stripe_connect_onboarding_status = 'complete'
    `);
    const results = [];
    for (const manager of managersResult.rows) {
      const result = await processManagerPayout(
        manager.id,
        dbPool,
        dryRun
      );
      results.push(result);
    }
    return results;
  } catch (error) {
    console.error("Error processing weekly payouts:", error);
    throw error;
  }
}
async function getPayoutSummary(dbPool) {
  if (!stripe4) {
    return {
      totalManagers: 0,
      eligibleManagers: 0,
      totalAvailableBalance: 0,
      managersWithBalance: 0
    };
  }
  try {
    const managersResult = await dbPool.query(`
      SELECT id, stripe_connect_account_id
      FROM users
      WHERE role = 'manager'
        AND stripe_connect_account_id IS NOT NULL
        AND stripe_connect_onboarding_status = 'complete'
    `);
    let totalAvailableBalance = 0;
    let managersWithBalance = 0;
    const { getAccountBalance: getAccountBalance2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
    for (const manager of managersResult.rows) {
      try {
        const balance = await getAccountBalance2(manager.stripe_connect_account_id);
        const available = balance.available[0]?.amount || 0;
        totalAvailableBalance += available;
        if (available > 0) {
          managersWithBalance++;
        }
      } catch (error) {
        console.error(`Error getting balance for manager ${manager.id}:`, error);
      }
    }
    const allManagersResult = await dbPool.query(`
      SELECT COUNT(*) as count
      FROM users
      WHERE role = 'manager'
    `);
    return {
      totalManagers: parseInt(allManagersResult.rows[0]?.count || "0"),
      eligibleManagers: managersResult.rows.length,
      totalAvailableBalance: totalAvailableBalance / 100,
      // Convert to dollars
      managersWithBalance
    };
  } catch (error) {
    console.error("Error getting payout summary:", error);
    throw error;
  }
}
var stripeSecretKey4, stripe4;
var init_payout_processing_service = __esm({
  "server/services/payout-processing-service.ts"() {
    "use strict";
    stripeSecretKey4 = process.env.STRIPE_SECRET_KEY;
    stripe4 = stripeSecretKey4 ? new Stripe4(stripeSecretKey4, {
      apiVersion: "2025-12-15.clover"
    }) : null;
  }
});

// server/index.ts
init_firebase_admin();
import "dotenv/config";
import express2 from "express";

// server/firebase-routes.ts
init_schema();
init_schema();
init_schema();
init_db();
init_db();
import { eq as eq3, and as and3 } from "drizzle-orm";
import { fromZodError } from "zod-validation-error";

// server/fileUpload.ts
init_r2_storage();
import multer from "multer";
import path from "path";
import fs from "fs";
var isProduction = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
var uploadsDir = path.join(process.cwd(), "uploads", "documents");
if (!isProduction && !fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}
var storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, uploadsDir);
  },
  filename: (req, file, cb) => {
    const userId = req.user?.id || "unknown";
    const timestamp2 = Date.now();
    const documentType = file.fieldname;
    const ext = path.extname(file.originalname);
    const baseName = path.basename(file.originalname, ext);
    const filename = `${userId}_${documentType}_${timestamp2}_${baseName}${ext}`;
    cb(null, filename);
  }
});
var memoryStorage = multer.memoryStorage();
var fileFilter = (req, file, cb) => {
  const allowedMimes = [
    "application/pdf",
    "image/jpeg",
    "image/jpg",
    "image/png",
    "image/webp"
  ];
  if (allowedMimes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error("Invalid file type. Only PDF, JPG, JPEG, PNG, and WebP files are allowed."));
  }
};
var upload = multer({
  storage: isProduction ? memoryStorage : storage,
  limits: {
    fileSize: 10 * 1024 * 1024
    // 10MB limit
  },
  fileFilter
});
var uploadToBlob = async (file, userId, folder = "documents") => {
  try {
    if (isProduction && isR2Configured()) {
      return await uploadToR2(file, userId, folder);
    } else {
      const filename = file.filename || `${userId}_${Date.now()}_${file.originalname}`;
      return getFileUrl(filename);
    }
  } catch (error) {
    console.error("Error uploading file:", error);
    throw new Error("Failed to upload file to cloud storage");
  }
};
var deleteFile = (filePath) => {
  try {
    const fullPath = path.join(process.cwd(), filePath);
    if (fs.existsSync(fullPath)) {
      fs.unlinkSync(fullPath);
    }
  } catch (error) {
    console.error("Error deleting file:", error);
  }
};
var getFileUrl = (filename) => {
  return `/api/files/documents/${filename}`;
};
var cleanupApplicationDocuments = async (application) => {
  try {
    const { deleteFromR2: deleteFromR22 } = await Promise.resolve().then(() => (init_r2_storage(), r2_storage_exports));
    if (isProduction && isR2Configured()) {
      if (application.foodSafetyLicenseUrl) {
        await deleteFromR22(application.foodSafetyLicenseUrl);
        console.log(`Deleted food safety license file from R2: ${application.foodSafetyLicenseUrl}`);
      }
      if (application.foodEstablishmentCertUrl) {
        await deleteFromR22(application.foodEstablishmentCertUrl);
        console.log(`Deleted food establishment certificate file from R2: ${application.foodEstablishmentCertUrl}`);
      }
      return;
    }
    if (application.foodSafetyLicenseUrl && application.foodSafetyLicenseUrl.startsWith("/api/files/")) {
      const filename = application.foodSafetyLicenseUrl.split("/").pop();
      if (filename) {
        const filePath = path.join(uploadsDir, filename);
        deleteFile(filePath);
        console.log(`Deleted food safety license file: ${filename}`);
      }
    }
    if (application.foodEstablishmentCertUrl && application.foodEstablishmentCertUrl.startsWith("/api/files/")) {
      const filename = application.foodEstablishmentCertUrl.split("/").pop();
      if (filename) {
        const filePath = path.join(uploadsDir, filename);
        deleteFile(filePath);
        console.log(`Deleted food establishment certificate file: ${filename}`);
      }
    }
  } catch (error) {
    console.error("Error cleaning up application documents:", error);
  }
};

// server/upload-handler.ts
init_r2_storage();
import fs2 from "fs";
async function handleFileUpload(req, res) {
  try {
    const userId = req.neonUser?.id || req.user?.id;
    if (!userId) {
      if (req.file && req.file.path) {
        try {
          fs2.unlinkSync(req.file.path);
        } catch (e) {
          console.error("Error cleaning up file:", e);
        }
      }
      res.status(401).json({ error: "Not authenticated" });
      return;
    }
    if (!req.file) {
      res.status(400).json({ error: "No file uploaded" });
      return;
    }
    const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
    let fileUrl;
    let fileName;
    const folder = req.file.fieldname === "profileImage" ? "profiles" : req.file.fieldname === "image" ? "images" : "documents";
    if (isProduction2 && isR2Configured()) {
      try {
        fileUrl = await uploadToBlob(req.file, userId, folder);
        fileName = fileUrl.split("/").pop() || req.file.originalname;
      } catch (error) {
        console.error("\u274C Error uploading to R2:", error);
        if (req.file.path) {
          try {
            fs2.unlinkSync(req.file.path);
          } catch (e) {
            console.error("Error cleaning up file:", e);
          }
        }
        res.status(500).json({
          error: "File upload failed",
          details: "Failed to upload file to cloud storage"
        });
        return;
      }
    } else {
      fileUrl = getFileUrl(req.file.filename || `${userId}_${Date.now()}_${req.file.originalname}`);
      fileName = req.file.filename || req.file.originalname;
    }
    res.status(200).json({
      success: true,
      url: fileUrl,
      fileName,
      size: req.file.size,
      type: req.file.mimetype
    });
  } catch (error) {
    console.error("File upload error:", error);
    if (req.file && req.file.path) {
      try {
        fs2.unlinkSync(req.file.path);
      } catch (e) {
        console.error("Error cleaning up file:", e);
      }
    }
    res.status(500).json({
      error: "File upload failed",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
}

// server/firebase-routes.ts
init_firebase_admin();

// server/firebase-auth-middleware.ts
init_firebase_admin();

// server/storage-firebase.ts
init_schema();
init_db();
import { eq, and, inArray, asc, desc, or } from "drizzle-orm";

// shared/timezone-utils.ts
import { TZDate } from "@date-fns/tz";
import { format, isBefore, isAfter, isWithinInterval } from "date-fns";
var DEFAULT_TIMEZONE = "America/St_Johns";
function getNowInTimezone(timezone = DEFAULT_TIMEZONE) {
  const nowTZ = new TZDate(/* @__PURE__ */ new Date(), timezone);
  return new Date(nowTZ.getTime());
}
function createBookingDateTime(dateStr, timeStr, timezone = DEFAULT_TIMEZONE) {
  const [year, month, day] = dateStr.split("-").map(Number);
  const [hours, minutes] = timeStr.split(":").map(Number);
  const tzDate = new TZDate(year, month - 1, day, hours, minutes, 0, 0, timezone);
  return new Date(tzDate.getTime());
}
function isBookingTimePast(bookingDate, bookingTime, timezone = DEFAULT_TIMEZONE) {
  const bookingDateTime = createBookingDateTime(bookingDate, bookingTime, timezone);
  const now = getNowInTimezone(timezone);
  return isBefore(bookingDateTime, now);
}
function getHoursUntilBooking(bookingDate, bookingTime, timezone = DEFAULT_TIMEZONE) {
  const bookingDateTime = createBookingDateTime(bookingDate, bookingTime, timezone);
  const now = getNowInTimezone(timezone);
  const diffMs = bookingDateTime.getTime() - now.getTime();
  return diffMs / (1e3 * 60 * 60);
}

// server/storage-firebase.ts
var FirebaseStorage = class {
  // ===== USER MANAGEMENT =====
  async getUser(id) {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || void 0;
  }
  async getUserByUsername(username) {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user || void 0;
  }
  async getUserByFirebaseUid(firebaseUid) {
    try {
      const [user] = await db.select().from(users).where(eq(users.firebaseUid, firebaseUid));
      return user || void 0;
    } catch (error) {
      console.error("Error getting user by firebase_uid:", error);
      return void 0;
    }
  }
  async updateUserFirebaseUid(userId, firebaseUid) {
    try {
      const [updated] = await db.update(users).set({ firebaseUid }).where(eq(users.id, userId)).returning();
      return updated || void 0;
    } catch (error) {
      console.error("Error updating user firebase_uid:", error);
      return void 0;
    }
  }
  async updateUser(id, updates) {
    try {
      const [updated] = await db.update(users).set(updates).where(eq(users.id, id)).returning();
      return updated || void 0;
    } catch (error) {
      console.error("Error updating user:", error);
      throw error;
    }
  }
  async deleteUser(id) {
    try {
      await db.transaction(async (tx) => {
        const managedLocations = await tx.select().from(locations).where(eq(locations.managerId, id));
        if (managedLocations.length > 0) {
          await tx.update(locations).set({ managerId: null }).where(eq(locations.managerId, id));
          console.log(`\u26A0\uFE0F Removed manager ${id} from ${managedLocations.length} location(s)`);
        }
        await tx.delete(users).where(eq(users.id, id));
      });
      console.log(`\u2705 Deleted user ${id}`);
    } catch (error) {
      console.error("Error deleting user:", error);
      throw error;
    }
  }
  async getAllManagers() {
    try {
      return await db.select().from(users).where(eq(users.role, "manager"));
    } catch (error) {
      console.error("Error getting all managers:", error);
      throw error;
    }
  }
  async createUser(insertUser) {
    if (!insertUser.username) {
      throw new Error("Username is required");
    }
    if (pool && insertUser.firebaseUid) {
      try {
        const result = await pool.query(
          "INSERT INTO users (username, password, role, firebase_uid, is_verified, has_seen_welcome, is_chef, is_manager, is_portal_user) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING *",
          [
            insertUser.username,
            insertUser.password || "",
            // Empty password for Firebase users
            insertUser.role || (() => {
              console.error(`\u274C CRITICAL ERROR: No role provided to createUser in storage-firebase.ts!`);
              console.error(`   - This should not happen - role should always be provided for Firebase users`);
              throw new Error("Role is required when creating a Firebase user. This is a programming error.");
            })(),
            insertUser.firebaseUid,
            insertUser.isVerified !== void 0 ? insertUser.isVerified : false,
            insertUser.has_seen_welcome !== void 0 ? insertUser.has_seen_welcome : false,
            insertUser.isChef !== void 0 ? insertUser.isChef : false,
            insertUser.isManager !== void 0 ? insertUser.isManager : false,
            insertUser.isPortalUser !== void 0 ? insertUser.isPortalUser : false
          ]
        );
        return result.rows[0];
      } catch (error) {
        console.error("Error creating user with firebase_uid:", error);
        throw error;
      }
    }
    const [user] = await db.insert(users).values({
      username: insertUser.username,
      password: insertUser.password || "",
      role: insertUser.role || (() => {
        console.error(`\u274C CRITICAL ERROR: No role provided to createUser (fallback) in storage-firebase.ts!`);
        throw new Error("Role is required when creating a Firebase user. This is a programming error.");
      })(),
      isVerified: insertUser.isVerified !== void 0 ? insertUser.isVerified : false,
      has_seen_welcome: insertUser.has_seen_welcome !== void 0 ? insertUser.has_seen_welcome : false,
      isChef: insertUser.isChef !== void 0 ? insertUser.isChef : false,
      isManager: insertUser.isManager !== void 0 ? insertUser.isManager : false,
      isPortalUser: insertUser.isPortalUser !== void 0 ? insertUser.isPortalUser : false
    }).returning();
    return user;
  }
  async setUserHasSeenWelcome(userId) {
    if (!pool) return;
    try {
      await pool.query(
        "UPDATE users SET has_seen_welcome = true WHERE id = $1",
        [userId]
      );
    } catch (error) {
      console.error("Error setting has_seen_welcome:", error);
      throw new Error("Failed to set has_seen_welcome");
    }
  }
  // ===== APPLICATION MANAGEMENT =====
  async getAllApplications() {
    return await db.select().from(applications);
  }
  async getApplicationById(id) {
    const [application] = await db.select().from(applications).where(eq(applications.id, id));
    return application || void 0;
  }
  async getApplicationsByUserId(userId) {
    console.log(`[STORAGE] getApplicationsByUserId called with userId: ${userId}`);
    console.log(`[STORAGE] Database connection check - pool exists: ${!!pool}, db exists: ${!!db}`);
    const results = await db.select().from(applications).where(eq(applications.userId, userId));
    console.log(`[STORAGE] Found ${results.length} applications for user ${userId}`);
    return results;
  }
  async createApplication(insertApplication) {
    const now = /* @__PURE__ */ new Date();
    const [application] = await db.insert(applications).values({
      ...insertApplication,
      status: "inReview",
      createdAt: now
    }).returning();
    return application;
  }
  async updateApplicationStatus(update) {
    const { id, status } = update;
    const [updatedApplication] = await db.update(applications).set({ status }).where(eq(applications.id, id)).returning();
    return updatedApplication || void 0;
  }
  async updateApplicationDocuments(update) {
    const { id, ...updateData } = update;
    const [updatedApplication] = await db.update(applications).set({
      ...updateData,
      // Reset document status to pending when new documents are uploaded
      ...updateData.foodSafetyLicenseUrl && { foodSafetyLicenseStatus: "pending" },
      ...updateData.foodEstablishmentCertUrl && { foodEstablishmentCertStatus: "pending" }
    }).where(eq(applications.id, id)).returning();
    return updatedApplication || void 0;
  }
  async updateApplicationDocumentVerification(update) {
    const { id, ...updateData } = update;
    const [updatedApplication] = await db.update(applications).set({
      ...updateData,
      documentsReviewedAt: /* @__PURE__ */ new Date()
    }).where(eq(applications.id, id)).returning();
    return updatedApplication || void 0;
  }
  // ===== MICROLEARNING =====
  async getMicrolearningProgress(userId) {
    if (!pool) return [];
    try {
      const result = await pool.query(
        "SELECT * FROM video_progress WHERE user_id = $1 ORDER BY updated_at DESC",
        [userId]
      );
      return result.rows;
    } catch (error) {
      console.error("Error getting microlearning progress:", error);
      return [];
    }
  }
  async getMicrolearningCompletion(userId) {
    if (!pool) return void 0;
    try {
      const result = await pool.query(
        "SELECT * FROM microlearning_completions WHERE user_id = $1",
        [userId]
      );
      return result.rows[0] || void 0;
    } catch (error) {
      console.error("Error getting microlearning completion:", error);
      return void 0;
    }
  }
  async updateVideoProgress(progressData) {
    if (!pool) return;
    try {
      await pool.query(
        `INSERT INTO video_progress (user_id, video_id, progress, completed, watched_percentage, is_rewatching, updated_at)
         VALUES ($1, $2, $3, $4, $5, $6, NOW())
         ON CONFLICT (user_id, video_id) 
         DO UPDATE SET 
           progress = EXCLUDED.progress,
           completed = EXCLUDED.completed,
           watched_percentage = EXCLUDED.watched_percentage,
           is_rewatching = EXCLUDED.is_rewatching,
           updated_at = NOW()`,
        [
          progressData.userId,
          progressData.videoId,
          progressData.progress || 0,
          progressData.completed || false,
          progressData.watchedPercentage || 0,
          progressData.isRewatching || false
        ]
      );
    } catch (error) {
      console.error("Error updating video progress:", error);
      throw error;
    }
  }
  async createMicrolearningCompletion(completionData) {
    if (!pool) return null;
    try {
      const result = await pool.query(
        `INSERT INTO microlearning_completions (user_id, confirmed, certificate_generated, video_progress, created_at, updated_at)
         VALUES ($1, $2, $3, $4, NOW(), NOW())
         RETURNING *`,
        [
          completionData.userId,
          completionData.confirmed || false,
          completionData.certificateGenerated || false,
          JSON.stringify(completionData.videoProgress || {})
        ]
      );
      return result.rows[0];
    } catch (error) {
      console.error("Error creating microlearning completion:", error);
      throw error;
    }
  }
  // ===== USER ROLES MANAGEMENT =====
  async updateUserRoles(userId, roles) {
    try {
      let mainRole = roles.isChef ? "chef" : null;
      console.log(`\u{1F3AF} Updating user ${userId} roles:`, {
        isChef: roles.isChef,
        mainRole
      });
      await db.update(users).set({
        isChef: roles.isChef,
        role: mainRole
        // Update main role field too
      }).where(eq(users.id, userId));
      console.log(`\u2705 Successfully updated user ${userId} roles in database`);
    } catch (error) {
      console.error("Error updating user roles:", error);
      throw error;
    }
  }
  // ===== LOCATIONS MANAGEMENT =====
  async createLocation(locationData) {
    try {
      console.log("Inserting location into database:", locationData);
      const { normalizePhoneForStorage: normalizePhoneForStorage2 } = await Promise.resolve().then(() => (init_phone_utils(), phone_utils_exports));
      const insertData = {
        name: locationData.name,
        address: locationData.address
      };
      if (locationData.managerId !== void 0 && locationData.managerId !== null) {
        insertData.managerId = locationData.managerId;
      }
      if (locationData.notificationEmail !== void 0 && locationData.notificationEmail !== null && locationData.notificationEmail !== "") {
        insertData.notificationEmail = locationData.notificationEmail;
      }
      if (locationData.notificationPhone !== void 0 && locationData.notificationPhone !== null && locationData.notificationPhone !== "") {
        const normalized = normalizePhoneForStorage2(locationData.notificationPhone);
        insertData.notificationPhone = normalized || locationData.notificationPhone;
      }
      console.log("Insert data:", insertData);
      const [location] = await db.insert(locations).values(insertData).returning();
      console.log("Location created successfully:", location);
      return location;
    } catch (error) {
      console.error("Error creating location:", error);
      console.error("Error message:", error.message);
      console.error("Error code:", error.code);
      console.error("Error detail:", error.detail);
      if (error.code === "23503") {
        throw new Error("The selected manager does not exist or is invalid.");
      } else if (error.code === "23505") {
        throw new Error("A location with this information already exists.");
      } else if (error.message) {
        throw new Error(error.message);
      } else {
        throw new Error("Failed to create location due to a database error.");
      }
    }
  }
  async getAllLocations() {
    try {
      const allLocations = await db.select().from(locations);
      return allLocations.map((location) => ({
        ...location,
        managerId: location.managerId || location.manager_id || null,
        notificationEmail: location.notificationEmail || location.notification_email || null,
        cancellationPolicyHours: location.cancellationPolicyHours || location.cancellation_policy_hours,
        cancellationPolicyMessage: location.cancellationPolicyMessage || location.cancellation_policy_message,
        defaultDailyBookingLimit: location.defaultDailyBookingLimit || location.default_daily_booking_limit,
        minimumBookingWindowHours: location.minimumBookingWindowHours || location.minimum_booking_window_hours,
        logoUrl: location.logoUrl || location.logo_url || null,
        brandImageUrl: location.brandImageUrl || location.brand_image_url || null
      }));
    } catch (error) {
      console.error("Error getting all locations:", error);
      return [];
    }
  }
  async getLocationById(id) {
    try {
      const [location] = await db.select().from(locations).where(eq(locations.id, id));
      if (!location) return void 0;
      return {
        ...location,
        managerId: location.managerId || location.manager_id || null,
        notificationEmail: location.notificationEmail || location.notification_email || null,
        cancellationPolicyHours: location.cancellationPolicyHours || location.cancellation_policy_hours || 24,
        timezone: location.timezone || DEFAULT_TIMEZONE,
        cancellationPolicyMessage: location.cancellationPolicyMessage || location.cancellation_policy_message || "Bookings cannot be cancelled within {hours} hours of the scheduled time.",
        defaultDailyBookingLimit: location.defaultDailyBookingLimit || location.default_daily_booking_limit || 2,
        createdAt: location.createdAt || location.created_at,
        updatedAt: location.updatedAt || location.updated_at
      };
    } catch (error) {
      console.error("Error getting location by ID:", error);
      throw error;
    }
  }
  async getLocationsByManager(managerId) {
    try {
      return await db.select().from(locations).where(eq(locations.managerId, managerId));
    } catch (error) {
      console.error("Error getting locations by manager:", error);
      throw error;
    }
  }
  // ===== LOCATION REQUIREMENTS MANAGEMENT =====
  async getLocationRequirements(locationId) {
    try {
      const [requirements] = await db.select().from(locationRequirements).where(eq(locationRequirements.locationId, locationId));
      return requirements || null;
    } catch (error) {
      console.error("Error getting location requirements:", error);
      return null;
    }
  }
  async getLocationRequirementsWithDefaults(locationId) {
    const requirements = await this.getLocationRequirements(locationId);
    if (requirements) {
      return {
        ...requirements,
        customFields: Array.isArray(requirements.customFields) ? requirements.customFields : []
      };
    }
    return {
      id: 0,
      locationId,
      requireFirstName: true,
      requireLastName: true,
      requireEmail: true,
      requirePhone: true,
      requireBusinessName: true,
      requireBusinessType: true,
      requireExperience: true,
      requireBusinessDescription: false,
      requireFoodHandlerCert: true,
      requireFoodHandlerExpiry: true,
      requireFoodEstablishmentCert: false,
      requireFoodEstablishmentExpiry: false,
      requireUsageFrequency: true,
      requireSessionDuration: true,
      requireTermsAgree: true,
      requireAccuracyAgree: true,
      customFields: [],
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    };
  }
  async upsertLocationRequirements(locationId, updates) {
    try {
      const existing = await this.getLocationRequirements(locationId);
      const processedUpdates = {
        ...updates,
        ...updates.customFields !== void 0 && {
          customFields: Array.isArray(updates.customFields) ? updates.customFields : []
        },
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (existing) {
        const [updated] = await db.update(locationRequirements).set(processedUpdates).where(eq(locationRequirements.locationId, locationId)).returning();
        return updated;
      } else {
        const [created] = await db.insert(locationRequirements).values({
          locationId,
          ...processedUpdates,
          // Ensure customFields defaults to empty array if not provided
          customFields: processedUpdates.customFields ?? []
        }).returning();
        return created;
      }
    } catch (error) {
      console.error("Error upserting location requirements:", error);
      throw error;
    }
  }
  async updateLocation(id, updates) {
    try {
      const { normalizePhoneForStorage: normalizePhoneForStorage2 } = await Promise.resolve().then(() => (init_phone_utils(), phone_utils_exports));
      const normalizedUpdates = { ...updates };
      if (updates.notificationPhone !== void 0) {
        if (updates.notificationPhone && updates.notificationPhone.trim() !== "") {
          normalizedUpdates.notificationPhone = normalizePhoneForStorage2(updates.notificationPhone) || updates.notificationPhone;
        } else {
          normalizedUpdates.notificationPhone = null;
        }
      }
      const [updated] = await db.update(locations).set({ ...normalizedUpdates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(locations.id, id)).returning();
      return updated;
    } catch (error) {
      console.error("Error updating location:", error);
      throw error;
    }
  }
  async deleteLocation(id) {
    try {
      const locationKitchens = await db.select().from(kitchens).where(eq(kitchens.locationId, id));
      if (locationKitchens.length > 0) {
        throw new Error(`Cannot delete location: It has ${locationKitchens.length} kitchen(s). Please delete or reassign kitchens first.`);
      }
      await db.transaction(async (tx) => {
        await tx.delete(locations).where(eq(locations.id, id));
      });
      console.log(`\u2705 Deleted location ${id}`);
    } catch (error) {
      console.error("Error deleting location:", error);
      throw error;
    }
  }
  // ===== KITCHENS MANAGEMENT =====
  async createKitchen(kitchenData) {
    try {
      console.log("Inserting kitchen into database:", kitchenData);
      const insertData = {
        locationId: kitchenData.locationId,
        name: kitchenData.name
      };
      if (kitchenData.description !== void 0 && kitchenData.description !== null && kitchenData.description !== "") {
        insertData.description = kitchenData.description;
      }
      if (kitchenData.isActive !== void 0) {
        insertData.isActive = kitchenData.isActive;
      } else {
        insertData.isActive = true;
      }
      console.log("Insert data:", insertData);
      const [kitchen] = await db.insert(kitchens).values(insertData).returning();
      console.log("Kitchen created successfully:", kitchen);
      return kitchen;
    } catch (error) {
      console.error("Error creating kitchen:", error);
      console.error("Error message:", error.message);
      console.error("Error code:", error.code);
      console.error("Error detail:", error.detail);
      if (error.code === "23503") {
        throw new Error("The selected location does not exist or is invalid.");
      } else if (error.code === "23505") {
        throw new Error("A kitchen with this name already exists in this location.");
      } else if (error.message) {
        throw new Error(error.message);
      } else {
        throw new Error("Failed to create kitchen due to a database error.");
      }
    }
  }
  async getKitchenById(id) {
    try {
      const [kitchen] = await db.select().from(kitchens).where(eq(kitchens.id, id));
      return kitchen || void 0;
    } catch (error) {
      console.error("Error getting kitchen by ID:", error);
      throw error;
    }
  }
  async getKitchensByLocation(locationId) {
    try {
      return await db.select().from(kitchens).where(eq(kitchens.locationId, locationId));
    } catch (error) {
      console.error("Error getting kitchens by location:", error);
      throw error;
    }
  }
  async getAllKitchens() {
    try {
      const result = await db.select().from(kitchens);
      console.log("\u{1F4E6} getAllKitchens - Raw result from DB:", JSON.stringify(result, null, 2));
      console.log("\u{1F4E6} Total kitchens in DB:", result.length);
      if (result.length > 0) {
        console.log("\u{1F4E6} First kitchen sample:", result[0]);
      }
      return result;
    } catch (error) {
      console.error("\u274C Error getting all kitchens:", error);
      throw error;
    }
  }
  async getAllKitchensWithLocationAndManager() {
    try {
      const allKitchens = await db.select().from(kitchens);
      const allLocations = await db.select().from(locations);
      const allUsers = await db.select({
        id: users.id,
        username: users.username
      }).from(users);
      const kitchensWithDetails = allKitchens.map((kitchen) => {
        const kitchenLocationId = kitchen.locationId ?? kitchen.location_id;
        const location = allLocations.find((loc) => {
          const locId = loc.id;
          return locId === kitchenLocationId;
        });
        const managerId = location ? location.managerId ?? location.manager_id : void 0;
        const manager = managerId ? allUsers.find((user) => user.id === managerId) : null;
        const locName = location ? location.name ?? location.location_name : void 0;
        const locAddress = location ? location.address ?? location.location_address : void 0;
        const kitchenImageUrl = kitchen.imageUrl || kitchen.image_url || null;
        const kitchenGalleryImages = kitchen.galleryImages || kitchen.gallery_images || [];
        const locationBrandImageUrl = location ? location.brandImageUrl || location.brand_image_url || null : null;
        const locationLogoUrl = location ? location.logoUrl || location.logo_url || null : null;
        const hourlyRateCents = kitchen.hourlyRate;
        const hourlyRate = hourlyRateCents !== null && hourlyRateCents !== void 0 ? (typeof hourlyRateCents === "string" ? parseFloat(hourlyRateCents) : hourlyRateCents) / 100 : null;
        const amenities = kitchen.amenities || [];
        const amenitiesArray = Array.isArray(amenities) ? amenities : [];
        const currency = kitchen.currency || "CAD";
        const minimumBookingHours = kitchen.minimumBookingHours || kitchen.minimum_booking_hours || 1;
        const pricingModel = kitchen.pricingModel || kitchen.pricing_model || "hourly";
        const isActive = kitchen.isActive !== void 0 ? kitchen.isActive : kitchen.is_active;
        return {
          ...kitchen,
          // Helpful flattened fields for clients that don't handle nested objects reliably
          locationId: kitchenLocationId,
          locationName: locName,
          locationAddress: locAddress,
          // Ensure imageUrl and galleryImages are always set (even if null/empty) and not undefined
          imageUrl: kitchenImageUrl,
          galleryImages: kitchenGalleryImages,
          locationBrandImageUrl,
          locationLogoUrl,
          // Format pricing fields for frontend
          hourlyRate,
          // Now in dollars, not cents
          currency,
          minimumBookingHours,
          pricingModel,
          amenities: amenitiesArray,
          // Ensure it's always an array
          isActive,
          location: location ? {
            id: location.id,
            name: locName,
            address: locAddress,
            brandImageUrl: locationBrandImageUrl || null,
            logoUrl: locationLogoUrl || null
          } : null,
          manager: manager ? {
            id: manager.id,
            username: manager.username,
            fullName: manager.fullName || manager.username
          } : null
        };
      });
      return kitchensWithDetails;
    } catch (error) {
      console.error("Error getting kitchens with location and manager:", error);
      throw error;
    }
  }
  // Get kitchens that a chef has access to (admin must grant access first)
  async getKitchensForChef(chefId) {
    try {
      const locationAccessRecords = await db.select().from(chefLocationAccess).where(eq(chefLocationAccess.chefId, chefId));
      if (locationAccessRecords.length === 0) {
        return [];
      }
      const locationIds = locationAccessRecords.map((access) => access.locationId);
      const allKitchensWithDetails = await this.getAllKitchensWithLocationAndManager();
      return allKitchensWithDetails.filter((kitchen) => {
        const isActive = kitchen.isActive !== void 0 ? kitchen.isActive : kitchen.is_active;
        const kitchenLocationId = kitchen.locationId ?? kitchen.location?.id;
        return locationIds.includes(kitchenLocationId) && isActive !== false && isActive !== null;
      });
    } catch (error) {
      console.error("Error getting kitchens for chef:", error);
      throw error;
    }
  }
  async updateKitchen(id, updates) {
    try {
      const dbUpdates = { ...updates, updatedAt: /* @__PURE__ */ new Date() };
      if (updates.hourlyRate !== void 0) {
        dbUpdates.hourlyRate = updates.hourlyRate === null ? null : updates.hourlyRate.toString();
      }
      const [updated] = await db.update(kitchens).set(dbUpdates).where(eq(kitchens.id, id)).returning();
      return updated;
    } catch (error) {
      console.error("Error updating kitchen:", error);
      throw error;
    }
  }
  // Get kitchen pricing
  async getKitchenPricing(kitchenId) {
    try {
      if (pool && "query" in pool) {
        try {
          const directQuery = await pool.query(
            "SELECT hourly_rate::text as hourly_rate, currency, minimum_booking_hours, pricing_model FROM kitchens WHERE id = $1",
            [kitchenId]
          );
          if (directQuery.rows && directQuery.rows[0]) {
            const row = directQuery.rows[0];
            const dbValue = row.hourly_rate;
            const hourlyRateCents2 = dbValue ? parseFloat(String(dbValue)) : null;
            return {
              hourlyRate: hourlyRateCents2 !== null ? hourlyRateCents2 / 100 : null,
              currency: row.currency || "CAD",
              minimumBookingHours: row.minimum_booking_hours || 1,
              pricingModel: row.pricing_model || "hourly"
            };
          }
        } catch (error) {
          console.error("Error getting kitchen pricing:", error);
        }
      }
      const kitchen = await this.getKitchenById(kitchenId);
      if (!kitchen) return void 0;
      const hourlyRateCents = kitchen.hourlyRate ? parseFloat(kitchen.hourlyRate.toString()) : null;
      const hourlyRateDollars = hourlyRateCents !== null ? hourlyRateCents / 100 : null;
      return {
        hourlyRate: hourlyRateDollars,
        currency: kitchen.currency || "CAD",
        minimumBookingHours: kitchen.minimumBookingHours || 1,
        pricingModel: kitchen.pricingModel || "hourly"
      };
    } catch (error) {
      console.error("Error getting kitchen pricing:", error);
      throw error;
    }
  }
  // Update kitchen pricing
  async updateKitchenPricing(kitchenId, pricing) {
    try {
      const updates = {
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (pricing.hourlyRate !== void 0) {
        const hourlyRateCents2 = pricing.hourlyRate === null ? null : Math.round(pricing.hourlyRate * 100);
        updates.hourlyRate = hourlyRateCents2 === null ? null : hourlyRateCents2.toString();
      }
      if (pricing.currency !== void 0) {
        updates.currency = pricing.currency;
      }
      if (pricing.minimumBookingHours !== void 0) {
        updates.minimumBookingHours = pricing.minimumBookingHours;
      }
      if (pricing.pricingModel !== void 0) {
        updates.pricingModel = pricing.pricingModel;
      }
      const [updated] = await db.update(kitchens).set(updates).where(eq(kitchens.id, kitchenId)).returning();
      let hourlyRateCents = null;
      if (pool && "query" in pool) {
        try {
          const directQuery = await pool.query(
            "SELECT hourly_rate::text as hourly_rate FROM kitchens WHERE id = $1",
            [kitchenId]
          );
          if (directQuery.rows && directQuery.rows[0]) {
            const dbValue = directQuery.rows[0].hourly_rate;
            hourlyRateCents = dbValue ? parseFloat(String(dbValue)) : null;
          }
        } catch (error) {
          console.error("Error updating kitchen pricing:", error);
        }
      }
      const hourlyRateDollars = hourlyRateCents !== null ? hourlyRateCents / 100 : null;
      const result = {
        hourlyRate: hourlyRateDollars,
        // Return in dollars for API consistency
        currency: updated.currency || "CAD",
        minimumBookingHours: updated.minimumBookingHours || 1,
        pricingModel: updated.pricingModel || "hourly"
      };
      console.log("[updateKitchenPricing] Final result:", JSON.stringify(result));
      return result;
    } catch (error) {
      console.error("Error updating kitchen pricing:", error);
      throw error;
    }
  }
  // ===== STORAGE LISTINGS MANAGEMENT =====
  // Get storage listing by ID (using direct SQL for numeric fields)
  async getStorageListingById(id) {
    try {
      if (pool && "query" in pool) {
        try {
          const directQuery = await pool.query(
            `SELECT 
              id, kitchen_id, storage_type, name, description,
              dimensions_length::text as dimensions_length,
              dimensions_width::text as dimensions_width,
              dimensions_height::text as dimensions_height,
              total_volume::text as total_volume,
              shelf_count, shelf_material, access_type,
              features, security_features, climate_control,
              temperature_range, humidity_control, power_outlets,
              pricing_model,
              base_price::text as base_price,
              price_per_cubic_foot::text as price_per_cubic_foot,
              minimum_booking_duration, booking_duration_unit, currency,
              status, approved_by, approved_at, rejection_reason,
              is_active, availability_calendar,
              certifications, photos, documents,
              house_rules, prohibited_items, insurance_required,
              created_at, updated_at
            FROM storage_listings 
            WHERE id = $1`,
            [id]
          );
          if (directQuery.rows && directQuery.rows[0]) {
            const row = directQuery.rows[0];
            return {
              ...row,
              basePrice: row.base_price ? parseFloat(String(row.base_price)) / 100 : null,
              pricePerCubicFoot: row.price_per_cubic_foot ? parseFloat(String(row.price_per_cubic_foot)) / 100 : null,
              dimensionsLength: row.dimensions_length ? parseFloat(String(row.dimensions_length)) : null,
              dimensionsWidth: row.dimensions_width ? parseFloat(String(row.dimensions_width)) : null,
              dimensionsHeight: row.dimensions_height ? parseFloat(String(row.dimensions_height)) : null,
              totalVolume: row.total_volume ? parseFloat(String(row.total_volume)) : null,
              kitchenId: row.kitchen_id,
              storageType: row.storage_type,
              minimumBookingDuration: row.minimum_booking_duration || 1,
              bookingDurationUnit: row.booking_duration_unit || "monthly",
              pricingModel: row.pricing_model,
              isActive: row.is_active,
              climateControl: row.climate_control,
              humidityControl: row.humidity_control,
              powerOutlets: row.power_outlets,
              insuranceRequired: row.insurance_required,
              approvedBy: row.approved_by,
              approvedAt: row.approved_at,
              createdAt: row.created_at,
              updatedAt: row.updated_at
            };
          }
        } catch (error) {
          console.error("Error getting storage listing by ID (direct query):", error);
        }
      }
      const [listing] = await db.select().from(storageListings).where(eq(storageListings.id, id));
      if (!listing) return void 0;
      const basePriceCents = listing.basePrice ? parseFloat(listing.basePrice.toString()) : null;
      const pricePerCubicFootCents = listing.pricePerCubicFoot ? parseFloat(listing.pricePerCubicFoot.toString()) : null;
      return {
        ...listing,
        basePrice: basePriceCents !== null ? basePriceCents / 100 : null,
        pricePerCubicFoot: pricePerCubicFootCents !== null ? pricePerCubicFootCents / 100 : null
      };
    } catch (error) {
      console.error("Error getting storage listing by ID:", error);
      throw error;
    }
  }
  // Get storage listings by kitchen ID
  async getStorageListingsByKitchen(kitchenId) {
    try {
      if (pool && "query" in pool) {
        try {
          const directQuery = await pool.query(
            `SELECT 
              id, kitchen_id, storage_type, name, description,
              base_price::text as base_price,
              price_per_cubic_foot::text as price_per_cubic_foot,
              pricing_model, 
              COALESCE(minimum_booking_duration, 1) as minimum_booking_duration,
              COALESCE(booking_duration_unit, 'monthly') as booking_duration_unit,
              currency,
              dimensions_length::text as dimensions_length,
              dimensions_width::text as dimensions_width,
              dimensions_height::text as dimensions_height,
              total_volume::text as total_volume,
              climate_control, temperature_range,
              status, is_active, created_at, updated_at
            FROM storage_listings 
            WHERE kitchen_id = $1
            ORDER BY created_at DESC`,
            [kitchenId]
          );
          return directQuery.rows.map((row) => ({
            id: row.id,
            kitchenId: row.kitchen_id,
            storageType: row.storage_type,
            name: row.name,
            description: row.description,
            // Convert cents to dollars for frontend display
            basePrice: row.base_price ? parseFloat(String(row.base_price)) / 100 : null,
            pricePerCubicFoot: row.price_per_cubic_foot ? parseFloat(String(row.price_per_cubic_foot)) / 100 : null,
            pricingModel: row.pricing_model,
            minimumBookingDuration: row.minimum_booking_duration ?? 1,
            bookingDurationUnit: row.booking_duration_unit ?? "monthly",
            currency: row.currency || "CAD",
            dimensionsLength: row.dimensions_length ? parseFloat(row.dimensions_length) : null,
            dimensionsWidth: row.dimensions_width ? parseFloat(row.dimensions_width) : null,
            dimensionsHeight: row.dimensions_height ? parseFloat(row.dimensions_height) : null,
            totalVolume: row.total_volume ? parseFloat(row.total_volume) : null,
            climateControl: row.climate_control ?? false,
            temperatureRange: row.temperature_range,
            status: row.status,
            isActive: row.is_active,
            createdAt: row.created_at,
            updatedAt: row.updated_at
          }));
        } catch (error) {
          console.error("Error getting storage listings by kitchen (direct query):", error);
        }
      }
      const listings = await db.select().from(storageListings).where(eq(storageListings.kitchenId, kitchenId));
      return listings.map((listing) => {
        const basePriceCents = listing.basePrice ? parseFloat(listing.basePrice.toString()) : null;
        const pricePerCubicFootCents = listing.pricePerCubicFoot ? parseFloat(listing.pricePerCubicFoot.toString()) : null;
        return {
          ...listing,
          basePrice: basePriceCents !== null ? basePriceCents / 100 : null,
          pricePerCubicFoot: pricePerCubicFootCents !== null ? pricePerCubicFootCents / 100 : null,
          minimumBookingDuration: listing.minimumBookingDuration || 1,
          bookingDurationUnit: listing.bookingDurationUnit || "monthly"
        };
      });
    } catch (error) {
      console.error("Error getting storage listings by kitchen:", error);
      throw error;
    }
  }
  // Create storage listing
  async createStorageListing(listing) {
    try {
      const basePriceCents = Math.round(listing.basePrice * 100);
      const pricePerCubicFootCents = listing.pricePerCubicFoot ? Math.round(listing.pricePerCubicFoot * 100) : null;
      const insertData = {
        kitchenId: listing.kitchenId,
        storageType: listing.storageType,
        name: listing.name,
        description: listing.description || null,
        basePrice: basePriceCents.toString(),
        // Store as string for numeric type
        pricePerCubicFoot: pricePerCubicFootCents ? pricePerCubicFootCents.toString() : null,
        pricingModel: listing.pricingModel,
        minimumBookingDuration: listing.minimumBookingDuration || 1,
        bookingDurationUnit: listing.bookingDurationUnit || "monthly",
        currency: "CAD",
        // Always CAD
        dimensionsLength: listing.dimensionsLength?.toString() || null,
        dimensionsWidth: listing.dimensionsWidth?.toString() || null,
        dimensionsHeight: listing.dimensionsHeight?.toString() || null,
        totalVolume: listing.totalVolume?.toString() || null,
        shelfCount: listing.shelfCount || null,
        shelfMaterial: listing.shelfMaterial || null,
        accessType: listing.accessType || null,
        temperatureRange: listing.temperatureRange || null,
        climateControl: listing.climateControl || false,
        humidityControl: listing.humidityControl || false,
        powerOutlets: listing.powerOutlets || 0,
        features: listing.features || [],
        securityFeatures: listing.securityFeatures || [],
        certifications: listing.certifications || [],
        photos: listing.photos || [],
        documents: listing.documents || [],
        houseRules: listing.houseRules || [],
        prohibitedItems: listing.prohibitedItems || [],
        insuranceRequired: listing.insuranceRequired || false,
        availabilityCalendar: listing.availabilityCalendar || {},
        status: "active",
        // Skip admin moderation - immediately visible to chefs
        isActive: true,
        updatedAt: /* @__PURE__ */ new Date()
      };
      const [created] = await db.insert(storageListings).values(insertData).returning();
      return await this.getStorageListingById(created.id);
    } catch (error) {
      console.error("Error creating storage listing:", error);
      throw error;
    }
  }
  // Update storage listing
  async updateStorageListing(id, updates) {
    try {
      const dbUpdates = {
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (updates.name !== void 0) dbUpdates.name = updates.name;
      if (updates.description !== void 0) dbUpdates.description = updates.description || null;
      if (updates.storageType !== void 0) dbUpdates.storageType = updates.storageType;
      if (updates.pricingModel !== void 0) dbUpdates.pricingModel = updates.pricingModel;
      if (updates.minimumBookingDuration !== void 0) dbUpdates.minimumBookingDuration = updates.minimumBookingDuration;
      if (updates.bookingDurationUnit !== void 0) dbUpdates.bookingDurationUnit = updates.bookingDurationUnit;
      if (updates.shelfCount !== void 0) dbUpdates.shelfCount = updates.shelfCount;
      if (updates.shelfMaterial !== void 0) dbUpdates.shelfMaterial = updates.shelfMaterial || null;
      if (updates.accessType !== void 0) dbUpdates.accessType = updates.accessType || null;
      if (updates.temperatureRange !== void 0) dbUpdates.temperatureRange = updates.temperatureRange || null;
      if (updates.climateControl !== void 0) dbUpdates.climateControl = updates.climateControl;
      if (updates.humidityControl !== void 0) dbUpdates.humidityControl = updates.humidityControl;
      if (updates.powerOutlets !== void 0) dbUpdates.powerOutlets = updates.powerOutlets;
      if (updates.isActive !== void 0) dbUpdates.isActive = updates.isActive;
      if (updates.insuranceRequired !== void 0) dbUpdates.insuranceRequired = updates.insuranceRequired;
      if (updates.features !== void 0) dbUpdates.features = updates.features;
      if (updates.securityFeatures !== void 0) dbUpdates.securityFeatures = updates.securityFeatures;
      if (updates.certifications !== void 0) dbUpdates.certifications = updates.certifications;
      if (updates.photos !== void 0) dbUpdates.photos = updates.photos;
      if (updates.documents !== void 0) dbUpdates.documents = updates.documents;
      if (updates.houseRules !== void 0) dbUpdates.houseRules = updates.houseRules;
      if (updates.prohibitedItems !== void 0) dbUpdates.prohibitedItems = updates.prohibitedItems;
      if (updates.availabilityCalendar !== void 0) dbUpdates.availabilityCalendar = updates.availabilityCalendar;
      if (updates.dimensionsLength !== void 0) {
        dbUpdates.dimensionsLength = updates.dimensionsLength?.toString() || null;
      }
      if (updates.dimensionsWidth !== void 0) {
        dbUpdates.dimensionsWidth = updates.dimensionsWidth?.toString() || null;
      }
      if (updates.dimensionsHeight !== void 0) {
        dbUpdates.dimensionsHeight = updates.dimensionsHeight?.toString() || null;
      }
      if (updates.totalVolume !== void 0) {
        dbUpdates.totalVolume = updates.totalVolume?.toString() || null;
      }
      if (updates.basePrice !== void 0) {
        dbUpdates.basePrice = updates.basePrice === null ? null : Math.round(updates.basePrice * 100).toString();
      }
      if (updates.pricePerCubicFoot !== void 0) {
        dbUpdates.pricePerCubicFoot = updates.pricePerCubicFoot === null ? null : Math.round(updates.pricePerCubicFoot * 100).toString();
      }
      const [updated] = await db.update(storageListings).set(dbUpdates).where(eq(storageListings.id, id)).returning();
      return await this.getStorageListingById(id);
    } catch (error) {
      console.error("Error updating storage listing:", error);
      throw error;
    }
  }
  // Delete storage listing
  async deleteStorageListing(id) {
    try {
      const result = await db.delete(storageListings).where(eq(storageListings.id, id)).returning({ id: storageListings.id });
      if (result.length === 0) {
        throw new Error(`Storage listing with id ${id} not found`);
      }
      console.log(`\u2705 Storage listing ${id} deleted successfully`);
    } catch (error) {
      console.error("Error deleting storage listing:", error);
      throw error;
    }
  }
  // ===== EQUIPMENT LISTINGS MANAGEMENT =====
  // Get equipment listing by ID
  async getEquipmentListingById(id) {
    try {
      if (pool && "query" in pool) {
        try {
          const directQuery = await pool.query(
            `SELECT 
              id, kitchen_id, category, equipment_type, brand, model, description,
              condition, age, service_history,
              dimensions::text as dimensions,
              power_requirements,
              specifications::text as specifications,
              certifications, safety_features,
              pricing_model,
              hourly_rate::text as hourly_rate,
              daily_rate::text as daily_rate,
              weekly_rate::text as weekly_rate,
              monthly_rate::text as monthly_rate,
              availability_type,
              minimum_rental_hours, minimum_rental_days, currency,
              usage_restrictions, training_required, cleaning_responsibility,
              status, approved_by, approved_at, rejection_reason,
              is_active, availability_calendar, prep_time_hours,
              photos, manuals, maintenance_log,
              damage_deposit::text as damage_deposit,
              insurance_required,
              created_at, updated_at
            FROM equipment_listings 
            WHERE id = $1`,
            [id]
          );
          if (directQuery.rows && directQuery.rows[0]) {
            const row = directQuery.rows[0];
            return {
              ...row,
              kitchenId: row.kitchen_id,
              equipmentType: row.equipment_type,
              powerRequirements: row.power_requirements,
              serviceHistory: row.service_history,
              cleaningResponsibility: row.cleaning_responsibility,
              prepTimeHours: row.prep_time_hours,
              insuranceRequired: row.insurance_required,
              trainingRequired: row.training_required,
              isActive: row.is_active,
              approvedBy: row.approved_by,
              approvedAt: row.approved_at,
              rejectionReason: row.rejection_reason,
              minimumRentalHours: row.minimum_rental_hours,
              minimumRentalDays: row.minimum_rental_days,
              availabilityCalendar: row.availability_calendar,
              maintenanceLog: row.maintenance_log,
              availabilityType: row.availability_type || "rental",
              // Convert prices from cents to dollars
              hourlyRate: row.hourly_rate ? parseFloat(String(row.hourly_rate)) / 100 : null,
              dailyRate: row.daily_rate ? parseFloat(String(row.daily_rate)) / 100 : null,
              weeklyRate: row.weekly_rate ? parseFloat(String(row.weekly_rate)) / 100 : null,
              monthlyRate: row.monthly_rate ? parseFloat(String(row.monthly_rate)) / 100 : null,
              damageDeposit: row.damage_deposit ? parseFloat(String(row.damage_deposit)) / 100 : null,
              // Parse JSONB fields
              dimensions: row.dimensions ? JSON.parse(row.dimensions) : {},
              specifications: row.specifications ? JSON.parse(row.specifications) : {}
            };
          }
        } catch (error) {
          console.error("Error getting equipment listing by ID (direct query):", error);
        }
      }
      const [listing] = await db.select().from(equipmentListings).where(eq(equipmentListings.id, id));
      if (!listing) return void 0;
      const hourlyRateCents = listing.hourlyRate ? parseFloat(listing.hourlyRate.toString()) : null;
      const dailyRateCents = listing.dailyRate ? parseFloat(listing.dailyRate.toString()) : null;
      const weeklyRateCents = listing.weeklyRate ? parseFloat(listing.weeklyRate.toString()) : null;
      const monthlyRateCents = listing.monthlyRate ? parseFloat(listing.monthlyRate.toString()) : null;
      const damageDepositCents = listing.damageDeposit ? parseFloat(listing.damageDeposit.toString()) : null;
      return {
        ...listing,
        hourlyRate: hourlyRateCents !== null ? hourlyRateCents / 100 : null,
        dailyRate: dailyRateCents !== null ? dailyRateCents / 100 : null,
        weeklyRate: weeklyRateCents !== null ? weeklyRateCents / 100 : null,
        monthlyRate: monthlyRateCents !== null ? monthlyRateCents / 100 : null,
        damageDeposit: damageDepositCents !== null ? damageDepositCents / 100 : null
      };
    } catch (error) {
      console.error("Error getting equipment listing by ID:", error);
      throw error;
    }
  }
  // Get equipment listings by kitchen ID
  async getEquipmentListingsByKitchen(kitchenId) {
    try {
      if (pool && "query" in pool) {
        try {
          const directQuery = await pool.query(
            `SELECT 
              id, kitchen_id, category, equipment_type, brand, model, description,
              condition, availability_type, pricing_model,
              session_rate::text as session_rate,
              hourly_rate::text as hourly_rate,
              daily_rate::text as daily_rate,
              weekly_rate::text as weekly_rate,
              monthly_rate::text as monthly_rate,
              damage_deposit::text as damage_deposit,
              minimum_rental_hours, minimum_rental_days, currency,
              training_required, cleaning_responsibility,
              status, is_active, created_at, updated_at
            FROM equipment_listings 
            WHERE kitchen_id = $1
            ORDER BY created_at DESC`,
            [kitchenId]
          );
          return directQuery.rows.map((row) => ({
            id: row.id,
            kitchenId: row.kitchen_id,
            category: row.category,
            equipmentType: row.equipment_type,
            brand: row.brand,
            model: row.model,
            description: row.description,
            condition: row.condition,
            availabilityType: row.availability_type || "rental",
            pricingModel: row.pricing_model,
            // PRIMARY: Flat session rate (convert cents to dollars)
            sessionRate: row.session_rate ? parseFloat(String(row.session_rate)) / 100 : 0,
            // Legacy rates (kept for backwards compatibility)
            hourlyRate: row.hourly_rate ? parseFloat(String(row.hourly_rate)) / 100 : null,
            dailyRate: row.daily_rate ? parseFloat(String(row.daily_rate)) / 100 : null,
            weeklyRate: row.weekly_rate ? parseFloat(String(row.weekly_rate)) / 100 : null,
            monthlyRate: row.monthly_rate ? parseFloat(String(row.monthly_rate)) / 100 : null,
            damageDeposit: row.damage_deposit ? parseFloat(String(row.damage_deposit)) / 100 : 0,
            minimumRentalHours: row.minimum_rental_hours,
            minimumRentalDays: row.minimum_rental_days,
            trainingRequired: row.training_required ?? false,
            cleaningResponsibility: row.cleaning_responsibility,
            currency: row.currency || "CAD",
            status: row.status,
            isActive: row.is_active,
            createdAt: row.created_at,
            updatedAt: row.updated_at
          }));
        } catch (error) {
          console.error("Error getting equipment listings by kitchen (direct query):", error);
        }
      }
      const listings = await db.select().from(equipmentListings).where(eq(equipmentListings.kitchenId, kitchenId));
      return listings.map((listing) => {
        const sessionRateCents = listing.sessionRate ? parseFloat(listing.sessionRate.toString()) : 0;
        const hourlyRateCents = listing.hourlyRate ? parseFloat(listing.hourlyRate.toString()) : null;
        const dailyRateCents = listing.dailyRate ? parseFloat(listing.dailyRate.toString()) : null;
        const weeklyRateCents = listing.weeklyRate ? parseFloat(listing.weeklyRate.toString()) : null;
        const monthlyRateCents = listing.monthlyRate ? parseFloat(listing.monthlyRate.toString()) : null;
        const damageDepositCents = listing.damageDeposit ? parseFloat(listing.damageDeposit.toString()) : 0;
        return {
          ...listing,
          sessionRate: sessionRateCents / 100,
          hourlyRate: hourlyRateCents !== null ? hourlyRateCents / 100 : null,
          dailyRate: dailyRateCents !== null ? dailyRateCents / 100 : null,
          weeklyRate: weeklyRateCents !== null ? weeklyRateCents / 100 : null,
          monthlyRate: monthlyRateCents !== null ? monthlyRateCents / 100 : null,
          damageDeposit: damageDepositCents / 100
        };
      });
    } catch (error) {
      console.error("Error getting equipment listings by kitchen:", error);
      throw error;
    }
  }
  // Create equipment listing
  async createEquipmentListing(listing) {
    try {
      const sessionRateCents = listing.sessionRate ? Math.round(listing.sessionRate * 100) : 0;
      const damageDepositCents = listing.damageDeposit ? Math.round(listing.damageDeposit * 100) : 0;
      const hourlyRateCents = listing.hourlyRate ? Math.round(listing.hourlyRate * 100) : null;
      const dailyRateCents = listing.dailyRate ? Math.round(listing.dailyRate * 100) : null;
      const weeklyRateCents = listing.weeklyRate ? Math.round(listing.weeklyRate * 100) : null;
      const monthlyRateCents = listing.monthlyRate ? Math.round(listing.monthlyRate * 100) : null;
      const insertData = {
        kitchenId: listing.kitchenId,
        category: listing.category,
        equipmentType: listing.equipmentType,
        brand: listing.brand || null,
        model: listing.model || null,
        description: listing.description || null,
        condition: listing.condition,
        age: listing.age || null,
        serviceHistory: listing.serviceHistory || null,
        dimensions: listing.dimensions || {},
        powerRequirements: listing.powerRequirements || null,
        specifications: listing.specifications || {},
        certifications: listing.certifications || [],
        safetyFeatures: listing.safetyFeatures || [],
        availabilityType: listing.availabilityType || "rental",
        // NEW: Flat session rate - primary pricing field for rental equipment
        sessionRate: listing.availabilityType === "rental" ? sessionRateCents.toString() : "0",
        // Legacy pricing fields - kept for backwards compatibility
        pricingModel: listing.availabilityType === "rental" ? listing.pricingModel || "hourly" : null,
        hourlyRate: listing.availabilityType === "rental" ? hourlyRateCents ? hourlyRateCents.toString() : null : null,
        dailyRate: listing.availabilityType === "rental" ? dailyRateCents ? dailyRateCents.toString() : null : null,
        weeklyRate: listing.availabilityType === "rental" ? weeklyRateCents ? weeklyRateCents.toString() : null : null,
        monthlyRate: listing.availabilityType === "rental" ? monthlyRateCents ? monthlyRateCents.toString() : null : null,
        minimumRentalHours: listing.availabilityType === "rental" ? listing.minimumRentalHours || null : null,
        minimumRentalDays: listing.availabilityType === "rental" ? listing.minimumRentalDays || null : null,
        currency: "CAD",
        usageRestrictions: listing.usageRestrictions || [],
        trainingRequired: listing.trainingRequired || false,
        cleaningResponsibility: listing.cleaningResponsibility || null,
        prepTimeHours: listing.prepTimeHours || 4,
        photos: listing.photos || [],
        manuals: listing.manuals || [],
        maintenanceLog: listing.maintenanceLog || [],
        damageDeposit: listing.availabilityType === "rental" ? damageDepositCents.toString() : "0",
        insuranceRequired: listing.insuranceRequired || false,
        availabilityCalendar: listing.availabilityCalendar || {},
        status: "active",
        // Skip admin moderation - immediately visible to chefs
        isActive: true,
        updatedAt: /* @__PURE__ */ new Date()
      };
      const [created] = await db.insert(equipmentListings).values(insertData).returning();
      return await this.getEquipmentListingById(created.id);
    } catch (error) {
      console.error("Error creating equipment listing:", error);
      throw error;
    }
  }
  // Update equipment listing
  async updateEquipmentListing(id, updates) {
    try {
      const dbUpdates = {
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (updates.category !== void 0) dbUpdates.category = updates.category;
      if (updates.equipmentType !== void 0) dbUpdates.equipmentType = updates.equipmentType;
      if (updates.brand !== void 0) dbUpdates.brand = updates.brand || null;
      if (updates.model !== void 0) dbUpdates.model = updates.model || null;
      if (updates.description !== void 0) dbUpdates.description = updates.description || null;
      if (updates.condition !== void 0) dbUpdates.condition = updates.condition;
      if (updates.age !== void 0) dbUpdates.age = updates.age || null;
      if (updates.serviceHistory !== void 0) dbUpdates.serviceHistory = updates.serviceHistory || null;
      if (updates.dimensions !== void 0) dbUpdates.dimensions = updates.dimensions || {};
      if (updates.powerRequirements !== void 0) dbUpdates.powerRequirements = updates.powerRequirements || null;
      if (updates.specifications !== void 0) dbUpdates.specifications = updates.specifications || {};
      if (updates.availabilityType !== void 0) {
        dbUpdates.availabilityType = updates.availabilityType;
        if (updates.availabilityType === "included") {
          dbUpdates.pricingModel = null;
          dbUpdates.hourlyRate = null;
          dbUpdates.dailyRate = null;
          dbUpdates.weeklyRate = null;
          dbUpdates.monthlyRate = null;
          dbUpdates.minimumRentalHours = null;
          dbUpdates.minimumRentalDays = null;
          dbUpdates.damageDeposit = "0";
        }
      }
      if (updates.pricingModel !== void 0) {
        if (updates.availabilityType === "rental" || !updates.availabilityType) {
          dbUpdates.pricingModel = updates.pricingModel;
        }
      }
      if (updates.minimumRentalHours !== void 0) {
        if (updates.availabilityType === "rental" || !updates.availabilityType) {
          dbUpdates.minimumRentalHours = updates.minimumRentalHours;
        }
      }
      if (updates.minimumRentalDays !== void 0) {
        if (updates.availabilityType === "rental" || !updates.availabilityType) {
          dbUpdates.minimumRentalDays = updates.minimumRentalDays || null;
        }
      }
      if (updates.usageRestrictions !== void 0) dbUpdates.usageRestrictions = updates.usageRestrictions;
      if (updates.trainingRequired !== void 0) dbUpdates.trainingRequired = updates.trainingRequired;
      if (updates.cleaningResponsibility !== void 0) dbUpdates.cleaningResponsibility = updates.cleaningResponsibility || null;
      if (updates.isActive !== void 0) dbUpdates.isActive = updates.isActive;
      if (updates.prepTimeHours !== void 0) dbUpdates.prepTimeHours = updates.prepTimeHours;
      if (updates.insuranceRequired !== void 0) dbUpdates.insuranceRequired = updates.insuranceRequired;
      if (updates.certifications !== void 0) dbUpdates.certifications = updates.certifications;
      if (updates.safetyFeatures !== void 0) dbUpdates.safetyFeatures = updates.safetyFeatures;
      if (updates.photos !== void 0) dbUpdates.photos = updates.photos;
      if (updates.manuals !== void 0) dbUpdates.manuals = updates.manuals;
      if (updates.maintenanceLog !== void 0) dbUpdates.maintenanceLog = updates.maintenanceLog;
      if (updates.availabilityCalendar !== void 0) dbUpdates.availabilityCalendar = updates.availabilityCalendar;
      if (updates.hourlyRate !== void 0) {
        if (updates.availabilityType === "rental" || !updates.availabilityType) {
          dbUpdates.hourlyRate = updates.hourlyRate === null ? null : Math.round(updates.hourlyRate * 100).toString();
        } else {
          dbUpdates.hourlyRate = null;
        }
      }
      if (updates.dailyRate !== void 0) {
        if (updates.availabilityType === "rental" || !updates.availabilityType) {
          dbUpdates.dailyRate = updates.dailyRate === null ? null : Math.round(updates.dailyRate * 100).toString();
        } else {
          dbUpdates.dailyRate = null;
        }
      }
      if (updates.weeklyRate !== void 0) {
        if (updates.availabilityType === "rental" || !updates.availabilityType) {
          dbUpdates.weeklyRate = updates.weeklyRate === null ? null : Math.round(updates.weeklyRate * 100).toString();
        } else {
          dbUpdates.weeklyRate = null;
        }
      }
      if (updates.monthlyRate !== void 0) {
        if (updates.availabilityType === "rental" || !updates.availabilityType) {
          dbUpdates.monthlyRate = updates.monthlyRate === null ? null : Math.round(updates.monthlyRate * 100).toString();
        } else {
          dbUpdates.monthlyRate = null;
        }
      }
      if (updates.damageDeposit !== void 0) {
        if (updates.availabilityType === "rental" || !updates.availabilityType) {
          dbUpdates.damageDeposit = updates.damageDeposit === null ? null : Math.round(updates.damageDeposit * 100).toString();
        } else {
          dbUpdates.damageDeposit = "0";
        }
      }
      const [updated] = await db.update(equipmentListings).set(dbUpdates).where(eq(equipmentListings.id, id)).returning();
      return await this.getEquipmentListingById(id);
    } catch (error) {
      console.error("Error updating equipment listing:", error);
      throw error;
    }
  }
  // Delete equipment listing
  async deleteEquipmentListing(id) {
    try {
      const result = await db.delete(equipmentListings).where(eq(equipmentListings.id, id)).returning({ id: equipmentListings.id });
      if (result.length === 0) {
        throw new Error(`Equipment listing with id ${id} not found`);
      }
      console.log(`\u2705 Equipment listing ${id} deleted successfully`);
    } catch (error) {
      console.error("Error deleting equipment listing:", error);
      throw error;
    }
  }
  // ==================== STORAGE BOOKING METHODS ====================
  /**
   * Create a storage booking
   * @param data - Storage booking data with prices in CENTS (internal use from booking flow)
   */
  async createStorageBooking(data) {
    try {
      const result = await db.insert(storageBookings).values({
        storageListingId: data.storageListingId,
        kitchenBookingId: data.kitchenBookingId,
        chefId: data.chefId,
        startDate: data.startDate,
        endDate: data.endDate,
        status: "pending",
        totalPrice: data.totalPriceCents.toString(),
        pricingModel: data.pricingModel,
        paymentStatus: "pending",
        serviceFee: (data.serviceFeeCents || 0).toString(),
        currency: data.currency || "CAD",
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      console.log(`\u2705 Storage booking created successfully with ID ${result[0].id}`);
      return result[0];
    } catch (error) {
      console.error("Error creating storage booking:", error);
      throw error;
    }
  }
  /**
   * Get storage bookings by kitchen booking ID
   * Returns prices in dollars for API response
   */
  async getStorageBookingsByKitchenBooking(kitchenBookingId) {
    try {
      if (pool && "query" in pool) {
        const result2 = await pool.query(
          `SELECT 
            sb.id, sb.storage_listing_id, sb.kitchen_booking_id, sb.chef_id,
            sb.start_date, sb.end_date, sb.status,
            sb.total_price::text as total_price,
            sb.pricing_model, sb.payment_status, sb.payment_intent_id,
            sb.service_fee::text as service_fee,
            sb.currency, sb.created_at, sb.updated_at,
            sl.name as storage_name, sl.storage_type
          FROM storage_bookings sb
          JOIN storage_listings sl ON sb.storage_listing_id = sl.id
          WHERE sb.kitchen_booking_id = $1
          ORDER BY sb.created_at DESC`,
          [kitchenBookingId]
        );
        return result2.rows.map((row) => ({
          id: row.id,
          storageListingId: row.storage_listing_id,
          kitchenBookingId: row.kitchen_booking_id,
          chefId: row.chef_id,
          startDate: row.start_date,
          endDate: row.end_date,
          status: row.status,
          totalPrice: row.total_price ? parseFloat(row.total_price) / 100 : 0,
          // Convert cents to dollars
          pricingModel: row.pricing_model,
          paymentStatus: row.payment_status,
          paymentIntentId: row.payment_intent_id,
          serviceFee: row.service_fee ? parseFloat(row.service_fee) / 100 : 0,
          // Convert cents to dollars
          currency: row.currency,
          createdAt: row.created_at,
          updatedAt: row.updated_at,
          storageName: row.storage_name,
          storageType: row.storage_type
        }));
      }
      const result = await db.select().from(storageBookings).where(eq(storageBookings.kitchenBookingId, kitchenBookingId));
      return result.map((row) => ({
        ...row,
        totalPrice: row.totalPrice ? parseFloat(row.totalPrice) / 100 : 0,
        serviceFee: row.serviceFee ? parseFloat(row.serviceFee) / 100 : 0
      }));
    } catch (error) {
      console.error("Error getting storage bookings:", error);
      throw error;
    }
  }
  /**
   * Get storage bookings by chef ID
   * Returns prices in dollars for API response
   */
  async getStorageBookingsByChef(chefId) {
    try {
      if (pool && "query" in pool) {
        const result = await pool.query(
          `SELECT 
            sb.id, sb.storage_listing_id, sb.kitchen_booking_id, sb.chef_id,
            sb.start_date, sb.end_date, sb.status,
            sb.total_price::text as total_price,
            sb.pricing_model, sb.payment_status, sb.payment_intent_id,
            sb.service_fee::text as service_fee,
            sb.currency, sb.created_at, sb.updated_at,
            sl.name as storage_name, sl.storage_type, sl.kitchen_id,
            k.name as kitchen_name
          FROM storage_bookings sb
          JOIN storage_listings sl ON sb.storage_listing_id = sl.id
          JOIN kitchens k ON sl.kitchen_id = k.id
          WHERE sb.chef_id = $1
          ORDER BY sb.start_date DESC`,
          [chefId]
        );
        return result.rows.map((row) => ({
          id: row.id,
          storageListingId: row.storage_listing_id,
          kitchenBookingId: row.kitchen_booking_id,
          chefId: row.chef_id,
          startDate: row.start_date,
          endDate: row.end_date,
          status: row.status,
          totalPrice: row.total_price ? parseFloat(row.total_price) / 100 : 0,
          pricingModel: row.pricing_model,
          paymentStatus: row.payment_status,
          paymentIntentId: row.payment_intent_id,
          serviceFee: row.service_fee ? parseFloat(row.service_fee) / 100 : 0,
          currency: row.currency,
          createdAt: row.created_at,
          updatedAt: row.updated_at,
          storageName: row.storage_name,
          storageType: row.storage_type,
          kitchenId: row.kitchen_id,
          kitchenName: row.kitchen_name
        }));
      }
      return [];
    } catch (error) {
      console.error("Error getting storage bookings by chef:", error);
      throw error;
    }
  }
  /**
   * Update storage booking status
   */
  async updateStorageBookingStatus(id, status, paymentStatus) {
    try {
      const updateData = {
        status,
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (paymentStatus) {
        updateData.paymentStatus = paymentStatus;
      }
      const result = await db.update(storageBookings).set(updateData).where(eq(storageBookings.id, id)).returning();
      if (result.length === 0) {
        throw new Error(`Storage booking with id ${id} not found`);
      }
      console.log(`\u2705 Storage booking ${id} status updated to ${status}`);
      return result[0];
    } catch (error) {
      console.error("Error updating storage booking status:", error);
      throw error;
    }
  }
  /**
   * Delete storage booking
   */
  async deleteStorageBooking(id) {
    try {
      const result = await db.delete(storageBookings).where(eq(storageBookings.id, id)).returning({ id: storageBookings.id });
      if (result.length === 0) {
        throw new Error(`Storage booking with id ${id} not found`);
      }
      console.log(`\u2705 Storage booking ${id} deleted successfully`);
    } catch (error) {
      console.error("Error deleting storage booking:", error);
      throw error;
    }
  }
  /**
   * Get storage booking by ID
   * Returns price in dollars for API response
   */
  async getStorageBookingById(id) {
    try {
      if (pool && "query" in pool) {
        const result = await pool.query(
          `SELECT 
            sb.id, sb.storage_listing_id, sb.kitchen_booking_id, sb.chef_id,
            sb.start_date, sb.end_date, sb.status,
            sb.total_price::text as total_price,
            sb.pricing_model, sb.payment_status, sb.payment_intent_id,
            sb.service_fee::text as service_fee,
            sb.currency, sb.created_at, sb.updated_at,
            sl.name as storage_name, sl.storage_type, sl.kitchen_id,
            sl.base_price::text as base_price,
            sl.minimum_booking_duration,
            k.name as kitchen_name
          FROM storage_bookings sb
          JOIN storage_listings sl ON sb.storage_listing_id = sl.id
          JOIN kitchens k ON sl.kitchen_id = k.id
          WHERE sb.id = $1`,
          [id]
        );
        if (result.rows.length === 0) {
          return void 0;
        }
        const row = result.rows[0];
        return {
          id: row.id,
          storageListingId: row.storage_listing_id,
          kitchenBookingId: row.kitchen_booking_id,
          chefId: row.chef_id,
          startDate: row.start_date,
          endDate: row.end_date,
          status: row.status,
          totalPrice: row.total_price ? parseFloat(row.total_price) / 100 : 0,
          pricingModel: row.pricing_model,
          paymentStatus: row.payment_status,
          paymentIntentId: row.payment_intent_id,
          serviceFee: row.service_fee ? parseFloat(row.service_fee) / 100 : 0,
          currency: row.currency,
          createdAt: row.created_at,
          updatedAt: row.updated_at,
          storageName: row.storage_name,
          storageType: row.storage_type,
          kitchenId: row.kitchen_id,
          kitchenName: row.kitchen_name,
          basePrice: row.base_price ? parseFloat(row.base_price) / 100 : 0,
          minimumBookingDuration: row.minimum_booking_duration
        };
      }
      return void 0;
    } catch (error) {
      console.error("Error getting storage booking by ID:", error);
      throw error;
    }
  }
  /**
   * Get platform service fee rate from settings
   * @returns Service fee rate as decimal (e.g., 0.05 for 5%)
   */
  async getServiceFeeRate() {
    try {
      const [setting] = await db.select().from(platformSettings).where(eq(platformSettings.key, "service_fee_rate")).limit(1);
      if (setting) {
        const rate = parseFloat(setting.value);
        if (!isNaN(rate) && rate >= 0 && rate <= 1) {
          return rate;
        }
      }
      return 0.05;
    } catch (error) {
      console.error("Error getting service fee rate:", error);
      return 0.05;
    }
  }
  /**
   * Extend storage booking to a new end date
   * Calculates additional cost based on the extension period
   * @param id - Storage booking ID
   * @param newEndDate - New end date for the booking
   * @returns Updated storage booking with new pricing
   */
  async extendStorageBooking(id, newEndDate) {
    try {
      const booking = await this.getStorageBookingById(id);
      if (!booking) {
        throw new Error(`Storage booking with id ${id} not found`);
      }
      const currentEndDate = new Date(booking.endDate);
      if (newEndDate <= currentEndDate) {
        throw new Error("New end date must be after the current end date");
      }
      const storageListing = await this.getStorageListingById(booking.storageListingId);
      if (!storageListing) {
        throw new Error(`Storage listing ${booking.storageListingId} not found`);
      }
      const extensionDays = Math.ceil((newEndDate.getTime() - currentEndDate.getTime()) / (1e3 * 60 * 60 * 24));
      const minDays = storageListing.minimumBookingDuration || 1;
      if (extensionDays < minDays) {
        throw new Error(`Extension must be at least ${minDays} day${minDays > 1 ? "s" : ""}`);
      }
      const serviceFeeRate = await this.getServiceFeeRate();
      const basePricePerDay = storageListing.basePrice || 0;
      const extensionBasePrice = basePricePerDay * extensionDays;
      const extensionServiceFee = extensionBasePrice * serviceFeeRate;
      const extensionTotalPrice = extensionBasePrice + extensionServiceFee;
      const extensionTotalPriceCents = Math.round(extensionTotalPrice * 100);
      const extensionServiceFeeCents = Math.round(extensionServiceFee * 100);
      const existingTotalPriceCents = Math.round(booking.totalPrice * 100);
      const existingServiceFeeCents = Math.round(booking.serviceFee * 100);
      const newTotalPriceCents = existingTotalPriceCents + extensionTotalPriceCents;
      const newServiceFeeCents = existingServiceFeeCents + extensionServiceFeeCents;
      const result = await db.update(storageBookings).set({
        endDate: newEndDate,
        totalPrice: newTotalPriceCents.toString(),
        serviceFee: newServiceFeeCents.toString(),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(storageBookings.id, id)).returning();
      if (result.length === 0) {
        throw new Error(`Failed to update storage booking ${id}`);
      }
      console.log(`\u2705 Storage booking ${id} extended to ${newEndDate.toISOString()}`);
      const updatedBooking = await this.getStorageBookingById(id);
      return {
        ...updatedBooking,
        extensionDetails: {
          extensionDays,
          extensionBasePrice,
          extensionServiceFee,
          extensionTotalPrice,
          newEndDate: newEndDate.toISOString()
        }
      };
    } catch (error) {
      console.error("Error extending storage booking:", error);
      throw error;
    }
  }
  /**
   * Process overstayer penalties for expired storage bookings
   * Charges 2x daily rate for each day past expiry
   * @param maxDaysToCharge - Maximum days to charge (default: 7 days)
   * @returns Array of processed bookings with penalty charges
   */
  async processOverstayerPenalties(maxDaysToCharge = 7) {
    try {
      if (!pool || !("query" in pool)) {
        console.warn("Database pool not available for overstayer penalty processing");
        return [];
      }
      const today = /* @__PURE__ */ new Date();
      today.setHours(0, 0, 0, 0);
      const result = await pool.query(
        `SELECT 
          sb.id, sb.storage_listing_id, sb.chef_id, sb.end_date, sb.total_price::text as total_price,
          sb.service_fee::text as service_fee, sb.payment_status, sb.payment_intent_id,
          sl.base_price::text as base_price, sl.minimum_booking_duration
        FROM storage_bookings sb
        JOIN storage_listings sl ON sb.storage_listing_id = sl.id
        WHERE sb.end_date < $1
          AND sb.status != 'cancelled'
          AND sb.payment_status != 'failed'
        ORDER BY sb.end_date ASC`,
        [today]
      );
      const processedBookings = [];
      for (const row of result.rows) {
        try {
          const bookingId = row.id;
          const endDate = new Date(row.end_date);
          const daysOverdue = Math.floor((today.getTime() - endDate.getTime()) / (1e3 * 60 * 60 * 24));
          const daysToCharge = Math.min(daysOverdue, maxDaysToCharge);
          if (daysToCharge <= 0) continue;
          const basePricePerDay = parseFloat(row.base_price) / 100;
          const penaltyRatePerDay = basePricePerDay * 2;
          const penaltyBasePrice = penaltyRatePerDay * daysToCharge;
          const serviceFeeRate = await this.getServiceFeeRate();
          const penaltyServiceFee = penaltyBasePrice * serviceFeeRate;
          const penaltyTotalPrice = penaltyBasePrice + penaltyServiceFee;
          const penaltyTotalPriceCents = Math.round(penaltyTotalPrice * 100);
          const penaltyServiceFeeCents = Math.round(penaltyServiceFee * 100);
          const currentTotalPriceCents = Math.round(parseFloat(row.total_price));
          const currentServiceFeeCents = Math.round(parseFloat(row.service_fee) || 0);
          const newTotalPriceCents = currentTotalPriceCents + penaltyTotalPriceCents;
          const newServiceFeeCents = currentServiceFeeCents + penaltyServiceFeeCents;
          const newEndDate = new Date(endDate);
          newEndDate.setDate(newEndDate.getDate() + daysToCharge);
          await db.update(storageBookings).set({
            endDate: newEndDate,
            totalPrice: newTotalPriceCents.toString(),
            serviceFee: newServiceFeeCents.toString(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq(storageBookings.id, bookingId));
          processedBookings.push({
            bookingId,
            chefId: row.chef_id,
            daysOverdue,
            daysCharged: daysToCharge,
            penaltyAmount: penaltyTotalPrice,
            newEndDate: newEndDate.toISOString()
          });
          console.log(`\u2705 Overstayer penalty applied to storage booking ${bookingId}: ${daysToCharge} days @ 2x rate = $${penaltyTotalPrice.toFixed(2)}`);
        } catch (error) {
          console.error(`Error processing overstayer penalty for booking ${row.id}:`, error);
        }
      }
      return processedBookings;
    } catch (error) {
      console.error("Error processing overstayer penalties:", error);
      throw error;
    }
  }
  // ==================== EQUIPMENT BOOKING METHODS ====================
  /**
   * Create an equipment booking
   * @param data - Equipment booking data with prices in CENTS (internal use from booking flow)
   */
  async createEquipmentBooking(data) {
    try {
      const result = await db.insert(equipmentBookings).values({
        equipmentListingId: data.equipmentListingId,
        kitchenBookingId: data.kitchenBookingId,
        chefId: data.chefId,
        startDate: data.startDate,
        endDate: data.endDate,
        status: "pending",
        totalPrice: data.totalPriceCents.toString(),
        pricingModel: data.pricingModel,
        paymentStatus: data.totalPriceCents > 0 ? "pending" : "not_required",
        damageDeposit: (data.damageDepositCents || 0).toString(),
        serviceFee: (data.serviceFeeCents || 0).toString(),
        currency: data.currency || "CAD",
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      console.log(`\u2705 Equipment booking created successfully with ID ${result[0].id}`);
      return result[0];
    } catch (error) {
      console.error("Error creating equipment booking:", error);
      throw error;
    }
  }
  /**
   * Get equipment bookings by kitchen booking ID
   * Returns prices in dollars for API response
   */
  async getEquipmentBookingsByKitchenBooking(kitchenBookingId) {
    try {
      if (pool && "query" in pool) {
        const result2 = await pool.query(
          `SELECT 
            eb.id, eb.equipment_listing_id, eb.kitchen_booking_id, eb.chef_id,
            eb.start_date, eb.end_date, eb.status,
            eb.total_price::text as total_price,
            eb.pricing_model, eb.payment_status, eb.payment_intent_id,
            eb.damage_deposit::text as damage_deposit,
            eb.service_fee::text as service_fee,
            eb.currency, eb.created_at, eb.updated_at,
            el.equipment_type, el.brand, el.model, el.availability_type
          FROM equipment_bookings eb
          JOIN equipment_listings el ON eb.equipment_listing_id = el.id
          WHERE eb.kitchen_booking_id = $1
          ORDER BY eb.created_at DESC`,
          [kitchenBookingId]
        );
        return result2.rows.map((row) => ({
          id: row.id,
          equipmentListingId: row.equipment_listing_id,
          kitchenBookingId: row.kitchen_booking_id,
          chefId: row.chef_id,
          startDate: row.start_date,
          endDate: row.end_date,
          status: row.status,
          totalPrice: row.total_price ? parseFloat(row.total_price) / 100 : 0,
          // Convert cents to dollars
          pricingModel: row.pricing_model,
          paymentStatus: row.payment_status,
          paymentIntentId: row.payment_intent_id,
          damageDeposit: row.damage_deposit ? parseFloat(row.damage_deposit) / 100 : 0,
          // Convert cents to dollars
          serviceFee: row.service_fee ? parseFloat(row.service_fee) / 100 : 0,
          // Convert cents to dollars
          currency: row.currency,
          createdAt: row.created_at,
          updatedAt: row.updated_at,
          equipmentType: row.equipment_type,
          brand: row.brand,
          model: row.model,
          availabilityType: row.availability_type
        }));
      }
      const result = await db.select().from(equipmentBookings).where(eq(equipmentBookings.kitchenBookingId, kitchenBookingId));
      return result.map((row) => ({
        ...row,
        totalPrice: row.totalPrice ? parseFloat(row.totalPrice) / 100 : 0,
        damageDeposit: row.damageDeposit ? parseFloat(row.damageDeposit) / 100 : 0,
        serviceFee: row.serviceFee ? parseFloat(row.serviceFee) / 100 : 0
      }));
    } catch (error) {
      console.error("Error getting equipment bookings:", error);
      throw error;
    }
  }
  /**
   * Get equipment bookings by chef ID
   * Returns prices in dollars for API response
   */
  async getEquipmentBookingsByChef(chefId) {
    try {
      if (pool && "query" in pool) {
        const result = await pool.query(
          `SELECT 
            eb.id, eb.equipment_listing_id, eb.kitchen_booking_id, eb.chef_id,
            eb.start_date, eb.end_date, eb.status,
            eb.total_price::text as total_price,
            eb.pricing_model, eb.payment_status, eb.payment_intent_id,
            eb.damage_deposit::text as damage_deposit,
            eb.service_fee::text as service_fee,
            eb.currency, eb.created_at, eb.updated_at,
            el.equipment_type, el.brand, el.model, el.availability_type, el.kitchen_id,
            k.name as kitchen_name
          FROM equipment_bookings eb
          JOIN equipment_listings el ON eb.equipment_listing_id = el.id
          JOIN kitchens k ON el.kitchen_id = k.id
          WHERE eb.chef_id = $1
          ORDER BY eb.start_date DESC`,
          [chefId]
        );
        return result.rows.map((row) => ({
          id: row.id,
          equipmentListingId: row.equipment_listing_id,
          kitchenBookingId: row.kitchen_booking_id,
          chefId: row.chef_id,
          startDate: row.start_date,
          endDate: row.end_date,
          status: row.status,
          totalPrice: row.total_price ? parseFloat(row.total_price) / 100 : 0,
          pricingModel: row.pricing_model,
          paymentStatus: row.payment_status,
          paymentIntentId: row.payment_intent_id,
          damageDeposit: row.damage_deposit ? parseFloat(row.damage_deposit) / 100 : 0,
          serviceFee: row.service_fee ? parseFloat(row.service_fee) / 100 : 0,
          currency: row.currency,
          createdAt: row.created_at,
          updatedAt: row.updated_at,
          equipmentType: row.equipment_type,
          brand: row.brand,
          model: row.model,
          availabilityType: row.availability_type,
          kitchenId: row.kitchen_id,
          kitchenName: row.kitchen_name
        }));
      }
      return [];
    } catch (error) {
      console.error("Error getting equipment bookings by chef:", error);
      throw error;
    }
  }
  /**
   * Update equipment booking status
   */
  async updateEquipmentBookingStatus(id, status, paymentStatus) {
    try {
      const updateData = {
        status,
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (paymentStatus) {
        updateData.paymentStatus = paymentStatus;
      }
      const result = await db.update(equipmentBookings).set(updateData).where(eq(equipmentBookings.id, id)).returning();
      if (result.length === 0) {
        throw new Error(`Equipment booking with id ${id} not found`);
      }
      console.log(`\u2705 Equipment booking ${id} status updated to ${status}`);
      return result[0];
    } catch (error) {
      console.error("Error updating equipment booking status:", error);
      throw error;
    }
  }
  /**
   * Delete equipment booking
   */
  async deleteEquipmentBooking(id) {
    try {
      const result = await db.delete(equipmentBookings).where(eq(equipmentBookings.id, id)).returning({ id: equipmentBookings.id });
      if (result.length === 0) {
        throw new Error(`Equipment booking with id ${id} not found`);
      }
      console.log(`\u2705 Equipment booking ${id} deleted successfully`);
    } catch (error) {
      console.error("Error deleting equipment booking:", error);
      throw error;
    }
  }
  async deleteKitchen(id) {
    try {
      const existingBookings = await db.select().from(kitchenBookings).where(eq(kitchenBookings.kitchenId, id));
      if (existingBookings.length > 0) {
        throw new Error(`Cannot delete kitchen: It has ${existingBookings.length} booking(s). Please cancel or reassign bookings first.`);
      }
      await db.transaction(async (tx) => {
        await tx.delete(kitchenAvailability).where(eq(kitchenAvailability.kitchenId, id));
        await tx.delete(kitchenDateOverrides).where(eq(kitchenDateOverrides.kitchenId, id));
        await tx.delete(kitchens).where(eq(kitchens.id, id));
      });
      console.log(`\u2705 Deleted kitchen ${id} and all related records`);
    } catch (error) {
      console.error("Error deleting kitchen:", error);
      throw error;
    }
  }
  // ===== KITCHEN AVAILABILITY MANAGEMENT =====
  async setKitchenAvailability(kitchenId, availability) {
    try {
      console.log("\u{1F552} Setting kitchen availability:", { kitchenId, ...availability });
      const isAvailable = availability.isAvailable !== void 0 ? availability.isAvailable : true;
      const existing = await db.select().from(kitchenAvailability).where(and(
        eq(kitchenAvailability.kitchenId, kitchenId),
        eq(kitchenAvailability.dayOfWeek, availability.dayOfWeek)
      ));
      console.log(`\u{1F50D} Found ${existing.length} existing availability records for kitchen ${kitchenId}, day ${availability.dayOfWeek}`);
      if (existing.length > 0) {
        console.log("\u{1F504} Updating existing availability record:", existing[0].id);
        const [updated] = await db.update(kitchenAvailability).set({
          startTime: availability.startTime,
          endTime: availability.endTime,
          isAvailable
        }).where(and(
          eq(kitchenAvailability.kitchenId, kitchenId),
          eq(kitchenAvailability.dayOfWeek, availability.dayOfWeek)
        )).returning();
        console.log("\u2705 Updated availability:", updated);
        return updated;
      } else {
        console.log("\u2795 Creating new availability record");
        const insertData = {
          kitchenId,
          dayOfWeek: availability.dayOfWeek,
          startTime: availability.startTime,
          endTime: availability.endTime,
          isAvailable
        };
        console.log("\u{1F4DD} Insert data:", insertData);
        const [created] = await db.insert(kitchenAvailability).values(insertData).returning();
        console.log("\u2705 Availability created successfully:", created);
        return created;
      }
    } catch (error) {
      console.error("Error setting kitchen availability:", error);
      console.error("Error message:", error.message);
      console.error("Error code:", error.code);
      throw error;
    }
  }
  async getKitchenAvailability(kitchenId) {
    try {
      return await db.select().from(kitchenAvailability).where(eq(kitchenAvailability.kitchenId, kitchenId));
    } catch (error) {
      console.error("Error getting kitchen availability:", error);
      throw error;
    }
  }
  // ===== KITCHEN DATE OVERRIDES MANAGEMENT =====
  async getKitchenDateOverrideById(id) {
    try {
      const [override] = await db.select().from(kitchenDateOverrides).where(eq(kitchenDateOverrides.id, id));
      return override || void 0;
    } catch (error) {
      console.error("Error getting kitchen date override by ID:", error);
      throw error;
    }
  }
  async createKitchenDateOverride(overrideData) {
    try {
      const dateStr = overrideData.specificDate.toISOString().split("T")[0];
      const existingOverrides = await db.select().from(kitchenDateOverrides).where(eq(kitchenDateOverrides.kitchenId, overrideData.kitchenId));
      const existing = existingOverrides.find((o) => {
        const existingDateStr = new Date(o.specificDate).toISOString().split("T")[0];
        return existingDateStr === dateStr;
      });
      if (existing) {
        console.log(`\u{1F4DD} Updating existing override ID ${existing.id} for date ${dateStr}`);
        const [updated] = await db.update(kitchenDateOverrides).set({
          startTime: overrideData.startTime,
          endTime: overrideData.endTime,
          isAvailable: overrideData.isAvailable,
          reason: overrideData.reason,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(kitchenDateOverrides.id, existing.id)).returning();
        return updated;
      }
      console.log(`\u2795 Creating new override for date ${dateStr}`);
      const [override] = await db.insert(kitchenDateOverrides).values(overrideData).returning();
      return override;
    } catch (error) {
      console.error("Error creating kitchen date override:", error);
      throw error;
    }
  }
  async getKitchenDateOverrides(kitchenId, startDate, endDate) {
    try {
      let query = db.select().from(kitchenDateOverrides).where(eq(kitchenDateOverrides.kitchenId, kitchenId));
      if (startDate && endDate) {
        return await query.then(
          (results) => results.filter((r) => {
            const overrideDate = new Date(r.specificDate);
            return overrideDate >= startDate && overrideDate <= endDate;
          })
        );
      }
      return await query;
    } catch (error) {
      console.error("Error getting kitchen date overrides:", error);
      throw error;
    }
  }
  async getKitchenDateOverrideForDate(kitchenId, date2) {
    try {
      let targetDateStr;
      if (typeof date2 === "string") {
        targetDateStr = date2.split("T")[0];
      } else if (date2 instanceof Date) {
        targetDateStr = date2.toISOString().split("T")[0];
      } else {
        throw new Error("Invalid date type");
      }
      console.log(`\u{1F50D} Looking for date override - kitchen: ${kitchenId}, target date: ${targetDateStr}`);
      const allOverrides = await db.select().from(kitchenDateOverrides).where(eq(kitchenDateOverrides.kitchenId, kitchenId));
      console.log(`   Found ${allOverrides.length} total overrides for kitchen ${kitchenId}`);
      const dateOverrides = allOverrides.filter((o) => {
        const overrideDateStr = new Date(o.specificDate).toISOString().split("T")[0];
        const matches = overrideDateStr === targetDateStr;
        if (matches) {
          console.log(`   Found override ID ${o.id}: isAvailable=${o.isAvailable}, startTime=${o.startTime}, endTime=${o.endTime}`);
        }
        return matches;
      });
      if (dateOverrides.length === 0) {
        console.log(`   Result: NO MATCH`);
        return void 0;
      }
      const availableOverride = dateOverrides.find(
        (o) => o.isAvailable === true && o.startTime && o.endTime
      );
      if (availableOverride) {
        console.log(`   Result: FOUND AVAILABLE override ID ${availableOverride.id}`);
        return availableOverride;
      }
      const override = dateOverrides[0];
      console.log(`   Result: FOUND override ID ${override.id} (isAvailable=${override.isAvailable})`);
      return override;
    } catch (error) {
      console.error("Error getting kitchen date override for specific date:", error);
      throw error;
    }
  }
  async updateKitchenDateOverride(id, updateData) {
    try {
      const [updated] = await db.update(kitchenDateOverrides).set({ ...updateData, updatedAt: /* @__PURE__ */ new Date() }).where(eq(kitchenDateOverrides.id, id)).returning();
      return updated;
    } catch (error) {
      console.error("Error updating kitchen date override:", error);
      throw error;
    }
  }
  async deleteKitchenDateOverride(id) {
    try {
      await db.delete(kitchenDateOverrides).where(eq(kitchenDateOverrides.id, id));
    } catch (error) {
      console.error("Error deleting kitchen date override:", error);
      throw error;
    }
  }
  // ===== KITCHEN BOOKINGS MANAGEMENT =====
  async createKitchenBooking(bookingData) {
    try {
      console.log("Inserting kitchen booking into database:", bookingData);
      const { calculateKitchenBookingPrice: calculateKitchenBookingPrice2, calculatePlatformFeeDynamic: calculatePlatformFeeDynamic2, calculateTotalWithFees: calculateTotalWithFees2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
      const pricing = await calculateKitchenBookingPrice2(
        bookingData.kitchenId,
        bookingData.startTime,
        bookingData.endTime,
        pool
      );
      const serviceFeeCents = await calculatePlatformFeeDynamic2(pricing.totalPriceCents, pool);
      const totalWithFeesCents = calculateTotalWithFees2(
        pricing.totalPriceCents,
        serviceFeeCents,
        0
        // No damage deposit for kitchen bookings alone
      );
      const insertData = {
        chefId: bookingData.chefId,
        kitchenId: bookingData.kitchenId,
        bookingDate: bookingData.bookingDate,
        startTime: bookingData.startTime,
        endTime: bookingData.endTime,
        // Pricing fields (stored as strings for numeric type)
        totalPrice: totalWithFeesCents.toString(),
        hourlyRate: pricing.hourlyRateCents.toString(),
        durationHours: pricing.durationHours.toString(),
        serviceFee: serviceFeeCents.toString(),
        currency: pricing.currency,
        paymentStatus: "pending",
        storageItems: [],
        equipmentItems: []
      };
      if (bookingData.specialNotes !== void 0 && bookingData.specialNotes !== null && bookingData.specialNotes !== "") {
        insertData.specialNotes = bookingData.specialNotes;
      }
      console.log("Insert data:", insertData);
      const [booking] = await db.insert(kitchenBookings).values(insertData).returning();
      console.log("Kitchen booking created successfully:", booking);
      return booking;
    } catch (error) {
      console.error("Error creating kitchen booking:", error);
      console.error("Error message:", error.message);
      console.error("Error code:", error.code);
      throw error;
    }
  }
  // Create booking with support for external/third-party bookings
  async createBooking(bookingData) {
    try {
      console.log("Creating booking (with external support):", bookingData);
      const { calculateKitchenBookingPrice: calculateKitchenBookingPrice2, calculatePlatformFeeDynamic: calculatePlatformFeeDynamic2, calculateTotalWithFees: calculateTotalWithFees2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
      const pricing = await calculateKitchenBookingPrice2(
        bookingData.kitchenId,
        bookingData.startTime,
        bookingData.endTime,
        pool
      );
      const serviceFeeCents = await calculatePlatformFeeDynamic2(pricing.totalPriceCents, pool);
      const totalWithFeesCents = calculateTotalWithFees2(
        pricing.totalPriceCents,
        serviceFeeCents,
        0
        // No damage deposit for kitchen bookings alone
      );
      const insertData = {
        kitchenId: bookingData.kitchenId,
        bookingDate: bookingData.bookingDate,
        startTime: bookingData.startTime,
        endTime: bookingData.endTime,
        bookingType: bookingData.bookingType || "chef",
        chefId: bookingData.chefId || bookingData.createdBy || null,
        createdBy: bookingData.createdBy || null,
        // Pricing fields (stored as strings for numeric type)
        totalPrice: totalWithFeesCents.toString(),
        hourlyRate: pricing.hourlyRateCents.toString(),
        durationHours: pricing.durationHours.toString(),
        serviceFee: serviceFeeCents.toString(),
        currency: pricing.currency,
        paymentStatus: bookingData.paymentStatus || "pending",
        paymentIntentId: bookingData.paymentIntentId || null,
        storageItems: [],
        equipmentItems: []
      };
      if (bookingData.specialNotes) {
        insertData.specialNotes = bookingData.specialNotes;
      }
      if (bookingData.externalContact) {
        insertData.externalContactName = bookingData.externalContact.name;
        insertData.externalContactEmail = bookingData.externalContact.email;
        insertData.externalContactPhone = bookingData.externalContact.phone || null;
        insertData.externalContactCompany = bookingData.externalContact.company || null;
      }
      const kitchen = await this.getKitchenById(bookingData.kitchenId);
      const kitchenName = kitchen?.name || "Kitchen";
      const [booking] = await db.insert(kitchenBookings).values(insertData).returning();
      console.log("Booking created successfully:", booking);
      return {
        ...booking,
        kitchenName
      };
    } catch (error) {
      console.error("Error creating booking:", error);
      throw error;
    }
  }
  async getKitchenBookingById(id) {
    try {
      const [booking] = await db.select().from(kitchenBookings).where(eq(kitchenBookings.id, id));
      return booking || void 0;
    } catch (error) {
      console.error("Error getting kitchen booking by ID:", error);
      throw error;
    }
  }
  async getBookingsByChef(chefId) {
    try {
      console.log(`[STORAGE] getBookingsByChef called with chefId: ${chefId}`);
      console.log(`[STORAGE] Database connection check - pool exists: ${!!pool}, db exists: ${!!db}`);
      const results = await db.select({
        booking: kitchenBookings,
        kitchen: kitchens,
        location: locations
      }).from(kitchenBookings).innerJoin(kitchens, eq(kitchenBookings.kitchenId, kitchens.id)).innerJoin(locations, eq(kitchens.locationId, locations.id)).where(eq(kitchenBookings.chefId, chefId)).orderBy(asc(kitchenBookings.bookingDate));
      console.log(`[STORAGE] Raw query returned ${results.length} results`);
      const mappedResults = results.map((r) => ({
        ...r.booking,
        kitchen: r.kitchen,
        location: {
          id: r.location.id,
          name: r.location.name,
          cancellationPolicyHours: r.location.cancellationPolicyHours,
          cancellationPolicyMessage: r.location.cancellationPolicyMessage
        }
      }));
      console.log(`[STORAGE] Mapped ${mappedResults.length} bookings for chef ${chefId}`);
      return mappedResults;
    } catch (error) {
      console.error("Error getting bookings by chef:", error);
      throw error;
    }
  }
  async getBookingsByKitchen(kitchenId) {
    try {
      return await db.select().from(kitchenBookings).where(eq(kitchenBookings.kitchenId, kitchenId)).orderBy(asc(kitchenBookings.bookingDate));
    } catch (error) {
      console.error("Error getting bookings by kitchen:", error);
      throw error;
    }
  }
  async getBookingsByManager(managerId) {
    try {
      if (!pool) {
        return [];
      }
      const locationsResult = await pool.query(
        "SELECT id FROM locations WHERE manager_id = $1",
        [managerId]
      );
      const locationIds = locationsResult.rows.map((row) => row.id);
      if (locationIds.length === 0) {
        return [];
      }
      const kitchensResult = await pool.query(
        "SELECT id FROM kitchens WHERE location_id = ANY($1::int[])",
        [locationIds]
      );
      const kitchenIds = kitchensResult.rows.map((row) => row.id);
      if (kitchenIds.length === 0) {
        return [];
      }
      const bookingsResult = await pool.query(
        `SELECT 
          id, chef_id, kitchen_id, booking_date, start_time, end_time, 
          status, special_notes, created_at, updated_at,
          total_price, payment_status, payment_intent_id, service_fee, currency
        FROM kitchen_bookings 
        WHERE kitchen_id = ANY($1::int[])
        ORDER BY booking_date DESC, start_time ASC`,
        [kitchenIds]
      );
      const enrichedBookings = await Promise.all(
        bookingsResult.rows.map(async (booking) => {
          let chefName = null;
          if (booking.chef_id) {
            try {
              const chefResult = await pool.query(
                "SELECT id, username FROM users WHERE id = $1",
                [booking.chef_id]
              );
              const chef = chefResult.rows[0];
              if (chef) {
                chefName = chef.username;
                const appResult = await pool.query(
                  "SELECT full_name FROM applications WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1",
                  [booking.chef_id]
                );
                if (appResult.rows.length > 0 && appResult.rows[0].full_name) {
                  chefName = appResult.rows[0].full_name;
                }
              }
            } catch (error) {
            }
          }
          let kitchenName = "Kitchen";
          let locationId = null;
          if (booking.kitchen_id) {
            try {
              const kitchenResult = await pool.query(
                "SELECT id, name, location_id FROM kitchens WHERE id = $1",
                [booking.kitchen_id]
              );
              const kitchen = kitchenResult.rows[0];
              if (kitchen) {
                kitchenName = kitchen.name || "Kitchen";
                locationId = kitchen.location_id;
              }
            } catch (error) {
            }
          }
          let locationName = null;
          let locationTimezone = DEFAULT_TIMEZONE;
          if (locationId) {
            try {
              const locationResult = await pool.query(
                "SELECT id, name, timezone FROM locations WHERE id = $1",
                [locationId]
              );
              const location = locationResult.rows[0];
              if (location) {
                locationName = location.name;
                locationTimezone = location.timezone || DEFAULT_TIMEZONE;
              }
            } catch (error) {
            }
          }
          return {
            id: booking.id,
            chefId: booking.chef_id,
            kitchenId: booking.kitchen_id,
            bookingDate: booking.booking_date,
            startTime: booking.start_time,
            endTime: booking.end_time,
            status: booking.status,
            specialNotes: booking.special_notes,
            createdAt: booking.created_at,
            updatedAt: booking.updated_at,
            chefName,
            kitchenName,
            locationName,
            locationTimezone,
            // Include payment fields for revenue dashboard
            totalPrice: booking.total_price ? parseInt(String(booking.total_price)) || 0 : null,
            paymentStatus: booking.payment_status || null,
            paymentIntentId: booking.payment_intent_id || null,
            serviceFee: booking.service_fee ? parseInt(String(booking.service_fee)) || 0 : null,
            currency: booking.currency || "CAD"
          };
        })
      );
      return enrichedBookings;
    } catch (error) {
      console.error("Error getting bookings by manager:", error);
      throw error;
    }
  }
  async updateKitchenBookingStatus(id, status) {
    try {
      const [updated] = await db.update(kitchenBookings).set({ status, updatedAt: /* @__PURE__ */ new Date() }).where(eq(kitchenBookings.id, id)).returning();
      return updated;
    } catch (error) {
      console.error("Error updating kitchen booking status:", error);
      throw error;
    }
  }
  async cancelKitchenBooking(id, chefId) {
    try {
      const [booking] = await db.select().from(kitchenBookings).where(and(
        eq(kitchenBookings.id, id),
        eq(kitchenBookings.chefId, chefId)
      ));
      if (!booking) {
        throw new Error("Booking not found or you do not have permission to cancel it");
      }
      const [updated] = await db.update(kitchenBookings).set({ status: "cancelled", updatedAt: /* @__PURE__ */ new Date() }).where(eq(kitchenBookings.id, id)).returning();
      return updated;
    } catch (error) {
      console.error("Error cancelling kitchen booking:", error);
      throw error;
    }
  }
  async getBookingById(id) {
    try {
      const [booking] = await db.select().from(kitchenBookings).where(eq(kitchenBookings.id, id));
      return booking;
    } catch (error) {
      console.error("Error getting booking by ID:", error);
      throw error;
    }
  }
  async deleteKitchenBooking(id) {
    try {
      await db.delete(kitchenBookings).where(eq(kitchenBookings.id, id));
      console.log(`\u2705 Deleted booking ${id}`);
    } catch (error) {
      console.error("Error deleting kitchen booking:", error);
      throw error;
    }
  }
  // New method: Get ALL time slots with booking info (for chef view)
  async getAllTimeSlotsWithBookingInfo(kitchenId, date2) {
    try {
      console.log(`\u{1F550} Getting all slots with booking info for kitchen ${kitchenId}, date: ${date2.toISOString()}`);
      const dateOverride = await this.getKitchenDateOverrideForDate(kitchenId, date2);
      let startHour;
      let endHour;
      let capacity;
      if (dateOverride) {
        if (!dateOverride.isAvailable) {
          console.log(`\u274C Kitchen closed on this date (override)`);
          return [];
        }
        if (dateOverride.startTime && dateOverride.endTime) {
          startHour = parseInt(dateOverride.startTime.split(":")[0]);
          endHour = parseInt(dateOverride.endTime.split(":")[0]);
          capacity = dateOverride.maxConcurrentBookings ?? dateOverride.max_concurrent_bookings ?? 1;
          console.log(`\u2705 Using override hours: ${startHour}:00 - ${endHour}:00, capacity: ${capacity}`);
        } else {
          console.log(`\u26A0\uFE0F Override says available but no times specified`);
          return [];
        }
      } else {
        const dayOfWeek = date2.getDay();
        const availability = await this.getKitchenAvailability(kitchenId);
        const dayAvailability = availability.find((a) => a.dayOfWeek === dayOfWeek);
        if (!dayAvailability || !dayAvailability.isAvailable) {
          console.log(`\u274C Kitchen not available on day ${dayOfWeek} (weekly schedule)`);
          return [];
        }
        startHour = parseInt(dayAvailability.startTime.split(":")[0]);
        endHour = parseInt(dayAvailability.endTime.split(":")[0]);
        capacity = dayAvailability.maxConcurrentBookings ?? dayAvailability.max_concurrent_bookings ?? 1;
        console.log(`\u2705 Using weekly schedule hours: ${startHour}:00 - ${endHour}:00, capacity: ${capacity}`);
      }
      const allSlots = [];
      for (let hour = startHour; hour < endHour; hour++) {
        allSlots.push(`${hour.toString().padStart(2, "0")}:00`);
      }
      const bookings = await this.getBookingsByKitchen(kitchenId);
      const dateStr = date2.toISOString().split("T")[0];
      const dayBookings = bookings.filter((b) => {
        const bookingDateStr = new Date(b.bookingDate).toISOString().split("T")[0];
        return bookingDateStr === dateStr && b.status !== "cancelled";
      });
      const slotBookingCounts = /* @__PURE__ */ new Map();
      allSlots.forEach((slot) => slotBookingCounts.set(slot, 0));
      dayBookings.forEach((booking) => {
        const [startHours, startMins] = booking.startTime.split(":").map(Number);
        const [endHours, endMins] = booking.endTime.split(":").map(Number);
        const startTotalMins = startHours * 60 + startMins;
        const endTotalMins = endHours * 60 + endMins;
        allSlots.forEach((slot) => {
          const [slotHours, slotMins] = slot.split(":").map(Number);
          const slotTotalMins = slotHours * 60 + slotMins;
          if (slotTotalMins >= startTotalMins && slotTotalMins < endTotalMins) {
            slotBookingCounts.set(slot, (slotBookingCounts.get(slot) || 0) + 1);
          }
        });
      });
      const result = allSlots.map((slot) => {
        const bookedCount = slotBookingCounts.get(slot) || 0;
        return {
          time: slot,
          available: Math.max(0, capacity - bookedCount),
          capacity,
          isFullyBooked: bookedCount >= capacity
        };
      });
      console.log(`\u{1F4C5} Generated ${result.length} total slots`);
      return result;
    } catch (error) {
      console.error("Error getting all time slots with booking info:", error);
      throw error;
    }
  }
  async getAvailableTimeSlots(kitchenId, date2) {
    try {
      console.log(`\u{1F550} Getting slots for kitchen ${kitchenId}, date: ${date2.toISOString()}`);
      const dateOverride = await this.getKitchenDateOverrideForDate(kitchenId, date2);
      console.log(`\u{1F4C5} Date override found:`, dateOverride ? "YES" : "NO");
      if (dateOverride) {
        console.log(`   Override details:`, {
          isAvailable: dateOverride.isAvailable,
          startTime: dateOverride.startTime,
          endTime: dateOverride.endTime,
          reason: dateOverride.reason
        });
      }
      let startHour;
      let endHour;
      if (dateOverride) {
        if (!dateOverride.isAvailable) {
          console.log(`\u274C Kitchen closed on this date (override)`);
          return [];
        }
        if (dateOverride.startTime && dateOverride.endTime) {
          startHour = parseInt(dateOverride.startTime.split(":")[0]);
          endHour = parseInt(dateOverride.endTime.split(":")[0]);
          console.log(`\u2705 Using override hours: ${startHour}:00 - ${endHour}:00`);
        } else {
          console.log(`\u26A0\uFE0F Override says available but no times specified`);
          return [];
        }
      } else {
        const dayOfWeek = date2.getDay();
        const availability = await this.getKitchenAvailability(kitchenId);
        console.log(`\u{1F4C6} No override, checking weekly schedule for day ${dayOfWeek}`);
        const dayAvailability = availability.find((a) => a.dayOfWeek === dayOfWeek);
        if (!dayAvailability || !dayAvailability.isAvailable) {
          console.log(`\u274C Kitchen not available on day ${dayOfWeek} (weekly schedule)`);
          return [];
        }
        startHour = parseInt(dayAvailability.startTime.split(":")[0]);
        endHour = parseInt(dayAvailability.endTime.split(":")[0]);
        console.log(`\u2705 Using weekly schedule hours: ${startHour}:00 - ${endHour}:00`);
      }
      const slots = [];
      for (let hour = startHour; hour < endHour; hour++) {
        slots.push(`${hour.toString().padStart(2, "0")}:00`);
      }
      const bookings = await this.getBookingsByKitchen(kitchenId);
      const dateStr = date2.toISOString().split("T")[0];
      const dayBookings = bookings.filter((b) => {
        const bookingDateStr = new Date(b.bookingDate).toISOString().split("T")[0];
        return bookingDateStr === dateStr && b.status !== "cancelled";
      });
      const bookedSlots = /* @__PURE__ */ new Set();
      dayBookings.forEach((booking) => {
        const [startHours, startMins] = booking.startTime.split(":").map(Number);
        const [endHours, endMins] = booking.endTime.split(":").map(Number);
        const startTotalMins = startHours * 60 + startMins;
        const endTotalMins = endHours * 60 + endMins;
        for (const slot of slots) {
          const [slotHours, slotMins] = slot.split(":").map(Number);
          const slotTotalMins = slotHours * 60 + slotMins;
          if (slotTotalMins >= startTotalMins && slotTotalMins < endTotalMins) {
            bookedSlots.add(slot);
          }
        }
      });
      console.log(`\u{1F4C5} Generated ${slots.length} total slots, ${bookedSlots.size} booked, returning ${slots.length - bookedSlots.size} available`);
      return slots.filter((slot) => !bookedSlots.has(slot));
    } catch (error) {
      console.error("Error getting available time slots:", error);
      throw error;
    }
  }
  // Get available slots in format expected by public API
  async getAvailableSlots(kitchenId, dateStr) {
    try {
      const date2 = new Date(dateStr);
      const slots = await this.getAvailableTimeSlots(kitchenId, date2);
      return slots.map((time) => ({ time, available: true }));
    } catch (error) {
      console.error("Error getting available slots:", error);
      return [];
    }
  }
  // Get location manager
  async getLocationManager(locationId) {
    try {
      const location = await this.getLocationById(locationId);
      if (!location || !location.managerId) return void 0;
      return await this.getUser(location.managerId);
    } catch (error) {
      console.error("Error getting location manager:", error);
      return void 0;
    }
  }
  // Validate that booking time is within manager-set availability
  async validateBookingAvailability(kitchenId, bookingDate, startTime, endTime) {
    try {
      if (startTime >= endTime) {
        return { valid: false, error: "End time must be after start time" };
      }
      const dateOverride = await this.getKitchenDateOverrideForDate(kitchenId, bookingDate);
      let availabilityStartTime;
      let availabilityEndTime;
      if (dateOverride) {
        if (!dateOverride.isAvailable) {
          return { valid: false, error: "Kitchen is closed on this date" };
        }
        if (dateOverride.startTime && dateOverride.endTime) {
          availabilityStartTime = dateOverride.startTime;
          availabilityEndTime = dateOverride.endTime;
        } else {
          return { valid: false, error: "Kitchen availability not properly configured for this date" };
        }
      } else {
        const dayOfWeek = bookingDate.getDay();
        const availability = await this.getKitchenAvailability(kitchenId);
        const dayAvailability = availability.find((a) => a.dayOfWeek === dayOfWeek);
        if (!dayAvailability || !dayAvailability.isAvailable) {
          return { valid: false, error: "Kitchen is not available on this day" };
        }
        availabilityStartTime = dayAvailability.startTime;
        availabilityEndTime = dayAvailability.endTime;
      }
      if (startTime < availabilityStartTime || endTime > availabilityEndTime) {
        return { valid: false, error: "Booking time must be within manager-set available hours" };
      }
      const startHour = parseInt(startTime.split(":")[0]);
      const availabilityStartHour = parseInt(availabilityStartTime.split(":")[0]);
      const availabilityEndHour = parseInt(availabilityEndTime.split(":")[0]);
      if (startHour < availabilityStartHour || startHour >= availabilityEndHour) {
        return { valid: false, error: "Start time must be within manager-set available slot times" };
      }
      return { valid: true };
    } catch (error) {
      console.error("Error validating booking availability:", error);
      return { valid: false, error: "Error validating booking availability" };
    }
  }
  async checkBookingConflict(kitchenId, bookingDate, startTime, endTime) {
    try {
      const bookings = await db.select().from(kitchenBookings).where(and(
        eq(kitchenBookings.kitchenId, kitchenId),
        or(
          eq(kitchenBookings.status, "confirmed"),
          eq(kitchenBookings.status, "pending")
        )
      ));
      const targetDateStr = bookingDate.toISOString().split("T")[0];
      for (const booking of bookings) {
        const bookingDateTime = new Date(booking.bookingDate);
        const bookingDateStr = bookingDateTime.toISOString().split("T")[0];
        if (bookingDateStr === targetDateStr) {
          if (startTime < booking.endTime && endTime > booking.startTime) {
            return true;
          }
        }
      }
      return false;
    } catch (error) {
      console.error("Error checking booking conflict:", error);
      return true;
    }
  }
  // ===== CHEF KITCHEN ACCESS MANAGEMENT (Admin grants access) =====
  // ===== CHEF LOCATION ACCESS MANAGEMENT (Admin grants access to locations) =====
  // When a chef has access to a location, they can book any kitchen within that location
  async grantChefLocationAccess(chefId, locationId, grantedBy) {
    try {
      const [access] = await db.insert(chefLocationAccess).values({
        chefId,
        locationId,
        grantedBy
      }).onConflictDoNothing().returning();
      return access;
    } catch (error) {
      console.error("Error granting chef location access:", error);
      throw error;
    }
  }
  async revokeChefLocationAccess(chefId, locationId) {
    try {
      await db.delete(chefLocationAccess).where(
        and(
          eq(chefLocationAccess.chefId, chefId),
          eq(chefLocationAccess.locationId, locationId)
        )
      );
    } catch (error) {
      console.error("Error revoking chef location access:", error);
      throw error;
    }
  }
  async getChefLocationAccess(chefId) {
    try {
      return await db.select().from(chefLocationAccess).where(eq(chefLocationAccess.chefId, chefId));
    } catch (error) {
      console.error("Error getting chef location access:", error);
      throw error;
    }
  }
  // Helper: Check if chef has access to a location (used for booking validation)
  async chefHasLocationAccess(chefId, locationId) {
    try {
      const access = await db.select().from(chefLocationAccess).where(
        and(
          eq(chefLocationAccess.chefId, chefId),
          eq(chefLocationAccess.locationId, locationId)
        )
      ).limit(1);
      return access.length > 0;
    } catch (error) {
      console.error("Error checking chef location access:", error);
      return false;
    }
  }
  // Helper: Get location ID for a kitchen
  async getKitchenLocation(kitchenId) {
    try {
      const [kitchen] = await db.select({ locationId: kitchens.locationId }).from(kitchens).where(eq(kitchens.id, kitchenId)).limit(1);
      return kitchen?.locationId ?? null;
    } catch (error) {
      console.error("Error getting kitchen location:", error);
      return null;
    }
  }
  // Legacy methods - kept for backward compatibility
  async grantChefKitchenAccess(chefId, kitchenId, grantedBy) {
    try {
      const [access] = await db.insert(chefKitchenAccess).values({
        chefId,
        kitchenId,
        grantedBy
      }).onConflictDoNothing().returning();
      return access;
    } catch (error) {
      console.error("Error granting chef kitchen access:", error);
      throw error;
    }
  }
  async revokeChefKitchenAccess(chefId, kitchenId) {
    try {
      await db.delete(chefKitchenAccess).where(
        and(
          eq(chefKitchenAccess.chefId, chefId),
          eq(chefKitchenAccess.kitchenId, kitchenId)
        )
      );
    } catch (error) {
      console.error("Error revoking chef kitchen access:", error);
      throw error;
    }
  }
  async getChefKitchenAccess(chefId) {
    try {
      return await db.select().from(chefKitchenAccess).where(eq(chefKitchenAccess.chefId, chefId));
    } catch (error) {
      console.error("Error getting chef kitchen access:", error);
      throw error;
    }
  }
  // ===== CHEF KITCHEN PROFILE MANAGEMENT (Chef shares, Manager approves) =====
  async shareChefProfileWithKitchen(chefId, kitchenId) {
    try {
      const existing = await db.select().from(chefKitchenProfiles).where(
        and(
          eq(chefKitchenProfiles.chefId, chefId),
          eq(chefKitchenProfiles.kitchenId, kitchenId)
        )
      );
      if (existing.length > 0) {
        if (existing[0].status === "rejected") {
          const [updated] = await db.update(chefKitchenProfiles).set({
            status: "pending",
            sharedAt: /* @__PURE__ */ new Date(),
            reviewedBy: null,
            reviewedAt: null,
            reviewFeedback: null
          }).where(eq(chefKitchenProfiles.id, existing[0].id)).returning();
          return updated;
        }
        return existing[0];
      }
      const [profile] = await db.insert(chefKitchenProfiles).values({
        chefId,
        kitchenId,
        status: "pending"
      }).returning();
      return profile;
    } catch (error) {
      console.error("Error sharing chef profile with kitchen:", error);
      throw error;
    }
  }
  async updateChefKitchenProfileStatus(profileId, status, reviewedBy, reviewFeedback) {
    try {
      const [updated] = await db.update(chefKitchenProfiles).set({
        status,
        reviewedBy,
        reviewedAt: /* @__PURE__ */ new Date(),
        reviewFeedback: reviewFeedback || null
      }).where(eq(chefKitchenProfiles.id, profileId)).returning();
      return updated;
    } catch (error) {
      console.error("Error updating chef kitchen profile status:", error);
      throw error;
    }
  }
  async getChefKitchenProfile(chefId, kitchenId) {
    try {
      const [profile] = await db.select().from(chefKitchenProfiles).where(
        and(
          eq(chefKitchenProfiles.chefId, chefId),
          eq(chefKitchenProfiles.kitchenId, kitchenId)
        )
      );
      return profile || void 0;
    } catch (error) {
      console.error("Error getting chef kitchen profile:", error);
      throw error;
    }
  }
  async getChefProfilesForManager(managerId) {
    try {
      const managerLocations = await db.select().from(locations).where(eq(locations.managerId, managerId));
      if (managerLocations.length === 0) {
        return [];
      }
      const locationIds = managerLocations.map((loc) => loc.id);
      const profiles = await db.select().from(chefLocationProfiles).where(inArray(chefLocationProfiles.locationId, locationIds));
      const enrichedProfiles = await Promise.all(
        profiles.map(async (profile) => {
          const chef = await this.getUser(profile.chefId);
          const location = await db.select().from(locations).where(eq(locations.id, profile.locationId)).then((rows) => rows[0]);
          const chefApplications = await db.select().from(applications).where(
            and(
              eq(applications.userId, profile.chefId),
              eq(applications.status, "approved")
            )
          ).orderBy(asc(applications.createdAt));
          const latestApp = chefApplications.length > 0 ? chefApplications[chefApplications.length - 1] : null;
          return {
            ...profile,
            chef: chef ? {
              id: chef.id,
              username: chef.username
            } : null,
            location: location ? {
              id: location.id,
              name: location.name,
              address: location.address
            } : null,
            application: latestApp ? {
              id: latestApp.id,
              fullName: latestApp.fullName,
              email: latestApp.email,
              phone: latestApp.phone,
              foodSafetyLicenseUrl: latestApp.foodSafetyLicenseUrl,
              foodEstablishmentCertUrl: latestApp.foodEstablishmentCertUrl
            } : null
          };
        })
      );
      return enrichedProfiles;
    } catch (error) {
      console.error("Error getting chef profiles for manager:", error);
      throw error;
    }
  }
  // ===== CHEF LOCATION PROFILE MANAGEMENT (NEW - Location-based profile sharing) =====
  async shareChefProfileWithLocation(chefId, locationId) {
    try {
      const existing = await db.select().from(chefLocationProfiles).where(
        and(
          eq(chefLocationProfiles.chefId, chefId),
          eq(chefLocationProfiles.locationId, locationId)
        )
      );
      if (existing.length > 0) {
        if (existing[0].status === "rejected") {
          const [updated] = await db.update(chefLocationProfiles).set({
            status: "pending",
            sharedAt: /* @__PURE__ */ new Date(),
            reviewedBy: null,
            reviewedAt: null,
            reviewFeedback: null
          }).where(eq(chefLocationProfiles.id, existing[0].id)).returning();
          return updated;
        }
        return existing[0];
      }
      const [profile] = await db.insert(chefLocationProfiles).values({
        chefId,
        locationId,
        status: "pending"
      }).returning();
      return profile;
    } catch (error) {
      console.error("Error sharing chef profile with location:", error);
      throw error;
    }
  }
  async getChefLocationProfile(chefId, locationId) {
    try {
      const [profile] = await db.select().from(chefLocationProfiles).where(
        and(
          eq(chefLocationProfiles.chefId, chefId),
          eq(chefLocationProfiles.locationId, locationId)
        )
      );
      return profile || void 0;
    } catch (error) {
      console.error("Error getting chef location profile:", error);
      throw error;
    }
  }
  async getChefLocationProfiles(chefId) {
    try {
      const profiles = await db.select().from(chefLocationProfiles).where(eq(chefLocationProfiles.chefId, chefId));
      return profiles;
    } catch (error) {
      console.error("Error getting chef location profiles:", error);
      throw error;
    }
  }
  async updateChefLocationProfileStatus(profileId, status, reviewedBy, reviewFeedback) {
    try {
      const [updated] = await db.update(chefLocationProfiles).set({
        status,
        reviewedBy,
        reviewedAt: /* @__PURE__ */ new Date(),
        reviewFeedback: reviewFeedback || null
      }).where(eq(chefLocationProfiles.id, profileId)).returning();
      return updated;
    } catch (error) {
      console.error("Error updating chef location profile status:", error);
      throw error;
    }
  }
  // ===== CHEF KITCHEN APPLICATIONS (NEW - Direct Kitchen Applications) =====
  // This replaces the "Share Profile" workflow with full application per kitchen
  /**
   * Submit a new kitchen application or update an existing rejected one
   * Allows re-application after rejection with updated documents
   */
  async createChefKitchenApplication(data) {
    try {
      const existing = await db.select().from(chefKitchenApplications).where(
        and(
          eq(chefKitchenApplications.chefId, data.chefId),
          eq(chefKitchenApplications.locationId, data.locationId)
        )
      ).limit(1);
      const now = /* @__PURE__ */ new Date();
      if (existing.length > 0) {
        if (existing[0].status === "rejected" || existing[0].status === "cancelled") {
          const [updated] = await db.update(chefKitchenApplications).set({
            ...data,
            // Ensure customFieldsData defaults to empty object if not provided
            customFieldsData: data.customFieldsData ?? {},
            status: "inReview",
            // Reset to pending review
            feedback: null,
            // Clear previous feedback
            reviewedBy: null,
            reviewedAt: null,
            updatedAt: now
          }).where(eq(chefKitchenApplications.id, existing[0].id)).returning();
          return updated;
        }
        return existing[0];
      }
      const [application] = await db.insert(chefKitchenApplications).values({
        ...data,
        // Ensure customFieldsData defaults to empty object if not provided
        customFieldsData: data.customFieldsData ?? {},
        status: "inReview",
        createdAt: now,
        updatedAt: now
      }).returning();
      return application;
    } catch (error) {
      console.error("Error creating chef kitchen application:", error);
      throw error;
    }
  }
  /**
   * Get a specific kitchen application by ID
   */
  async getChefKitchenApplicationById(applicationId) {
    try {
      const [application] = await db.select().from(chefKitchenApplications).where(eq(chefKitchenApplications.id, applicationId)).limit(1);
      return application || void 0;
    } catch (error) {
      console.error("Error getting chef kitchen application by id:", error);
      throw error;
    }
  }
  /**
   * Get a chef's application for a specific location
   */
  async getChefKitchenApplication(chefId, locationId) {
    try {
      const [application] = await db.select().from(chefKitchenApplications).where(
        and(
          eq(chefKitchenApplications.chefId, chefId),
          eq(chefKitchenApplications.locationId, locationId)
        )
      ).limit(1);
      return application || void 0;
    } catch (error) {
      console.error("Error getting chef kitchen application:", error);
      throw error;
    }
  }
  /**
   * Get all kitchen applications for a chef
   */
  async getChefKitchenApplicationsByChefId(chefId) {
    try {
      console.log(`[STORAGE] getChefKitchenApplicationsByChefId called with chefId: ${chefId}`);
      console.log(`[STORAGE] Database connection check - pool exists: ${!!pool}, db exists: ${!!db}`);
      const applications2 = await db.select().from(chefKitchenApplications).where(eq(chefKitchenApplications.chefId, chefId)).orderBy(desc(chefKitchenApplications.createdAt));
      console.log(`[STORAGE] Found ${applications2.length} kitchen applications for chef ${chefId}`);
      if (applications2.length > 0) {
        console.log(`[STORAGE] First kitchen application sample:`, {
          id: applications2[0].id,
          chefId: applications2[0].chefId,
          locationId: applications2[0].locationId,
          status: applications2[0].status
        });
      }
      return applications2;
    } catch (error) {
      console.error("Error getting chef kitchen applications:", error);
      throw error;
    }
  }
  /**
   * Get all applications for a location with enriched chef details
   * Used by managers to review applications
   */
  async getChefKitchenApplicationsByLocationId(locationId) {
    try {
      const apps = await db.select().from(chefKitchenApplications).where(eq(chefKitchenApplications.locationId, locationId)).orderBy(desc(chefKitchenApplications.createdAt));
      const enrichedApplications = await Promise.all(
        apps.map(async (app3) => {
          const chef = await this.getUser(app3.chefId);
          const location = await this.getLocationById(app3.locationId);
          return {
            ...app3,
            chef: chef ? {
              id: chef.id,
              username: chef.username,
              role: chef.role
            } : null,
            location: location ? {
              id: location.id,
              name: location.name,
              address: location.address
            } : null
          };
        })
      );
      return enrichedApplications;
    } catch (error) {
      console.error("Error getting applications for location:", error);
      throw error;
    }
  }
  /**
   * Get all applications for locations managed by a specific manager
   * Returns applications enriched with chef and location details
   */
  async getChefKitchenApplicationsForManager(managerId) {
    try {
      const managedLocations = await db.select().from(locations).where(eq(locations.managerId, managerId));
      if (managedLocations.length === 0) {
        return [];
      }
      const locationIds = managedLocations.map((loc) => loc.id);
      const apps = await db.select().from(chefKitchenApplications).where(inArray(chefKitchenApplications.locationId, locationIds)).orderBy(desc(chefKitchenApplications.createdAt));
      const enrichedApplications = await Promise.all(
        apps.map(async (app3) => {
          const chef = await this.getUser(app3.chefId);
          const location = managedLocations.find((l) => l.id === app3.locationId);
          return {
            ...app3,
            chef: chef ? {
              id: chef.id,
              username: chef.username,
              role: chef.role
            } : null,
            location: location ? {
              id: location.id,
              name: location.name,
              address: location.address
            } : null
          };
        })
      );
      return enrichedApplications;
    } catch (error) {
      console.error("Error getting chef kitchen applications for manager:", error);
      throw error;
    }
  }
  /**
   * Update application status (approve/reject) by manager
   */
  async updateChefKitchenApplicationStatus(update, reviewedBy) {
    try {
      const [updated] = await db.update(chefKitchenApplications).set({
        status: update.status,
        feedback: update.feedback || null,
        reviewedBy,
        reviewedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(chefKitchenApplications.id, update.id)).returning();
      return updated || void 0;
    } catch (error) {
      console.error("Error updating chef kitchen application status:", error);
      throw error;
    }
  }
  /**
   * Update application documents (by chef re-uploading)
   */
  async updateChefKitchenApplicationDocuments(update) {
    try {
      const setData = { updatedAt: /* @__PURE__ */ new Date() };
      if (update.foodSafetyLicenseUrl !== void 0) {
        setData.foodSafetyLicenseUrl = update.foodSafetyLicenseUrl;
        setData.foodSafetyLicenseStatus = "pending";
      }
      if (update.foodEstablishmentCertUrl !== void 0) {
        setData.foodEstablishmentCertUrl = update.foodEstablishmentCertUrl;
        setData.foodEstablishmentCertStatus = "pending";
      }
      if (update.foodSafetyLicenseStatus !== void 0) {
        setData.foodSafetyLicenseStatus = update.foodSafetyLicenseStatus;
      }
      if (update.foodEstablishmentCertStatus !== void 0) {
        setData.foodEstablishmentCertStatus = update.foodEstablishmentCertStatus;
      }
      const [updated] = await db.update(chefKitchenApplications).set(setData).where(eq(chefKitchenApplications.id, update.id)).returning();
      return updated || void 0;
    } catch (error) {
      console.error("Error updating chef kitchen application documents:", error);
      throw error;
    }
  }
  /**
   * Check if chef has an approved application for a specific location
   * This is used for booking validation
   */
  async chefHasApprovedKitchenApplication(chefId, locationId) {
    try {
      const [application] = await db.select().from(chefKitchenApplications).where(
        and(
          eq(chefKitchenApplications.chefId, chefId),
          eq(chefKitchenApplications.locationId, locationId),
          eq(chefKitchenApplications.status, "approved")
        )
      ).limit(1);
      return !!application;
    } catch (error) {
      console.error("Error checking chef kitchen application approval:", error);
      return false;
    }
  }
  /**
   * Get kitchen application status for booking check
   * Returns detailed status for better error messages
   */
  async getChefKitchenApplicationStatus(chefId, locationId) {
    try {
      const application = await this.getChefKitchenApplication(chefId, locationId);
      if (!application) {
        return {
          hasApplication: false,
          status: null,
          canBook: false,
          message: "You must apply to this kitchen before booking. Please submit an application first."
        };
      }
      switch (application.status) {
        case "approved":
          return {
            hasApplication: true,
            status: "approved",
            canBook: true,
            message: "Application approved. You can book kitchens at this location."
          };
        case "inReview":
          return {
            hasApplication: true,
            status: "inReview",
            canBook: false,
            message: "Your application is pending manager review. Please wait for approval before booking."
          };
        case "rejected":
          return {
            hasApplication: true,
            status: "rejected",
            canBook: false,
            message: "Your application was rejected. You can re-apply with updated documents."
          };
        case "cancelled":
          return {
            hasApplication: true,
            status: "cancelled",
            canBook: false,
            message: "Your application was cancelled. You can submit a new application."
          };
        default:
          return {
            hasApplication: true,
            status: application.status,
            canBook: false,
            message: "Unknown application status. Please contact support."
          };
      }
    } catch (error) {
      console.error("Error getting kitchen application status:", error);
      return {
        hasApplication: false,
        status: null,
        canBook: false,
        message: "Error checking application status. Please try again."
      };
    }
  }
  /**
   * Cancel/withdraw an application (by chef)
   */
  async cancelChefKitchenApplication(applicationId, chefId) {
    try {
      const [existing] = await db.select().from(chefKitchenApplications).where(
        and(
          eq(chefKitchenApplications.id, applicationId),
          eq(chefKitchenApplications.chefId, chefId)
        )
      ).limit(1);
      if (!existing) {
        throw new Error("Application not found or access denied");
      }
      if (existing.status !== "inReview") {
        throw new Error("Can only cancel pending applications");
      }
      const [updated] = await db.update(chefKitchenApplications).set({
        status: "cancelled",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(chefKitchenApplications.id, applicationId)).returning();
      return updated || void 0;
    } catch (error) {
      console.error("Error cancelling chef kitchen application:", error);
      throw error;
    }
  }
  /**
   * Get chef's kitchen access across all locations
   * Returns all approved applications with location details
   */
  async getChefApprovedKitchens(chefId) {
    try {
      console.log(`[getChefApprovedKitchens] Fetching approved kitchens for chef ${chefId}`);
      const approvedApps = await db.select().from(chefKitchenApplications).where(
        and(
          eq(chefKitchenApplications.chefId, chefId),
          eq(chefKitchenApplications.status, "approved")
        )
      );
      console.log(`[getChefApprovedKitchens] Found ${approvedApps.length} approved applications for chef ${chefId}`);
      const enrichedApps = await Promise.all(
        approvedApps.map(async (app3) => {
          const location = await this.getLocationById(app3.locationId);
          if (!location) {
            console.warn(`[getChefApprovedKitchens] Location ${app3.locationId} not found for application ${app3.id}`);
            return null;
          }
          return {
            id: location.id,
            name: location.name,
            address: location.address,
            logoUrl: location.logoUrl || location.logo_url || void 0,
            brandImageUrl: location.brandImageUrl || location.brand_image_url || void 0,
            applicationId: app3.id,
            approvedAt: app3.reviewedAt ? app3.reviewedAt.toISOString() : null,
            // Keep locationId for backward compatibility
            locationId: app3.locationId
          };
        })
      );
      const validApps = enrichedApps.filter((app3) => app3 !== null);
      console.log(`[getChefApprovedKitchens] Returning ${validApps.length} valid approved locations`);
      return validApps;
    } catch (error) {
      console.error("Error getting chef approved kitchens:", error);
      return [];
    }
  }
};
var firebaseStorage = new FirebaseStorage();

// server/firebase-auth-middleware.ts
async function verifyFirebaseAuth(req, res, next) {
  try {
    if (res.headersSent) {
      return;
    }
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({
        error: "Unauthorized",
        message: "No auth token provided"
      });
    }
    const token = authHeader.substring(7);
    const decodedToken = await verifyFirebaseToken(token);
    if (!decodedToken) {
      return res.status(401).json({
        error: "Unauthorized",
        message: "Invalid auth token"
      });
    }
    req.firebaseUser = {
      uid: decodedToken.uid,
      email: decodedToken.email,
      email_verified: decodedToken.email_verified
    };
    next();
  } catch (error) {
    if (res.headersSent) {
      console.error("Firebase auth verification error (response already sent):", error);
      return;
    }
    console.error("Firebase auth verification error:", error);
    return res.status(401).json({
      error: "Unauthorized",
      message: "Token verification failed"
    });
  }
}
async function requireFirebaseAuthWithUser(req, res, next) {
  try {
    if (res.headersSent) {
      return;
    }
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({
        error: "Unauthorized",
        message: "No auth token provided"
      });
    }
    const token = authHeader.substring(7);
    const decodedToken = await verifyFirebaseToken(token);
    if (!decodedToken) {
      return res.status(401).json({
        error: "Unauthorized",
        message: "Invalid auth token"
      });
    }
    req.firebaseUser = {
      uid: decodedToken.uid,
      email: decodedToken.email,
      email_verified: decodedToken.email_verified
    };
    const neonUser = await firebaseStorage.getUserByFirebaseUid(req.firebaseUser.uid);
    if (!neonUser) {
      return res.status(404).json({
        error: "User not found",
        message: "This account is not registered with Local Cooks. Please create an account first."
      });
    }
    req.neonUser = {
      id: neonUser.id,
      username: neonUser.username,
      role: neonUser.role,
      firebaseUid: neonUser.firebaseUid || void 0,
      // Include role flags - these are now properly mapped by Drizzle ORM
      isChef: neonUser.isChef || false,
      isManager: neonUser.isManager || false,
      isVerified: neonUser.isVerified || false,
      has_seen_welcome: neonUser.has_seen_welcome || false
    };
    console.log(`\u{1F504} Auth translation: Firebase UID ${req.firebaseUser.uid} \u2192 Neon User ID ${neonUser.id}`, {
      role: neonUser.role,
      isChef: neonUser.isChef,
      isManager: neonUser.isManager
    });
    next();
  } catch (error) {
    if (res.headersSent) {
      console.error("Firebase auth with user verification error (response already sent):", error);
      return;
    }
    console.error("Firebase auth with user verification error:", error);
    return res.status(500).json({
      error: "Internal server error",
      message: "Authentication verification failed"
    });
  }
}
async function optionalFirebaseAuth(req, res, next) {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return next();
    }
    const token = authHeader.substring(7);
    const decodedToken = await verifyFirebaseToken(token);
    if (decodedToken) {
      req.firebaseUser = {
        uid: decodedToken.uid,
        email: decodedToken.email,
        email_verified: decodedToken.email_verified
      };
      const neonUser = await firebaseStorage.getUserByFirebaseUid(decodedToken.uid);
      if (neonUser) {
        req.neonUser = {
          id: neonUser.id,
          username: neonUser.username,
          role: neonUser.role,
          firebaseUid: neonUser.firebaseUid || void 0,
          // Include role flags - these are now properly mapped by Drizzle ORM
          isChef: neonUser.isChef || false,
          isManager: neonUser.isManager || false,
          isVerified: neonUser.isVerified || false,
          has_seen_welcome: neonUser.has_seen_welcome || false
        };
      }
    }
    next();
  } catch (error) {
    console.error("Optional Firebase auth error:", error);
    next();
  }
}
function requireAdmin(req, res, next) {
  if (res.headersSent) {
    return;
  }
  if (!req.neonUser) {
    return res.status(401).json({
      error: "Unauthorized",
      message: "Authentication required"
    });
  }
  if (req.neonUser.role !== "admin") {
    return res.status(403).json({
      error: "Forbidden",
      message: "Admin access required"
    });
  }
  next();
}
function requireManager(req, res, next) {
  if (res.headersSent) {
    return;
  }
  if (!req.neonUser) {
    return res.status(401).json({
      error: "Unauthorized",
      message: "Authentication required"
    });
  }
  if (req.neonUser.role !== "manager") {
    return res.status(403).json({
      error: "Forbidden",
      message: "Manager access required"
    });
  }
  next();
}

// server/firebase-user-sync.ts
async function syncFirebaseUserToNeon(params) {
  const { uid, email, emailVerified, displayName, role } = params;
  const isGoogleUser = emailVerified === true;
  const isUserVerified = isGoogleUser;
  console.log(`\u{1F504} SYNC TO NEON: Firebase UID ${uid} \u2192 Neon database`);
  console.log(`   - Email: ${email}`);
  console.log(`   - Email Verified (Firebase): ${emailVerified}`);
  console.log(`   - Is Google User: ${isGoogleUser}`);
  console.log(`   - Setting is_verified: ${isUserVerified}`);
  console.log(`   - Role: ${role}`);
  if (!email) {
    throw new Error("Email is required for user sync");
  }
  try {
    const existingUser = await firebaseStorage.getUserByFirebaseUid(uid);
    if (existingUser) {
      console.log(`\u2705 EXISTING USER FOUND: ${existingUser.id} (${existingUser.username})`);
      return existingUser;
    }
    let finalRole;
    let isChef = false;
    let isManager = false;
    console.log(`\u{1F50D} Role received in syncFirebaseUserToNeon: "${role}"`);
    if (!role || role === "null" || role === "undefined") {
      console.error(`\u274C ERROR: No role provided in syncFirebaseUserToNeon during registration. Cannot create user without role.`);
      console.error(`   - Received role value: ${role}`);
      console.error(`   - This should not happen - role should be detected from URL path in frontend`);
      throw new Error("Role is required for user registration. Please register from the appropriate page (admin, manager, or chef).");
    }
    if (role === "admin") {
      finalRole = "admin";
      isChef = true;
      console.log(`\u{1F3AF} Admin role assignment: role="admin" \u2192 isChef=true (admin has full access)`);
    } else if (role === "manager") {
      finalRole = "manager";
      isManager = true;
      console.log(`\u{1F3AF} Manager role assignment: role="manager" \u2192 isManager=true`);
    } else if (role === "chef") {
      finalRole = "chef";
      isChef = true;
      console.log(`\u{1F3AF} Chef role assignment: role="chef" \u2192 isChef=true`);
    } else {
      console.error(`\u274C ERROR: Unknown role value "${role}" in syncFirebaseUserToNeon`);
      throw new Error(`Invalid role: ${role}. Valid roles are: admin, manager, chef`);
    }
    const hasSeenWelcome = finalRole === "admin" || finalRole === "manager";
    const userData = {
      username: email,
      // Always use email as username to ensure consistency
      password: "",
      // Empty for Firebase users
      role: finalRole,
      isChef,
      // Set correctly based on role (admin or chef)
      isManager,
      // Set correctly for manager role
      isPortalUser: false,
      firebaseUid: uid,
      isVerified: isUserVerified,
      // Google users are verified, email/password users need verification
      hasSeenWelcome
      // Admins and managers skip welcome screen
    };
    console.log(`\u2795 CREATING NEW USER with data:`, userData);
    const newUser = await firebaseStorage.createUser({
      ...userData,
      has_seen_welcome: hasSeenWelcome
    });
    console.log(`\u2705 USER CREATED: ${newUser.id} (${newUser.username})`);
    console.log(`   - is_verified in DB: ${newUser.isVerified}`);
    console.log(`   - has_seen_welcome in DB: ${newUser.has_seen_welcome} (admins/managers skip welcome screen)`);
    if (!isGoogleUser && email) {
      console.log(`\u{1F4E7} Email/password user - Firebase will handle verification email for ${email}`);
    } else if (isGoogleUser && email) {
      console.log(`\u{1F4E7} SENDING WELCOME EMAIL for Google user: ${email}`);
      try {
        const { sendEmail: sendEmail2, generateWelcomeEmail: generateWelcomeEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        const emailContent = generateWelcomeEmail2({
          fullName: displayName || email.split("@")[0],
          email
        });
        const emailSent = await sendEmail2(emailContent, {
          trackingId: `google_welcome_${email}_${Date.now()}`
        });
        if (emailSent) {
          console.log(`\u2705 Welcome email sent to Google user: ${email}`);
        } else {
          console.error(`\u274C Failed to send welcome email to Google user: ${email}`);
        }
      } catch (emailError) {
        console.error("\u274C Error sending welcome email to Google user:", emailError);
      }
    }
    return newUser;
  } catch (error) {
    console.error("\u274C Error in syncFirebaseUserToNeon:", error);
    throw error;
  }
}

// server/storage.ts
init_schema();
init_db();
import connectPg from "connect-pg-simple";
import { and as and2, eq as eq2 } from "drizzle-orm";
import session from "express-session";
import createMemoryStore from "memorystore";
var MemoryStore = createMemoryStore(session);
var MemStorage = class {
  users;
  applications;
  videoProgress;
  // key: userId-videoId
  microlearningCompletions;
  // key: userId
  userCurrentId;
  applicationCurrentId;
  sessionStore;
  // TypeScript fixes for instagramId and twitterId
  constructor() {
    this.users = /* @__PURE__ */ new Map();
    this.applications = /* @__PURE__ */ new Map();
    this.videoProgress = /* @__PURE__ */ new Map();
    this.microlearningCompletions = /* @__PURE__ */ new Map();
    this.userCurrentId = 1;
    this.applicationCurrentId = 1;
    this.sessionStore = new MemoryStore({
      checkPeriod: 864e5
      // 24hrs
    });
    this.initializeDefaultAdmin();
  }
  async initializeDefaultAdmin() {
    const adminUser = {
      id: this.userCurrentId++,
      username: "admin",
      password: "fcf0872ea0a0c91f3d8e64dc5005c9b6a36371eddc6c1127a3c0b45c71db5b72f85c5e93b80993ec37c6aff8b08d07b68e9c58f28e3bd20d9d2a4eb38992aad0.ef32a41b7d478668",
      // "localcooks"
      role: "admin",
      googleId: null,
      facebookId: null,
      firebaseUid: null,
      isVerified: true,
      has_seen_welcome: true,
      managerOnboardingCompleted: false,
      managerOnboardingSkipped: false,
      managerOnboardingStepsCompleted: {},
      isManager: false,
      isChef: false,
      isPortalUser: false,
      applicationType: null,
      stripeConnectAccountId: null,
      stripeConnectOnboardingStatus: "not_started"
    };
    this.users.set(adminUser.id, adminUser);
    console.log("Development: Default admin user created (username: admin, password: localcooks)");
  }
  // User-related methods
  async getUser(id) {
    return this.users.get(id);
  }
  async getUserByUsername(username) {
    return Array.from(this.users.values()).find(
      (user) => user.username === username
    );
  }
  async getUserByFirebaseUid(firebaseUid) {
    return void 0;
  }
  async updateUserFirebaseUid(userId, firebaseUid) {
    return this.getUser(userId);
  }
  async getUserByGoogleId(googleId) {
    if (!googleId) return void 0;
    for (const user of Array.from(this.users.values())) {
      if (user.googleId === googleId) return user;
    }
    return void 0;
  }
  async getUserByFacebookId(facebookId) {
    if (!facebookId) return void 0;
    for (const user of Array.from(this.users.values())) {
      if (user.facebookId === facebookId) return user;
    }
    return void 0;
  }
  // Instagram authentication was removed
  async getUserByInstagramId(instagramId) {
    return void 0;
  }
  async createUser(insertUser) {
    if (!insertUser.username || insertUser.password === void 0) {
      throw new Error("Username and password are required");
    }
    const user = {
      id: this.userCurrentId++,
      username: insertUser.username,
      password: insertUser.password,
      role: insertUser.role || "chef",
      googleId: insertUser.googleId || null,
      facebookId: insertUser.facebookId || null,
      firebaseUid: insertUser.firebaseUid || null,
      isVerified: insertUser.isVerified !== void 0 ? insertUser.isVerified : false,
      has_seen_welcome: insertUser.has_seen_welcome !== void 0 ? insertUser.has_seen_welcome : false,
      isChef: insertUser.isChef || false,
      isManager: insertUser.isManager || false,
      isPortalUser: insertUser.isPortalUser !== void 0 ? insertUser.isPortalUser : false,
      applicationType: insertUser.applicationType || null,
      managerOnboardingCompleted: insertUser.managerOnboardingCompleted !== void 0 ? insertUser.managerOnboardingCompleted : false,
      managerOnboardingSkipped: insertUser.managerOnboardingSkipped !== void 0 ? insertUser.managerOnboardingSkipped : false,
      managerOnboardingStepsCompleted: insertUser.managerOnboardingStepsCompleted !== void 0 ? insertUser.managerOnboardingStepsCompleted : {},
      stripeConnectAccountId: insertUser.stripeConnectAccountId || null,
      stripeConnectOnboardingStatus: insertUser.stripeConnectOnboardingStatus || "not_started"
    };
    this.users.set(user.id, user);
    return user;
  }
  // Application-related methods
  async getAllApplications() {
    return Array.from(this.applications.values());
  }
  async getApplicationById(id) {
    return this.applications.get(id);
  }
  async getApplicationsByUserId(userId) {
    return Array.from(this.applications.values()).filter(
      (application) => application.userId === userId
    );
  }
  async createApplication(insertApplication) {
    const id = this.applicationCurrentId++;
    const now = /* @__PURE__ */ new Date();
    const application = {
      id,
      userId: insertApplication.userId || null,
      fullName: insertApplication.fullName,
      email: insertApplication.email,
      phone: insertApplication.phone,
      foodSafetyLicense: insertApplication.foodSafetyLicense,
      foodEstablishmentCert: insertApplication.foodEstablishmentCert,
      kitchenPreference: insertApplication.kitchenPreference,
      feedback: insertApplication.feedback || null,
      status: "inReview",
      // Initialize document verification fields
      foodSafetyLicenseUrl: insertApplication.foodSafetyLicenseUrl || null,
      foodEstablishmentCertUrl: insertApplication.foodEstablishmentCertUrl || null,
      foodSafetyLicenseStatus: "pending",
      foodEstablishmentCertStatus: "pending",
      documentsAdminFeedback: null,
      documentsReviewedBy: null,
      documentsReviewedAt: null,
      createdAt: now
    };
    this.applications.set(id, application);
    return application;
  }
  async updateApplicationStatus(update) {
    const application = this.applications.get(update.id);
    if (!application) {
      return void 0;
    }
    if (update.status === "cancelled") {
      cleanupApplicationDocuments(application);
    }
    const updatedApplication = {
      ...application,
      status: update.status
    };
    this.applications.set(update.id, updatedApplication);
    return updatedApplication;
  }
  async getUserByOAuthId(provider, oauthId) {
    if (!oauthId) return void 0;
    if (provider === "google") {
      return this.getUserByGoogleId(oauthId);
    } else if (provider === "facebook") {
      return this.getUserByFacebookId(oauthId);
    }
    return void 0;
  }
  async createOAuthUser(userData) {
    const { oauth_provider, oauth_id, ...rest } = userData;
    const insertData = {
      ...rest,
      password: "",
      // No password for OAuth users
      isVerified: oauth_provider === "google" ? true : false,
      has_seen_welcome: false
    };
    if (oauth_provider === "google") {
      insertData.googleId = oauth_id;
    } else if (oauth_provider === "facebook") {
      insertData.facebookId = oauth_id;
    }
    return this.createUser(insertData);
  }
  // Application-related methods (now includes document verification)
  async updateApplicationDocuments(update) {
    const application = this.applications.get(update.id);
    if (!application) {
      return void 0;
    }
    const updatedApplication = {
      ...application,
      ...update,
      // Reset document status to pending when new documents are uploaded
      ...update.foodSafetyLicenseUrl && { foodSafetyLicenseStatus: "pending" },
      ...update.foodEstablishmentCertUrl && { foodEstablishmentCertStatus: "pending" }
    };
    this.applications.set(update.id, updatedApplication);
    return updatedApplication;
  }
  async updateApplicationDocumentVerification(update) {
    const application = this.applications.get(update.id);
    if (!application) {
      return void 0;
    }
    const updatedApplication = {
      ...application,
      ...update,
      documentsReviewedAt: /* @__PURE__ */ new Date()
    };
    this.applications.set(update.id, updatedApplication);
    return updatedApplication;
  }
  async updateUserVerificationStatus(userId, isVerified) {
    const user = this.users.get(userId);
    if (!user) {
      return void 0;
    }
    const updatedUser = {
      ...user,
      isVerified
    };
    this.users.set(userId, updatedUser);
    return updatedUser;
  }
  // Microlearning methods
  async getMicrolearningProgress(userId) {
    const progress = [];
    for (const [key, value] of Array.from(this.videoProgress.entries())) {
      if (key.startsWith(`${userId}-`)) {
        progress.push(value);
      }
    }
    return progress;
  }
  async getMicrolearningCompletion(userId) {
    return this.microlearningCompletions.get(userId);
  }
  async updateVideoProgress(progressData) {
    const key = `${progressData.userId}-${progressData.videoId}`;
    const existingProgress = this.videoProgress.get(key);
    if (existingProgress && existingProgress.completed && !progressData.completed) {
      this.videoProgress.set(key, {
        ...progressData,
        completed: true,
        // Keep it marked as completed
        completedAt: existingProgress.completedAt,
        // Preserve original completion date
        isRewatching: true
        // Flag to indicate this is a rewatch
      });
    } else {
      this.videoProgress.set(key, {
        ...progressData,
        isRewatching: existingProgress?.completed || false
      });
    }
  }
  async createMicrolearningCompletion(completionData) {
    this.microlearningCompletions.set(completionData.userId, completionData);
    return completionData;
  }
  async setUserHasSeenWelcome(userId) {
    try {
      await pool.query(
        "UPDATE users SET has_seen_welcome = true WHERE id = $1",
        [userId]
      );
    } catch (error) {
      console.error("Error setting has_seen_welcome:", error);
      throw new Error("Failed to set has_seen_welcome");
    }
  }
};
var DatabaseStorage = class {
  sessionStore;
  constructor() {
    const PostgresSessionStore = connectPg(session);
    this.sessionStore = new PostgresSessionStore({
      pool,
      createTableIfMissing: true
    });
  }
  async getUser(id) {
    try {
      if (!process.env.DATABASE_URL) {
        console.error("DATABASE_URL not configured");
        throw new Error("Database not configured");
      }
      const [user] = await db.select().from(users).where(eq2(users.id, id));
      return user || void 0;
    } catch (error) {
      console.error("Error in getUser:", error);
      throw error;
    }
  }
  async getUserByUsername(username) {
    try {
      if (!process.env.DATABASE_URL) {
        console.error("DATABASE_URL not configured");
        throw new Error("Database not configured");
      }
      const [user] = await db.select().from(users).where(eq2(users.username, username));
      return user || void 0;
    } catch (error) {
      console.error("Error in getUserByUsername:", error);
      throw error;
    }
  }
  async getUserByFirebaseUid(firebaseUid) {
    try {
      const [user] = await db.select().from(users).where(eq2(users.firebaseUid, firebaseUid));
      return user || void 0;
    } catch (error) {
      console.error("Error getting user by firebase_uid:", error);
      return void 0;
    }
  }
  async updateUserFirebaseUid(userId, firebaseUid) {
    try {
      const [updated] = await db.update(users).set({ firebaseUid }).where(eq2(users.id, userId)).returning();
      return updated || void 0;
    } catch (error) {
      console.error("Error updating user firebase_uid:", error);
      return void 0;
    }
  }
  async getUserByGoogleId(googleId) {
    if (!googleId) return void 0;
    const [user] = await db.select().from(users).where(eq2(users.googleId, googleId));
    return user || void 0;
  }
  async getUserByFacebookId(facebookId) {
    if (!facebookId) return void 0;
    const [user] = await db.select().from(users).where(eq2(users.facebookId, facebookId));
    return user || void 0;
  }
  async getUserByInstagramId(instagramId) {
    return void 0;
  }
  async createUser(insertUser) {
    if (!insertUser.username || insertUser.password === void 0) {
      throw new Error("Username and password are required");
    }
    if (pool && insertUser.firebaseUid) {
      try {
        const result = await pool.query(
          "INSERT INTO users (username, password, role, google_id, facebook_id, firebase_uid, is_verified, has_seen_welcome, is_chef, is_manager) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *",
          [
            insertUser.username,
            insertUser.password,
            insertUser.role || "chef",
            insertUser.googleId || null,
            insertUser.facebookId || null,
            insertUser.firebaseUid,
            insertUser.isVerified !== void 0 ? insertUser.isVerified : false,
            insertUser.has_seen_welcome !== void 0 ? insertUser.has_seen_welcome : false,
            insertUser.isChef || false,
            insertUser.isManager || false
          ]
        );
        return result.rows[0];
      } catch (error) {
        console.error("Error creating user with firebase_uid:", error);
        throw error;
      }
    }
    if (!insertUser.role) {
      console.error(`\u274C CRITICAL ERROR: No role provided to createUser (fallback) in storage.ts!`);
      console.error(`   - Username: ${insertUser.username}`);
      console.error(`   - This should not happen - role should always be provided`);
      throw new Error("Role is required when creating a user. This is a programming error.");
    }
    const [user] = await db.insert(users).values({
      username: insertUser.username,
      password: insertUser.password,
      role: insertUser.role,
      // No default - must be provided
      googleId: insertUser.googleId || null,
      facebookId: insertUser.facebookId || null,
      isVerified: insertUser.isVerified !== void 0 ? insertUser.isVerified : false,
      has_seen_welcome: insertUser.has_seen_welcome !== void 0 ? insertUser.has_seen_welcome : false,
      isChef: insertUser.isChef || false,
      isManager: insertUser.isManager || false
    }).returning();
    return user;
  }
  // Application-related methods
  async getAllApplications() {
    return await db.select().from(applications);
  }
  async getApplicationById(id) {
    const [application] = await db.select().from(applications).where(eq2(applications.id, id));
    return application || void 0;
  }
  async getApplicationsByUserId(userId) {
    return await db.select().from(applications).where(eq2(applications.userId, userId));
  }
  async createApplication(insertApplication) {
    const now = /* @__PURE__ */ new Date();
    const [application] = await db.insert(applications).values({
      ...insertApplication,
      status: "inReview",
      createdAt: now
    }).returning();
    return application;
  }
  async updateApplicationStatus(update) {
    const { id, status } = update;
    const [application] = await db.select().from(applications).where(eq2(applications.id, id));
    if (application && status === "cancelled") {
      cleanupApplicationDocuments(application);
    }
    const [updatedApplication] = await db.update(applications).set({ status }).where(eq2(applications.id, id)).returning();
    return updatedApplication || void 0;
  }
  async getUserByOAuthId(provider, oauthId) {
    if (!oauthId) return void 0;
    if (provider === "google") {
      return this.getUserByGoogleId(oauthId);
    } else if (provider === "facebook") {
      return this.getUserByFacebookId(oauthId);
    }
    return void 0;
  }
  async createOAuthUser(userData) {
    const { oauth_provider, oauth_id, ...rest } = userData;
    const insertData = {
      ...rest,
      password: "",
      // No password for OAuth users
      isVerified: oauth_provider === "google" ? true : false,
      has_seen_welcome: false
    };
    if (oauth_provider === "google") {
      insertData.googleId = oauth_id;
    } else if (oauth_provider === "facebook") {
      insertData.facebookId = oauth_id;
    }
    return this.createUser(insertData);
  }
  // Application-related methods (now includes document verification)
  async updateApplicationDocuments(update) {
    const { id, ...updateData } = update;
    const [updatedApplication] = await db.update(applications).set({
      ...updateData,
      // Reset document status to pending when new documents are uploaded
      ...updateData.foodSafetyLicenseUrl && { foodSafetyLicenseStatus: "pending" },
      ...updateData.foodEstablishmentCertUrl && { foodEstablishmentCertStatus: "pending" }
    }).where(eq2(applications.id, id)).returning();
    return updatedApplication || void 0;
  }
  async updateApplicationDocumentVerification(update) {
    const { id, ...updateData } = update;
    const [updatedApplication] = await db.update(applications).set({
      ...updateData,
      documentsReviewedAt: /* @__PURE__ */ new Date()
    }).where(eq2(applications.id, id)).returning();
    return updatedApplication || void 0;
  }
  async updateUserVerificationStatus(userId, isVerified) {
    const [updatedUser] = await db.update(users).set({ isVerified }).where(eq2(users.id, userId)).returning();
    return updatedUser || void 0;
  }
  // Microlearning methods
  async getMicrolearningProgress(userId) {
    const progressRecords = await db.select().from(videoProgress).where(eq2(videoProgress.userId, userId));
    return progressRecords.map((record) => ({
      videoId: record.videoId,
      progress: parseFloat(record.progress.toString()),
      completed: record.completed,
      completedAt: record.completedAt,
      watchedPercentage: parseFloat(record.watchedPercentage.toString()),
      isRewatching: record.isRewatching
    }));
  }
  async getMicrolearningCompletion(userId) {
    const [completion] = await db.select().from(microlearningCompletions).where(eq2(microlearningCompletions.userId, userId));
    return completion || void 0;
  }
  async updateVideoProgress(progressData) {
    const { userId, videoId, progress, completed, completedAt, watchedPercentage, isRewatching } = progressData;
    const existingProgress = await db.select().from(videoProgress).where(and2(eq2(videoProgress.userId, userId), eq2(videoProgress.videoId, videoId))).limit(1);
    const existing = existingProgress[0];
    const finalCompleted = completed || (existing?.completed || false);
    const finalCompletedAt = finalCompleted ? existing?.completedAt || (completed ? new Date(completedAt) : /* @__PURE__ */ new Date()) : null;
    const updateData = {
      progress: progress?.toString() || "0",
      completed: finalCompleted,
      completedAt: finalCompletedAt,
      updatedAt: /* @__PURE__ */ new Date(),
      watchedPercentage: watchedPercentage?.toString() || "0",
      isRewatching: isRewatching || (existing?.completed || false)
      // Mark as rewatching if previously completed
    };
    if (existingProgress.length > 0) {
      await db.update(videoProgress).set(updateData).where(and2(eq2(videoProgress.userId, userId), eq2(videoProgress.videoId, videoId)));
    } else {
      await db.insert(videoProgress).values({
        userId,
        videoId,
        ...updateData
      });
    }
  }
  async createMicrolearningCompletion(completionData) {
    const { userId, confirmed, certificateGenerated, videoProgress: videoProgressData } = completionData;
    const existingCompletion = await db.select().from(microlearningCompletions).where(eq2(microlearningCompletions.userId, userId)).limit(1);
    const completionRecord = {
      userId,
      confirmed: confirmed || false,
      certificateGenerated: certificateGenerated || false,
      videoProgress: videoProgressData || [],
      updatedAt: /* @__PURE__ */ new Date()
    };
    if (existingCompletion.length > 0) {
      const [updated] = await db.update(microlearningCompletions).set(completionRecord).where(eq2(microlearningCompletions.userId, userId)).returning();
      return updated;
    } else {
      const [inserted] = await db.insert(microlearningCompletions).values({
        ...completionRecord,
        completedAt: /* @__PURE__ */ new Date(),
        createdAt: /* @__PURE__ */ new Date()
      }).returning();
      return inserted;
    }
  }
  async setUserHasSeenWelcome(userId) {
    try {
      await pool.query(
        "UPDATE users SET has_seen_welcome = true WHERE id = $1",
        [userId]
      );
    } catch (error) {
      console.error("Error setting has_seen_welcome:", error);
      throw new Error("Failed to set has_seen_welcome");
    }
  }
};
var storage2 = process.env.DATABASE_URL ? new DatabaseStorage() : new MemStorage();

// shared/subdomain-utils.ts
function getSubdomainFromHostname(hostname) {
  if (!hostname) return null;
  const hostWithoutPort = hostname.split(":")[0];
  const parts = hostWithoutPort.split(".");
  if (hostWithoutPort === "localhost" || hostWithoutPort === "127.0.0.1") {
    return "main";
  }
  if (parts.length === 2 && parts[1] === "localhost") {
    const subdomain = parts[0].toLowerCase();
    switch (subdomain) {
      case "chef":
        return "chef";
      case "kitchen":
        return "kitchen";
      case "admin":
        return "admin";
      default:
        return "main";
    }
  }
  if (parts.length >= 3) {
    const subdomain = parts[0].toLowerCase();
    switch (subdomain) {
      case "chef":
        return "chef";
      case "kitchen":
        return "kitchen";
      case "admin":
        return "admin";
      default:
        return null;
    }
  }
  return "main";
}
function getSubdomainFromHeaders(headers) {
  const forwardedHost = headers["x-forwarded-host"] || headers["x-vercel-deployment-url"];
  if (forwardedHost) {
    const hostname = Array.isArray(forwardedHost) ? forwardedHost[0] : forwardedHost;
    return getSubdomainFromHostname(hostname);
  }
  const host = headers["host"];
  if (host) {
    const hostname = Array.isArray(host) ? host[0] : host;
    return getSubdomainFromHostname(hostname);
  }
  return null;
}
function getRequiredSubdomainForRole(role) {
  if (!role) return null;
  switch (role.toLowerCase()) {
    case "chef":
      return "chef";
    case "manager":
      return "kitchen";
    case "admin":
      return "admin";
    default:
      return null;
  }
}
function isRoleAllowedForSubdomain(role, subdomain, isPortalUser = false, isChef = false, isManager = false) {
  if (isPortalUser && subdomain === "kitchen") {
    return true;
  }
  let effectiveRole = role;
  if (!effectiveRole) {
    if (isManager) {
      effectiveRole = "manager";
    } else if (isChef) {
      effectiveRole = "chef";
    }
  }
  const requiredSubdomain = getRequiredSubdomainForRole(effectiveRole);
  if (!requiredSubdomain) {
    return false;
  }
  return subdomain === requiredSubdomain;
}

// server/firebase-routes.ts
function registerFirebaseRoutes(app3) {
  async function getAuthenticatedUserFromSession(req) {
    if (req.isAuthenticated?.() && req.user) {
      return req.user;
    }
    if (req.session?.userId) {
      const userId = req.session.userId;
      const user = await storage2.getUser(userId);
      if (user) {
        return user;
      }
    }
    if (req.session?.user) {
      return req.session.user;
    }
    return null;
  }
  async function requireSessionAdmin(req, res, next) {
    try {
      delete req.firebaseUser;
      const user = await getAuthenticatedUserFromSession(req);
      if (!user) {
        console.log("\u274C Session admin auth failed: No session found");
        return res.status(401).json({
          error: "Unauthorized",
          message: "Session authentication required. Please login as an admin."
        });
      }
      if (user.role !== "admin") {
        console.log(`\u274C Session admin auth failed: User ${user.id} is not an admin (role: ${user.role})`);
        return res.status(403).json({
          error: "Forbidden",
          message: "Admin access required",
          userRole: user.role || "none"
        });
      }
      req.sessionUser = user;
      req.neonUser = user;
      console.log(`\u2705 Session admin auth: User ${user.id} (${user.username}) authenticated as admin`);
      next();
    } catch (error) {
      console.error("Session admin auth error:", error);
      return res.status(500).json({
        error: "Internal server error",
        message: "Authentication verification failed"
      });
    }
  }
  app3.post("/api/firebase-register-user", verifyFirebaseAuth, async (req, res) => {
    try {
      if (!req.firebaseUser) {
        return res.status(401).json({ error: "Firebase authentication required" });
      }
      const { displayName, role, emailVerified } = req.body;
      const existingUser = await firebaseStorage.getUserByFirebaseUid(req.firebaseUser.uid);
      if (existingUser) {
        return res.status(409).json({
          error: "User already exists",
          message: "This account is already registered. Please sign in instead.",
          user: {
            id: existingUser.id,
            username: existingUser.username,
            role: existingUser.role,
            firebaseUid: existingUser.firebaseUid
          }
        });
      }
      const subdomain = getSubdomainFromHeaders(req.headers);
      if (role && !isRoleAllowedForSubdomain(role, subdomain, false, false, false)) {
        const requiredSubdomain = role === "chef" ? "chef" : role === "manager" ? "kitchen" : role === "admin" ? "admin" : null;
        return res.status(403).json({
          error: `Access denied. ${role} users must register from the ${requiredSubdomain} subdomain.`,
          requiredSubdomain
        });
      }
      const user = await syncFirebaseUserToNeon({
        uid: req.firebaseUser.uid,
        email: req.firebaseUser.email || null,
        displayName,
        emailVerified: emailVerified !== void 0 ? emailVerified : req.firebaseUser.email_verified,
        role
        // Don't set default role - let user choose
      });
      res.json({
        success: true,
        user: {
          id: user.id,
          username: user.username,
          role: user.role,
          firebaseUid: user.firebaseUid
        },
        message: "Account created successfully"
      });
    } catch (error) {
      console.error("Error registering Firebase user:", error);
      res.status(500).json({
        error: "Failed to create account",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app3.post("/api/firebase/forgot-password", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      console.log(`\u{1F525} Firebase password reset requested for: ${email}`);
      const firebaseApp = initializeFirebaseAdmin();
      if (!firebaseApp) {
        console.error("Firebase Admin not initialized");
        return res.status(500).json({
          message: "Password reset service unavailable. Please try again later."
        });
      }
      try {
        const { getAuth: getAuth2 } = await import("firebase-admin/auth");
        const auth2 = getAuth2(firebaseApp);
        const userRecord = await auth2.getUserByEmail(email);
        console.log(`\u2705 Firebase user found: ${userRecord.uid}`);
        const neonUser = await firebaseStorage.getUserByFirebaseUid(userRecord.uid);
        if (!neonUser) {
          console.log(`\u274C User not found in Neon DB for Firebase UID: ${userRecord.uid}`);
          return res.status(200).json({
            message: "If an account with this email exists, you will receive a password reset link."
          });
        }
        if (!neonUser.password || neonUser.password === "") {
          console.log(`\u274C User ${userRecord.uid} is OAuth user, no password reset needed`);
          return res.status(400).json({
            message: "This account uses Google/OAuth sign-in. Please use 'Sign in with Google' or contact your OAuth provider to reset your password."
          });
        }
        const resetUrl = `${process.env.BASE_URL || "http://localhost:5000"}/auth/reset-password`;
        const resetLink = await auth2.generatePasswordResetLink(email, {
          url: resetUrl,
          handleCodeInApp: true
        });
        console.log(`\u2705 Firebase password reset link generated for: ${email}`);
        return res.status(200).json({
          message: "If an account with this email exists, you will receive a password reset link.",
          resetLink: process.env.NODE_ENV === "development" ? resetLink : void 0
          // Only show in dev
        });
      } catch (firebaseError) {
        if (firebaseError.code === "auth/user-not-found") {
          console.log(`\u274C Firebase user not found: ${email}`);
          return res.status(200).json({
            message: "If an account with this email exists, you will receive a password reset link."
          });
        } else {
          console.error(`\u274C Firebase error:`, firebaseError);
          return res.status(500).json({
            message: "Error processing password reset request. Please try again later."
          });
        }
      }
    } catch (error) {
      console.error("Error in Firebase forgot password:", error);
      return res.status(500).json({
        message: "Internal server error. Please try again later."
      });
    }
  });
  app3.post("/api/firebase/reset-password", async (req, res) => {
    try {
      const { oobCode, newPassword } = req.body;
      if (!oobCode || !newPassword) {
        return res.status(400).json({ message: "Reset code and new password are required" });
      }
      if (newPassword.length < 8) {
        return res.status(400).json({ message: "Password must be at least 8 characters long" });
      }
      console.log(`\u{1F525} Firebase password reset confirmation with code: ${oobCode.substring(0, 8)}...`);
      const firebaseApp = initializeFirebaseAdmin();
      if (!firebaseApp) {
        console.error("Firebase Admin not initialized");
        return res.status(500).json({
          message: "Password reset service unavailable. Please try again later."
        });
      }
      try {
        const { getAuth: getAuth2 } = await import("firebase-admin/auth");
        const auth2 = getAuth2(firebaseApp);
        const email = await auth2.verifyPasswordResetCode(oobCode);
        console.log(`\u2705 Password reset code verified for: ${email}`);
        await auth2.confirmPasswordReset(oobCode, newPassword);
        console.log(`\u2705 Password reset confirmed for: ${email}`);
        const userRecord = await auth2.getUserByEmail(email);
        const neonUser = await firebaseStorage.getUserByFirebaseUid(userRecord.uid);
        if (neonUser) {
          const bcrypt2 = __require("bcryptjs");
          const hashedPassword = await bcrypt2.hash(newPassword, 12);
          const { pool: pool3 } = await Promise.resolve().then(() => (init_db(), db_exports));
          if (pool3) {
            await pool3.query(
              "UPDATE users SET password = $1 WHERE firebase_uid = $2",
              [hashedPassword, userRecord.uid]
            );
            console.log(`\u2705 Password hash updated in Neon DB for user: ${neonUser.id}`);
          }
        }
        return res.status(200).json({
          message: "Password reset successfully. You can now log in with your new password."
        });
      } catch (firebaseError) {
        console.error(`\u274C Firebase password reset error:`, firebaseError);
        if (firebaseError.code === "auth/invalid-action-code") {
          return res.status(400).json({ message: "Invalid or expired reset code" });
        } else if (firebaseError.code === "auth/weak-password") {
          return res.status(400).json({ message: "Password is too weak. Please choose a stronger password." });
        } else {
          return res.status(500).json({
            message: "Error resetting password. Please try again later."
          });
        }
      }
    } catch (error) {
      console.error("Error in Firebase reset password:", error);
      return res.status(500).json({
        message: "Internal server error. Please try again later."
      });
    }
  });
  app3.post("/api/firebase-sync-user", verifyFirebaseAuth, async (req, res) => {
    try {
      if (!req.firebaseUser) {
        return res.status(401).json({ error: "Firebase authentication required" });
      }
      const { displayName, role, emailVerified, isRegistration } = req.body;
      if (isRegistration) {
        const existingUser2 = await firebaseStorage.getUserByFirebaseUid(req.firebaseUser.uid);
        if (existingUser2) {
          return res.json({
            success: true,
            user: {
              id: existingUser2.id,
              username: existingUser2.username,
              role: existingUser2.role,
              firebaseUid: existingUser2.firebaseUid
            },
            message: "User already exists"
          });
        }
        const user = await syncFirebaseUserToNeon({
          uid: req.firebaseUser.uid,
          email: req.firebaseUser.email || null,
          displayName,
          emailVerified: emailVerified !== void 0 ? emailVerified : req.firebaseUser.email_verified,
          role: role || "chef"
        });
        return res.json({
          success: true,
          user: {
            id: user.id,
            username: user.username,
            role: user.role,
            firebaseUid: user.firebaseUid
          }
        });
      }
      const existingUser = await firebaseStorage.getUserByFirebaseUid(req.firebaseUser.uid);
      if (!existingUser) {
        return res.status(404).json({
          error: "User not found",
          message: "This account is not registered with Local Cooks. Please create an account first."
        });
      }
      const subdomain = getSubdomainFromHeaders(req.headers);
      const isPortalUser = existingUser.isPortalUser || existingUser.is_portal_user || false;
      const isChef = existingUser.isChef || existingUser.is_chef || false;
      const isManager = existingUser.isManager || existingUser.is_manager || false;
      if (!isRoleAllowedForSubdomain(existingUser.role, subdomain, isPortalUser, isChef, isManager)) {
        const effectiveRole = existingUser.role || (isManager ? "manager" : isChef ? "chef" : null);
        const requiredSubdomain = effectiveRole === "chef" ? "chef" : effectiveRole === "manager" ? "kitchen" : effectiveRole === "admin" ? "admin" : null;
        return res.status(403).json({
          error: `Access denied. ${effectiveRole || "user"} users must login from the ${requiredSubdomain} subdomain.`,
          requiredSubdomain
        });
      }
      res.json({
        success: true,
        user: {
          id: existingUser.id,
          username: existingUser.username,
          role: existingUser.role,
          firebaseUid: existingUser.firebaseUid
        }
      });
    } catch (error) {
      console.error("Error syncing Firebase user:", error);
      res.status(500).json({
        error: "Failed to sync user",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app3.get("/api/user/profile", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      let userFullName = null;
      let stripeConnectAccountId = null;
      let stripeConnectOnboardingStatus = null;
      if (pool) {
        try {
          const chefAppResult = await pool.query(
            "SELECT full_name FROM applications WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1",
            [req.neonUser.id]
          );
          if (chefAppResult.rows.length > 0 && chefAppResult.rows[0].full_name) {
            userFullName = chefAppResult.rows[0].full_name;
          }
          const stripeResult = await pool.query(
            "SELECT stripe_connect_account_id, stripe_connect_onboarding_status FROM users WHERE id = $1",
            [req.neonUser.id]
          );
          if (stripeResult.rows.length > 0) {
            stripeConnectAccountId = stripeResult.rows[0].stripe_connect_account_id || null;
            stripeConnectOnboardingStatus = stripeResult.rows[0].stripe_connect_onboarding_status || null;
          }
        } catch (dbError) {
          console.error("Error fetching user data:", dbError);
        }
      }
      console.log(`[USER PROFILE] Returning profile for user ${req.neonUser.id}:`, {
        id: req.neonUser.id,
        username: req.neonUser.username,
        role: req.neonUser.role,
        isChef: req.neonUser.isChef,
        isManager: req.neonUser.isManager,
        rawNeonUser: req.neonUser
      });
      res.json({
        id: req.neonUser.id,
        username: req.neonUser.username,
        role: req.neonUser.role,
        is_verified: req.neonUser.isVerified !== void 0 ? req.neonUser.isVerified : req.firebaseUser.email_verified,
        has_seen_welcome: req.neonUser.has_seen_welcome || false,
        isChef: req.neonUser.isChef || false,
        displayName: userFullName || null,
        // User's full name from application
        fullName: userFullName || null,
        // Alias for compatibility
        stripeConnectAccountId,
        // Stripe Connect account ID
        stripe_connect_account_id: stripeConnectAccountId,
        // Alias for compatibility
        stripeConnectOnboardingStatus,
        // Stripe Connect onboarding status
        stripe_connect_onboarding_status: stripeConnectOnboardingStatus,
        // Alias for compatibility
        // Also include original structure for compatibility
        neonUser: {
          id: req.neonUser.id,
          username: req.neonUser.username,
          role: req.neonUser.role
        },
        firebaseUser: {
          uid: req.firebaseUser.uid,
          email: req.firebaseUser.email,
          emailVerified: req.firebaseUser.email_verified
        }
      });
    } catch (error) {
      console.error("Error getting user profile:", error);
      res.status(500).json({ error: "Failed to get user profile" });
    }
  });
  app3.get("/api/user", verifyFirebaseAuth, async (req, res) => {
    try {
      if (!req.firebaseUser) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = await firebaseStorage.getUserByFirebaseUid(req.firebaseUser.uid);
      if (!user) {
        return res.status(404).json({
          error: "User not found",
          message: "This account is not registered with Local Cooks. Please create an account first."
        });
      }
      res.json({
        id: user.id,
        username: user.username,
        role: user.role,
        is_verified: user.isVerified,
        has_seen_welcome: user.has_seen_welcome,
        firebaseUid: user.firebaseUid
      });
    } catch (error) {
      console.error("Error getting user:", error);
      res.status(500).json({ error: "Failed to get user data" });
    }
  });
  app3.post("/api/user/seen-welcome", verifyFirebaseAuth, async (req, res) => {
    try {
      if (!req.firebaseUser) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = await firebaseStorage.getUserByFirebaseUid(req.firebaseUser.uid);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      await firebaseStorage.setUserHasSeenWelcome(user.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error setting has_seen_welcome:", error);
      res.status(500).json({ error: "Failed to update welcome status" });
    }
  });
  app3.post(
    "/api/firebase/applications",
    upload.fields([
      { name: "foodSafetyLicense", maxCount: 1 },
      { name: "foodEstablishmentCert", maxCount: 1 }
    ]),
    requireFirebaseAuthWithUser,
    async (req, res) => {
      try {
        console.log(`\u{1F4DD} POST /api/firebase/applications - User ${req.neonUser.id} submitting chef application`);
        const files = req.files;
        let foodSafetyLicenseUrl;
        let foodEstablishmentCertUrl;
        if (files) {
          if (files["foodSafetyLicense"]?.[0]) {
            try {
              foodSafetyLicenseUrl = await uploadToBlob(files["foodSafetyLicense"][0], req.neonUser.id, "documents");
              console.log(`\u2705 Uploaded food safety license: ${foodSafetyLicenseUrl}`);
            } catch (uploadError) {
              console.error("\u274C Failed to upload food safety license:", uploadError);
            }
          }
          if (files["foodEstablishmentCert"]?.[0]) {
            try {
              foodEstablishmentCertUrl = await uploadToBlob(files["foodEstablishmentCert"][0], req.neonUser.id, "documents");
              console.log(`\u2705 Uploaded food establishment cert: ${foodEstablishmentCertUrl}`);
            } catch (uploadError) {
              console.error("\u274C Failed to upload food establishment cert:", uploadError);
            }
          }
        }
        const applicationData = {
          ...req.body,
          userId: req.neonUser.id,
          // This is the Neon user ID from the middleware
          // Use uploaded file URLs if available, otherwise use provided URLs
          foodSafetyLicenseUrl: foodSafetyLicenseUrl || req.body.foodSafetyLicenseUrl || void 0,
          foodEstablishmentCertUrl: foodEstablishmentCertUrl || req.body.foodEstablishmentCertUrl || void 0
        };
        if (applicationData.foodSafetyLicenseUrl) {
          applicationData.foodSafetyLicenseStatus = "pending";
        }
        if (applicationData.foodEstablishmentCertUrl) {
          applicationData.foodEstablishmentCertStatus = "pending";
        }
        const parsedData = insertApplicationSchema.safeParse(applicationData);
        if (!parsedData.success) {
          const validationError = fromZodError(parsedData.error);
          console.log("\u274C Validation failed:", validationError.details);
          return res.status(400).json({
            message: "Validation error",
            errors: validationError.details
          });
        }
        console.log(`\u{1F4DD} Creating application: Firebase UID ${req.firebaseUser.uid} \u2192 Neon User ID ${req.neonUser.id}`);
        const application = await firebaseStorage.createApplication(parsedData.data);
        res.json({
          success: true,
          application,
          message: "Application submitted successfully"
        });
      } catch (error) {
        console.error("Error creating application:", error);
        res.status(500).json({
          error: "Failed to create application",
          message: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
  );
  app3.get("/api/firebase/applications/my", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const userId = req.neonUser.id;
      const firebaseUid = req.firebaseUser.uid;
      console.log(`[APPLICATIONS] Fetching applications for user ID: ${userId} (Firebase UID: ${firebaseUid})`);
      console.log(`[APPLICATIONS] User object:`, {
        id: req.neonUser.id,
        username: req.neonUser.username,
        role: req.neonUser.role,
        isChef: req.neonUser.isChef
      });
      const applications2 = await firebaseStorage.getApplicationsByUserId(userId);
      console.log(`[APPLICATIONS] Retrieved ${applications2.length} applications for user ${userId}`);
      if (applications2.length > 0) {
        console.log(`[APPLICATIONS] First application sample:`, {
          id: applications2[0].id,
          userId: applications2[0].userId,
          status: applications2[0].status
        });
      }
      res.json(applications2);
    } catch (error) {
      console.error("Error getting user applications:", error);
      res.status(500).json({ error: "Failed to get applications" });
    }
  });
  app3.get("/api/firebase/admin/applications", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
    try {
      const applications2 = await firebaseStorage.getAllApplications();
      console.log(`\u{1F451} Admin ${req.firebaseUser.uid} requested all applications`);
      res.json(applications2);
    } catch (error) {
      console.error("Error getting all applications:", error);
      res.status(500).json({ error: "Failed to get applications" });
    }
  });
  app3.get("/api/firebase/dashboard", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const userId = req.neonUser.id;
      const firebaseUid = req.firebaseUser.uid;
      console.log(`\u{1F3E0} Dashboard request: Firebase UID ${firebaseUid} \u2192 Neon User ID ${userId}`);
      const [applications2, microlearningProgress] = await Promise.all([
        firebaseStorage.getApplicationsByUserId(userId),
        firebaseStorage.getMicrolearningProgress(userId)
      ]);
      res.json({
        user: {
          id: userId,
          username: req.neonUser.username,
          role: req.neonUser.role,
          firebaseUid
        },
        applications: applications2,
        microlearningProgress
      });
    } catch (error) {
      console.error("Error getting dashboard data:", error);
      res.status(500).json({ error: "Failed to get dashboard data" });
    }
  });
  app3.post("/api/firebase/user/update-roles", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const { isChef } = req.body;
      if (typeof isChef !== "boolean") {
        return res.status(400).json({
          error: "Invalid role data. isChef must be a boolean value"
        });
      }
      console.log(`\u{1F3AF} Updating user roles: Firebase UID ${req.firebaseUser.uid} \u2192 Neon User ID ${req.neonUser.id} \u2192 Chef: ${isChef}`);
      await firebaseStorage.updateUserRoles(req.neonUser.id, { isChef });
      res.json({
        success: true,
        message: "User roles updated successfully"
      });
    } catch (error) {
      console.error("Error updating user roles:", error);
      res.status(500).json({
        error: "Failed to update user roles",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app3.post(
    "/api/upload",
    upload.single("file"),
    requireFirebaseAuthWithUser,
    handleFileUpload
  );
  app3.post("/api/firebase/microlearning/progress", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const { videoId, progress, completed } = req.body;
      const userId = req.neonUser.id;
      console.log(`\u{1F4FA} Video progress update: Firebase UID ${req.firebaseUser.uid} \u2192 Neon User ID ${userId}`);
      await firebaseStorage.updateVideoProgress({
        userId,
        videoId,
        progress,
        completed
      });
      res.json({ success: true, message: "Progress updated" });
    } catch (error) {
      console.error("Error updating video progress:", error);
      res.status(500).json({ error: "Failed to update progress" });
    }
  });
  app3.patch("/api/firebase/applications/:id/cancel", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid application ID" });
      }
      const application = await firebaseStorage.getApplicationById(id);
      if (!application) {
        return res.status(404).json({ message: "Application not found" });
      }
      if (application.userId !== req.neonUser.id && req.neonUser.role !== "admin") {
        return res.status(403).json({ message: "Access denied. You can only cancel your own applications." });
      }
      const updateData = {
        id,
        status: "cancelled"
      };
      const updatedApplication = await firebaseStorage.updateApplicationStatus(updateData);
      if (!updatedApplication) {
        return res.status(404).json({ message: "Application not found" });
      }
      try {
        if (updatedApplication.email) {
          const { generateStatusChangeEmail: generateStatusChangeEmail2, sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
          const emailContent = generateStatusChangeEmail2({
            fullName: updatedApplication.fullName || "Applicant",
            email: updatedApplication.email,
            status: "cancelled"
          });
          await sendEmail2(emailContent, {
            trackingId: `cancel_${updatedApplication.id}_${Date.now()}`
          });
          console.log(`Cancellation email sent to ${updatedApplication.email} for application ${updatedApplication.id}`);
        } else {
          console.warn(`Cannot send cancellation email for application ${updatedApplication.id}: No email address found`);
        }
      } catch (emailError) {
        console.error("Error sending cancellation email:", emailError);
      }
      return res.status(200).json(updatedApplication);
    } catch (error) {
      console.error("Error cancelling application:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  app3.patch("/api/firebase/admin/applications/:id/cancel", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid application ID" });
      }
      const application = await firebaseStorage.getApplicationById(id);
      if (!application) {
        return res.status(404).json({ message: "Application not found" });
      }
      const updateData = {
        id,
        status: "cancelled"
      };
      const updatedApplication = await firebaseStorage.updateApplicationStatus(updateData);
      if (!updatedApplication) {
        return res.status(404).json({ message: "Application not found" });
      }
      try {
        if (updatedApplication.email) {
          const { generateStatusChangeEmail: generateStatusChangeEmail2, sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
          const emailContent = generateStatusChangeEmail2({
            fullName: updatedApplication.fullName || "Applicant",
            email: updatedApplication.email,
            status: "cancelled"
          });
          await sendEmail2(emailContent, {
            trackingId: `admin_cancel_${updatedApplication.id}_${Date.now()}`
          });
          console.log(`Admin cancellation email sent to ${updatedApplication.email} for application ${updatedApplication.id}`);
        } else {
          console.warn(`Cannot send admin cancellation email for application ${updatedApplication.id}: No email address found`);
        }
      } catch (emailError) {
        console.error("Error sending admin cancellation email:", emailError);
      }
      return res.status(200).json(updatedApplication);
    } catch (error) {
      console.error("Error cancelling application (admin):", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  app3.get("/api/firebase-health", (req, res) => {
    res.json({
      status: "OK",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      message: "Firebase Auth \u2192 Neon DB bridge is working",
      architecture: "Stateless JWT - No Sessions Required",
      auth: {
        firebaseConfigured: !!process.env.FIREBASE_PROJECT_ID,
        neonConfigured: !!process.env.DATABASE_URL,
        sessionFree: true
      }
    });
  });
  app3.post("/api/admin/send-company-email", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
    try {
      console.log(`\u{1F525} POST /api/admin/send-company-email - Firebase UID: ${req.firebaseUser?.uid}, Neon User ID: ${req.neonUser?.id}`);
      const {
        emailType = "general",
        // 'promotional', 'general', 'announcement', 'newsletter'
        emailMode,
        recipients,
        promoCode,
        // Optional for non-promotional emails
        promoCodeLabel,
        message,
        customMessage,
        greeting,
        subject,
        previewText,
        header,
        footer,
        orderButton,
        usageSteps,
        emailContainer,
        dividers,
        promoCodeStyling,
        promoStyle,
        sections,
        customDesign
      } = req.body;
      const messageContent = customMessage || message;
      if (!messageContent || messageContent.length < 10) {
        console.log("\u{1F525} Company email request - Invalid message:", {
          customMessage: customMessage?.substring(0, 50),
          message: message?.substring(0, 50),
          messageLength: messageContent?.length
        });
        return res.status(400).json({ error: "Message content is required (minimum 10 characters)" });
      }
      if (emailType === "promotional" && !promoCode) {
        console.log("\u{1F525} Company email request - Missing promo code for promotional email");
        return res.status(400).json({ error: "Promo code is required for promotional emails" });
      }
      let targetEmails = [];
      if (emailMode === "all") {
        try {
          const result = await pool.query("SELECT email FROM users WHERE email IS NOT NULL AND email != ''");
          targetEmails = result.rows.map((row) => row.email);
        } catch (error) {
          console.error("\u{1F525} Error fetching user emails:", error);
          return res.status(500).json({ error: "Failed to fetch user emails" });
        }
      } else if (emailMode === "custom" && recipients) {
        const customEmails = recipients.split(",").map((email) => email.trim()).filter((email) => email.length > 0);
        targetEmails = customEmails;
      } else {
        return res.status(400).json({ error: "Invalid email mode or recipients" });
      }
      if (targetEmails.length === 0) {
        console.log("\u{1F525} Company email request - No valid email addresses provided");
        return res.status(400).json({ error: "At least one email address is required" });
      }
      console.log(`\u{1F525} Admin ${req.neonUser?.username} sending ${emailType} email to ${targetEmails.length} recipient(s)`);
      const { sendEmail: sendEmail2, generatePromoCodeEmail: generatePromoCodeEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
      const results = [];
      let successCount = 0;
      let failureCount = 0;
      for (const targetEmail of targetEmails) {
        try {
          const emailContent = generatePromoCodeEmail2({
            email: targetEmail,
            promoCode,
            promoCodeLabel: promoCodeLabel || "\u{1F381} Special Offer Code For You",
            customMessage: messageContent,
            greeting: greeting || "Hello! \u{1F44B}",
            subject: subject || `\u{1F381} Special Offer: ${promoCode}`,
            previewText,
            header: header || {
              title: "Special Offer Just For You!",
              subtitle: "Don't miss out on this exclusive deal"
            },
            footer,
            orderButton: orderButton || {
              text: "\u{1F31F} Start Shopping Now",
              url: "https://localcooks.ca"
            },
            usageSteps: usageSteps || {
              enabled: true,
              title: "\u{1F680} How to use your offer:",
              steps: [
                `Visit our website: <a href="https://localcooks.ca" style="color: #1d4ed8;">https://localcooks.ca</a>`,
                "Browse our amazing local cooks and their delicious offerings",
                promoCode ? "Apply your promo code during checkout" : "Complete your order",
                "Enjoy your special offer!"
              ]
            },
            emailContainer: emailContainer || {
              maxWidth: "600px",
              backgroundColor: "#f1f5f9",
              borderRadius: "12px",
              boxShadow: "0 4px 20px rgba(0,0,0,0.08)",
              opacity: "1"
            },
            dividers,
            promoCodeStyling,
            promoStyle: promoStyle || { colorTheme: "green", borderStyle: "dashed" },
            sections
          });
          const emailSent = await sendEmail2(emailContent, {
            trackingId: `promo_email_${targetEmail}_${Date.now()}`
          });
          if (emailSent) {
            console.log(`\u{1F525} ${emailType} email sent successfully to ${targetEmail}`);
            results.push({ email: targetEmail, status: "success" });
            successCount++;
          } else {
            console.error(`\u{1F525} Failed to send ${emailType} email to ${targetEmail}`);
            results.push({ email: targetEmail, status: "failed", error: "Email sending failed" });
            failureCount++;
          }
        } catch (error) {
          console.error(`\u{1F525} Error sending ${emailType} email to ${targetEmail}:`, error);
          results.push({ email: targetEmail, status: "failed", error: error instanceof Error ? error.message : "Unknown error" });
          failureCount++;
        }
      }
      if (successCount > 0) {
        res.json({
          success: true,
          message: `${emailType} emails sent: ${successCount} successful, ${failureCount} failed`,
          emailType,
          results,
          summary: {
            total: targetEmails.length,
            successful: successCount,
            failed: failureCount
          }
        });
      } else {
        res.status(500).json({
          error: "All email sending failed",
          message: `Failed to send ${emailType} emails to any recipients.`,
          results
        });
      }
    } catch (error) {
      console.error("\u{1F525} Error sending company email:", error);
      res.status(500).json({
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error occurred"
      });
    }
  });
  app3.post("/api/admin/send-promo-email", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
    try {
      console.log(`\u{1F525} POST /api/admin/send-promo-email - Firebase UID: ${req.firebaseUser?.uid}, Neon User ID: ${req.neonUser?.id}`);
      const {
        email,
        customEmails,
        emailMode,
        promoCode,
        customMessage,
        message,
        promoCodeLabel,
        greeting,
        recipientType,
        designSystem,
        isPremium,
        sections,
        orderButton,
        header,
        footer,
        usageSteps,
        emailContainer,
        subject,
        previewText,
        promoStyle,
        promoCodeStyling,
        buttonText,
        orderUrl
      } = req.body;
      const messageContent = customMessage || message;
      if (emailMode === "custom") {
        if (!customEmails || !Array.isArray(customEmails) || customEmails.length === 0) {
          console.log("Promo email request - Missing custom emails");
          return res.status(400).json({ error: "At least one email address is required" });
        }
      } else {
        if (!email) {
          console.log("Promo email request - Missing email");
          return res.status(400).json({ error: "Email is required" });
        }
      }
      if (promoCode && promoCode.length > 0 && promoCode.length < 3) {
        console.log("\u{1F525} Promo email request - Invalid promo code length");
        return res.status(400).json({ error: "Promo code must be at least 3 characters long if provided" });
      }
      if (!messageContent || messageContent.length < 10) {
        console.log("Promo email request - Invalid message:", {
          customMessage: customMessage?.substring(0, 50),
          message: message?.substring(0, 50),
          messageContent: messageContent?.substring(0, 50)
        });
        return res.status(400).json({ error: "Message must be at least 10 characters" });
      }
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (emailMode === "custom") {
        for (const customEmail of customEmails) {
          if (!emailRegex.test(customEmail)) {
            return res.status(400).json({
              error: "Invalid email",
              message: `Please provide a valid email address: ${customEmail}`
            });
          }
        }
      } else {
        if (!emailRegex.test(email)) {
          return res.status(400).json({
            error: "Invalid email",
            message: "Please provide a valid email address"
          });
        }
      }
      if (promoCode && promoCode.length > 0 && (promoCode.length < 3 || promoCode.length > 50)) {
        return res.status(400).json({
          error: "Invalid promo code",
          message: "Promo code must be between 3 and 50 characters"
        });
      }
      if (messageContent.length > 1e3) {
        return res.status(400).json({
          error: "Invalid message",
          message: "Message must be less than 1000 characters"
        });
      }
      const targetEmails = emailMode === "custom" ? customEmails : [email];
      console.log(`\u{1F525} Admin ${req.neonUser?.username} sending promo email to ${targetEmails.length} recipient(s) with code: ${promoCode}`);
      const { sendEmail: sendEmail2, generatePromoCodeEmail: generatePromoCodeEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
      const results = [];
      let successCount = 0;
      let failureCount = 0;
      for (const targetEmail of targetEmails) {
        try {
          const emailContent = generatePromoCodeEmail2({
            email: targetEmail,
            promoCode: promoCode.trim(),
            customMessage: messageContent.trim(),
            greeting,
            promoStyle: promoStyle || { colorTheme: "green", borderStyle: "dashed" },
            promoCodeStyling,
            designSystem,
            isPremium: isPremium || false,
            sections: sections || [],
            orderButton: orderButton || {
              text: buttonText || "Get Started",
              url: orderUrl || "https://localcooks.ca",
              styling: {
                backgroundColor: "#F51042",
                color: "#ffffff",
                fontSize: "16px",
                fontWeight: "600",
                padding: "12px 24px",
                borderRadius: "8px",
                textAlign: "center"
              }
            },
            header: header || {
              title: "Local Cooks Header",
              subtitle: "Premium Quality Food Subheader",
              styling: {
                backgroundColor: "linear-gradient(135deg, #F51042 0%, #FF5470 100%)",
                titleColor: "#ffffff",
                subtitleColor: "#ffffff",
                titleFontSize: "32px",
                subtitleFontSize: "18px",
                padding: "24px",
                borderRadius: "0px",
                textAlign: "center"
              }
            },
            footer: footer || {
              mainText: "Thank you for being part of the Local Cooks community!",
              contactText: "Questions? Contact us at support@localcooks.com",
              copyrightText: "\xA9 2024 Local Cooks. All rights reserved.",
              showContact: true,
              showCopyright: true,
              styling: {
                backgroundColor: "#f8fafc",
                textColor: "#64748b",
                linkColor: "#F51042",
                fontSize: "14px",
                padding: "24px 32px",
                textAlign: "center",
                borderColor: "#e2e8f0"
              }
            },
            usageSteps: usageSteps || {
              title: "\u{1F680} How to use your promo code:",
              steps: [
                `Visit our website: <a href="${orderUrl || "https://localcooks.ca"}" style="color: #1d4ed8;">${orderUrl || "https://localcooks.ca"}</a>`,
                "Browse our amazing local cooks and their delicious offerings",
                "Apply your promo code during checkout",
                "Enjoy your special offer!"
              ],
              enabled: true,
              styling: {
                backgroundColor: "linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)",
                borderColor: "#93c5fd",
                titleColor: "#1d4ed8",
                textColor: "#1e40af",
                linkColor: "#1d4ed8",
                padding: "20px",
                borderRadius: "8px"
              }
            },
            emailContainer: emailContainer || {
              maxWidth: "600px",
              backgroundColor: "#f1f5f9",
              borderRadius: "12px",
              boxShadow: "0 4px 20px rgba(0,0,0,0.08)"
            },
            dividers: {
              enabled: true,
              style: "solid",
              color: "#e2e8f0",
              thickness: "1px",
              margin: "24px 0",
              opacity: "1"
            },
            subject,
            previewText,
            promoCodeLabel
          });
          const emailSent = await sendEmail2(emailContent, {
            trackingId: `promo_custom_${targetEmail}_${promoCode}_${Date.now()}`
          });
          if (emailSent) {
            console.log(`\u{1F525} Promo email sent successfully to ${targetEmail} with code ${promoCode}`);
            results.push({ email: targetEmail, status: "success" });
            successCount++;
          } else {
            console.error(`\u{1F525} Failed to send promo email to ${targetEmail}`);
            results.push({ email: targetEmail, status: "failed", error: "Email sending failed" });
            failureCount++;
          }
        } catch (error) {
          console.error(`\u{1F525} Error sending promo email to ${targetEmail}:`, error);
          results.push({ email: targetEmail, status: "failed", error: error instanceof Error ? error.message : "Unknown error" });
          failureCount++;
        }
      }
      if (successCount > 0) {
        return res.status(200).json({
          message: `Promo code emails sent: ${successCount} successful, ${failureCount} failed`,
          results,
          promoCode,
          sentBy: req.neonUser?.username,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          summary: {
            total: targetEmails.length,
            successful: successCount,
            failed: failureCount
          }
        });
      } else {
        return res.status(500).json({
          error: "All email sending failed",
          message: "Failed to send promo code emails to any recipients.",
          results
        });
      }
    } catch (error) {
      console.error("\u{1F525} Error sending promo email:", error);
      return res.status(500).json({
        error: "Internal server error",
        message: "An error occurred while sending the promo code email"
      });
    }
  });
  app3.post("/api/test-promo-email", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
    try {
      console.log(`\u{1F525} POST /api/test-promo-email - Firebase UID: ${req.firebaseUser?.uid}, Neon User ID: ${req.neonUser?.id}`);
      const {
        email,
        promoCode,
        customMessage,
        message,
        promoCodeLabel,
        greeting,
        designSystem,
        isPremium,
        sections,
        orderButton,
        header,
        footer,
        usageSteps,
        emailContainer,
        subject,
        previewText,
        promoStyle,
        promoCodeStyling
      } = req.body;
      const messageContent = customMessage || message;
      console.log(`\u{1F525} Admin ${req.neonUser?.username} testing promo email`);
      const { sendEmail: sendEmail2, generatePromoCodeEmail: generatePromoCodeEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
      const emailContent = generatePromoCodeEmail2({
        email: email || "test@example.com",
        promoCode: promoCode || "TEST20",
        customMessage: messageContent || "This is a test promo code email from the admin panel. Thank you for being an amazing customer!",
        greeting,
        promoStyle: promoStyle || { colorTheme: "green", borderStyle: "dashed" },
        promoCodeStyling,
        designSystem,
        isPremium: isPremium || false,
        sections: sections || [],
        orderButton,
        header: header || {
          title: "Local Cooks Header",
          subtitle: "Premium Quality Food Subheader",
          styling: {
            backgroundColor: "linear-gradient(135deg, #F51042 0%, #FF5470 100%)",
            titleColor: "#ffffff",
            subtitleColor: "#ffffff",
            titleFontSize: "32px",
            subtitleFontSize: "18px",
            padding: "24px",
            borderRadius: "0px",
            textAlign: "center"
          }
        },
        footer: footer || {
          mainText: "Thank you for being part of the Local Cooks community!",
          contactText: "Questions? Contact us at support@localcooks.com",
          copyrightText: "\xA9 2024 Local Cooks. All rights reserved.",
          showContact: true,
          showCopyright: true,
          styling: {
            backgroundColor: "#f8fafc",
            textColor: "#64748b",
            linkColor: "#F51042",
            fontSize: "14px",
            padding: "24px 32px",
            textAlign: "center",
            borderColor: "#e2e8f0"
          }
        },
        usageSteps: usageSteps || {
          title: "\u{1F680} How to use your promo code:",
          steps: [
            'Visit our website: <a href="https://localcooks.ca" style="color: #1d4ed8;">https://localcooks.ca</a>',
            "Browse our amazing local cooks and their delicious offerings",
            "Apply your promo code during checkout",
            "Enjoy your special offer!"
          ],
          enabled: true,
          styling: {
            backgroundColor: "linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)",
            borderColor: "#93c5fd",
            titleColor: "#1d4ed8",
            textColor: "#1e40af",
            linkColor: "#1d4ed8",
            padding: "20px",
            borderRadius: "8px"
          }
        },
        emailContainer: emailContainer || {
          maxWidth: "600px",
          backgroundColor: "#f1f5f9",
          borderRadius: "12px",
          boxShadow: "0 4px 20px rgba(0,0,0,0.08)"
        },
        dividers: {
          enabled: true,
          style: "solid",
          color: "#e2e8f0",
          thickness: "1px",
          margin: "24px 0",
          opacity: "1"
        },
        subject,
        previewText,
        promoCodeLabel
      });
      const emailSent = await sendEmail2(emailContent, {
        trackingId: `test_promo_custom_${email || "test"}_${Date.now()}`
      });
      if (emailSent) {
        return res.status(200).json({
          message: "Test promo email sent successfully",
          email: email || "test@example.com",
          promoCode: promoCode || "TEST20"
        });
      } else {
        return res.status(500).json({
          error: "Test email failed",
          message: "Failed to send test promo email"
        });
      }
    } catch (error) {
      console.error("\u{1F525} Error sending test promo email:", error);
      return res.status(500).json({
        error: "Internal server error",
        message: "An error occurred while testing promo email"
      });
    }
  });
  app3.post(
    "/api/preview-promo-email",
    requireFirebaseAuthWithUser,
    requireAdmin,
    async (req, res) => {
      try {
        console.log(`\u{1F525} POST /api/preview-promo-email - Firebase UID: ${req.firebaseUser?.uid}, Neon User ID: ${req.neonUser?.id}`);
        const {
          promoCode,
          customMessage,
          message,
          promoCodeLabel,
          greeting,
          designSystem,
          isPremium,
          sections,
          orderButton,
          header,
          footer,
          usageSteps,
          emailContainer,
          subject,
          previewText,
          promoStyle,
          promoCodeStyling,
          buttonText,
          orderUrl
        } = req.body;
        const messageContent = customMessage || message;
        if (!promoCode || !messageContent) {
          return res.status(400).json({
            error: "Missing required fields",
            message: "Promo code and message are required for preview"
          });
        }
        console.log(`\u{1F525} Admin ${req.neonUser?.username} previewing promo email`);
        const { generatePromoCodeEmail: generatePromoCodeEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        const emailContent = generatePromoCodeEmail2({
          email: "preview@example.com",
          // Dummy email for preview
          promoCode: promoCode.trim(),
          customMessage: messageContent.trim(),
          message: messageContent.trim(),
          // Also pass as message for compatibility
          greeting,
          promoStyle: promoStyle || { colorTheme: "green", borderStyle: "dashed" },
          promoCodeStyling,
          designSystem,
          isPremium: isPremium || false,
          sections: sections || [],
          orderButton: orderButton || {
            text: buttonText || "Get Started",
            url: orderUrl || "https://localcooks.ca",
            styling: {
              backgroundColor: "#F51042",
              color: "#ffffff",
              fontSize: "16px",
              fontWeight: "600",
              padding: "12px 24px",
              borderRadius: "8px",
              textAlign: "center"
            }
          },
          header: header || {
            title: "Local Cooks Header",
            subtitle: "Premium Quality Food Subheader",
            styling: {
              backgroundColor: "linear-gradient(135deg, #F51042 0%, #FF5470 100%)",
              titleColor: "#ffffff",
              subtitleColor: "#ffffff",
              titleFontSize: "32px",
              subtitleFontSize: "18px",
              padding: "24px",
              borderRadius: "0px",
              textAlign: "center"
            }
          },
          footer: footer || {
            mainText: "Thank you for being part of the Local Cooks community!",
            contactText: "Questions? Contact us at support@localcooks.com",
            copyrightText: "\xA9 2024 Local Cooks. All rights reserved.",
            showContact: true,
            showCopyright: true,
            styling: {
              backgroundColor: "#f8fafc",
              textColor: "#64748b",
              linkColor: "#F51042",
              fontSize: "14px",
              padding: "24px 32px",
              textAlign: "center",
              borderColor: "#e2e8f0"
            }
          },
          usageSteps: usageSteps || {
            title: "\u{1F680} How to use your promo code:",
            steps: [
              `Visit our website: <a href="${orderUrl || "https://localcooks.ca"}" style="color: #1d4ed8;">${orderUrl || "https://localcooks.ca"}</a>`,
              "Browse our amazing local cooks and their delicious offerings",
              "Apply your promo code during checkout",
              "Enjoy your special offer!"
            ],
            enabled: true,
            styling: {
              backgroundColor: "linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)",
              borderColor: "#93c5fd",
              titleColor: "#1d4ed8",
              textColor: "#1e40af",
              linkColor: "#1d4ed8",
              padding: "20px",
              borderRadius: "8px"
            }
          },
          emailContainer: emailContainer || {
            maxWidth: "600px",
            backgroundColor: "#f1f5f9",
            borderRadius: "12px",
            boxShadow: "0 4px 20px rgba(0,0,0,0.08)"
          },
          dividers: {
            enabled: true,
            style: "solid",
            color: "#e2e8f0",
            thickness: "1px",
            margin: "24px 0",
            opacity: "1"
          },
          subject,
          previewText,
          promoCodeLabel
        });
        res.setHeader("Content-Type", "text/html");
        return res.status(200).send(emailContent.html || "<p>No HTML content generated</p>");
      } catch (error) {
        console.error("\u{1F525} Error generating promo email preview:", error);
        return res.status(500).json({
          error: "Internal server error",
          message: "An error occurred while generating email preview"
        });
      }
    }
  );
  app3.get("/api/platform-settings/service-fee-rate", async (req, res) => {
    try {
      const [setting] = await db.select().from(platformSettings).where(eq3(platformSettings.key, "service_fee_rate")).limit(1);
      if (setting) {
        const rate = parseFloat(setting.value);
        if (!isNaN(rate) && rate >= 0 && rate <= 1) {
          return res.json({
            key: "service_fee_rate",
            value: setting.value,
            rate,
            percentage: (rate * 100).toFixed(2),
            description: setting.description
          });
        }
      }
      return res.json({
        key: "service_fee_rate",
        value: "0.05",
        rate: 0.05,
        percentage: "5.00",
        description: "Platform service fee rate as decimal (e.g., 0.05 for 5%). Admin configurable."
      });
    } catch (error) {
      console.error("Error getting service fee rate:", error);
      res.status(500).json({
        error: "Failed to get service fee rate",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app3.get("/api/admin/platform-settings/service-fee-rate", requireSessionAdmin, async (req, res) => {
    try {
      const [setting] = await db.select().from(platformSettings).where(eq3(platformSettings.key, "service_fee_rate")).limit(1);
      if (setting) {
        const rate = parseFloat(setting.value);
        if (!isNaN(rate) && rate >= 0 && rate <= 1) {
          return res.json({
            key: "service_fee_rate",
            value: setting.value,
            rate,
            percentage: (rate * 100).toFixed(2),
            description: setting.description,
            updatedAt: setting.updatedAt
          });
        }
      }
      return res.json({
        key: "service_fee_rate",
        value: "0.05",
        rate: 0.05,
        percentage: "5.00",
        description: "Platform service fee rate as decimal (e.g., 0.05 for 5%). Admin configurable."
      });
    } catch (error) {
      console.error("Error getting service fee rate:", error);
      res.status(500).json({
        error: "Failed to get service fee rate",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app3.put("/api/admin/platform-settings/service-fee-rate", requireSessionAdmin, async (req, res) => {
    try {
      const { rate } = req.body;
      if (rate === void 0 || rate === null) {
        return res.status(400).json({ error: "Rate is required" });
      }
      const rateValue = typeof rate === "string" ? parseFloat(rate) : rate;
      if (isNaN(rateValue) || rateValue < 0 || rateValue > 1) {
        return res.status(400).json({ error: "Rate must be a number between 0 and 1 (e.g., 0.05 for 5%)" });
      }
      const userId = req.sessionUser?.id || req.neonUser?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      const [existing] = await db.select().from(platformSettings).where(eq3(platformSettings.key, "service_fee_rate")).limit(1);
      if (existing) {
        const [updated] = await db.update(platformSettings).set({
          value: rateValue.toString(),
          updatedBy: userId,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq3(platformSettings.key, "service_fee_rate")).returning();
        return res.json({
          key: "service_fee_rate",
          value: updated.value,
          rate: rateValue,
          percentage: (rateValue * 100).toFixed(2),
          description: updated.description,
          updatedAt: updated.updatedAt,
          message: "Service fee rate updated successfully"
        });
      } else {
        const [created] = await db.insert(platformSettings).values({
          key: "service_fee_rate",
          value: rateValue.toString(),
          description: "Platform service fee rate as decimal (e.g., 0.05 for 5%). Admin configurable.",
          updatedBy: userId
        }).returning();
        return res.json({
          key: "service_fee_rate",
          value: created.value,
          rate: rateValue,
          percentage: (rateValue * 100).toFixed(2),
          description: created.description,
          updatedAt: created.updatedAt,
          message: "Service fee rate created successfully"
        });
      }
    } catch (error) {
      console.error("Error updating service fee rate:", error);
      res.status(500).json({
        error: "Failed to update service fee rate",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app3.post(
    "/api/firebase/chef/kitchen-applications",
    upload.fields([
      { name: "foodSafetyLicenseFile", maxCount: 1 },
      { name: "foodEstablishmentCertFile", maxCount: 1 }
    ]),
    requireFirebaseAuthWithUser,
    async (req, res) => {
      try {
        console.log(`\u{1F373} POST /api/firebase/chef/kitchen-applications - Chef ${req.neonUser.id} submitting kitchen application`);
        const files = req.files;
        let foodSafetyLicenseUrl;
        let foodEstablishmentCertUrl;
        if (files) {
          if (files["foodSafetyLicenseFile"]?.[0]) {
            try {
              foodSafetyLicenseUrl = await uploadToBlob(files["foodSafetyLicenseFile"][0], req.neonUser.id, "documents");
              console.log(`\u2705 Uploaded food safety license: ${foodSafetyLicenseUrl}`);
            } catch (uploadError) {
              console.error("\u274C Failed to upload food safety license:", uploadError);
            }
          }
          if (files["foodEstablishmentCertFile"]?.[0]) {
            try {
              foodEstablishmentCertUrl = await uploadToBlob(files["foodEstablishmentCertFile"][0], req.neonUser.id, "documents");
              console.log(`\u2705 Uploaded food establishment cert: ${foodEstablishmentCertUrl}`);
            } catch (uploadError) {
              console.error("\u274C Failed to upload food establishment cert:", uploadError);
            }
          }
        }
        let customFieldsData;
        if (req.body.customFieldsData) {
          try {
            customFieldsData = typeof req.body.customFieldsData === "string" ? JSON.parse(req.body.customFieldsData) : req.body.customFieldsData;
          } catch (error) {
            console.error("Error parsing customFieldsData:", error);
            customFieldsData = void 0;
          }
        }
        const formData = {
          chefId: req.neonUser.id,
          locationId: parseInt(req.body.locationId),
          fullName: req.body.fullName,
          email: req.body.email,
          phone: req.body.phone,
          kitchenPreference: req.body.kitchenPreference,
          businessDescription: req.body.businessDescription || void 0,
          cookingExperience: req.body.cookingExperience || void 0,
          foodSafetyLicense: req.body.foodSafetyLicense,
          foodSafetyLicenseUrl: foodSafetyLicenseUrl || req.body.foodSafetyLicenseUrl || void 0,
          foodEstablishmentCert: req.body.foodEstablishmentCert,
          foodEstablishmentCertUrl: foodEstablishmentCertUrl || req.body.foodEstablishmentCertUrl || void 0,
          customFieldsData: customFieldsData || void 0
        };
        const parsedData = insertChefKitchenApplicationSchema.safeParse(formData);
        if (!parsedData.success) {
          const validationError = fromZodError(parsedData.error);
          console.log("\u274C Validation failed:", validationError.details);
          return res.status(400).json({
            error: "Validation error",
            message: validationError.message,
            details: validationError.details
          });
        }
        const location = await firebaseStorage.getLocationById(parsedData.data.locationId);
        if (!location) {
          return res.status(404).json({ error: "Kitchen location not found" });
        }
        const application = await firebaseStorage.createChefKitchenApplication(parsedData.data);
        console.log(`\u2705 Kitchen application created/updated: Chef ${req.neonUser.id} \u2192 Location ${parsedData.data.locationId}, ID: ${application.id}`);
        res.status(201).json({
          success: true,
          application,
          message: "Kitchen application submitted successfully. The kitchen manager will review your application.",
          isResubmission: application.createdAt < application.updatedAt
        });
      } catch (error) {
        console.error("Error creating kitchen application:", error);
        res.status(500).json({
          error: "Failed to submit kitchen application",
          message: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
  );
  app3.get("/api/firebase/chef/kitchen-applications", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const chefId = req.neonUser.id;
      const firebaseUid = req.firebaseUser.uid;
      console.log(`[KITCHEN APPLICATIONS] Fetching kitchen applications for chef ID: ${chefId} (Firebase UID: ${firebaseUid})`);
      console.log(`[KITCHEN APPLICATIONS] User object:`, {
        id: req.neonUser.id,
        username: req.neonUser.username,
        role: req.neonUser.role,
        isChef: req.neonUser.isChef
      });
      const applications2 = await firebaseStorage.getChefKitchenApplicationsByChefId(chefId);
      console.log(`[KITCHEN APPLICATIONS] Retrieved ${applications2.length} kitchen applications for chef ${chefId}`);
      if (applications2.length > 0) {
        console.log(`[KITCHEN APPLICATIONS] First application sample:`, {
          id: applications2[0].id,
          chefId: applications2[0].chefId,
          locationId: applications2[0].locationId,
          status: applications2[0].status
        });
      }
      const enrichedApplications = await Promise.all(
        applications2.map(async (app4) => {
          const location = await firebaseStorage.getLocationById(app4.locationId);
          return {
            ...app4,
            location: location ? {
              id: location.id,
              name: location.name,
              address: location.address,
              city: location.city
            } : null
          };
        })
      );
      res.json(enrichedApplications);
    } catch (error) {
      console.error("Error getting chef kitchen applications:", error);
      res.status(500).json({ error: "Failed to get kitchen applications" });
    }
  });
  app3.get("/api/firebase/chef/kitchen-applications/location/:locationId", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const locationId = parseInt(req.params.locationId);
      if (isNaN(locationId)) {
        return res.status(400).json({ error: "Invalid location ID" });
      }
      console.log(`\u{1F373} GET /api/firebase/chef/kitchen-applications/location/${locationId} - Chef ${req.neonUser.id}`);
      const application = await firebaseStorage.getChefKitchenApplication(req.neonUser.id, locationId);
      if (!application) {
        return res.status(404).json({
          error: "No application found",
          hasApplication: false,
          canBook: false,
          message: "You have not applied to this kitchen yet."
        });
      }
      const location = await firebaseStorage.getLocationById(locationId);
      res.json({
        ...application,
        hasApplication: true,
        canBook: application.status === "approved",
        location: location ? {
          id: location.id,
          name: location.name,
          address: location.address
        } : null
      });
    } catch (error) {
      console.error("Error getting chef kitchen application:", error);
      res.status(500).json({ error: "Failed to get kitchen application" });
    }
  });
  app3.get("/api/firebase/chef/kitchen-access-status/:locationId", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const locationId = parseInt(req.params.locationId);
      if (isNaN(locationId)) {
        return res.status(400).json({ error: "Invalid location ID" });
      }
      console.log(`\u{1F373} GET /api/firebase/chef/kitchen-access-status/${locationId} - Chef ${req.neonUser.id}`);
      const accessStatus = await firebaseStorage.getChefKitchenApplicationStatus(req.neonUser.id, locationId);
      res.json(accessStatus);
    } catch (error) {
      console.error("Error getting kitchen access status:", error);
      res.status(500).json({ error: "Failed to get kitchen access status" });
    }
  });
  app3.get("/api/firebase/chef/approved-kitchens", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      console.log(`\u{1F373} GET /api/firebase/chef/approved-kitchens - Chef ${req.neonUser.id}`);
      const approvedKitchens = await firebaseStorage.getChefApprovedKitchens(req.neonUser.id);
      console.log(`[APPROVED KITCHENS] Returning ${approvedKitchens.length} approved locations for chef ${req.neonUser.id}`);
      if (approvedKitchens.length > 0) {
        console.log(`[APPROVED KITCHENS] First location sample:`, approvedKitchens[0]);
      }
      res.json(approvedKitchens);
    } catch (error) {
      console.error("Error getting approved kitchens:", error);
      res.status(500).json({ error: "Failed to get approved kitchens" });
    }
  });
  app3.patch("/api/firebase/chef/kitchen-applications/:id/cancel", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const applicationId = parseInt(req.params.id);
      if (isNaN(applicationId)) {
        return res.status(400).json({ error: "Invalid application ID" });
      }
      console.log(`\u{1F373} PATCH /api/firebase/chef/kitchen-applications/${applicationId}/cancel - Chef ${req.neonUser.id}`);
      const cancelledApplication = await firebaseStorage.cancelChefKitchenApplication(applicationId, req.neonUser.id);
      res.json({
        success: true,
        application: cancelledApplication,
        message: "Application cancelled successfully"
      });
    } catch (error) {
      console.error("Error cancelling kitchen application:", error);
      res.status(500).json({
        error: "Failed to cancel application",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app3.patch(
    "/api/firebase/chef/kitchen-applications/:id/documents",
    upload.fields([
      { name: "foodSafetyLicenseFile", maxCount: 1 },
      { name: "foodEstablishmentCertFile", maxCount: 1 }
    ]),
    requireFirebaseAuthWithUser,
    async (req, res) => {
      try {
        const applicationId = parseInt(req.params.id);
        if (isNaN(applicationId)) {
          return res.status(400).json({ error: "Invalid application ID" });
        }
        console.log(`\u{1F373} PATCH /api/firebase/chef/kitchen-applications/${applicationId}/documents - Chef ${req.neonUser.id}`);
        const existing = await firebaseStorage.getChefKitchenApplicationById(applicationId);
        if (!existing || existing.chefId !== req.neonUser.id) {
          return res.status(403).json({ error: "Application not found or access denied" });
        }
        const files = req.files;
        const updateData = { id: applicationId };
        if (files) {
          if (files["foodSafetyLicenseFile"]?.[0]) {
            try {
              updateData.foodSafetyLicenseUrl = await uploadToBlob(files["foodSafetyLicenseFile"][0], req.neonUser.id, "documents");
              console.log(`\u2705 Uploaded updated food safety license: ${updateData.foodSafetyLicenseUrl}`);
            } catch (uploadError) {
              console.error("\u274C Failed to upload food safety license:", uploadError);
            }
          }
          if (files["foodEstablishmentCertFile"]?.[0]) {
            try {
              updateData.foodEstablishmentCertUrl = await uploadToBlob(files["foodEstablishmentCertFile"][0], req.neonUser.id, "documents");
              console.log(`\u2705 Uploaded updated food establishment cert: ${updateData.foodEstablishmentCertUrl}`);
            } catch (uploadError) {
              console.error("\u274C Failed to upload food establishment cert:", uploadError);
            }
          }
        }
        const updatedApplication = await firebaseStorage.updateChefKitchenApplicationDocuments(updateData);
        res.json({
          success: true,
          application: updatedApplication,
          message: "Documents updated successfully. They will be reviewed by the manager."
        });
      } catch (error) {
        console.error("Error updating kitchen application documents:", error);
        res.status(500).json({
          error: "Failed to update documents",
          message: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
  );
  app3.get("/api/manager/kitchen-applications", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      console.log(`\u{1F468}\u200D\u{1F373} GET /api/manager/kitchen-applications - Manager ${user.id}`);
      const applications2 = await firebaseStorage.getChefKitchenApplicationsForManager(user.id);
      res.json(applications2);
    } catch (error) {
      console.error("Error getting kitchen applications for manager:", error);
      res.status(500).json({ error: "Failed to get applications" });
    }
  });
  app3.get("/api/manager/kitchen-applications/location/:locationId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const locationId = parseInt(req.params.locationId);
      if (isNaN(locationId)) {
        return res.status(400).json({ error: "Invalid location ID" });
      }
      console.log(`\u{1F468}\u200D\u{1F373} GET /api/manager/kitchen-applications/location/${locationId} - Manager ${user.id}`);
      const location = await firebaseStorage.getLocationById(locationId);
      if (!location || location.managerId !== user.id) {
        return res.status(403).json({ error: "Access denied to this location" });
      }
      const applications2 = await firebaseStorage.getChefKitchenApplicationsByLocationId(locationId);
      res.json(applications2);
    } catch (error) {
      console.error("Error getting kitchen applications for location:", error);
      res.status(500).json({ error: "Failed to get applications" });
    }
  });
  app3.patch("/api/manager/kitchen-applications/:id/status", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const applicationId = parseInt(req.params.id);
      if (isNaN(applicationId)) {
        return res.status(400).json({ error: "Invalid application ID" });
      }
      console.log(`\u{1F468}\u200D\u{1F373} PATCH /api/manager/kitchen-applications/${applicationId}/status - Manager ${user.id}`);
      const { status, feedback } = req.body;
      if (!status || !["approved", "rejected"].includes(status)) {
        return res.status(400).json({ error: 'Status must be "approved" or "rejected"' });
      }
      const application = await firebaseStorage.getChefKitchenApplicationById(applicationId);
      if (!application) {
        return res.status(404).json({ error: "Application not found" });
      }
      const location = await firebaseStorage.getLocationById(application.locationId);
      if (!location || location.managerId !== user.id) {
        return res.status(403).json({ error: "Access denied to this application" });
      }
      const updatedApplication = await firebaseStorage.updateChefKitchenApplicationStatus(
        { id: applicationId, status, feedback },
        user.id
      );
      console.log(`\u2705 Application ${applicationId} ${status} by Manager ${user.id}`);
      if (status === "approved" && updatedApplication) {
        try {
          const existingAccess = await db.select().from(chefLocationAccess).where(
            and3(
              eq3(chefLocationAccess.chefId, application.chefId),
              eq3(chefLocationAccess.locationId, application.locationId)
            )
          );
          if (existingAccess.length === 0) {
            await db.insert(chefLocationAccess).values({
              chefId: application.chefId,
              locationId: application.locationId,
              grantedBy: req.neonUser.id,
              grantedAt: /* @__PURE__ */ new Date()
            });
            console.log(`\u2705 Granted chef ${application.chefId} access to location ${application.locationId}`);
          } else {
            console.log(`\u2139\uFE0F Chef ${application.chefId} already has access to location ${application.locationId}`);
          }
        } catch (accessError) {
          console.error("Error granting chef access:", accessError);
        }
      }
      res.json({
        success: true,
        application: updatedApplication,
        message: `Application ${status} successfully`
      });
    } catch (error) {
      console.error("Error updating kitchen application status:", error);
      res.status(500).json({
        error: "Failed to update application status",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app3.patch("/api/manager/kitchen-applications/:id/verify-documents", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const applicationId = parseInt(req.params.id);
      if (isNaN(applicationId)) {
        return res.status(400).json({ error: "Invalid application ID" });
      }
      console.log(`\u{1F468}\u200D\u{1F373} PATCH /api/manager/kitchen-applications/${applicationId}/verify-documents - Manager ${user.id}`);
      const { foodSafetyLicenseStatus, foodEstablishmentCertStatus } = req.body;
      const validStatuses = ["pending", "approved", "rejected"];
      if (foodSafetyLicenseStatus && !validStatuses.includes(foodSafetyLicenseStatus)) {
        return res.status(400).json({ error: "Invalid food safety license status" });
      }
      if (foodEstablishmentCertStatus && !validStatuses.includes(foodEstablishmentCertStatus)) {
        return res.status(400).json({ error: "Invalid food establishment cert status" });
      }
      const application = await firebaseStorage.getChefKitchenApplicationById(applicationId);
      if (!application) {
        return res.status(404).json({ error: "Application not found" });
      }
      const location = await firebaseStorage.getLocationById(application.locationId);
      if (!location || location.managerId !== user.id) {
        return res.status(403).json({ error: "Access denied to this application" });
      }
      const updateData = { id: applicationId };
      if (foodSafetyLicenseStatus) updateData.foodSafetyLicenseStatus = foodSafetyLicenseStatus;
      if (foodEstablishmentCertStatus) updateData.foodEstablishmentCertStatus = foodEstablishmentCertStatus;
      const updatedApplication = await firebaseStorage.updateChefKitchenApplicationDocuments(updateData);
      res.json({
        success: true,
        application: updatedApplication,
        message: "Document verification updated"
      });
    } catch (error) {
      console.error("Error verifying kitchen application documents:", error);
      res.status(500).json({
        error: "Failed to verify documents",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app3.get(
    "/api/manager/locations/:locationId/requirements",
    requireFirebaseAuthWithUser,
    requireManager,
    async (req, res) => {
      try {
        const user = req.neonUser;
        const locationId = parseInt(req.params.locationId);
        if (isNaN(locationId)) {
          return res.status(400).json({ error: "Invalid location ID" });
        }
        const location = await firebaseStorage.getLocationById(locationId);
        if (!location || location.managerId !== user.id) {
          return res.status(403).json({ error: "Access denied" });
        }
        const requirements = await firebaseStorage.getLocationRequirementsWithDefaults(locationId);
        res.json(requirements);
      } catch (error) {
        console.error("Error getting location requirements:", error);
        res.status(500).json({ error: "Failed to get requirements" });
      }
    }
  );
  app3.put(
    "/api/manager/locations/:locationId/requirements",
    requireFirebaseAuthWithUser,
    requireManager,
    async (req, res) => {
      try {
        const user = req.neonUser;
        const locationId = parseInt(req.params.locationId);
        if (isNaN(locationId)) {
          return res.status(400).json({ error: "Invalid location ID" });
        }
        const location = await firebaseStorage.getLocationById(locationId);
        if (!location || location.managerId !== user.id) {
          return res.status(403).json({ error: "Access denied" });
        }
        const updates = updateLocationRequirementsSchema.parse(req.body);
        const requirements = await firebaseStorage.upsertLocationRequirements(locationId, updates);
        res.json({ success: true, requirements });
      } catch (error) {
        console.error("Error updating location requirements:", error);
        res.status(500).json({
          error: "Failed to update requirements",
          message: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
  );
  app3.get("/api/public/locations/:locationId/requirements", async (req, res) => {
    try {
      const locationId = parseInt(req.params.locationId);
      if (isNaN(locationId)) {
        return res.status(400).json({ error: "Invalid location ID" });
      }
      const requirements = await firebaseStorage.getLocationRequirementsWithDefaults(locationId);
      res.json(requirements);
    } catch (error) {
      console.error("Error getting location requirements:", error);
      res.status(500).json({ error: "Failed to get requirements" });
    }
  });
  app3.get("/api/firebase/microlearning/completion/:userId", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const userIdParam = req.params.userId;
      const currentUserId = req.neonUser.id;
      const currentFirebaseUid = req.firebaseUser.uid;
      const isNumeric = !isNaN(parseInt(userIdParam));
      const requestedUserId = isNumeric ? parseInt(userIdParam) : null;
      const isOwnData = userIdParam === currentFirebaseUid || requestedUserId === currentUserId;
      const isAdmin = req.neonUser.role === "admin";
      if (!isOwnData && !isAdmin) {
        return res.status(403).json({ message: "Access denied" });
      }
      const targetUserId = isOwnData ? currentUserId : requestedUserId;
      if (!targetUserId) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      const completion = await firebaseStorage.getMicrolearningCompletion(targetUserId);
      if (!completion) {
        return res.status(404).json({ message: "No completion found" });
      }
      res.json(completion);
    } catch (error) {
      console.error("Error getting microlearning completion status:", error);
      res.status(500).json({ message: "Failed to get completion status" });
    }
  });
  app3.get("/api/firebase/microlearning/certificate/:userId", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const userIdParam = req.params.userId;
      const currentUserId = req.neonUser.id;
      const currentFirebaseUid = req.firebaseUser.uid;
      const isNumeric = !isNaN(parseInt(userIdParam));
      const requestedUserId = isNumeric ? parseInt(userIdParam) : null;
      const isOwnData = userIdParam === currentFirebaseUid || requestedUserId === currentUserId;
      const isAdmin = req.neonUser.role === "admin";
      if (!isOwnData && !isAdmin) {
        return res.status(403).json({ message: "Access denied" });
      }
      const targetUserId = isOwnData ? currentUserId : requestedUserId;
      if (!targetUserId) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      const completion = await firebaseStorage.getMicrolearningCompletion(targetUserId);
      if (!completion || !completion.confirmed) {
        return res.status(404).json({ message: "No confirmed completion found" });
      }
      const user = await firebaseStorage.getUser(targetUserId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const certificateUrl = `/api/certificates/microlearning-${targetUserId}-${Date.now()}.pdf`;
      res.json({
        success: true,
        certificateUrl,
        completionDate: completion.completedAt,
        message: "Certificate for skillpass.nl food safety training preparation - Complete your official certification at skillpass.nl"
      });
    } catch (error) {
      console.error("Error getting microlearning certificate:", error);
      res.status(500).json({ message: "Failed to get certificate" });
    }
  });
  app3.get("/api/firebase/microlearning/progress/:userId", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const userIdParam = req.params.userId;
      const currentUserId = req.neonUser.id;
      const currentFirebaseUid = req.firebaseUser.uid;
      const isNumeric = !isNaN(parseInt(userIdParam));
      const requestedUserId = isNumeric ? parseInt(userIdParam) : null;
      const isOwnData = userIdParam === currentFirebaseUid || requestedUserId === currentUserId;
      const isAdmin = req.neonUser.role === "admin";
      if (!isOwnData && !isAdmin) {
        return res.status(403).json({ message: "Access denied" });
      }
      const targetUserId = isOwnData ? currentUserId : requestedUserId;
      if (!targetUserId) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      const progress = await firebaseStorage.getMicrolearningProgress(targetUserId);
      const completionStatus = await firebaseStorage.getMicrolearningCompletion(targetUserId);
      const applications2 = await firebaseStorage.getApplicationsByUserId(targetUserId);
      const hasApproval = applications2.some((app4) => app4.status === "approved");
      const isCompleted = completionStatus?.confirmed || false;
      const accessLevel = isAdmin || hasApproval || isCompleted ? "full" : "limited";
      res.json({
        success: true,
        progress: progress || [],
        completionConfirmed: completionStatus?.confirmed || false,
        completedAt: completionStatus?.completedAt,
        hasApprovedApplication: hasApproval,
        accessLevel,
        isAdmin
      });
    } catch (error) {
      console.error("Error fetching microlearning progress:", error);
      res.status(500).json({ message: "Failed to fetch progress" });
    }
  });
  app3.post("/api/firebase/microlearning/complete", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const { userId, completionDate, videoProgress: videoProgress2 } = req.body;
      const currentUserId = req.neonUser.id;
      if (currentUserId !== userId && req.neonUser.role !== "admin") {
        return res.status(403).json({ message: "Access denied" });
      }
      const applications2 = await firebaseStorage.getApplicationsByUserId(userId);
      const hasApproval = applications2.some((app4) => app4.status === "approved");
      const isAdmin = req.neonUser.role === "admin";
      if (!hasApproval && !isAdmin) {
        return res.status(403).json({
          message: "Application approval required to complete full certification",
          accessLevel: "limited",
          requiresApproval: true
        });
      }
      const requiredVideos = [
        "basics-personal-hygiene",
        "basics-temperature-danger",
        "basics-cross-contamination",
        "basics-allergen-awareness",
        "basics-food-storage",
        "basics-cooking-temps",
        "basics-cooling-reheating",
        "basics-thawing",
        "basics-receiving",
        "basics-fifo",
        "basics-illness-reporting",
        "basics-pest-control",
        "basics-chemical-safety",
        "basics-food-safety-plan",
        "howto-handwashing",
        "howto-sanitizing",
        "howto-thermometer",
        "howto-cleaning-schedule",
        "howto-equipment-cleaning",
        "howto-uniform-care",
        "howto-wound-care",
        "howto-inspection-prep"
      ];
      const completedVideos = videoProgress2.filter((v) => v.completed).map((v) => v.videoId);
      const allRequired = requiredVideos.every((videoId) => completedVideos.includes(videoId));
      if (!allRequired) {
        return res.status(400).json({
          message: "All required videos must be completed before certification",
          missingVideos: requiredVideos.filter((id) => !completedVideos.includes(id))
        });
      }
      const user = await firebaseStorage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const completionData = {
        userId,
        completedAt: new Date(completionDate),
        videoProgress: videoProgress2,
        confirmed: true,
        certificateGenerated: false
      };
      await firebaseStorage.createMicrolearningCompletion(completionData);
      res.json({
        success: true,
        message: "Microlearning completed successfully",
        completionConfirmed: true
      });
    } catch (error) {
      console.error("Error completing microlearning:", error);
      res.status(500).json({ message: "Failed to complete microlearning" });
    }
  });
  app3.post(
    "/api/firebase/upload-file",
    upload.single("file"),
    requireFirebaseAuthWithUser,
    handleFileUpload
  );
  console.log("\u{1F525} Firebase authentication routes registered successfully");
  console.log("\u2728 Session-free architecture active - JWT tokens only");
  console.log("\u2699\uFE0F Admin platform settings endpoints registered successfully");
  console.log("\u{1F373} Chef kitchen application endpoints registered successfully");
}

// server/routes.ts
init_schema();
import fs3 from "fs";
import { createServer } from "http";
import passport from "passport";
import path2 from "path";
import { fromZodError as fromZodError2 } from "zod-validation-error";

// server/alwaysFoodSafeAPI.ts
async function submitToAlwaysFoodSafe(submission) {
  const apiKey = process.env.ALWAYS_FOOD_SAFE_API_KEY;
  const apiUrl = process.env.ALWAYS_FOOD_SAFE_API_URL || "https://api.alwaysfoodsafe.com";
  if (!apiKey) {
    throw new Error("Always Food Safe API key not configured");
  }
  try {
    const response = await fetch(`${apiUrl}/api/v1/completions`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
        "User-Agent": "LocalCooks-Platform/1.0"
      },
      body: JSON.stringify({
        user: {
          id: submission.userId,
          name: submission.userName,
          email: submission.email
        },
        completion: {
          date: submission.completionDate.toISOString(),
          modules: submission.videoProgress.map((video) => ({
            id: video.videoId,
            completed: video.completed,
            progress: video.progress,
            completedAt: video.completedAt
          }))
        },
        course: {
          type: "microlearning",
          provider: "LocalCooks",
          modules: ["food-handling", "contamination-prevention", "allergen-awareness"]
        }
      })
    });
    if (!response.ok) {
      throw new Error(`Always Food Safe API error: ${response.status} ${response.statusText}`);
    }
    const data = await response.json();
    return {
      success: true,
      certificateId: data.certificate?.id,
      certificateUrl: data.certificate?.url,
      message: data.message || "Completion submitted successfully"
    };
  } catch (error) {
    console.error("Always Food Safe API submission failed:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error occurred"
    };
  }
}
function isAlwaysFoodSafeConfigured() {
  return !!(process.env.ALWAYS_FOOD_SAFE_API_KEY && process.env.ALWAYS_FOOD_SAFE_API_URL);
}

// server/auth.ts
function setupAuth(app3) {
  console.log("\u2705 Session-based auth removed - Using Firebase Auth only");
  console.log("\u2705 All OAuth strategies removed - Firebase Auth handles all authentication");
}

// server/routes.ts
init_email();

// server/sms.ts
import twilio from "twilio";
var getSMSConfig = () => {
  const accountSid = process.env.TWILIO_ACCOUNT_SID;
  const authToken = process.env.TWILIO_AUTH_TOKEN;
  const fromNumber = process.env.TWILIO_PHONE_NUMBER;
  if (!accountSid || !authToken || !fromNumber) {
    const missing = [];
    if (!accountSid) missing.push("TWILIO_ACCOUNT_SID");
    if (!authToken) missing.push("TWILIO_AUTH_TOKEN");
    if (!fromNumber) missing.push("TWILIO_PHONE_NUMBER");
    console.warn("\u26A0\uFE0F Twilio configuration is missing. SMS functionality will be disabled.");
    console.warn(`   Missing variables: ${missing.join(", ")}`);
    console.warn("   Please set these environment variables to enable SMS functionality.");
    return null;
  }
  if (!fromNumber.startsWith("+")) {
    console.warn(`\u26A0\uFE0F TWILIO_PHONE_NUMBER should be in E.164 format (e.g., +14161234567 for Canada, +12125551234 for US). Current value: ${fromNumber}`);
  }
  if (fromNumber.startsWith("+1") && fromNumber.length === 12) {
    const areaCode = fromNumber.substring(2, 5);
    const firstDigit = parseInt(areaCode[0]);
    if (firstDigit >= 2 && firstDigit <= 9) {
      console.log(`\u2705 Twilio phone number detected as North American (US/Canada): ${fromNumber}`);
    }
  }
  return {
    accountSid,
    authToken,
    fromNumber
  };
};
var formatPhoneNumber = (phone) => {
  if (!phone) return null;
  const trimmed = phone.trim();
  if (!trimmed) return null;
  const cleaned = trimmed.replace(/[^\d+]/g, "");
  if (cleaned.startsWith("+")) {
    const digitsAfterPlus = cleaned.substring(1);
    if (digitsAfterPlus.length >= 1 && digitsAfterPlus.length <= 15 && /^\d+$/.test(digitsAfterPlus)) {
      return cleaned;
    }
    console.warn(`\u26A0\uFE0F Invalid E.164 format (must be + followed by 1-15 digits): ${phone}`);
    return null;
  }
  const digitsOnly = cleaned.replace(/\D/g, "");
  if (digitsOnly.length === 11 && digitsOnly.startsWith("1")) {
    return `+${digitsOnly}`;
  }
  if (digitsOnly.length === 10) {
    const areaCode = digitsOnly.substring(0, 3);
    const exchangeCode = digitsOnly.substring(3, 6);
    const firstDigit = parseInt(digitsOnly[0]);
    const fourthDigit = parseInt(digitsOnly[3]);
    if (firstDigit >= 2 && firstDigit <= 9 && fourthDigit >= 2 && fourthDigit <= 9) {
      return `+1${digitsOnly}`;
    } else {
      console.warn(`\u26A0\uFE0F Invalid North American phone number format: ${phone}`);
      console.warn("   Area code and exchange code must start with digits 2-9");
      return null;
    }
  }
  console.warn(`\u26A0\uFE0F Could not format phone number: ${phone} (digits only: ${digitsOnly}, length: ${digitsOnly.length})`);
  console.warn("   Phone numbers should be in E.164 format (e.g., +14161234567 for Canada, +12125551234 for US)");
  console.warn("   Or 10-digit North American numbers (e.g., 4161234567 for Canada, 2125551234 for US)");
  return null;
};
var sendSMS = async (to, message, options) => {
  const startTime = Date.now();
  try {
    const config = getSMSConfig();
    if (!config) {
      console.warn("\u26A0\uFE0F SMS not sent - Twilio configuration missing");
      return false;
    }
    const formattedPhone = formatPhoneNumber(to);
    if (!formattedPhone) {
      console.error(`\u274C SMS not sent - Invalid phone number: ${to}`);
      console.error("   Phone numbers should be in E.164 format (e.g., +14161234567 for Canada, +12125551234 for US)");
      console.error("   Or 10-digit North American numbers (e.g., 4161234567 for Canada, 2125551234 for US)");
      return false;
    }
    if (message.length > 1600) {
      console.warn(`\u26A0\uFE0F SMS message is ${message.length} characters (limit: 1600). Message will be split into multiple parts.`);
    }
    const client = twilio(config.accountSid, config.authToken);
    const formattedFrom = formatPhoneNumber(config.fromNumber);
    if (!formattedFrom) {
      console.error(`\u274C SMS not sent - Invalid TWILIO_PHONE_NUMBER format: ${config.fromNumber}`);
      console.error("   TWILIO_PHONE_NUMBER must be in E.164 format (e.g., +1234567890)");
      return false;
    }
    const messageResult = await client.messages.create({
      body: message,
      from: formattedFrom,
      // Use formatted from number
      to: formattedPhone
    });
    const duration = Date.now() - startTime;
    console.log(`\u2705 SMS sent successfully:`, {
      to: formattedPhone,
      messageSid: messageResult.sid,
      status: messageResult.status,
      duration: `${duration}ms`,
      trackingId: options?.trackingId || `auto_${Date.now()}`,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    return true;
  } catch (error) {
    const duration = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    const errorDetails = {
      to,
      formattedTo: formatPhoneNumber(to),
      error: errorMessage,
      duration: `${duration}ms`,
      trackingId: options?.trackingId || `auto_${Date.now()}`,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    if (error && typeof error === "object" && "code" in error) {
      errorDetails.twilioCode = error.code;
      errorDetails.twilioMessage = error.message;
      errorDetails.twilioStatus = error.status;
      errorDetails.twilioMoreInfo = error.moreInfo;
    }
    console.error(`\u274C SMS sending failed:`, errorDetails);
    if (error && typeof error === "object" && "code" in error) {
      const twilioCode = error.code;
      switch (twilioCode) {
        case 21211:
          console.error("   \u2192 Invalid phone number format. Ensure phone numbers are in E.164 format (e.g., +1234567890)");
          break;
        case 21212:
          console.error("   \u2192 Invalid phone number. The number provided is not a valid phone number.");
          break;
        case 21408:
          console.error("   \u2192 Permission denied. Check your Twilio account permissions.");
          break;
        case 21608:
          console.error("   \u2192 Unsubscribed recipient. The recipient has opted out of receiving messages.");
          break;
        case 21610:
          console.error('   \u2192 Invalid "from" phone number. Check TWILIO_PHONE_NUMBER is correct and verified in Twilio.');
          break;
        case 21614:
          console.error('   \u2192 "To" number is not a valid mobile number.');
          break;
        case 30003:
          console.error("   \u2192 Unreachable destination. The phone number may be invalid or unreachable.");
          break;
        case 30004:
          console.error("   \u2192 Message blocked. The message may be blocked by carrier or Twilio.");
          break;
        case 30005:
          console.error("   \u2192 Unknown destination. The destination number is not recognized.");
          break;
        case 30006:
          console.error("   \u2192 Landline or unreachable. The number may be a landline that cannot receive SMS.");
          break;
        default:
          console.error(`   \u2192 Twilio error code: ${twilioCode}. Check Twilio documentation for details.`);
      }
    }
    return false;
  }
};
var generateManagerBookingSMS = (data) => {
  const date2 = new Date(data.bookingDate).toLocaleDateString();
  return `New kitchen booking from ${data.chefName}:

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}

Please check your dashboard to confirm or manage this booking.

We've also sent you an email. If not found, please check your spam folder.`;
};
var generateManagerPortalBookingSMS = (data) => {
  const date2 = new Date(data.bookingDate).toLocaleDateString();
  return `New kitchen booking from portal user ${data.portalUserName}:

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}

Please check your dashboard to confirm or manage this booking.

We've also sent you an email. If not found, please check your spam folder.`;
};
var generateChefBookingConfirmationSMS = (data) => {
  const date2 = new Date(data.bookingDate).toLocaleDateString();
  return `Your kitchen booking has been confirmed!

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}

See you there!

We've also sent you an email. If not found, please check your spam folder.`;
};
var generateChefBookingCancellationSMS = (data) => {
  const date2 = new Date(data.bookingDate).toLocaleDateString();
  const reasonText = data.reason ? `
Reason: ${data.reason}` : "";
  return `Your kitchen booking has been cancelled.

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}${reasonText}

Please contact the manager if you have questions.

We've also sent you an email. If not found, please check your spam folder.`;
};
var generatePortalUserBookingConfirmationSMS = (data) => {
  const date2 = new Date(data.bookingDate).toLocaleDateString();
  return `Your kitchen booking has been confirmed!

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}

See you there!

We've also sent you an email. If not found, please check your spam folder.`;
};
var generatePortalUserBookingCancellationSMS = (data) => {
  const date2 = new Date(data.bookingDate).toLocaleDateString();
  const reasonText = data.reason ? `
Reason: ${data.reason}` : "";
  return `Your kitchen booking has been cancelled.

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}${reasonText}

Please contact the manager if you have questions.

We've also sent you an email. If not found, please check your spam folder.`;
};
var generateManagerBookingCancellationSMS = (data) => {
  const date2 = new Date(data.bookingDate).toLocaleDateString();
  return `Chef ${data.chefName} has cancelled their booking:

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}

Please check your dashboard for details.

We've also sent you an email. If not found, please check your spam folder.`;
};
var generateChefSelfCancellationSMS = (data) => {
  const date2 = new Date(data.bookingDate).toLocaleDateString();
  return `Your kitchen booking has been cancelled:

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}

If you need to book again, please visit the dashboard.

We've also sent you an email. If not found, please check your spam folder.`;
};

// server/routes.ts
init_phone_utils();

// server/passwordUtils.ts
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
import bcrypt from "bcryptjs";
var scryptAsync = promisify(scrypt);
async function hashPassword(password) {
  const salt = randomBytes(16).toString("hex");
  const buf = await scryptAsync(password, salt, 64);
  return `${buf.toString("hex")}.${salt}`;
}
async function comparePasswords(password, hash) {
  const isBcrypt = hash && (hash.startsWith("$2a$") || hash.startsWith("$2b$") || hash.startsWith("$2y$") || hash.startsWith("$2$"));
  if (isBcrypt) {
    return await bcrypt.compare(password, hash);
  } else {
    const [hashedPassword, salt] = hash.split(".");
    const hashedPasswordBuf = Buffer.from(hashedPassword, "hex");
    const suppliedPasswordBuf = await scryptAsync(password, salt, 64);
    return timingSafeEqual(hashedPasswordBuf, suppliedPasswordBuf);
  }
}

// server/routes.ts
init_firebase_admin();
init_db();
init_schema();
import Stripe5 from "stripe";
import { eq as eq4, inArray as inArray2, and as and4, desc as desc2, count } from "drizzle-orm";
init_schema();
async function getAuthenticatedUser(req) {
  if (req.neonUser) {
    return {
      id: req.neonUser.id,
      username: req.neonUser.username,
      role: req.neonUser.role || ""
    };
  }
  if (req.isAuthenticated && req.isAuthenticated() && req.user) {
    return {
      id: req.user.id,
      username: req.user.username,
      role: req.user.role
    };
  }
  return null;
}
function normalizeImageUrl(url, req) {
  if (!url) return null;
  const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
  const getOrigin = () => {
    let protocol;
    let host;
    if (isProduction2) {
      protocol = (req.get("x-forwarded-proto") || "https").split(",")[0].trim();
      host = req.get("x-forwarded-host") || req.get("host") || req.headers.host || "";
      if (protocol !== "https") protocol = "https";
    } else {
      protocol = req.protocol || "http";
      host = req.get("host") || req.headers.host || "localhost:5001";
    }
    return `${protocol}://${host}`;
  };
  if (url.startsWith("https://files.localcooks.ca/")) {
    const r2Path = url.replace("https://files.localcooks.ca/", "");
    const origin = getOrigin();
    return `${origin}/api/images/r2/${encodeURIComponent(r2Path)}`;
  }
  if (url.startsWith("http://") || url.startsWith("https://")) {
    return url;
  }
  if (url.startsWith("/")) {
    const origin = getOrigin();
    if (!origin || origin === "://") {
      console.warn(`[normalizeImageUrl] Could not determine host for URL: ${url}`);
      return url;
    }
    return `${origin}${url}`;
  }
  return url;
}
async function registerRoutes(app3) {
  console.log("[Routes] Registering all routes including chef-kitchen-access and portal user routes...");
  setupAuth(app3);
  app3.get("/api/auth/facebook", (req, res, next) => {
    console.log("Starting Facebook auth flow");
    if (process.env.FACEBOOK_CLIENT_ID && process.env.FACEBOOK_CLIENT_SECRET) {
      passport.authenticate("facebook", {
        scope: ["email"],
        failureRedirect: "/login?error=facebook_auth_failed",
        state: Date.now().toString()
        // Add state parameter for security
      })(req, res, next);
    } else {
      console.error("Facebook OAuth credentials not configured");
      res.redirect("/login?error=facebook_not_configured");
    }
  });
  app3.get(
    "/api/auth/facebook/callback",
    (req, res, next) => {
      console.log("Facebook OAuth callback received:", req.query);
      if (req.query.error) {
        console.error("Facebook OAuth error:", req.query.error);
        return res.redirect(`/login?error=${req.query.error}`);
      }
      next();
    },
    passport.authenticate("facebook", {
      failureRedirect: "/login?error=facebook_callback_failed",
      failWithError: true
    }),
    (req, res) => {
      console.log("Facebook authentication successful");
      res.redirect("/");
    },
    // Error handler
    (err, req, res, next) => {
      console.error("Facebook authentication error:", err);
      res.redirect("/login?error=internal_error");
    }
  );
  app3.get("/api/auth/instagram", (req, res, next) => {
    console.log("Starting Instagram auth flow");
    if (process.env.INSTAGRAM_CLIENT_ID && process.env.INSTAGRAM_CLIENT_SECRET) {
      passport.authenticate("instagram", {
        failureRedirect: "/login?error=instagram_auth_failed",
        state: Date.now().toString()
        // Add state parameter for security
      })(req, res, next);
    } else {
      console.error("Instagram OAuth credentials not configured");
      res.redirect("/login?error=instagram_not_configured");
    }
  });
  app3.get(
    "/api/auth/instagram/callback",
    (req, res, next) => {
      console.log("Instagram OAuth callback received:", req.query);
      if (req.query.error) {
        console.error("Instagram OAuth error:", req.query.error);
        return res.redirect(`/login?error=${req.query.error}`);
      }
      next();
    },
    passport.authenticate("instagram", {
      failureRedirect: "/login?error=instagram_callback_failed",
      failWithError: true
    }),
    (req, res) => {
      console.log("Instagram authentication successful");
      res.redirect("/");
    },
    // Error handler
    (err, req, res, next) => {
      console.error("Instagram authentication error:", err);
      res.redirect("/login?error=internal_error");
    }
  );
  app3.post(
    "/api/applications",
    upload.fields([
      { name: "foodSafetyLicense", maxCount: 1 },
      { name: "foodEstablishmentCert", maxCount: 1 }
    ]),
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          if (req.files) {
            const files2 = req.files;
            Object.values(files2).flat().forEach((file) => {
              try {
                fs3.unlinkSync(file.path);
              } catch (e) {
                console.error("Error cleaning up file:", e);
              }
            });
          }
          return res.status(401).json({ message: "You must be logged in to submit an application" });
        }
        const parsedData = insertApplicationSchema.safeParse(req.body);
        if (!parsedData.success) {
          if (req.files) {
            const files2 = req.files;
            Object.values(files2).flat().forEach((file) => {
              try {
                fs3.unlinkSync(file.path);
              } catch (e) {
                console.error("Error cleaning up file:", e);
              }
            });
          }
          const validationError = fromZodError2(parsedData.error);
          return res.status(400).json({
            message: "Validation error",
            errors: validationError.details
          });
        }
        const applicationData = {
          ...parsedData.data,
          userId: req.user.id,
          phone: normalizePhoneForStorage(parsedData.data.phone) || parsedData.data.phone
          // Ensure normalization
        };
        console.log("=== APPLICATION SUBMISSION WITH DOCUMENTS ===");
        console.log("Request details:", {
          method: req.method,
          contentType: req.headers["content-type"],
          hasFiles: !!req.files,
          fileKeys: req.files ? Object.keys(req.files) : [],
          bodyKeys: Object.keys(req.body || {}),
          bodyData: {
            foodSafetyLicense: req.body.foodSafetyLicense,
            foodEstablishmentCert: req.body.foodEstablishmentCert,
            foodSafetyLicenseUrl: req.body.foodSafetyLicenseUrl,
            foodEstablishmentCertUrl: req.body.foodEstablishmentCertUrl,
            userId: req.body.userId
          }
        });
        console.log("Form data:", {
          foodSafetyLicense: applicationData.foodSafetyLicense,
          foodEstablishmentCert: applicationData.foodEstablishmentCert,
          hasFiles: !!req.files,
          fileKeys: req.files ? Object.keys(req.files) : []
        });
        const files = req.files;
        if (files) {
          const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
          if (files.foodSafetyLicense && files.foodSafetyLicense[0]) {
            console.log("\u{1F4C4} Uploading food safety license file...");
            if (isProduction2) {
              applicationData.foodSafetyLicenseUrl = await uploadToBlob(files.foodSafetyLicense[0], req.user.id);
            } else {
              applicationData.foodSafetyLicenseUrl = getFileUrl(files.foodSafetyLicense[0].filename);
            }
            console.log("\u2705 Food safety license uploaded:", applicationData.foodSafetyLicenseUrl);
          }
          if (files.foodEstablishmentCert && files.foodEstablishmentCert[0]) {
            console.log("\u{1F4C4} Uploading food establishment cert file...");
            if (isProduction2) {
              applicationData.foodEstablishmentCertUrl = await uploadToBlob(files.foodEstablishmentCert[0], req.user.id);
            } else {
              applicationData.foodEstablishmentCertUrl = getFileUrl(files.foodEstablishmentCert[0].filename);
            }
            console.log("\u2705 Food establishment cert uploaded:", applicationData.foodEstablishmentCertUrl);
          }
        }
        if (req.body.foodSafetyLicenseUrl && !applicationData.foodSafetyLicenseUrl) {
          applicationData.foodSafetyLicenseUrl = req.body.foodSafetyLicenseUrl;
          console.log("\u{1F4C4} Using provided food safety license URL:", applicationData.foodSafetyLicenseUrl);
        }
        if (req.body.foodEstablishmentCertUrl && !applicationData.foodEstablishmentCertUrl) {
          applicationData.foodEstablishmentCertUrl = req.body.foodEstablishmentCertUrl;
          console.log("\u{1F4C4} Using provided food establishment cert URL:", applicationData.foodEstablishmentCertUrl);
        }
        if (applicationData.foodSafetyLicenseUrl) {
          applicationData.foodSafetyLicenseStatus = "pending";
          console.log("\u2705 Food safety license document provided, status set to pending");
        }
        if (applicationData.foodEstablishmentCertUrl) {
          applicationData.foodEstablishmentCertStatus = "pending";
          console.log("\u2705 Food establishment cert document provided, status set to pending");
        }
        console.log("Final application data:", {
          userId: applicationData.userId,
          hasDocuments: !!(applicationData.foodSafetyLicenseUrl || applicationData.foodEstablishmentCertUrl),
          documentUrls: {
            foodSafetyLicense: applicationData.foodSafetyLicenseUrl || null,
            foodEstablishmentCert: applicationData.foodEstablishmentCertUrl || null
          }
        });
        const application = await storage2.createApplication(applicationData);
        const fullApplication = await storage2.getApplicationById(application.id);
        console.log("\u2705 Application created successfully:", {
          id: fullApplication?.id,
          hasDocuments: !!(fullApplication?.foodSafetyLicenseUrl || fullApplication?.foodEstablishmentCertUrl)
        });
        try {
          if (fullApplication && fullApplication.email) {
            const hasDocuments = !!(fullApplication.foodSafetyLicenseUrl || fullApplication.foodEstablishmentCertUrl);
            if (hasDocuments) {
              const emailContent = generateApplicationWithDocumentsEmail({
                fullName: fullApplication.fullName || "Applicant",
                email: fullApplication.email
              });
              await sendEmail(emailContent, {
                trackingId: `app_with_docs_${fullApplication.id}_${Date.now()}`
              });
              console.log(`Application with documents email sent to ${fullApplication.email} for application ${fullApplication.id}`);
            } else {
              const emailContent = generateApplicationWithoutDocumentsEmail({
                fullName: fullApplication.fullName || "Applicant",
                email: fullApplication.email
              });
              await sendEmail(emailContent, {
                trackingId: `app_no_docs_${fullApplication.id}_${Date.now()}`
              });
              console.log(`Application without documents email sent to ${fullApplication.email} for application ${fullApplication.id}`);
            }
          } else {
            console.warn(`Cannot send new application email: Application record not found or missing email.`);
          }
        } catch (emailError) {
          console.error("Error sending new application email:", emailError);
        }
        console.log("=== APPLICATION SUBMISSION COMPLETE ===");
        return res.status(201).json(application);
      } catch (error) {
        console.error("Error creating application:", error);
        if (req.files) {
          const files = req.files;
          Object.values(files).flat().forEach((file) => {
            try {
              if (file.path) {
                fs3.unlinkSync(file.path);
              }
            } catch (e) {
              console.error("Error cleaning up file:", e);
            }
          });
        }
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app3.get("/api/applications", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    if (req.user.role !== "admin") {
      return res.status(403).json({ message: "Access denied. Admin role required." });
    }
    try {
      const applications2 = await storage2.getAllApplications();
      return res.status(200).json(applications2);
    } catch (error) {
      console.error("Error fetching applications:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  app3.get("/api/applications/my-applications", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ error: "Not authenticated" });
    }
    try {
      const userId = req.user.id;
      const applications2 = await storage2.getApplicationsByUserId(userId);
      return res.status(200).json(applications2);
    } catch (error) {
      console.error("Error fetching user applications:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  app3.get("/api/applications/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid application ID" });
      }
      const application = await storage2.getApplicationById(id);
      if (!application) {
        return res.status(404).json({ message: "Application not found" });
      }
      return res.status(200).json(application);
    } catch (error) {
      console.error("Error fetching application:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  app3.patch("/api/applications/:id/status", async (req, res) => {
    try {
      console.log("Status update request - Auth info:", {
        isAuthenticated: req.isAuthenticated(),
        userRole: req.user?.role,
        userId: req.user?.id
      });
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      if (req.user.role !== "admin") {
        return res.status(403).json({ message: "Access denied. Admin role required." });
      }
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid application ID" });
      }
      const application = await storage2.getApplicationById(id);
      if (!application) {
        return res.status(404).json({ message: "Application not found" });
      }
      const parsedData = updateApplicationStatusSchema.safeParse({
        id,
        ...req.body
      });
      if (!parsedData.success) {
        const validationError = fromZodError2(parsedData.error);
        return res.status(400).json({
          message: "Validation error",
          errors: validationError.details
        });
      }
      const updatedApplication = await storage2.updateApplicationStatus(parsedData.data);
      if (!updatedApplication) {
        return res.status(404).json({ message: "Application not found or could not be updated" });
      }
      try {
        if (updatedApplication.email) {
          const emailContent = generateStatusChangeEmail({
            fullName: updatedApplication.fullName || "Applicant",
            email: updatedApplication.email,
            status: updatedApplication.status
          });
          await sendEmail(emailContent, {
            trackingId: `status_${updatedApplication.id}_${updatedApplication.status}_${Date.now()}`
          });
          console.log(`Status change email sent to ${updatedApplication.email} for application ${updatedApplication.id}`);
        } else {
          console.warn(`Cannot send status change email for application ${updatedApplication.id}: No email address found`);
        }
      } catch (emailError) {
        console.error("Error sending status change email:", emailError);
      }
      return res.status(200).json(updatedApplication);
    } catch (error) {
      console.error("Error updating application status:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  app3.patch("/api/applications/:id/cancel", async (req, res) => {
    const userId = req.isAuthenticated() ? req.user.id : req.headers["x-user-id"] ? parseInt(req.headers["x-user-id"]) : null;
    console.log("Cancel application request - Auth info:", {
      isAuthenticated: req.isAuthenticated(),
      sessionUserId: req.isAuthenticated() ? req.user.id : null,
      headerUserId: req.headers["x-user-id"],
      resolvedUserId: userId
    });
    if (!userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid application ID" });
      }
      const application = await storage2.getApplicationById(id);
      if (!application) {
        return res.status(404).json({ message: "Application not found" });
      }
      if (application.userId !== userId) {
        return res.status(403).json({ message: "Access denied. You can only cancel your own applications." });
      }
      const updateData = {
        id,
        status: "cancelled"
      };
      const updatedApplication = await storage2.updateApplicationStatus(updateData);
      if (!updatedApplication) {
        return res.status(404).json({ message: "Application not found" });
      }
      try {
        if (updatedApplication.email) {
          const emailContent = generateStatusChangeEmail({
            fullName: updatedApplication.fullName || "Applicant",
            email: updatedApplication.email,
            status: "cancelled"
          });
          await sendEmail(emailContent, {
            trackingId: `cancel_${updatedApplication.id}_${Date.now()}`
          });
          console.log(`Cancellation email sent to ${updatedApplication.email} for application ${updatedApplication.id}`);
        } else {
          console.warn(`Cannot send cancellation email for application ${updatedApplication.id}: No email address found`);
        }
      } catch (emailError) {
        console.error("Error sending cancellation email:", emailError);
      }
      return res.status(200).json(updatedApplication);
    } catch (error) {
      console.error("Error cancelling application:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  app3.post("/api/test-status-email", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      if (req.user.role !== "admin") {
        return res.status(403).json({ message: "Access denied. Admin role required." });
      }
      const { fullName, email, status } = req.body;
      const emailContent = generateStatusChangeEmail({
        fullName: fullName || "Test User",
        email: email || "test@example.com",
        status: status || "approved"
      });
      const emailSent = await sendEmail(emailContent, {
        trackingId: `test_${email}_${status}_${Date.now()}`
      });
      if (emailSent) {
        console.log(`Test status email sent to: ${email}`);
        return res.status(200).json({ message: "Test email sent successfully" });
      } else {
        return res.status(500).json({ message: "Failed to send test email" });
      }
    } catch (error) {
      console.error("Error sending test email:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  app3.post("/api/test-verification-email", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      if (req.user.role !== "admin") {
        return res.status(403).json({ message: "Access denied. Admin role required." });
      }
      const { fullName, email, phone } = req.body;
      const { generateFullVerificationEmail: generateFullVerificationEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
      const emailContent = generateFullVerificationEmail2({
        fullName: fullName || "Test User",
        email: email || "test@example.com",
        phone: phone || "5551234567"
      });
      const emailSent = await sendEmail(emailContent, {
        trackingId: `test_verification_${email}_${Date.now()}`
      });
      if (emailSent) {
        console.log(`Test verification email sent to: ${email}`);
        return res.status(200).json({ message: "Test verification email sent successfully" });
      } else {
        return res.status(500).json({ message: "Failed to send test verification email" });
      }
    } catch (error) {
      console.error("Error sending test verification email:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  app3.post("/api/test-document-status-email", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      if (req.user.role !== "admin") {
        return res.status(403).json({ message: "Access denied. Admin role required." });
      }
      const { fullName, email, documentType, status, adminFeedback } = req.body;
      const emailContent = generateDocumentStatusChangeEmail({
        fullName: fullName || "Test User",
        email: email || "test@example.com",
        documentType: documentType || "foodSafetyLicenseStatus",
        status: status || "approved",
        adminFeedback: adminFeedback || void 0
      });
      const emailSent = await sendEmail(emailContent, {
        trackingId: `test_doc_status_${email}_${documentType}_${status}_${Date.now()}`
      });
      if (emailSent) {
        console.log(`Test document status email sent to: ${email} for ${documentType}: ${status}`);
        return res.status(200).json({ message: "Test document status email sent successfully" });
      } else {
        return res.status(500).json({ message: "Failed to send test document status email" });
      }
    } catch (error) {
      console.error("Error sending test document status email:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  app3.post("/api/register", async (req, res) => {
    res.status(410).json({ error: "Session-based authentication removed. Please use Firebase Auth." });
  });
  app3.post("/api/admin-login", async (req, res) => {
    try {
      const { username, password } = req.body;
      if (!username || !password) {
        return res.status(400).json({ error: "Username and password are required" });
      }
      console.log("Admin login attempt for:", username);
      console.log("Storage type:", storage2.constructor.name);
      console.log("DATABASE_URL exists:", !!process.env.DATABASE_URL);
      let admin2;
      try {
        console.log("Calling storage.getUserByUsername...");
        admin2 = await storage2.getUserByUsername(username);
        console.log("Storage call completed, user:", admin2 ? "found" : "not found");
      } catch (dbError) {
        console.error("Database error fetching user:", dbError);
        console.error("Error stack:", dbError?.stack);
        console.error("Error code:", dbError?.code);
        console.error("Error detail:", dbError?.detail);
        return res.status(500).json({
          error: "Database connection failed",
          message: dbError instanceof Error ? dbError.message : "Unknown database error",
          code: dbError?.code
        });
      }
      if (!admin2) {
        console.log("Admin user not found:", username);
        return res.status(401).json({ error: "Incorrect username or password" });
      }
      console.log("User found:", { id: admin2.id, username: admin2.username, role: admin2.role });
      if (admin2.role !== "admin") {
        console.log("User is not an admin:", username, "role:", admin2.role);
        return res.status(403).json({ error: "Not authorized - admin access required. Managers should use /api/manager-login" });
      }
      let passwordMatches = false;
      if (password === "localcooks" && admin2.role === "admin") {
        passwordMatches = true;
        console.log("Admin password matched with hardcoded value");
      } else {
        try {
          passwordMatches = await comparePasswords(password, admin2.password);
          console.log("Password compared with stored hash:", passwordMatches);
        } catch (error) {
          console.error("Error comparing passwords:", error);
        }
      }
      if (!passwordMatches) {
        return res.status(401).json({ error: "Incorrect username or password" });
      }
      console.log("Admin login successful for:", username);
      req.session.userId = admin2.id;
      req.session.user = { ...admin2, password: void 0 };
      req.login(admin2, (err) => {
        if (err) {
          console.error("Error setting session:", err);
          return res.status(500).json({ error: "Session creation failed" });
        }
        req.session.save((saveErr) => {
          if (saveErr) {
            console.error("Error saving session:", saveErr);
            return res.status(500).json({ error: "Session save failed" });
          }
          const { password: _, ...adminWithoutPassword } = admin2;
          return res.status(200).json(adminWithoutPassword);
        });
      });
    } catch (error) {
      console.error("Admin login error:", error);
      console.error("Error details:", error instanceof Error ? error.stack : error);
      res.status(500).json({
        error: "Admin login failed",
        message: error instanceof Error ? error.message : "Unknown error",
        details: process.env.NODE_ENV === "development" ? error : void 0
      });
    }
  });
  app3.get("/api/user-exists", async (req, res) => {
    const username = req.query.username;
    if (!username) {
      return res.status(400).json({ error: "Username required" });
    }
    const user = await storage2.getUserByUsername(username);
    res.json({ exists: !!user });
  });
  app3.get("/api/get-users", async (req, res) => {
    try {
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const { search } = req.query;
      let query;
      let params = [];
      if (search && typeof search === "string" && search.trim()) {
        query = `
          SELECT 
            u.id,
            u.username,
            COALESCE(a.email, u.username) as email,
            COALESCE(a.full_name, 
              CASE 
                WHEN u.username LIKE '%@%' THEN SPLIT_PART(u.username, '@', 1)
                ELSE u.username 
              END
            ) as full_name,
            u.role
          FROM users u
          LEFT JOIN applications a ON u.id = a.user_id
          WHERE 
            LOWER(u.username) LIKE LOWER($1) OR 
            LOWER(COALESCE(a.email, '')) LIKE LOWER($1) OR
            LOWER(COALESCE(a.full_name, '')) LIKE LOWER($1)
          ORDER BY 
            u.role = 'admin' DESC,
            u.username
          LIMIT 20
        `;
        params = [`%${search.trim()}%`];
      } else {
        query = `
          SELECT 
            u.id,
            u.username,
            COALESCE(a.email, u.username) as email,
            COALESCE(a.full_name, 
              CASE 
                WHEN u.username LIKE '%@%' THEN SPLIT_PART(u.username, '@', 1)
                ELSE u.username 
              END
            ) as full_name,
            u.role
          FROM users u
          LEFT JOIN applications a ON u.id = a.user_id
          ORDER BY 
            u.role = 'admin' DESC,
            u.username
          LIMIT 50
        `;
      }
      const result = await pool.query(query, params);
      const users2 = result.rows.map((user) => ({
        id: user.id,
        username: user.username,
        email: user.email,
        fullName: user.full_name,
        role: user.role,
        displayText: `${user.full_name} (${user.email})`
        // For dropdown display
      }));
      res.status(200).json({ users: users2 });
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ error: "Failed to fetch users" });
    }
  });
  app3.post(
    "/api/upload-file",
    upload.single("file"),
    optionalFirebaseAuth,
    // Try Firebase auth, but don't require it (supports legacy session auth too)
    async (req, res) => {
      try {
        const userId = req.neonUser?.id || req.user?.id;
        if (!userId) {
          if (req.file && req.file.path) {
            try {
              fs3.unlinkSync(req.file.path);
            } catch (e) {
              console.error("Error cleaning up file:", e);
            }
          }
          return res.status(401).json({ error: "Not authenticated" });
        }
        if (!req.file) {
          return res.status(400).json({ error: "No file uploaded" });
        }
        const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
        let fileUrl;
        let fileName;
        if (isProduction2) {
          fileUrl = await uploadToBlob(req.file, userId);
          fileName = fileUrl.split("/").pop() || req.file.originalname;
        } else {
          fileUrl = getFileUrl(req.file.filename);
          fileName = req.file.filename;
        }
        return res.status(200).json({
          success: true,
          url: fileUrl,
          fileName,
          size: req.file.size,
          type: req.file.mimetype
        });
      } catch (error) {
        console.error("File upload error:", error);
        if (req.file && req.file.path) {
          try {
            fs3.unlinkSync(req.file.path);
          } catch (e) {
            console.error("Error cleaning up file:", e);
          }
        }
        return res.status(500).json({
          error: "File upload failed",
          details: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
  );
  app3.get("/api/images/r2/:path(*)", async (req, res) => {
    try {
      const r2Path = decodeURIComponent(req.params.path);
      if (!r2Path) {
        return res.status(400).json({ error: "Path is required" });
      }
      const allowedPrefixes = ["documents/", "images/", "profiles/", "kitchen-applications/"];
      const isAllowed = allowedPrefixes.some((prefix) => r2Path.startsWith(prefix));
      if (!isAllowed) {
        console.warn(`[R2 Proxy] Blocked request for path: ${r2Path}`);
        return res.status(403).json({ error: "Access denied" });
      }
      const { isR2Configured: isR2Configured2 } = await Promise.resolve().then(() => (init_r2_storage(), r2_storage_exports));
      if (!isR2Configured2()) {
        console.error("[R2 Proxy] R2 is not configured");
        return res.status(503).json({ error: "Storage not configured" });
      }
      const R2_ACCOUNT_ID2 = process.env.CLOUDFLARE_ACCOUNT_ID;
      const R2_ACCESS_KEY_ID2 = process.env.CLOUDFLARE_R2_ACCESS_KEY_ID;
      const R2_SECRET_ACCESS_KEY2 = process.env.CLOUDFLARE_R2_SECRET_ACCESS_KEY;
      const R2_BUCKET_NAME2 = process.env.CLOUDFLARE_R2_BUCKET_NAME;
      if (!R2_ACCOUNT_ID2 || !R2_ACCESS_KEY_ID2 || !R2_SECRET_ACCESS_KEY2 || !R2_BUCKET_NAME2) {
        return res.status(503).json({ error: "R2 credentials not configured" });
      }
      const { S3Client: S3Client2, GetObjectCommand: GetObjectCommand2 } = await import("@aws-sdk/client-s3");
      const s3Client2 = new S3Client2({
        region: "auto",
        endpoint: `https://${R2_ACCOUNT_ID2}.r2.cloudflarestorage.com`,
        credentials: {
          accessKeyId: R2_ACCESS_KEY_ID2,
          secretAccessKey: R2_SECRET_ACCESS_KEY2
        }
      });
      const command = new GetObjectCommand2({
        Bucket: R2_BUCKET_NAME2,
        Key: r2Path
      });
      const response = await s3Client2.send(command);
      if (!response.Body) {
        return res.status(404).json({ error: "File not found" });
      }
      if (response.ContentType) {
        res.setHeader("Content-Type", response.ContentType);
      }
      if (response.ContentLength) {
        res.setHeader("Content-Length", response.ContentLength);
      }
      res.setHeader("Cache-Control", "public, max-age=86400");
      const stream = response.Body;
      stream.pipe(res);
    } catch (error) {
      console.error("[R2 Proxy] Error fetching file:", error);
      if (error.name === "NoSuchKey" || error.$metadata?.httpStatusCode === 404) {
        return res.status(404).json({ error: "File not found" });
      }
      return res.status(500).json({
        error: "Failed to fetch file",
        details: error.message
      });
    }
  });
  app3.post("/api/files/presigned-url", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const user = req.neonUser;
      const { fileUrl } = req.body;
      if (!fileUrl || typeof fileUrl !== "string") {
        return res.status(400).json({ error: "fileUrl is required" });
      }
      if (fileUrl.startsWith("/api/files/documents/")) {
        const filename = fileUrl.replace("/api/files/documents/", "");
        const filenameParts = filename.split("_");
        let fileUserId = null;
        if (filenameParts[0] === "unknown") {
          if (user.role !== "admin" && user.role !== "manager") {
            return res.status(403).json({ error: "Access denied" });
          }
        } else {
          const userIdMatch = filenameParts[0].match(/^\d+$/);
          if (userIdMatch) {
            fileUserId = parseInt(userIdMatch[0]);
          }
        }
        if (fileUserId !== null && user.id !== fileUserId && user.role !== "admin" && user.role !== "manager") {
          return res.status(403).json({ error: "Access denied" });
        }
        const { auth: auth2 } = await Promise.resolve().then(() => (init_firebase(), firebase_exports));
        const currentUser = auth2.currentUser;
        if (currentUser) {
          const token = await currentUser.getIdToken();
          return res.json({ url: `${fileUrl}?token=${encodeURIComponent(token)}` });
        }
        return res.json({ url: fileUrl });
      }
      const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
      if (isProduction2) {
        try {
          const { getPresignedUrl: getPresignedUrl2, isR2Configured: isR2Configured2 } = await Promise.resolve().then(() => (init_r2_storage(), r2_storage_exports));
          if (isR2Configured2()) {
            const urlParts = fileUrl.split("/");
            const fileUserIdMatch = urlParts.find((part) => /^\d+$/.test(part));
            const fileUserId = fileUserIdMatch ? parseInt(fileUserIdMatch) : null;
            if (fileUserId && user.id !== fileUserId && user.role !== "admin" && user.role !== "manager") {
              return res.status(403).json({ error: "Access denied" });
            }
            const presignedUrl = await getPresignedUrl2(fileUrl, 3600);
            return res.json({ url: presignedUrl });
          }
        } catch (error) {
          console.error("Error generating presigned URL:", error);
          return res.json({ url: fileUrl });
        }
      }
      return res.json({ url: fileUrl });
    } catch (error) {
      console.error("Error in document presigned URL endpoint:", error);
      return res.status(500).json({
        error: "Failed to generate presigned URL",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app3.post("/api/images/presigned-url", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const user = req.neonUser;
      console.log(`\u2705 Presigned URL request from authenticated user: ${user.id} (${user.role || "no role"})`);
      const { imageUrl } = req.body;
      if (!imageUrl || typeof imageUrl !== "string") {
        return res.status(400).json({ error: "imageUrl is required" });
      }
      const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
      const isDevelopment = process.env.NODE_ENV === "development" || !isProduction2 && !process.env.VERCEL_ENV;
      if (isDevelopment) {
        console.log("\u{1F4BB} Development mode: Returning original URL without presigned URL");
        return res.json({ url: imageUrl });
      }
      if (isProduction2) {
        try {
          const { getPresignedUrl: getPresignedUrl2, isR2Configured: isR2Configured2 } = await Promise.resolve().then(() => (init_r2_storage(), r2_storage_exports));
          if (!isR2Configured2()) {
            console.warn("R2 not configured, returning original URL");
            return res.json({ url: imageUrl });
          }
          const presignedUrl = await getPresignedUrl2(imageUrl, 3600);
          return res.json({ url: presignedUrl });
        } catch (error) {
          console.error("Error generating presigned URL, falling back to original URL:", {
            error: error instanceof Error ? error.message : "Unknown error",
            imageUrl
          });
          return res.json({ url: imageUrl });
        }
      }
      return res.json({ url: imageUrl });
    } catch (error) {
      console.error("Error in presigned URL endpoint:", error);
      return res.status(500).json({
        error: "Failed to generate presigned URL",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app3.get("/api/files/documents/:filename", optionalFirebaseAuth, async (req, res) => {
    try {
      let userId = null;
      let userRole = null;
      if (req.neonUser) {
        userId = req.neonUser.id;
        userRole = req.neonUser.role || null;
      } else if (req.query.token && typeof req.query.token === "string") {
        try {
          const { verifyFirebaseToken: verifyFirebaseToken2 } = await Promise.resolve().then(() => (init_firebase_admin(), firebase_admin_exports));
          const decodedToken = await verifyFirebaseToken2(req.query.token);
          if (decodedToken) {
            const neonUser = await firebaseStorage.getUserByFirebaseUid(decodedToken.uid);
            if (neonUser) {
              userId = neonUser.id;
              userRole = neonUser.role || null;
            }
          }
        } catch (error) {
          console.error("Error verifying query token:", error);
        }
      } else if (req.session?.userId) {
        try {
          const sessionUserId = req.session.userId;
          const sessionUser = await storage2.getUser(sessionUserId);
          if (sessionUser) {
            userId = sessionUser.id;
            userRole = sessionUser.role;
          }
        } catch (error) {
          console.error("Error loading user from session:", error);
        }
      } else if (req.isAuthenticated && typeof req.isAuthenticated === "function" && req.isAuthenticated() && req.user) {
        userId = req.user.id;
        userRole = req.user.role;
      }
      if (!userId) {
        console.log("[FILE ACCESS] Authentication failed for:", req.params.filename, {
          hasNeonUser: !!req.neonUser,
          hasQueryToken: !!req.query.token,
          hasSession: !!req.session?.userId,
          hasPassport: req.isAuthenticated && typeof req.isAuthenticated === "function" ? req.isAuthenticated() : false,
          authHeader: !!req.headers.authorization,
          cookies: Object.keys(req.headers.cookie ? {} : {}),
          // Don't log cookie values for security
          method: req.method,
          path: req.path
        });
        return res.status(401).json({
          message: "Not authenticated",
          hint: "Files must be accessed with authentication. Use the presigned URL endpoint or include an auth token."
        });
      }
      console.log("[FILE ACCESS] Authenticated user:", userId, "role:", userRole, "accessing:", req.params.filename);
      const filename = req.params.filename;
      const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
      if (filename.startsWith("http://") || filename.startsWith("https://")) {
        if (isProduction2) {
          try {
            const { getPresignedUrl: getPresignedUrl2, isR2Configured: isR2Configured2 } = await Promise.resolve().then(() => (init_r2_storage(), r2_storage_exports));
            if (isR2Configured2()) {
              const urlParts = filename.split("/");
              const fileUserIdMatch = urlParts.find((part) => /^\d+$/.test(part));
              const fileUserId2 = fileUserIdMatch ? parseInt(fileUserIdMatch) : null;
              if (fileUserId2 && userId !== fileUserId2 && userRole !== "admin" && userRole !== "manager") {
                return res.status(403).json({ message: "Access denied" });
              }
              const presignedUrl = await getPresignedUrl2(filename, 3600);
              return res.redirect(presignedUrl);
            }
          } catch (error) {
            console.error("Error generating presigned URL:", error);
            return res.status(500).json({ message: "Error accessing file" });
          }
        }
      }
      const filePath = path2.join(process.cwd(), "uploads", "documents", filename);
      if (!fs3.existsSync(filePath)) {
        return res.status(404).json({ message: "File not found" });
      }
      const filenameParts = filename.split("_");
      let fileUserId = null;
      if (filenameParts[0] === "unknown") {
        if (userRole !== "admin" && userRole !== "manager") {
          return res.status(403).json({ message: "Access denied" });
        }
      } else {
        const userIdMatch = filenameParts[0].match(/^\d+$/);
        if (userIdMatch) {
          fileUserId = parseInt(userIdMatch[0]);
        }
      }
      if (fileUserId !== null && userId !== fileUserId && userRole !== "admin" && userRole !== "manager") {
        return res.status(403).json({ message: "Access denied" });
      }
      const stat = fs3.statSync(filePath);
      const ext = path2.extname(filename).toLowerCase();
      let contentType = "application/octet-stream";
      if (ext === ".pdf") {
        contentType = "application/pdf";
      } else if ([".jpg", ".jpeg"].includes(ext)) {
        contentType = "image/jpeg";
      } else if (ext === ".png") {
        contentType = "image/png";
      } else if (ext === ".webp") {
        contentType = "image/webp";
      }
      res.setHeader("Content-Type", contentType);
      res.setHeader("Content-Length", stat.size);
      res.setHeader("Content-Disposition", `inline; filename="${filename}"`);
      const readStream = fs3.createReadStream(filePath);
      readStream.pipe(res);
    } catch (error) {
      console.error("Error serving file:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  app3.patch(
    "/api/applications/:id/documents",
    (req, res, next) => {
      const contentType = req.get("Content-Type") || "";
      if (contentType.includes("multipart/form-data")) {
        const fileUploadMiddleware = upload.fields([
          { name: "foodSafetyLicense", maxCount: 1 },
          { name: "foodEstablishmentCert", maxCount: 1 }
        ]);
        fileUploadMiddleware(req, res, next);
      } else {
        next();
      }
    },
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Not authenticated" });
        }
        const applicationId = parseInt(req.params.id);
        if (isNaN(applicationId)) {
          return res.status(400).json({ message: "Invalid application ID" });
        }
        const application = await storage2.getApplicationById(applicationId);
        if (!application) {
          if (req.files) {
            const files = req.files;
            Object.values(files).flat().forEach((file) => {
              try {
                fs3.unlinkSync(file.path);
              } catch (e) {
                console.error("Error cleaning up file:", e);
              }
            });
          }
          return res.status(404).json({ message: "Application not found" });
        }
        if (application.userId !== req.user.id && req.user.role !== "admin") {
          if (req.files) {
            const files = req.files;
            Object.values(files).flat().forEach((file) => {
              try {
                fs3.unlinkSync(file.path);
              } catch (e) {
                console.error("Error cleaning up file:", e);
              }
            });
          }
          return res.status(403).json({ message: "Access denied" });
        }
        if (application.status === "cancelled" || application.status === "rejected") {
          if (req.files) {
            const files = req.files;
            Object.values(files).flat().forEach((file) => {
              try {
                fs3.unlinkSync(file.path);
              } catch (e) {
                console.error("Error cleaning up file:", e);
              }
            });
          }
          return res.status(400).json({
            message: "Document uploads are not permitted for cancelled or rejected applications",
            applicationStatus: application.status
          });
        }
        const updateData = {
          id: applicationId
        };
        const contentType = req.get("Content-Type") || "";
        const isFileUpload = contentType.includes("multipart/form-data");
        if (isFileUpload) {
          const files = req.files;
          const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
          if (files && files.foodSafetyLicense && files.foodSafetyLicense[0]) {
            if (!isProduction2 && application.foodSafetyLicenseUrl && application.foodSafetyLicenseUrl.startsWith("/api/files/")) {
              const oldFilename = application.foodSafetyLicenseUrl.split("/").pop();
              if (oldFilename) {
                const oldFilePath = path2.join(process.cwd(), "uploads", "documents", oldFilename);
                deleteFile(oldFilePath);
              }
            }
            if (isProduction2) {
              updateData.foodSafetyLicenseUrl = await uploadToBlob(files.foodSafetyLicense[0], req.user.id);
            } else {
              const filename = files.foodSafetyLicense[0].filename;
              updateData.foodSafetyLicenseUrl = getFileUrl(filename);
            }
          }
          if (files && files.foodEstablishmentCert && files.foodEstablishmentCert[0]) {
            if (!isProduction2 && application.foodEstablishmentCertUrl && application.foodEstablishmentCertUrl.startsWith("/api/files/")) {
              const oldFilename = application.foodEstablishmentCertUrl.split("/").pop();
              if (oldFilename) {
                const oldFilePath = path2.join(process.cwd(), "uploads", "documents", oldFilename);
                deleteFile(oldFilePath);
              }
            }
            if (isProduction2) {
              updateData.foodEstablishmentCertUrl = await uploadToBlob(files.foodEstablishmentCert[0], req.user.id);
            } else {
              const filename = files.foodEstablishmentCert[0].filename;
              updateData.foodEstablishmentCertUrl = getFileUrl(filename);
            }
          }
          if (req.body.foodSafetyLicenseUrl && !updateData.foodSafetyLicenseUrl) {
            updateData.foodSafetyLicenseUrl = req.body.foodSafetyLicenseUrl;
          }
          if (req.body.foodEstablishmentCertUrl && !updateData.foodEstablishmentCertUrl) {
            updateData.foodEstablishmentCertUrl = req.body.foodEstablishmentCertUrl;
          }
        } else {
          if (req.body.foodSafetyLicenseUrl) {
            updateData.foodSafetyLicenseUrl = req.body.foodSafetyLicenseUrl;
          }
          if (req.body.foodEstablishmentCertUrl) {
            updateData.foodEstablishmentCertUrl = req.body.foodEstablishmentCertUrl;
          }
        }
        const updatedApplication = await storage2.updateApplicationDocuments(updateData);
        if (!updatedApplication) {
          return res.status(404).json({ message: "Failed to update application documents" });
        }
        return res.status(200).json(updatedApplication);
      } catch (error) {
        console.error("Error updating application documents:", error);
        if (req.files) {
          const files = req.files;
          Object.values(files).flat().forEach((file) => {
            try {
              fs3.unlinkSync(file.path);
            } catch (e) {
              console.error("Error cleaning up file:", e);
            }
          });
        }
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app3.patch("/api/applications/:id/document-verification", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      if (req.user.role !== "admin") {
        return res.status(403).json({ message: "Access denied. Admin role required." });
      }
      const applicationId = parseInt(req.params.id);
      if (isNaN(applicationId)) {
        return res.status(400).json({ message: "Invalid application ID" });
      }
      const parsedData = updateDocumentVerificationSchema.safeParse({
        id: applicationId,
        ...req.body,
        documentsReviewedBy: req.user.id
      });
      if (!parsedData.success) {
        const validationError = fromZodError2(parsedData.error);
        return res.status(400).json({
          message: "Validation error",
          errors: validationError.details
        });
      }
      const updatedApplication = await storage2.updateApplicationDocumentVerification(parsedData.data);
      if (!updatedApplication) {
        return res.status(404).json({ message: "Application not found" });
      }
      console.log(`Document verification updated for application ${applicationId}:`, {
        foodSafetyLicenseStatus: updatedApplication.foodSafetyLicenseStatus,
        foodEstablishmentCertStatus: updatedApplication.foodEstablishmentCertStatus,
        reviewedBy: parsedData.data.documentsReviewedBy,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      if (updatedApplication.foodSafetyLicenseStatus === "approved" && (!updatedApplication.foodEstablishmentCertUrl || updatedApplication.foodEstablishmentCertStatus === "approved")) {
        await storage2.updateUserVerificationStatus(updatedApplication.userId, true);
        console.log(`User ${updatedApplication.userId} has been fully verified`);
      }
      try {
        if (updatedApplication.email) {
          const hasFoodSafetyLicense = updatedApplication.foodSafetyLicenseUrl;
          const hasFoodEstablishmentCert = updatedApplication.foodEstablishmentCertUrl;
          const foodSafetyApproved = updatedApplication.foodSafetyLicenseStatus === "approved";
          const foodEstablishmentApproved = !hasFoodEstablishmentCert || updatedApplication.foodEstablishmentCertStatus === "approved";
          if (foodSafetyApproved && foodEstablishmentApproved) {
            const approvedDocuments = [];
            if (hasFoodSafetyLicense) approvedDocuments.push("Food Safety License");
            if (hasFoodEstablishmentCert) approvedDocuments.push("Food Establishment Certificate");
            const emailContent = generateChefAllDocumentsApprovedEmail({
              fullName: updatedApplication.fullName || "Applicant",
              email: updatedApplication.email,
              approvedDocuments,
              adminFeedback: req.body.documentsAdminFeedback
            });
            await sendEmail(emailContent, {
              trackingId: `all_docs_approved_chef_${updatedApplication.id}_${Date.now()}`
            });
            console.log(`All documents approved email sent to ${updatedApplication.email} for application ${updatedApplication.id}`);
          }
        } else {
          console.warn(`Cannot send all documents approved email for application ${updatedApplication.id}: No email address found`);
        }
      } catch (emailError) {
        console.error("Error sending all documents approved email:", emailError);
      }
      return res.status(200).json(updatedApplication);
    } catch (error) {
      console.error("Error updating application document verification:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  const hasApprovedApplication = async (userId) => {
    try {
      const applications2 = await storage2.getApplicationsByUserId(userId);
      return applications2.some((app4) => app4.status === "approved");
    } catch (error) {
      console.error("Error checking application status:", error);
      return false;
    }
  };
  app3.get("/api/microlearning/progress/:userId", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Authentication required" });
      }
      const userId = parseInt(req.params.userId);
      if (req.user.id !== userId && req.user.role !== "admin") {
        return res.status(403).json({ message: "Access denied" });
      }
      const progress = await storage2.getMicrolearningProgress(userId);
      const completionStatus = await storage2.getMicrolearningCompletion(userId);
      const hasApproval = await hasApprovedApplication(userId);
      const isAdmin = req.user.role === "admin";
      const isCompleted = completionStatus?.confirmed || false;
      const accessLevel = isAdmin || hasApproval || isCompleted ? "full" : "limited";
      res.json({
        success: true,
        progress: progress || [],
        completionConfirmed: completionStatus?.confirmed || false,
        completedAt: completionStatus?.completedAt,
        hasApprovedApplication: hasApproval,
        accessLevel,
        // admins get full access, others limited to first video only
        isAdmin
      });
    } catch (error) {
      console.error("Error fetching microlearning progress:", error);
      res.status(500).json({ message: "Failed to fetch progress" });
    }
  });
  app3.post("/api/microlearning/progress", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Authentication required" });
      }
      const { userId, videoId, progress, completed, completedAt, watchedPercentage } = req.body;
      if (req.user.id !== userId && req.user.role !== "admin") {
        return res.status(403).json({ message: "Access denied" });
      }
      const hasApproval = await hasApprovedApplication(userId);
      const completionStatus = await storage2.getMicrolearningCompletion(userId);
      const isCompleted = completionStatus?.confirmed || false;
      const firstVideoId = "basics-cross-contamination";
      const isAdmin = req.user.role === "admin";
      if (!hasApproval && !isAdmin && !isCompleted && videoId !== firstVideoId) {
        return res.status(403).json({
          message: "Application approval required to access this video",
          accessLevel: "limited",
          firstVideoOnly: true
        });
      }
      const actualCompleted = completed;
      const progressData = {
        userId,
        videoId,
        progress: Math.max(0, Math.min(100, progress)),
        // Clamp between 0-100
        watchedPercentage: Math.max(0, Math.min(100, watchedPercentage || 0)),
        // Clamp between 0-100
        completed: actualCompleted,
        completedAt: actualCompleted ? completedAt ? new Date(completedAt) : /* @__PURE__ */ new Date() : null,
        updatedAt: /* @__PURE__ */ new Date()
      };
      await storage2.updateVideoProgress(progressData);
      res.json({
        success: true,
        message: "Progress updated successfully"
      });
    } catch (error) {
      console.error("Error updating video progress:", error);
      res.status(500).json({ message: "Failed to update progress" });
    }
  });
  app3.post("/api/microlearning/complete", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Authentication required" });
      }
      const { userId, completionDate, videoProgress: videoProgress2 } = req.body;
      if (req.user.id !== userId && req.user.role !== "admin") {
        return res.status(403).json({ message: "Access denied" });
      }
      const hasApproval = await hasApprovedApplication(userId);
      const isAdmin = req.user.role === "admin";
      if (!hasApproval && !isAdmin) {
        return res.status(403).json({
          message: "Application approval required to complete full certification",
          accessLevel: "limited",
          requiresApproval: true
        });
      }
      const requiredVideos = [
        // Food Safety Basics Module (14 videos)
        "basics-personal-hygiene",
        "basics-temperature-danger",
        "basics-cross-contamination",
        "basics-allergen-awareness",
        "basics-food-storage",
        "basics-cooking-temps",
        "basics-cooling-reheating",
        "basics-thawing",
        "basics-receiving",
        "basics-fifo",
        "basics-illness-reporting",
        "basics-pest-control",
        "basics-chemical-safety",
        "basics-food-safety-plan",
        // Safety and Hygiene How-To's Module (8 videos)
        "howto-handwashing",
        "howto-sanitizing",
        "howto-thermometer",
        "howto-cleaning-schedule",
        "howto-equipment-cleaning",
        "howto-uniform-care",
        "howto-wound-care",
        "howto-inspection-prep"
      ];
      const completedVideos = videoProgress2.filter((v) => v.completed).map((v) => v.videoId);
      const allRequired = requiredVideos.every((videoId) => completedVideos.includes(videoId));
      if (!allRequired) {
        return res.status(400).json({
          message: "All required videos must be completed before certification",
          missingVideos: requiredVideos.filter((id) => !completedVideos.includes(id))
        });
      }
      const user = await storage2.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const completionData = {
        userId,
        completedAt: new Date(completionDate),
        videoProgress: videoProgress2,
        confirmed: true,
        certificateGenerated: false
      };
      await storage2.createMicrolearningCompletion(completionData);
      let alwaysFoodSafeResult = null;
      if (isAlwaysFoodSafeConfigured()) {
        try {
          alwaysFoodSafeResult = await submitToAlwaysFoodSafe({
            userId,
            userName: user.username,
            email: `${user.username}@localcooks.ca`,
            // Placeholder email since User type doesn't have email
            completionDate: new Date(completionDate),
            videoProgress: videoProgress2
          });
        } catch (afsError) {
          console.error("Always Food Safe API error:", afsError);
        }
      }
      res.json({
        success: true,
        message: "Microlearning completed successfully",
        completionConfirmed: true,
        alwaysFoodSafeIntegration: alwaysFoodSafeResult?.success ? "success" : "not_configured",
        certificateId: alwaysFoodSafeResult?.certificateId,
        certificateUrl: alwaysFoodSafeResult?.certificateUrl
      });
    } catch (error) {
      console.error("Error completing microlearning:", error);
      res.status(500).json({ message: "Failed to complete microlearning" });
    }
  });
  app3.get("/api/microlearning/completion/:userId", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Authentication required" });
      }
      const userId = parseInt(req.params.userId);
      if (req.user.id !== userId && req.user.role !== "admin") {
        return res.status(403).json({ message: "Access denied" });
      }
      const completion = await storage2.getMicrolearningCompletion(userId);
      if (!completion) {
        return res.status(404).json({ message: "No completion found" });
      }
      res.json(completion);
    } catch (error) {
      console.error("Error getting microlearning completion status:", error);
      res.status(500).json({ message: "Failed to get completion status" });
    }
  });
  app3.get("/api/microlearning/certificate/:userId", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Authentication required" });
      }
      const userId = parseInt(req.params.userId);
      if (req.user.id !== userId && req.user.role !== "admin") {
        return res.status(403).json({ message: "Access denied" });
      }
      const completion = await storage2.getMicrolearningCompletion(userId);
      if (!completion || !completion.confirmed) {
        return res.status(404).json({ message: "No confirmed completion found" });
      }
      const user = await storage2.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const certificateUrl = `/api/certificates/microlearning-${userId}-${Date.now()}.pdf`;
      res.json({
        success: true,
        certificateUrl,
        completionDate: completion.completedAt,
        message: "Certificate for skillpass.nl food safety training preparation - Complete your official certification at skillpass.nl"
      });
    } catch (error) {
      console.error("Error generating certificate:", error);
      res.status(500).json({ message: "Failed to generate certificate" });
    }
  });
  app3.post("/api/auth/send-verification-email", async (req, res) => {
    try {
      const { email, fullName } = req.body;
      if (!email || !fullName) {
        return res.status(400).json({ message: "Email and full name are required" });
      }
      const crypto = await import("crypto");
      const verificationToken = crypto.randomBytes(32).toString("hex");
      const verificationTokenExpiry = new Date(Date.now() + 864e5);
      const { pool: pool3 } = await Promise.resolve().then(() => (init_db(), db_exports));
      await pool3.query(`
        INSERT INTO email_verification_tokens (email, token, expires_at, created_at) 
        VALUES ($1, $2, $3, NOW()) 
        ON CONFLICT (email) DO UPDATE SET token = $2, expires_at = $3, created_at = NOW()
      `, [email, verificationToken, verificationTokenExpiry]);
      const verificationUrl = `${process.env.BASE_URL || "http://localhost:5000"}/auth/verify-email?token=${verificationToken}`;
      const { sendEmail: sendEmail2, generateEmailVerificationEmail: generateEmailVerificationEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
      const emailContent = generateEmailVerificationEmail2({
        fullName,
        email,
        verificationToken,
        verificationUrl
      });
      const emailSent = await sendEmail2(emailContent, {
        trackingId: `email_verification_${email}_${Date.now()}`
      });
      if (emailSent) {
        console.log(`Email verification sent to ${email}`);
        return res.status(200).json({
          message: "Verification email sent successfully"
        });
      } else {
        console.error(`Failed to send verification email to ${email}`);
        return res.status(500).json({
          message: "Error sending verification email. Please try again later."
        });
      }
    } catch (error) {
      console.error("Error sending verification email:", error);
      return res.status(500).json({
        message: "Internal server error. Please try again later."
      });
    }
  });
  app3.get("/api/auth/verify-email", async (req, res) => {
    try {
      const { token } = req.query;
      if (!token || typeof token !== "string") {
        return res.status(400).json({ message: "Verification token is required" });
      }
      const { pool: pool3 } = await Promise.resolve().then(() => (init_db(), db_exports));
      const result = await pool3.query(
        "SELECT email FROM email_verification_tokens WHERE token = $1 AND expires_at > NOW()",
        [token]
      );
      if (result.rows.length === 0) {
        return res.status(400).json({ message: "Invalid or expired verification token" });
      }
      const { email } = result.rows[0];
      await pool3.query("UPDATE users SET is_verified = true, updated_at = NOW() WHERE email = $1", [email]);
      await pool3.query("UPDATE users SET is_verified = true, updated_at = NOW() WHERE email = $1", [email]);
      await pool3.query("DELETE FROM email_verification_tokens WHERE token = $1", [token]);
      console.log(`Email verified successfully: ${email}`);
      return res.redirect(`${process.env.BASE_URL || "http://localhost:5000"}/auth?verified=true`);
    } catch (error) {
      console.error("Error in email verification:", error);
      return res.status(500).json({
        message: "Internal server error. Please try again later."
      });
    }
  });
  app3.post("/api/admin/send-promo-email", async (req, res) => {
    try {
      console.log(`POST /api/admin/send-promo-email - Session ID: ${req.sessionID}, User ID: ${req.user?.id}`);
      if (!req.isAuthenticated || !req.isAuthenticated() || !req.user) {
        console.log("Promo email request - User not authenticated");
        return res.status(401).json({ error: "Not authenticated" });
      }
      if (req.user.role !== "admin") {
        console.log(`Promo email request - User ${req.user.id} is not admin (role: ${req.user.role})`);
        return res.status(403).json({ error: "Admin access required" });
      }
      const {
        email,
        customEmails,
        emailMode,
        recipients,
        promoCode,
        promoCodeLabel,
        message,
        customMessage,
        greeting,
        buttonText,
        orderUrl,
        subject,
        previewText,
        designSystem,
        isPremium,
        sections,
        header,
        footer,
        usageSteps,
        emailContainer,
        dividers,
        promoCodeStyling,
        promoStyle,
        customDesign
      } = req.body;
      const messageContent = customMessage || message;
      console.log("Promo email request - Auth info:", {
        sessionUserId: req.user?.id,
        headerUserId: req.headers["user-id"],
        rawUserId: req.user?.id
      });
      let targetEmails = [];
      if (recipients && Array.isArray(recipients) && recipients.length > 0) {
        targetEmails = recipients.map(
          (recipient) => typeof recipient === "string" ? recipient : recipient.email
        ).filter(Boolean);
      } else if (emailMode === "custom" && customEmails && Array.isArray(customEmails)) {
        targetEmails = customEmails;
      } else if (email) {
        targetEmails = [email];
      }
      if (targetEmails.length === 0) {
        console.log("Promo email request - No valid email addresses provided");
        return res.status(400).json({ error: "At least one email address is required" });
      }
      if (promoCode && promoCode.length > 0 && promoCode.length < 3) {
        console.log("Promo email request - Invalid promo code length");
        return res.status(400).json({ error: "Promo code must be at least 3 characters long if provided" });
      }
      if (!messageContent || messageContent.length < 10) {
        console.log("Promo email request - Invalid message:", {
          customMessage: customMessage?.substring(0, 50),
          message: message?.substring(0, 50),
          messageContent: messageContent?.substring(0, 50)
        });
        return res.status(400).json({ error: "Message must be at least 10 characters" });
      }
      console.log("Promo email request - Validation passed, generating email");
      console.log(`Promo email request - Sending to ${targetEmails.length} recipient(s)`);
      const results = [];
      let successCount = 0;
      let failureCount = 0;
      for (const targetEmail of targetEmails) {
        try {
          const emailContent = generatePromoCodeEmail({
            email: targetEmail,
            promoCode,
            promoCodeLabel: promoCodeLabel || "\u{1F381} Special Offer Code For You",
            customMessage: messageContent,
            greeting: greeting || "Hi there! \u{1F44B}",
            subject: subject || "Special Offer from Local Cooks",
            previewText: previewText || "Don't miss out on this exclusive offer",
            designSystem,
            isPremium: isPremium || true,
            sections: sections || [],
            header: header || {
              title: "Local Cooks Header",
              subtitle: "Premium Quality Food Subheader",
              styling: {
                backgroundColor: "linear-gradient(135deg, #F51042 0%, #FF5470 100%)",
                titleColor: "#ffffff",
                subtitleColor: "#ffffff",
                titleFontSize: "32px",
                subtitleFontSize: "18px",
                padding: "24px",
                borderRadius: "0px",
                textAlign: "center"
              }
            },
            footer: footer || {
              mainText: "Thank you for being part of the Local Cooks community!",
              contactText: "Questions? Contact us at support@localcooks.com",
              copyrightText: "\xA9 2024 Local Cooks. All rights reserved.",
              showContact: true,
              showCopyright: true,
              styling: {
                backgroundColor: "#f8fafc",
                textColor: "#64748b",
                linkColor: "#F51042",
                fontSize: "14px",
                padding: "24px 32px",
                textAlign: "center",
                borderColor: "#e2e8f0"
              }
            },
            usageSteps: usageSteps || {
              title: "\u{1F680} How to use your promo code:",
              steps: [
                `Visit our website: <a href="${orderUrl || "https://localcooks.ca"}" style="color: #1d4ed8;">${orderUrl || "https://localcooks.ca"}</a>`,
                "Browse our amazing local cooks and their delicious offerings",
                "Apply your promo code during checkout",
                "Enjoy your special offer!"
              ],
              enabled: true,
              styling: {
                backgroundColor: "linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)",
                borderColor: "#93c5fd",
                titleColor: "#1d4ed8",
                textColor: "#1e40af",
                linkColor: "#1d4ed8",
                padding: "20px",
                borderRadius: "8px"
              }
            },
            emailContainer: emailContainer || {
              maxWidth: "600px",
              backgroundColor: "#f1f5f9",
              borderRadius: "12px",
              boxShadow: "0 4px 20px rgba(0,0,0,0.08)"
            },
            dividers: dividers || {
              enabled: true,
              style: "solid",
              color: "#e2e8f0",
              thickness: "1px",
              margin: "24px 0",
              opacity: "1"
            },
            promoCodeStyling,
            promoStyle: promoStyle || { colorTheme: "green", borderStyle: "dashed" },
            orderButton: {
              text: buttonText || "\u{1F31F} Start Shopping Now",
              url: orderUrl || "https://localcooks.ca",
              styling: {
                backgroundColor: "#F51042",
                color: "#ffffff",
                fontSize: "16px",
                fontWeight: "600",
                padding: "12px 24px",
                borderRadius: "8px",
                textAlign: "center"
              }
            }
          });
          const emailSent = await sendEmail(emailContent, {
            trackingId: `promo_email_${targetEmail}_${Date.now()}`
          });
          if (emailSent) {
            console.log(`Promo email sent successfully to ${targetEmail}`);
            results.push({ email: targetEmail, status: "success" });
            successCount++;
          } else {
            console.error(`Failed to send promo email to ${targetEmail}`);
            results.push({ email: targetEmail, status: "failed", error: "Email sending failed" });
            failureCount++;
          }
        } catch (error) {
          console.error(`Error sending promo email to ${targetEmail}:`, error);
          results.push({ email: targetEmail, status: "failed", error: error instanceof Error ? error.message : "Unknown error" });
          failureCount++;
        }
      }
      if (successCount > 0) {
        res.json({
          success: true,
          message: `Promo emails sent: ${successCount} successful, ${failureCount} failed`,
          results,
          promoCode,
          summary: {
            total: targetEmails.length,
            successful: successCount,
            failed: failureCount
          }
        });
      } else {
        res.status(500).json({
          error: "All email sending failed",
          message: "Failed to send promo emails to any recipients.",
          results
        });
      }
    } catch (error) {
      console.error("Error sending promo email:", error);
      res.status(500).json({
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app3.post("/api/admin/test-email", async (req, res) => {
    try {
      console.log(`POST /api/admin/test-email - Session ID: ${req.sessionID}, User ID: ${req.user?.id}`);
      if (!req.isAuthenticated || !req.isAuthenticated() || !req.user) {
        console.log("Test email request - User not authenticated");
        return res.status(401).json({ error: "Not authenticated" });
      }
      if (req.user.role !== "admin") {
        console.log(`Test email request - User ${req.user.id} is not admin (role: ${req.user.role})`);
        return res.status(403).json({ error: "Admin access required" });
      }
      const {
        email,
        subject,
        previewText,
        sections,
        header,
        footer,
        usageSteps,
        emailContainer,
        customDesign
      } = req.body;
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      console.log("Test email request - Validation passed, generating test email");
      const emailContent = generatePromoCodeEmail({
        email,
        promoCode: "TEST123",
        promoCodeLabel: "\u{1F381} Test Promo Code",
        customMessage: "This is a test email to verify the email system is working correctly.",
        greeting: "Hello! \u{1F44B}",
        subject: subject || "Test Email from Local Cooks",
        previewText: previewText || "Test email preview",
        designSystem: customDesign?.designSystem,
        isPremium: true,
        sections: sections || [],
        header: header || {
          title: "Local Cooks Header",
          subtitle: "Premium Quality Food Subheader",
          styling: {
            backgroundColor: "linear-gradient(135deg, #F51042 0%, #FF5470 100%)",
            titleColor: "#ffffff",
            subtitleColor: "#ffffff",
            titleFontSize: "32px",
            subtitleFontSize: "18px",
            padding: "24px",
            borderRadius: "0px",
            textAlign: "center"
          }
        },
        footer: footer || {
          mainText: "Thank you for being part of the Local Cooks community!",
          contactText: "Questions? Contact us at support@localcooks.com",
          copyrightText: "\xA9 2024 Local Cooks. All rights reserved.",
          showContact: true,
          showCopyright: true,
          styling: {
            backgroundColor: "#f8fafc",
            textColor: "#64748b",
            linkColor: "#F51042",
            fontSize: "14px",
            padding: "24px 32px",
            textAlign: "center",
            borderColor: "#e2e8f0"
          }
        },
        usageSteps: usageSteps || {
          title: "\u{1F680} How to use your promo code:",
          steps: [
            'Visit our website: <a href="https://localcooks.ca" style="color: #1d4ed8;">https://localcooks.ca</a>',
            "Browse our amazing local cooks and their delicious offerings",
            "Apply your promo code during checkout",
            "Enjoy your special offer!"
          ],
          enabled: true,
          styling: {
            backgroundColor: "linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)",
            borderColor: "#93c5fd",
            titleColor: "#1d4ed8",
            textColor: "#1e40af",
            linkColor: "#1d4ed8",
            padding: "20px",
            borderRadius: "8px"
          }
        },
        emailContainer: emailContainer || {
          maxWidth: "600px",
          backgroundColor: "#f1f5f9",
          borderRadius: "12px",
          boxShadow: "0 4px 20px rgba(0,0,0,0.08)"
        },
        dividers: {
          enabled: true,
          style: "solid",
          color: "#e2e8f0",
          thickness: "1px",
          margin: "24px 0",
          opacity: "1"
        },
        promoStyle: { colorTheme: "green", borderStyle: "dashed" },
        orderButton: {
          text: "\u{1F31F} Test Order Button",
          url: "https://localcooks.ca",
          styling: {
            backgroundColor: "#F51042",
            color: "#ffffff",
            fontSize: "16px",
            fontWeight: "600",
            padding: "12px 24px",
            borderRadius: "8px",
            textAlign: "center"
          }
        }
      });
      const emailSent = await sendEmail(emailContent, {
        trackingId: `test_email_${email}_${Date.now()}`
      });
      if (emailSent) {
        console.log(`Test email sent successfully to ${email}`);
        res.json({
          success: true,
          message: "Test email sent successfully",
          recipient: email
        });
      } else {
        console.error(`Failed to send test email to ${email}`);
        res.status(500).json({
          error: "Failed to send email",
          message: "Email service unavailable"
        });
      }
    } catch (error) {
      console.error("Error sending test email:", error);
      res.status(500).json({
        error: "Internal server error",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app3.post("/api/user/seen-welcome", async (req, res) => {
    try {
      if (!req.isAuthenticated || !req.isAuthenticated() || !req.user) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = req.user;
      await storage2.setUserHasSeenWelcome(user.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error setting has_seen_welcome:", error);
      res.status(500).json({ error: "Failed to update welcome status" });
    }
  });
  app3.post("/api/unsubscribe", async (req, res) => {
    try {
      const { email, reason, feedback, timestamp: timestamp2 } = req.body;
      if (!email) {
        return res.status(400).json({
          success: false,
          message: "Email address is required"
        });
      }
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        return res.status(400).json({
          success: false,
          message: "Invalid email format"
        });
      }
      const unsubscribeNotificationContent = {
        to: "localcooks@localcook.shop",
        subject: `\u{1F6AB} Unsubscribe Request - ${email}`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f9fafb;">
            <div style="background: linear-gradient(135deg, #F51042 0%, #FF5470 100%); padding: 20px; border-radius: 8px 8px 0 0; text-align: center;">
              <h1 style="color: white; margin: 0; font-size: 24px;">Local Cooks - Unsubscribe Request</h1>
            </div>
            
            <div style="background: white; padding: 30px; border-radius: 0 0 8px 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
              <h2 style="color: #1f2937; margin-top: 0;">New Unsubscribe Request</h2>
              
              <div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 15px; margin: 20px 0;">
                <p style="margin: 0; color: #dc2626; font-weight: 600;">
                  \u{1F4E7} Email: <span style="font-weight: normal;">${email}</span>
                </p>
              </div>
              
              <div style="margin: 20px 0;">
                <h3 style="color: #374151; margin-bottom: 10px;">Request Details:</h3>
                <ul style="color: #6b7280; line-height: 1.6;">
                  <li><strong>Timestamp:</strong> ${new Date(timestamp2).toLocaleString()}</li>
                  <li><strong>Reason:</strong> ${reason || "Not specified"}</li>
                  ${feedback ? `<li><strong>Feedback:</strong> ${feedback}</li>` : ""}
                </ul>
              </div>
              
              <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 6px; padding: 15px; margin: 20px 0;">
                <h4 style="color: #0369a1; margin: 0 0 10px 0;">Action Required:</h4>
                <p style="color: #0c4a6e; margin: 0; font-size: 14px;">
                  Please manually remove <strong>${email}</strong> from all email lists and marketing databases within 24 hours.
                </p>
              </div>
              
              <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb;">
                <p style="color: #6b7280; font-size: 12px; margin: 0;">
                  This is an automated notification from the Local Cooks unsubscribe system.
                </p>
              </div>
            </div>
          </div>
        `,
        text: `
          Local Cooks - Unsubscribe Request
          
          New unsubscribe request received:
          
          Email: ${email}
          Timestamp: ${new Date(timestamp2).toLocaleString()}
          Reason: ${reason || "Not specified"}
          ${feedback ? `Feedback: ${feedback}` : ""}
          
          ACTION REQUIRED: Please manually remove ${email} from all email lists and marketing databases within 24 hours.
        `
      };
      const emailSent = await sendEmail(unsubscribeNotificationContent, {
        trackingId: `unsubscribe_${email}_${Date.now()}`
      });
      if (!emailSent) {
        console.error("Failed to send unsubscribe notification email");
        return res.status(500).json({
          success: false,
          message: "Failed to process unsubscribe request"
        });
      }
      const userConfirmationContent = {
        to: email,
        subject: "Local Cooks - Unsubscribe Request Received",
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f9fafb;">
            <div style="background: linear-gradient(135deg, #F51042 0%, #FF5470 100%); padding: 20px; border-radius: 8px 8px 0 0; text-align: center;">
              <h1 style="color: white; margin: 0; font-size: 24px;">Local Cooks</h1>
              <p style="color: white; margin: 5px 0 0 0; opacity: 0.9;">Unsubscribe Confirmation</p>
            </div>
            
            <div style="background: white; padding: 30px; border-radius: 0 0 8px 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
              <h2 style="color: #1f2937; margin-top: 0;">We've Received Your Request</h2>
              
              <p style="color: #374151; line-height: 1.6;">
                Hi there,
              </p>
              
              <p style="color: #374151; line-height: 1.6;">
                We've received your request to unsubscribe from our email communications. We're sorry to see you go!
              </p>
              
              <div style="background: #f0f9ff; border-left: 4px solid #0ea5e9; padding: 15px; margin: 20px 0;">
                <p style="margin: 0; color: #0c4a6e;">
                  <strong>What happens next:</strong><br>
                  Your email address will be removed from our mailing lists within 24 hours. You may receive one final confirmation email once the process is complete.
                </p>
              </div>
              
              <p style="color: #374151; line-height: 1.6;">
                If you have any questions or if this was done in error, please don't hesitate to contact us at 
                <a href="mailto:localcooks@localcook.shop" style="color: #F51042; text-decoration: none;">localcooks@localcook.shop</a>.
              </p>
              
              <p style="color: #374151; line-height: 1.6;">
                Thank you for being part of the Local Cooks community!
              </p>
              
              <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center;">
                <p style="color: #6b7280; font-size: 12px; margin: 0;">
                  Local Cooks Team<br>
                  <a href="mailto:localcooks@localcook.shop" style="color: #F51042; text-decoration: none;">localcooks@localcook.shop</a>
                </p>
              </div>
            </div>
          </div>
        `,
        text: `
          Local Cooks - Unsubscribe Confirmation
          
          Hi there,
          
          We've received your request to unsubscribe from our email communications. We're sorry to see you go!
          
          What happens next:
          Your email address will be removed from our mailing lists within 24 hours. You may receive one final confirmation email once the process is complete.
          
          If you have any questions or if this was done in error, please contact us at localcooks@localcook.shop.
          
          Thank you for being part of the Local Cooks community!
          
          Local Cooks Team
          localcooks@localcook.shop
        `
      };
      await sendEmail(userConfirmationContent, {
        trackingId: `unsubscribe_confirmation_${email}_${Date.now()}`
      });
      console.log(`\u2705 Unsubscribe request processed for: ${email}`);
      res.json({
        success: true,
        message: "Unsubscribe request processed successfully"
      });
    } catch (error) {
      console.error("Error processing unsubscribe request:", error);
      res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app3.put("/api/manager/locations/:locationId/cancellation-policy", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    console.log("[PUT] /api/manager/locations/:locationId/cancellation-policy hit", {
      locationId: req.params.locationId,
      body: req.body
    });
    try {
      const user = req.neonUser;
      const { locationId } = req.params;
      const locationIdNum = parseInt(locationId);
      if (isNaN(locationIdNum) || locationIdNum <= 0) {
        console.error("[PUT] Invalid locationId:", locationId);
        return res.status(400).json({ error: "Invalid location ID" });
      }
      const { cancellationPolicyHours, cancellationPolicyMessage, defaultDailyBookingLimit, minimumBookingWindowHours, notificationEmail, notificationPhone, logoUrl, brandImageUrl, timezone } = req.body;
      console.log("[PUT] Request body:", {
        cancellationPolicyHours,
        cancellationPolicyMessage,
        defaultDailyBookingLimit,
        minimumBookingWindowHours,
        notificationEmail,
        logoUrl,
        brandImageUrl,
        timezone,
        locationId: locationIdNum
      });
      if (cancellationPolicyHours !== void 0 && (typeof cancellationPolicyHours !== "number" || cancellationPolicyHours < 0)) {
        return res.status(400).json({ error: "Cancellation policy hours must be a non-negative number" });
      }
      if (defaultDailyBookingLimit !== void 0 && (typeof defaultDailyBookingLimit !== "number" || defaultDailyBookingLimit < 1 || defaultDailyBookingLimit > 24)) {
        return res.status(400).json({ error: "Daily booking limit must be between 1 and 24 hours" });
      }
      if (minimumBookingWindowHours !== void 0 && (typeof minimumBookingWindowHours !== "number" || minimumBookingWindowHours < 0 || minimumBookingWindowHours > 168)) {
        return res.status(400).json({ error: "Minimum booking window hours must be between 0 and 168 hours" });
      }
      const { db: db3 } = await Promise.resolve().then(() => (init_db(), db_exports));
      const { locations: locations2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const { eq: eq5, and: and5, sql } = await import("drizzle-orm");
      const locationResults = await db3.select().from(locations2).where(and5(eq5(locations2.id, locationIdNum), eq5(locations2.managerId, user.id)));
      const location = locationResults[0];
      if (!location) {
        console.error("[PUT] Location not found or access denied:", {
          locationId: locationIdNum,
          managerId: user.id,
          userRole: user.role
        });
        return res.status(404).json({ error: "Location not found or access denied" });
      }
      console.log("[PUT] Location verified:", {
        locationId: location.id,
        locationName: location.name,
        managerId: location.managerId
      });
      const oldNotificationEmail = location.notificationEmail || location.notification_email || null;
      const updates = {
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (cancellationPolicyHours !== void 0) {
        updates.cancellationPolicyHours = cancellationPolicyHours;
      }
      if (cancellationPolicyMessage !== void 0) {
        updates.cancellationPolicyMessage = cancellationPolicyMessage;
      }
      if (defaultDailyBookingLimit !== void 0) {
        updates.defaultDailyBookingLimit = defaultDailyBookingLimit;
      }
      if (minimumBookingWindowHours !== void 0) {
        updates.minimumBookingWindowHours = minimumBookingWindowHours;
      }
      if (notificationEmail !== void 0) {
        if (notificationEmail && notificationEmail.trim() !== "" && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(notificationEmail)) {
          return res.status(400).json({ error: "Invalid email format" });
        }
        updates.notificationEmail = notificationEmail && notificationEmail.trim() !== "" ? notificationEmail.trim() : null;
        console.log("[PUT] Setting notificationEmail:", {
          raw: notificationEmail,
          processed: updates.notificationEmail,
          oldEmail: oldNotificationEmail
        });
      }
      if (notificationPhone !== void 0) {
        if (notificationPhone && notificationPhone.trim() !== "") {
          const normalized = normalizePhoneForStorage(notificationPhone);
          if (!normalized) {
            return res.status(400).json({
              error: "Invalid phone number format. Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
            });
          }
          updates.notificationPhone = normalized;
          console.log("[PUT] Setting notificationPhone:", {
            raw: notificationPhone,
            normalized
          });
        } else {
          updates.notificationPhone = null;
        }
      }
      if (logoUrl !== void 0) {
        const processedLogoUrl = logoUrl && logoUrl.trim() !== "" ? logoUrl.trim() : null;
        updates.logoUrl = processedLogoUrl;
        updates.logo_url = processedLogoUrl;
        console.log("[PUT] Setting logoUrl:", {
          raw: logoUrl,
          processed: processedLogoUrl,
          type: typeof processedLogoUrl,
          inUpdates: updates.logoUrl,
          alsoSetAsLogo_url: updates.logo_url
        });
      }
      if (brandImageUrl !== void 0) {
        const processedBrandImageUrl = brandImageUrl && brandImageUrl.trim() !== "" ? brandImageUrl.trim() : null;
        updates.brandImageUrl = processedBrandImageUrl;
        updates.brand_image_url = processedBrandImageUrl;
        console.log("[PUT] Setting brandImageUrl:", {
          raw: brandImageUrl,
          processed: processedBrandImageUrl
        });
      }
      if (timezone !== void 0) {
        updates.timezone = DEFAULT_TIMEZONE;
        console.log("[PUT] Setting timezone (locked to Newfoundland):", {
          raw: timezone,
          processed: DEFAULT_TIMEZONE,
          note: "Timezone is locked and cannot be changed"
        });
      }
      console.log("[PUT] Final updates object before DB update:", JSON.stringify(updates, null, 2));
      console.log("[PUT] Updates keys:", Object.keys(updates));
      console.log("[PUT] Updates object has logoUrl?", "logoUrl" in updates);
      console.log("[PUT] Updates object logoUrl value:", updates.logoUrl);
      console.log("[PUT] Updates object has logo_url?", "logo_url" in updates);
      console.log("[PUT] Updates object logo_url value:", updates.logo_url);
      const updatedResults = await db3.update(locations2).set(updates).where(eq5(locations2.id, locationIdNum)).returning();
      console.log("[PUT] Updated location from DB (full object):", JSON.stringify(updatedResults[0], null, 2));
      console.log("[PUT] Updated location logoUrl (camelCase):", updatedResults[0].logoUrl);
      console.log("[PUT] Updated location logo_url (snake_case):", updatedResults[0].logo_url);
      console.log("[PUT] Updated location all keys:", Object.keys(updatedResults[0] || {}));
      if (!updatedResults || updatedResults.length === 0) {
        console.error("[PUT] Cancellation policy update failed: No location returned from DB", {
          locationId: locationIdNum,
          updates
        });
        return res.status(500).json({ error: "Failed to update location settings - no rows updated" });
      }
      const updated = updatedResults[0];
      console.log("[PUT] Location settings updated successfully:", {
        locationId: updated.id,
        cancellationPolicyHours: updated.cancellationPolicyHours,
        defaultDailyBookingLimit: updated.defaultDailyBookingLimit,
        defaultDailyBookingLimitRaw: updated.default_daily_booking_limit,
        notificationEmail: updated.notificationEmail || updated.notification_email || "not set",
        logoUrl: updated.logoUrl || updated.logo_url || "NOT SET"
      });
      if (defaultDailyBookingLimit !== void 0) {
        const savedValue = updated.defaultDailyBookingLimit ?? updated.default_daily_booking_limit;
        console.log("[PUT] \u2705 Verified defaultDailyBookingLimit save:", {
          requested: defaultDailyBookingLimit,
          saved: savedValue,
          match: savedValue === defaultDailyBookingLimit
        });
        if (savedValue !== defaultDailyBookingLimit) {
          console.error("[PUT] \u274C WARNING: defaultDailyBookingLimit mismatch!", {
            requested: defaultDailyBookingLimit,
            saved: savedValue
          });
        }
      }
      const response = {
        ...updated,
        logoUrl: updated.logoUrl || updated.logo_url || null,
        notificationEmail: updated.notificationEmail || updated.notification_email || null,
        notificationPhone: updated.notificationPhone || updated.notification_phone || null,
        cancellationPolicyHours: updated.cancellationPolicyHours || updated.cancellation_policy_hours,
        cancellationPolicyMessage: updated.cancellationPolicyMessage || updated.cancellation_policy_message,
        defaultDailyBookingLimit: updated.defaultDailyBookingLimit || updated.default_daily_booking_limit,
        minimumBookingWindowHours: updated.minimumBookingWindowHours || updated.minimum_booking_window_hours || 1,
        timezone: updated.timezone || DEFAULT_TIMEZONE
      };
      if (notificationEmail !== void 0 && response.notificationEmail && response.notificationEmail !== oldNotificationEmail) {
        try {
          const emailContent = generateLocationEmailChangedEmail({
            email: response.notificationEmail,
            locationName: location.name || "Location",
            locationId: locationIdNum
          });
          await sendEmail(emailContent);
          console.log(`\u2705 Location notification email change notification sent to: ${response.notificationEmail}`);
        } catch (emailError) {
          console.error("Error sending location email change notification:", emailError);
        }
      }
      console.log("[PUT] Sending response with notificationEmail:", response.notificationEmail);
      res.status(200).json(response);
    } catch (error) {
      console.error("Error updating cancellation policy:", error);
      res.status(500).json({ error: error.message || "Failed to update cancellation policy" });
    }
  });
  app3.get("/api/manager/locations", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      console.log("[GET] /api/manager/locations - Raw locations from DB:", locations2.map((loc) => ({
        id: loc.id,
        name: loc.name,
        logoUrl: loc.logoUrl,
        logo_url: loc.logo_url,
        allKeys: Object.keys(loc)
      })));
      const mappedLocations = locations2.map((loc) => ({
        ...loc,
        notificationEmail: loc.notificationEmail || loc.notification_email || null,
        notificationPhone: loc.notificationPhone || loc.notification_phone || null,
        cancellationPolicyHours: loc.cancellationPolicyHours || loc.cancellation_policy_hours,
        cancellationPolicyMessage: loc.cancellationPolicyMessage || loc.cancellation_policy_message,
        defaultDailyBookingLimit: loc.defaultDailyBookingLimit || loc.default_daily_booking_limit,
        minimumBookingWindowHours: loc.minimumBookingWindowHours || loc.minimum_booking_window_hours || 1,
        logoUrl: loc.logoUrl || loc.logo_url || null,
        timezone: loc.timezone || DEFAULT_TIMEZONE,
        // Kitchen license status fields
        kitchenLicenseUrl: loc.kitchenLicenseUrl || loc.kitchen_license_url || null,
        kitchenLicenseStatus: loc.kitchenLicenseStatus || loc.kitchen_license_status || "pending",
        kitchenLicenseApprovedBy: loc.kitchenLicenseApprovedBy || loc.kitchen_license_approved_by || null,
        kitchenLicenseApprovedAt: loc.kitchenLicenseApprovedAt || loc.kitchen_license_approved_at || null,
        kitchenLicenseFeedback: loc.kitchenLicenseFeedback || loc.kitchen_license_feedback || null
      }));
      console.log(
        "[GET] /api/manager/locations - Mapped locations:",
        mappedLocations.map((loc) => ({
          id: loc.id,
          name: loc.name,
          logoUrl: loc.logoUrl,
          notificationEmail: loc.notificationEmail || "not set"
        }))
      );
      res.json(mappedLocations);
    } catch (error) {
      console.error("Error fetching locations:", error);
      res.status(500).json({ error: error.message || "Failed to fetch locations" });
    }
  });
  app3.post("/api/manager/locations", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const { name, address, notificationEmail, notificationPhone } = req.body;
      if (!name || !address) {
        return res.status(400).json({ error: "Name and address are required" });
      }
      let normalizedNotificationPhone = void 0;
      if (notificationPhone && notificationPhone.trim() !== "") {
        const normalized = normalizePhoneForStorage(notificationPhone);
        if (!normalized) {
          return res.status(400).json({
            error: "Invalid phone number format. Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
          });
        }
        normalizedNotificationPhone = normalized;
      }
      console.log("Creating location for manager:", { managerId: user.id, name, address, notificationPhone: normalizedNotificationPhone });
      const location = await firebaseStorage.createLocation({
        name,
        address,
        managerId: user.id,
        notificationEmail: notificationEmail || void 0,
        notificationPhone: normalizedNotificationPhone
      });
      const mappedLocation = {
        ...location,
        managerId: location.managerId || location.manager_id || null,
        notificationEmail: location.notificationEmail || location.notification_email || null,
        notificationPhone: location.notificationPhone || location.notification_phone || null,
        cancellationPolicyHours: location.cancellationPolicyHours || location.cancellation_policy_hours || 24,
        cancellationPolicyMessage: location.cancellationPolicyMessage || location.cancellation_policy_message || "Bookings cannot be cancelled within {hours} hours of the scheduled time.",
        defaultDailyBookingLimit: location.defaultDailyBookingLimit || location.default_daily_booking_limit || 2,
        createdAt: location.createdAt || location.created_at,
        updatedAt: location.updatedAt || location.updated_at
      };
      res.status(201).json(mappedLocation);
    } catch (error) {
      console.error("Error creating location:", error);
      console.error("Error details:", error.message, error.stack);
      res.status(500).json({ error: error.message || "Failed to create location" });
    }
  });
  app3.put("/api/manager/locations/:locationId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const locationId = parseInt(req.params.locationId);
      if (isNaN(locationId) || locationId <= 0) {
        return res.status(400).json({ error: "Invalid location ID" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this location" });
      }
      const {
        name,
        address,
        notificationEmail,
        notificationPhone,
        kitchenLicenseUrl,
        kitchenLicenseStatus,
        kitchenLicenseExpiry
      } = req.body;
      const updates = {};
      if (name !== void 0) updates.name = name;
      if (address !== void 0) updates.address = address;
      if (notificationEmail !== void 0) updates.notificationEmail = notificationEmail || null;
      if (notificationPhone !== void 0) {
        if (notificationPhone && notificationPhone.trim() !== "") {
          const normalized = normalizePhoneForStorage(notificationPhone);
          if (!normalized) {
            return res.status(400).json({
              error: "Invalid phone number format. Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
            });
          }
          updates.notificationPhone = normalized;
        } else {
          updates.notificationPhone = null;
        }
      }
      if (kitchenLicenseUrl !== void 0) {
        updates.kitchenLicenseUrl = kitchenLicenseUrl || null;
        if (kitchenLicenseUrl) {
          updates.kitchenLicenseUploadedAt = /* @__PURE__ */ new Date();
          if (kitchenLicenseStatus === void 0) {
            updates.kitchenLicenseStatus = "pending";
          }
        }
      }
      if (kitchenLicenseStatus !== void 0) {
        if (kitchenLicenseStatus && !["pending", "approved", "rejected"].includes(kitchenLicenseStatus)) {
          return res.status(400).json({
            error: "Invalid kitchenLicenseStatus. Must be 'pending', 'approved', or 'rejected'"
          });
        }
        updates.kitchenLicenseStatus = kitchenLicenseStatus || null;
      }
      if (kitchenLicenseExpiry !== void 0) {
        updates.kitchenLicenseExpiry = kitchenLicenseExpiry || null;
      }
      console.log(`\u{1F4BE} Updating location ${locationId} with:`, updates);
      const updated = await firebaseStorage.updateLocation(locationId, updates);
      if (!updated) {
        console.error(`\u274C Location ${locationId} not found in database`);
        return res.status(404).json({ error: "Location not found" });
      }
      console.log(`\u2705 Location ${locationId} updated successfully`);
      const mappedLocation = {
        ...updated,
        managerId: updated.managerId || updated.manager_id || null,
        notificationEmail: updated.notificationEmail || updated.notification_email || null,
        notificationPhone: updated.notificationPhone || updated.notification_phone || null,
        cancellationPolicyHours: updated.cancellationPolicyHours || updated.cancellation_policy_hours || 24,
        cancellationPolicyMessage: updated.cancellationPolicyMessage || updated.cancellation_policy_message || "Bookings cannot be cancelled within {hours} hours of the scheduled time.",
        defaultDailyBookingLimit: updated.defaultDailyBookingLimit || updated.default_daily_booking_limit || 2,
        createdAt: updated.createdAt || updated.created_at,
        updatedAt: updated.updatedAt || updated.updated_at
      };
      return res.json(mappedLocation);
    } catch (error) {
      console.error("\u274C Error updating location:", error);
      console.error("Error stack:", error.stack);
      res.status(500).json({ error: error.message || "Failed to update location" });
    }
  });
  app3.post("/api/manager/onboarding/step", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const { stepId } = req.body;
      if (!pool) {
        return res.status(500).json({ error: "Database not available" });
      }
      if (stepId === void 0 || stepId === null) {
        return res.status(400).json({ error: "stepId is required" });
      }
      const result = await pool.query(
        "SELECT manager_onboarding_steps_completed FROM users WHERE id = $1",
        [user.id]
      );
      const currentSteps = result.rows[0]?.manager_onboarding_steps_completed || {};
      const updatedSteps = {
        ...currentSteps,
        [`step_${stepId}`]: true
      };
      await pool.query(
        `UPDATE users 
         SET manager_onboarding_steps_completed = $1 
         WHERE id = $2`,
        [JSON.stringify(updatedSteps), user.id]
      );
      res.json({ success: true, stepsCompleted: updatedSteps });
    } catch (error) {
      console.error("Error tracking onboarding step:", error);
      res.status(500).json({ error: error.message || "Failed to track step" });
    }
  });
  app3.post("/api/manager/complete-onboarding", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const { skipped } = req.body;
      if (!pool) {
        return res.status(500).json({ error: "Database not available" });
      }
      await pool.query(
        `UPDATE users 
         SET manager_onboarding_completed = $1, 
             manager_onboarding_skipped = $2 
         WHERE id = $3`,
        [!skipped, !!skipped, user.id]
      );
      res.json({ success: true });
    } catch (error) {
      console.error("Error completing onboarding:", error);
      res.status(500).json({ error: error.message || "Failed to complete onboarding" });
    }
  });
  app3.post("/api/manager/stripe-connect/create", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const managerId = req.neonUser.id;
      const managerEmail = req.firebaseUser.email || req.neonUser.username;
      if (!managerEmail) {
        return res.status(400).json({ error: "Email address is required for Stripe Connect account creation" });
      }
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const userResult = await pool.query(
        "SELECT stripe_connect_account_id FROM users WHERE id = $1",
        [managerId]
      );
      if (userResult.rows[0]?.stripe_connect_account_id) {
        return res.status(400).json({
          error: "Stripe Connect account already exists",
          accountId: userResult.rows[0].stripe_connect_account_id
        });
      }
      const { createConnectAccount: createConnectAccount2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
      const { accountId } = await createConnectAccount2({
        managerId,
        email: managerEmail,
        country: "CA"
        // Canada
      });
      await pool.query(
        "UPDATE users SET stripe_connect_account_id = $1, stripe_connect_onboarding_status = $2 WHERE id = $3",
        [accountId, "in_progress", managerId]
      );
      res.json({ accountId });
    } catch (error) {
      console.error("Error creating Connect account:", error);
      res.status(500).json({ error: error.message || "Failed to create Stripe Connect account" });
    }
  });
  app3.get("/api/manager/stripe-connect/onboarding-link", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const managerId = req.neonUser.id;
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const userResult = await pool.query(
        "SELECT stripe_connect_account_id FROM users WHERE id = $1",
        [managerId]
      );
      if (!userResult.rows[0]?.stripe_connect_account_id) {
        return res.status(400).json({ error: "Stripe Connect account not found. Please create one first." });
      }
      const accountId = userResult.rows[0].stripe_connect_account_id;
      let baseUrl;
      const baseDomain = process.env.BASE_DOMAIN || "localcooks.ca";
      const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
      if (process.env.BASE_URL && !process.env.BASE_URL.includes("localhost")) {
        baseUrl = process.env.BASE_URL;
      } else if (isProduction2) {
        baseUrl = `https://${baseDomain}`;
      } else {
        baseUrl = "http://localhost:5173";
      }
      const { createAccountLink: createAccountLink2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
      const { url } = await createAccountLink2(
        accountId,
        `${baseUrl}/manager/stripe-connect/refresh`,
        `${baseUrl}/manager/stripe-connect/return`
      );
      res.json({ url });
    } catch (error) {
      console.error("Error creating onboarding link:", error);
      res.status(500).json({ error: error.message || "Failed to create onboarding link" });
    }
  });
  app3.get("/api/manager/stripe-connect/status", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const managerId = req.neonUser.id;
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const userResult = await pool.query(
        "SELECT stripe_connect_account_id, stripe_connect_onboarding_status FROM users WHERE id = $1",
        [managerId]
      );
      if (!userResult.rows[0]?.stripe_connect_account_id) {
        return res.json({
          hasAccount: false,
          status: "not_started"
        });
      }
      const accountId = userResult.rows[0].stripe_connect_account_id;
      const { isAccountReady: isAccountReady2, getAccountStatus: getAccountStatus2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
      const accountStatus = await getAccountStatus2(accountId);
      const ready = await isAccountReady2(accountId);
      const isComplete = ready || accountStatus.detailsSubmitted && accountStatus.chargesEnabled;
      if (isComplete && userResult.rows[0].stripe_connect_onboarding_status !== "complete") {
        await pool.query(
          "UPDATE users SET stripe_connect_onboarding_status = $1 WHERE id = $2",
          ["complete", managerId]
        );
      } else if (!isComplete && userResult.rows[0].stripe_connect_onboarding_status === "complete") {
        await pool.query(
          "UPDATE users SET stripe_connect_onboarding_status = $1 WHERE id = $2",
          ["in_progress", managerId]
        );
      }
      res.json({
        hasAccount: true,
        accountId,
        status: isComplete ? "complete" : "in_progress",
        details: accountStatus
      });
    } catch (error) {
      console.error("Error checking Connect status:", error);
      res.status(500).json({ error: error.message || "Failed to check Connect status" });
    }
  });
  app3.get("/api/manager/stripe-connect/dashboard-link", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    let accountId = null;
    try {
      const managerId = req.neonUser.id;
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const userResult = await pool.query(
        "SELECT stripe_connect_account_id, stripe_connect_onboarding_status FROM users WHERE id = $1",
        [managerId]
      );
      if (!userResult.rows[0]?.stripe_connect_account_id) {
        return res.status(400).json({ error: "Stripe Connect account not found. Please create a Stripe Connect account first." });
      }
      accountId = userResult.rows[0].stripe_connect_account_id;
      const onboardingStatus = userResult.rows[0].stripe_connect_onboarding_status;
      const createOnboardingLink = async () => {
        let baseUrl;
        const baseDomain = process.env.BASE_DOMAIN || "localcooks.ca";
        const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
        if (process.env.BASE_URL && !process.env.BASE_URL.includes("localhost")) {
          baseUrl = process.env.BASE_URL;
        } else if (isProduction2) {
          baseUrl = `https://${baseDomain}`;
        } else {
          baseUrl = "http://localhost:5173";
        }
        const { createAccountLink: createAccountLink2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
        const { url: url2 } = await createAccountLink2(
          accountId,
          `${baseUrl}/manager/stripe-connect/refresh`,
          `${baseUrl}/manager/stripe-connect/return`
        );
        return { url: url2 };
      };
      const { isAccountReady: isAccountReady2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
      const accountReady = await isAccountReady2(accountId);
      if (onboardingStatus !== "complete" && !accountReady) {
        const { url: url2 } = await createOnboardingLink();
        return res.json({
          url: url2,
          requiresOnboarding: true,
          message: "Please complete Stripe Connect onboarding to access your dashboard."
        });
      }
      const { createDashboardLoginLink: createDashboardLoginLink2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
      const { url } = await createDashboardLoginLink2(accountId);
      res.json({ url, requiresOnboarding: false });
    } catch (error) {
      console.error("Error creating dashboard login link:", error);
      if (error.message?.includes("not completed onboarding") && accountId) {
        try {
          let baseUrl;
          const baseDomain = process.env.BASE_DOMAIN || "localcooks.ca";
          const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
          if (process.env.BASE_URL && !process.env.BASE_URL.includes("localhost")) {
            baseUrl = process.env.BASE_URL;
          } else if (isProduction2) {
            baseUrl = `https://${baseDomain}`;
          } else {
            baseUrl = "http://localhost:5173";
          }
          const { createAccountLink: createAccountLink2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
          const { url } = await createAccountLink2(
            accountId,
            `${baseUrl}/manager/stripe-connect/refresh`,
            `${baseUrl}/manager/stripe-connect/return`
          );
          return res.json({
            url,
            requiresOnboarding: true,
            message: "Please complete Stripe Connect onboarding to access your dashboard."
          });
        } catch (onboardingError) {
          console.error("Error creating onboarding link as fallback:", onboardingError);
        }
      }
      res.status(500).json({ error: error.message || "Failed to create dashboard login link" });
    }
  });
  app3.post("/api/webhooks/stripe", async (req, res) => {
    try {
      const sig = req.headers["stripe-signature"];
      const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
      const stripeSecretKey5 = process.env.STRIPE_SECRET_KEY;
      if (!stripeSecretKey5) {
        return res.status(500).json({ error: "Stripe not configured" });
      }
      const stripe5 = new Stripe5(stripeSecretKey5, {
        apiVersion: "2025-12-15.clover"
      });
      if (!webhookSecret) {
        console.warn("\u26A0\uFE0F STRIPE_WEBHOOK_SECRET not configured - webhook verification disabled");
      }
      let event;
      if (webhookSecret && sig) {
        try {
          event = stripe5.webhooks.constructEvent(req.body, sig, webhookSecret);
        } catch (err) {
          console.error("\u26A0\uFE0F Webhook signature verification failed:", err.message);
          return res.status(400).json({ error: `Webhook Error: ${err.message}` });
        }
      } else {
        event = req.body;
      }
      const webhookEventId = event.id;
      switch (event.type) {
        case "checkout.session.completed":
          await handleCheckoutSessionCompleted(event.data.object, webhookEventId);
          break;
        case "payment_intent.succeeded":
          await handlePaymentIntentSucceeded(event.data.object, webhookEventId);
          break;
        case "payment_intent.payment_failed":
          await handlePaymentIntentFailed(event.data.object, webhookEventId);
          break;
        case "payment_intent.canceled":
          await handlePaymentIntentCanceled(event.data.object, webhookEventId);
          break;
        case "charge.refunded":
          await handleChargeRefunded(event.data.object, webhookEventId);
          break;
        default:
          if (event.type.startsWith("charge.")) {
            await handleChargeRefunded(event.data.object, webhookEventId);
          } else {
            console.log(`Unhandled event type: ${event.type}`);
          }
      }
      res.json({ received: true });
    } catch (error) {
      console.error("Error handling webhook:", error);
      res.status(500).json({ error: error.message || "Webhook handler failed" });
    }
  });
  async function handleCheckoutSessionCompleted(session2, webhookEventId) {
    if (!pool) {
      console.error("Database pool not available for webhook");
      return;
    }
    try {
      const { updateTransactionBySessionId: updateTransactionBySessionId2 } = await Promise.resolve().then(() => (init_stripe_checkout_transactions_service(), stripe_checkout_transactions_service_exports));
      const stripeSecretKey5 = process.env.STRIPE_SECRET_KEY;
      if (!stripeSecretKey5) {
        console.error("Stripe secret key not available");
        return;
      }
      const stripe5 = new Stripe5(stripeSecretKey5, {
        apiVersion: "2025-12-15.clover"
      });
      const expandedSession = await stripe5.checkout.sessions.retrieve(session2.id, {
        expand: ["line_items", "payment_intent"]
      });
      const paymentIntent = expandedSession.payment_intent;
      let paymentIntentId;
      let chargeId;
      if (typeof paymentIntent === "object" && paymentIntent !== null) {
        paymentIntentId = paymentIntent.id;
        if (paymentIntent.latest_charge) {
          chargeId = typeof paymentIntent.latest_charge === "string" ? paymentIntent.latest_charge : paymentIntent.latest_charge.id;
        }
      } else if (typeof paymentIntent === "string") {
        paymentIntentId = paymentIntent;
        try {
          const pi = await stripe5.paymentIntents.retrieve(paymentIntent);
          if (pi.latest_charge) {
            chargeId = typeof pi.latest_charge === "string" ? pi.latest_charge : pi.latest_charge.id;
          }
        } catch (error) {
          console.warn("Could not fetch payment intent details:", error);
        }
      }
      const updateParams = {
        status: "completed",
        completedAt: /* @__PURE__ */ new Date(),
        metadata: {
          webhook_event_id: webhookEventId,
          session_mode: expandedSession.mode
        }
      };
      if (paymentIntentId) {
        updateParams.stripePaymentIntentId = paymentIntentId;
      }
      if (chargeId) {
        updateParams.stripeChargeId = chargeId;
      }
      const updatedTransaction = await updateTransactionBySessionId2(
        session2.id,
        updateParams,
        pool
      );
      if (updatedTransaction) {
        console.log(`[Webhook] Updated transaction for Checkout session ${session2.id}:`, {
          paymentIntentId,
          chargeId,
          amount: `$${(updatedTransaction.total_customer_charged_cents / 100).toFixed(2)}`,
          managerReceives: `$${(updatedTransaction.manager_receives_cents / 100).toFixed(2)}`
        });
      } else {
        console.warn(`[Webhook] Transaction not found for Checkout session ${session2.id}`);
      }
    } catch (error) {
      console.error(`[Webhook] Error handling checkout.session.completed:`, error);
    }
  }
  async function handlePaymentIntentSucceeded(paymentIntent, webhookEventId) {
    if (!pool) {
      console.error("Database pool not available for webhook");
      return;
    }
    try {
      const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
      const { getStripePaymentAmounts: getStripePaymentAmounts2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
      const transaction = await findPaymentTransactionByIntentId2(paymentIntent.id, pool);
      if (transaction) {
        let managerConnectAccountId;
        try {
          const managerResult = await pool.query(`
            SELECT stripe_connect_account_id 
            FROM users 
            WHERE id = $1 AND stripe_connect_account_id IS NOT NULL
          `, [transaction.manager_id]);
          if (managerResult.rows.length > 0) {
            managerConnectAccountId = managerResult.rows[0].stripe_connect_account_id;
          }
        } catch (error) {
          console.warn(`[Webhook] Could not fetch manager Connect account:`, error);
        }
        const stripeAmounts = await getStripePaymentAmounts2(paymentIntent.id, managerConnectAccountId);
        const updateParams = {
          status: "succeeded",
          stripeStatus: paymentIntent.status,
          chargeId: typeof paymentIntent.latest_charge === "string" ? paymentIntent.latest_charge : paymentIntent.latest_charge?.id,
          paidAt: /* @__PURE__ */ new Date(),
          lastSyncedAt: /* @__PURE__ */ new Date(),
          webhookEventId
        };
        if (stripeAmounts) {
          updateParams.stripeAmount = stripeAmounts.stripeAmount;
          updateParams.stripeNetAmount = stripeAmounts.stripeNetAmount;
          updateParams.stripeProcessingFee = stripeAmounts.stripeProcessingFee;
          updateParams.stripePlatformFee = stripeAmounts.stripePlatformFee;
          console.log(`[Webhook] Syncing Stripe amounts for ${paymentIntent.id}:`, {
            amount: `$${(stripeAmounts.stripeAmount / 100).toFixed(2)}`,
            netAmount: `$${(stripeAmounts.stripeNetAmount / 100).toFixed(2)}`,
            processingFee: `$${(stripeAmounts.stripeProcessingFee / 100).toFixed(2)}`,
            platformFee: `$${(stripeAmounts.stripePlatformFee / 100).toFixed(2)}`
          });
        }
        await updatePaymentTransaction2(transaction.id, updateParams, pool);
        console.log(`[Webhook] Updated payment_transactions for PaymentIntent ${paymentIntent.id}${stripeAmounts ? " with Stripe amounts" : ""}`);
        if (stripeAmounts) {
          const { syncStripeAmountsToBookings: syncStripeAmountsToBookings2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
          await syncStripeAmountsToBookings2(paymentIntent.id, stripeAmounts, pool);
        }
      }
      await pool.query(`
        UPDATE kitchen_bookings
        SET 
          payment_status = 'paid',
          updated_at = NOW()
        WHERE payment_intent_id = $1
          AND payment_status != 'paid'
      `, [paymentIntent.id]);
      await pool.query(`
        UPDATE storage_bookings
        SET 
          payment_status = 'paid',
          updated_at = NOW()
        WHERE payment_intent_id = $1
          AND payment_status != 'paid'
      `, [paymentIntent.id]);
      await pool.query(`
        UPDATE equipment_bookings
        SET 
          payment_status = 'paid',
          updated_at = NOW()
        WHERE payment_intent_id = $1
          AND payment_status != 'paid'
      `, [paymentIntent.id]);
      console.log(`[Webhook] Updated booking payment status to 'paid' for PaymentIntent ${paymentIntent.id}`);
    } catch (error) {
      console.error(`[Webhook] Error updating payment status for ${paymentIntent.id}:`, error);
    }
  }
  async function handlePaymentIntentFailed(paymentIntent, webhookEventId) {
    if (!pool) {
      console.error("Database pool not available for webhook");
      return;
    }
    try {
      const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
      const transaction = await findPaymentTransactionByIntentId2(paymentIntent.id, pool);
      if (transaction) {
        await updatePaymentTransaction2(transaction.id, {
          status: "failed",
          stripeStatus: paymentIntent.status,
          failureReason: paymentIntent.last_payment_error?.message || "Payment failed",
          lastSyncedAt: /* @__PURE__ */ new Date(),
          webhookEventId
        }, pool);
        console.log(`[Webhook] Updated payment_transactions for PaymentIntent ${paymentIntent.id}`);
      }
      await pool.query(`
        UPDATE kitchen_bookings
        SET 
          payment_status = 'failed',
          updated_at = NOW()
        WHERE payment_intent_id = $1
          AND payment_status NOT IN ('paid', 'refunded', 'partially_refunded')
      `, [paymentIntent.id]);
      await pool.query(`
        UPDATE storage_bookings
        SET 
          payment_status = 'failed',
          updated_at = NOW()
        WHERE payment_intent_id = $1
          AND payment_status NOT IN ('paid', 'refunded', 'partially_refunded')
      `, [paymentIntent.id]);
      await pool.query(`
        UPDATE equipment_bookings
        SET 
          payment_status = 'failed',
          updated_at = NOW()
        WHERE payment_intent_id = $1
          AND payment_status NOT IN ('paid', 'refunded', 'partially_refunded')
      `, [paymentIntent.id]);
      console.log(`[Webhook] Updated booking payment status to 'failed' for PaymentIntent ${paymentIntent.id}`);
    } catch (error) {
      console.error(`[Webhook] Error updating payment status for ${paymentIntent.id}:`, error);
    }
  }
  async function handlePaymentIntentCanceled(paymentIntent, webhookEventId) {
    if (!pool) {
      console.error("Database pool not available for webhook");
      return;
    }
    try {
      const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
      const transaction = await findPaymentTransactionByIntentId2(paymentIntent.id, pool);
      if (transaction) {
        await updatePaymentTransaction2(transaction.id, {
          status: "canceled",
          stripeStatus: paymentIntent.status,
          lastSyncedAt: /* @__PURE__ */ new Date(),
          webhookEventId
        }, pool);
        console.log(`[Webhook] Updated payment_transactions for PaymentIntent ${paymentIntent.id}`);
      }
      await pool.query(`
        UPDATE kitchen_bookings
        SET 
          payment_status = 'canceled',
          updated_at = NOW()
        WHERE payment_intent_id = $1
          AND payment_status NOT IN ('paid', 'refunded', 'partially_refunded')
      `, [paymentIntent.id]);
      await pool.query(`
        UPDATE storage_bookings
        SET 
          payment_status = 'canceled',
          updated_at = NOW()
        WHERE payment_intent_id = $1
          AND payment_status NOT IN ('paid', 'refunded', 'partially_refunded')
      `, [paymentIntent.id]);
      await pool.query(`
        UPDATE equipment_bookings
        SET 
          payment_status = 'canceled',
          updated_at = NOW()
        WHERE payment_intent_id = $1
          AND payment_status NOT IN ('paid', 'refunded', 'partially_refunded')
      `, [paymentIntent.id]);
      console.log(`[Webhook] Updated booking payment status to 'canceled' for PaymentIntent ${paymentIntent.id}`);
    } catch (error) {
      console.error(`[Webhook] Error updating payment status for ${paymentIntent.id}:`, error);
    }
  }
  async function handleChargeRefunded(charge, webhookEventId) {
    if (!pool) {
      console.error("Database pool not available for webhook");
      return;
    }
    try {
      const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
      const paymentIntentId = typeof charge.payment_intent === "string" ? charge.payment_intent : charge.payment_intent?.id;
      if (!paymentIntentId) {
        console.warn(`[Webhook] Charge ${charge.id} has no payment_intent`);
        return;
      }
      const isPartial = charge.amount_refunded < charge.amount;
      const refundStatus = isPartial ? "partially_refunded" : "refunded";
      const refundAmountCents = charge.amount_refunded;
      const transaction = await findPaymentTransactionByIntentId2(paymentIntentId, pool);
      if (transaction) {
        await updatePaymentTransaction2(transaction.id, {
          status: refundStatus,
          refundAmount: refundAmountCents,
          refundId: charge.refunds?.data?.[0]?.id,
          refundedAt: /* @__PURE__ */ new Date(),
          lastSyncedAt: /* @__PURE__ */ new Date(),
          webhookEventId
        }, pool);
        console.log(`[Webhook] Updated payment_transactions for refund on PaymentIntent ${paymentIntentId}`);
      }
      await pool.query(`
        UPDATE kitchen_bookings
        SET 
          payment_status = $1,
          updated_at = NOW()
        WHERE payment_intent_id = $2
          AND payment_status = 'paid'
      `, [refundStatus, paymentIntentId]);
      await pool.query(`
        UPDATE storage_bookings
        SET 
          payment_status = $1,
          updated_at = NOW()
        WHERE payment_intent_id = $2
          AND payment_status = 'paid'
      `, [refundStatus, paymentIntentId]);
      await pool.query(`
        UPDATE equipment_bookings
        SET 
          payment_status = $1,
          updated_at = NOW()
        WHERE payment_intent_id = $2
          AND payment_status = 'paid'
      `, [refundStatus, paymentIntentId]);
      console.log(`[Webhook] Updated booking payment status to '${refundStatus}' for PaymentIntent ${paymentIntentId}`);
    } catch (error) {
      console.error(`[Webhook] Error updating refund status for charge ${charge.id}:`, error);
    }
  }
  app3.get("/api/manager/revenue/overview", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const managerId = req.neonUser.id;
      const { startDate, endDate, locationId, syncPayments } = req.query;
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      if (syncPayments === "true") {
        try {
          const { syncManagerPayments: syncManagerPayments2 } = await Promise.resolve().then(() => (init_payment_tracking_service(), payment_tracking_service_exports));
          await syncManagerPayments2(managerId, pool);
          console.log(`[Revenue] Synced payments for manager ${managerId} before calculating metrics`);
        } catch (syncError) {
          console.warn(`[Revenue] Payment sync failed (continuing anyway):`, syncError.message);
        }
      }
      const { getCompleteRevenueMetrics: getCompleteRevenueMetrics2 } = await Promise.resolve().then(() => (init_revenue_service(), revenue_service_exports));
      const metrics = await getCompleteRevenueMetrics2(
        managerId,
        pool,
        startDate ? new Date(startDate) : void 0,
        endDate ? new Date(endDate) : void 0,
        locationId ? parseInt(locationId) : void 0
      );
      if (!metrics) {
        console.error(`[Revenue] getCompleteRevenueMetrics returned null/undefined for manager ${managerId}`);
        return res.status(500).json({ error: "Failed to calculate revenue metrics" });
      }
      console.log(`[Revenue] Metrics for manager ${managerId}:`, {
        totalRevenue: metrics.totalRevenue,
        managerRevenue: metrics.managerRevenue,
        bookingCount: metrics.bookingCount,
        completedPayments: metrics.completedPayments,
        pendingPayments: metrics.pendingPayments
      });
      res.json({
        totalRevenue: metrics.totalRevenue / 100,
        platformFee: metrics.platformFee / 100,
        managerRevenue: metrics.managerRevenue / 100,
        depositedManagerRevenue: (metrics.depositedManagerRevenue || 0) / 100,
        // Only succeeded transactions
        pendingPayments: metrics.pendingPayments / 100,
        completedPayments: metrics.completedPayments / 100,
        averageBookingValue: metrics.averageBookingValue / 100,
        bookingCount: metrics.bookingCount,
        paidBookingCount: metrics.paidBookingCount,
        cancelledBookingCount: metrics.cancelledBookingCount,
        refundedAmount: metrics.refundedAmount / 100,
        // Include raw values in cents for precise calculations
        _raw: {
          totalRevenue: metrics.totalRevenue,
          platformFee: metrics.platformFee,
          managerRevenue: metrics.managerRevenue,
          depositedManagerRevenue: metrics.depositedManagerRevenue || 0
        }
      });
    } catch (error) {
      console.error("Error getting revenue overview:", error);
      res.status(500).json({ error: error.message || "Failed to get revenue overview" });
    }
  });
  app3.get("/api/manager/revenue/by-location", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const managerId = req.neonUser.id;
      const { startDate, endDate } = req.query;
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      let revenueByLocation;
      try {
        const { getRevenueByLocationFromTransactions: getRevenueByLocationFromTransactions2 } = await Promise.resolve().then(() => (init_revenue_service_v2(), revenue_service_v2_exports));
        revenueByLocation = await getRevenueByLocationFromTransactions2(
          managerId,
          pool,
          startDate ? new Date(startDate) : void 0,
          endDate ? new Date(endDate) : void 0
        );
      } catch (error) {
        console.warn("[Revenue] Falling back to legacy getRevenueByLocation:", error);
        const { getRevenueByLocation: getRevenueByLocation2 } = await Promise.resolve().then(() => (init_revenue_service(), revenue_service_exports));
        revenueByLocation = await getRevenueByLocation2(
          managerId,
          pool,
          startDate ? new Date(startDate) : void 0,
          endDate ? new Date(endDate) : void 0
        );
      }
      res.json(revenueByLocation.map((loc) => ({
        ...loc,
        totalRevenue: loc.totalRevenue / 100,
        platformFee: loc.platformFee / 100,
        managerRevenue: loc.managerRevenue / 100,
        _raw: {
          totalRevenue: loc.totalRevenue,
          platformFee: loc.platformFee,
          managerRevenue: loc.managerRevenue
        }
      })));
    } catch (error) {
      console.error("Error getting revenue by location:", error);
      res.status(500).json({ error: error.message || "Failed to get revenue by location" });
    }
  });
  app3.post("/api/manager/revenue/sync-payments", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const managerId = req.neonUser.id;
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const { syncManagerPayments: syncManagerPayments2 } = await Promise.resolve().then(() => (init_payment_tracking_service(), payment_tracking_service_exports));
      const result = await syncManagerPayments2(managerId, pool);
      res.json({
        success: true,
        synced: result.synced,
        updated: result.updated,
        errors: result.errors,
        message: `Synced ${result.synced} payments: ${result.updated} updated, ${result.errors} errors`
      });
    } catch (error) {
      console.error("Error syncing payments:", error);
      res.status(500).json({ error: error.message || "Failed to sync payments" });
    }
  });
  app3.get("/api/manager/payments/booking/:bookingId/status", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const bookingId = parseInt(req.params.bookingId);
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const bookingCheck = await pool.query(`
        SELECT kb.id
        FROM kitchen_bookings kb
        JOIN kitchens k ON kb.kitchen_id = k.id
        JOIN locations l ON k.location_id = l.id
        WHERE kb.id = $1 AND l.manager_id = $2
      `, [bookingId, req.neonUser.id]);
      if (bookingCheck.rows.length === 0) {
        return res.status(404).json({ error: "Booking not found or access denied" });
      }
      const { getPaymentStatus: getPaymentStatus2 } = await Promise.resolve().then(() => (init_payment_tracking_service(), payment_tracking_service_exports));
      const status = await getPaymentStatus2(bookingId, pool);
      res.json(status);
    } catch (error) {
      console.error("Error getting payment status:", error);
      res.status(500).json({ error: error.message || "Failed to get payment status" });
    }
  });
  app3.post("/api/manager/payments/booking/:bookingId/sync", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const bookingId = parseInt(req.params.bookingId);
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const bookingCheck = await pool.query(`
        SELECT kb.id
        FROM kitchen_bookings kb
        JOIN kitchens k ON kb.kitchen_id = k.id
        JOIN locations l ON k.location_id = l.id
        WHERE kb.id = $1 AND l.manager_id = $2
      `, [bookingId, req.neonUser.id]);
      if (bookingCheck.rows.length === 0) {
        return res.status(404).json({ error: "Booking not found or access denied" });
      }
      const { syncPaymentStatusFromStripe: syncPaymentStatusFromStripe2 } = await Promise.resolve().then(() => (init_payment_tracking_service(), payment_tracking_service_exports));
      const result = await syncPaymentStatusFromStripe2(bookingId, pool);
      res.json(result);
    } catch (error) {
      console.error("Error syncing payment status:", error);
      res.status(500).json({ error: error.message || "Failed to sync payment status" });
    }
  });
  app3.post("/api/manager/payments/booking/:bookingId/recover", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const bookingId = parseInt(req.params.bookingId);
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const bookingCheck = await pool.query(`
        SELECT kb.id
        FROM kitchen_bookings kb
        JOIN kitchens k ON kb.kitchen_id = k.id
        JOIN locations l ON k.location_id = l.id
        WHERE kb.id = $1 AND l.manager_id = $2
      `, [bookingId, req.neonUser.id]);
      if (bookingCheck.rows.length === 0) {
        return res.status(404).json({ error: "Booking not found or access denied" });
      }
      const { recoverMissingPaymentData: recoverMissingPaymentData2 } = await Promise.resolve().then(() => (init_payment_tracking_service(), payment_tracking_service_exports));
      const result = await recoverMissingPaymentData2(bookingId, pool);
      res.json(result);
    } catch (error) {
      console.error("Error recovering payment data:", error);
      res.status(500).json({ error: error.message || "Failed to recover payment data" });
    }
  });
  app3.get("/api/manager/revenue/charts", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const managerId = req.neonUser.id;
      const { startDate, endDate, locationId, period = "daily" } = req.query;
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const end = endDate ? new Date(endDate) : /* @__PURE__ */ new Date();
      const start = startDate ? new Date(startDate) : (() => {
        const d = /* @__PURE__ */ new Date();
        d.setDate(d.getDate() - 30);
        return d;
      })();
      let revenueByDate;
      try {
        const { getRevenueByDateFromTransactions: getRevenueByDateFromTransactions2 } = await Promise.resolve().then(() => (init_revenue_service_v2(), revenue_service_v2_exports));
        revenueByDate = await getRevenueByDateFromTransactions2(
          managerId,
          pool,
          start,
          end
        );
      } catch (error) {
        console.warn("[Revenue] Falling back to legacy getRevenueByDate:", error);
        const { getRevenueByDate: getRevenueByDate2 } = await Promise.resolve().then(() => (init_revenue_service(), revenue_service_exports));
        revenueByDate = await getRevenueByDate2(
          managerId,
          pool,
          start,
          end
        );
      }
      res.json({
        period,
        data: revenueByDate.map((item) => ({
          date: item.date,
          totalRevenue: item.totalRevenue / 100,
          platformFee: item.platformFee / 100,
          managerRevenue: item.managerRevenue / 100,
          bookingCount: item.bookingCount,
          _raw: {
            totalRevenue: item.totalRevenue,
            platformFee: item.platformFee,
            managerRevenue: item.managerRevenue
          }
        }))
      });
    } catch (error) {
      console.error("Error getting revenue chart data:", error);
      res.status(500).json({ error: error.message || "Failed to get revenue chart data" });
    }
  });
  app3.get("/api/manager/revenue/transactions", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const managerId = req.neonUser.id;
      const { startDate, endDate, locationId, limit = "100", offset = "0", paymentStatus } = req.query;
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      let transactions = [];
      let usePaymentTransactions = false;
      try {
        const { getManagerPaymentTransactions: getManagerPaymentTransactions2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
        const result = await getManagerPaymentTransactions2(managerId, pool, {
          startDate: startDate ? new Date(startDate) : void 0,
          endDate: endDate ? new Date(endDate) : void 0,
          limit: parseInt(limit),
          offset: parseInt(offset)
        });
        if (result.transactions.length > 0 || paymentStatus) {
          usePaymentTransactions = true;
          transactions = result.transactions.map((pt) => {
            return {
              id: pt.booking_id,
              bookingType: pt.booking_type,
              totalPrice: parseInt(pt.amount),
              serviceFee: parseInt(pt.service_fee),
              managerRevenue: parseInt(pt.manager_revenue),
              paymentStatus: pt.status === "succeeded" ? "paid" : pt.status === "pending" ? "pending" : pt.status === "failed" ? "failed" : pt.status,
              paymentIntentId: pt.payment_intent_id,
              currency: pt.currency,
              createdAt: pt.created_at,
              paidAt: pt.paid_at
            };
          });
          if (transactions.length > 0) {
            const bookingIds = transactions.map((t) => t.id);
            const bookingDetails = await pool.query(`
              SELECT 
                kb.id,
                kb.booking_date,
                kb.start_time,
                kb.end_time,
                kb.status,
                k.name as kitchen_name,
                l.id as location_id,
                l.name as location_name,
                u.username as chef_name,
                u.username as chef_email
              FROM kitchen_bookings kb
              JOIN kitchens k ON kb.kitchen_id = k.id
              JOIN locations l ON k.location_id = l.id
              LEFT JOIN users u ON kb.chef_id = u.id
              WHERE kb.id = ANY($1)
            `, [bookingIds]);
            const detailsMap = new Map(bookingDetails.rows.map((b) => [b.id, b]));
            transactions = transactions.map((t) => ({
              ...t,
              bookingDate: detailsMap.get(t.id)?.booking_date,
              startTime: detailsMap.get(t.id)?.start_time,
              endTime: detailsMap.get(t.id)?.end_time,
              status: detailsMap.get(t.id)?.status,
              kitchenName: detailsMap.get(t.id)?.kitchen_name,
              locationId: detailsMap.get(t.id)?.location_id,
              locationName: detailsMap.get(t.id)?.location_name,
              chefName: detailsMap.get(t.id)?.chef_name || "Guest",
              chefEmail: detailsMap.get(t.id)?.chef_email
            }));
          }
          console.log(`[Revenue] Using payment_transactions for transaction history: ${transactions.length} transactions`);
        }
      } catch (error) {
        console.warn("[Revenue] Error using payment_transactions, falling back to legacy method:", error);
        usePaymentTransactions = false;
      }
      if (!usePaymentTransactions) {
        console.log("[Revenue] Using legacy getTransactionHistory method");
        const { getTransactionHistory: getTransactionHistory2 } = await Promise.resolve().then(() => (init_revenue_service(), revenue_service_exports));
        transactions = await getTransactionHistory2(
          managerId,
          pool,
          startDate ? new Date(startDate) : void 0,
          endDate ? new Date(endDate) : void 0,
          locationId ? parseInt(locationId) : void 0,
          parseInt(limit),
          parseInt(offset)
        );
      }
      if (paymentStatus) {
        transactions = transactions.filter((t) => t.paymentStatus === paymentStatus);
      }
      console.log(`[Revenue] Transaction history for manager ${managerId}: ${transactions.length} transactions`, {
        usedPaymentTransactions: usePaymentTransactions,
        dateRange: { startDate, endDate },
        locationId,
        paymentStatusFilter: paymentStatus
      });
      res.json({
        transactions: transactions.map((t) => ({
          ...t,
          totalPrice: t.totalPrice / 100,
          serviceFee: t.serviceFee / 100,
          managerRevenue: t.managerRevenue / 100,
          _raw: {
            totalPrice: t.totalPrice,
            serviceFee: t.serviceFee,
            managerRevenue: t.managerRevenue
          }
        })),
        total: transactions.length
      });
    } catch (error) {
      console.error("Error getting transaction history:", error);
      res.status(500).json({ error: error.message || "Failed to get transaction history" });
    }
  });
  app3.get("/api/manager/revenue/invoices", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const managerId = req.neonUser.id;
      const { startDate, endDate, locationId, limit = "50", offset = "0" } = req.query;
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      let whereClause = `
        WHERE l.manager_id = $1
        AND kb.status != 'cancelled'
        AND kb.payment_status = 'paid'
        AND (kb.total_price IS NOT NULL OR kb.payment_intent_id IS NOT NULL)
      `;
      const params = [managerId];
      let paramIndex = 2;
      if (startDate) {
        const start = typeof startDate === "string" ? startDate : Array.isArray(startDate) ? startDate[0] : String(startDate);
        whereClause += ` AND (DATE(kb.booking_date) >= $${paramIndex}::date OR DATE(kb.created_at) >= $${paramIndex}::date)`;
        params.push(start);
        paramIndex++;
      }
      if (endDate) {
        const end = typeof endDate === "string" ? endDate : Array.isArray(endDate) ? endDate[0] : String(endDate);
        whereClause += ` AND (DATE(kb.booking_date) <= $${paramIndex}::date OR DATE(kb.created_at) <= $${paramIndex}::date)`;
        params.push(end);
        paramIndex++;
      }
      if (locationId) {
        whereClause += ` AND l.id = $${paramIndex}`;
        params.push(parseInt(locationId));
        paramIndex++;
      }
      const result = await pool.query(`
        SELECT 
          kb.id,
          kb.booking_date,
          kb.start_time,
          kb.end_time,
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::bigint as total_price,
          COALESCE(kb.service_fee, 0)::bigint as service_fee,
          kb.payment_status,
          kb.payment_intent_id,
          kb.currency,
          k.name as kitchen_name,
          l.name as location_name,
          u.username as chef_name,
          u.username as chef_email,
          kb.created_at
        FROM kitchen_bookings kb
        JOIN kitchens k ON kb.kitchen_id = k.id
        JOIN locations l ON k.location_id = l.id
        LEFT JOIN users u ON kb.chef_id = u.id
        ${whereClause}
        ORDER BY kb.created_at DESC, kb.booking_date DESC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `, [...params, parseInt(limit), parseInt(offset)]);
      console.log(`[Revenue] Invoices query for manager ${managerId}: Found ${result.rows.length} invoices`);
      res.json({
        invoices: result.rows.map((row) => {
          const totalPriceCents = row.total_price != null ? parseInt(String(row.total_price)) : 0;
          const serviceFeeCents = row.service_fee != null ? parseInt(String(row.service_fee)) : 0;
          return {
            bookingId: row.id,
            bookingDate: row.booking_date,
            startTime: row.start_time,
            endTime: row.end_time,
            totalPrice: totalPriceCents / 100,
            serviceFee: serviceFeeCents / 100,
            paymentStatus: row.payment_status,
            paymentIntentId: row.payment_intent_id,
            currency: row.currency || "CAD",
            kitchenName: row.kitchen_name,
            locationName: row.location_name,
            chefName: row.chef_name || "Guest",
            chefEmail: row.chef_email,
            createdAt: row.created_at
          };
        }),
        total: result.rows.length
      });
    } catch (error) {
      console.error("Error getting invoices:", error);
      res.status(500).json({ error: error.message || "Failed to get invoices" });
    }
  });
  app3.get("/api/manager/revenue/invoices/:bookingId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const managerId = req.neonUser.id;
      const bookingId = parseInt(req.params.bookingId);
      if (isNaN(bookingId) || bookingId <= 0) {
        return res.status(400).json({ error: "Invalid booking ID" });
      }
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const bookingResult = await pool.query(`
        SELECT kb.*, k.name as kitchen_name, l.name as location_name, l.manager_id
        FROM kitchen_bookings kb
        JOIN kitchens k ON kb.kitchen_id = k.id
        JOIN locations l ON k.location_id = l.id
        WHERE kb.id = $1
      `, [bookingId]);
      if (bookingResult.rows.length === 0) {
        return res.status(404).json({ error: "Booking not found" });
      }
      const booking = bookingResult.rows[0];
      if (booking.manager_id !== managerId) {
        return res.status(403).json({ error: "Access denied to this booking" });
      }
      if (booking.status === "cancelled" && !booking.payment_intent_id && !booking.total_price) {
        return res.status(400).json({ error: "Invoice cannot be downloaded for cancelled bookings without payment information" });
      }
      let chef = null;
      if (booking.chef_id) {
        const chefResult = await pool.query("SELECT id, username FROM users WHERE id = $1", [booking.chef_id]);
        chef = chefResult.rows[0] || null;
      }
      const storageResult = await pool.query(`
        SELECT sb.*, sl.name as storage_name
        FROM storage_bookings sb
        JOIN storage_listings sl ON sb.storage_listing_id = sl.id
        WHERE sb.kitchen_booking_id = $1
      `, [bookingId]);
      const equipmentResult = await pool.query(`
        SELECT eb.*, el.equipment_type, el.brand, el.model
        FROM equipment_bookings eb
        JOIN equipment_listings el ON eb.equipment_listing_id = el.id
        WHERE eb.kitchen_booking_id = $1
      `, [bookingId]);
      const { generateInvoicePDF: generateInvoicePDF2 } = await Promise.resolve().then(() => (init_invoice_service(), invoice_service_exports));
      const pdfBuffer = await generateInvoicePDF2(
        booking,
        chef,
        { name: booking.kitchen_name },
        { name: booking.location_name },
        storageResult.rows,
        equipmentResult.rows,
        booking.payment_intent_id,
        pool
      );
      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Content-Disposition", `attachment; filename="invoice-${bookingId}.pdf"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error("Error generating invoice PDF:", error);
      res.status(500).json({ error: error.message || "Failed to generate invoice" });
    }
  });
  app3.get("/api/manager/revenue/payouts", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const managerId = req.neonUser.id;
      const { limit = "50" } = req.query;
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const userResult = await pool.query(
        "SELECT stripe_connect_account_id FROM users WHERE id = $1",
        [managerId]
      );
      if (!userResult.rows[0]?.stripe_connect_account_id) {
        return res.json({
          payouts: [],
          total: 0,
          message: "No Stripe Connect account linked"
        });
      }
      const accountId = userResult.rows[0].stripe_connect_account_id;
      const { getPayouts: getPayouts2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
      const payouts = await getPayouts2(accountId, parseInt(limit));
      res.json({
        payouts: payouts.map((p) => ({
          id: p.id,
          amount: p.amount / 100,
          // Convert cents to dollars
          currency: p.currency,
          status: p.status,
          arrivalDate: new Date(p.arrival_date * 1e3).toISOString(),
          created: new Date(p.created * 1e3).toISOString(),
          description: p.description,
          method: p.method,
          type: p.type
        })),
        total: payouts.length
      });
    } catch (error) {
      console.error("Error getting payouts:", error);
      res.status(500).json({ error: error.message || "Failed to get payouts" });
    }
  });
  app3.get("/api/manager/revenue/payouts/:payoutId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const managerId = req.neonUser.id;
      const payoutId = req.params.payoutId;
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const userResult = await pool.query(
        "SELECT stripe_connect_account_id FROM users WHERE id = $1",
        [managerId]
      );
      if (!userResult.rows[0]?.stripe_connect_account_id) {
        return res.status(404).json({ error: "No Stripe Connect account linked" });
      }
      const accountId = userResult.rows[0].stripe_connect_account_id;
      const { getPayout: getPayout2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
      const payout = await getPayout2(accountId, payoutId);
      if (!payout) {
        return res.status(404).json({ error: "Payout not found" });
      }
      const payoutDate = new Date(payout.created * 1e3);
      const periodStart = new Date(payoutDate);
      periodStart.setDate(periodStart.getDate() - 7);
      const { getBalanceTransactions: getBalanceTransactions2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
      const transactions = await getBalanceTransactions2(
        accountId,
        periodStart,
        payoutDate,
        100
      );
      const bookingsResult = await pool.query(`
        SELECT 
          kb.id,
          kb.booking_date,
          kb.start_time,
          kb.end_time,
          kb.total_price,
          kb.service_fee,
          kb.payment_status,
          kb.payment_intent_id,
          k.name as kitchen_name,
          l.name as location_name,
          u.username as chef_name,
          u.email as chef_email
        FROM kitchen_bookings kb
        JOIN kitchens k ON kb.kitchen_id = k.id
        JOIN locations l ON k.location_id = l.id
        LEFT JOIN users u ON kb.chef_id = u.id
        WHERE l.manager_id = $1
          AND kb.payment_status = 'paid'
          AND kb.booking_date >= $2::date
          AND kb.booking_date <= $3::date
        ORDER BY kb.booking_date DESC
      `, [managerId, periodStart.toISOString().split("T")[0], payoutDate.toISOString().split("T")[0]]);
      res.json({
        payout: {
          id: payout.id,
          amount: payout.amount / 100,
          currency: payout.currency,
          status: payout.status,
          arrivalDate: new Date(payout.arrival_date * 1e3).toISOString(),
          created: new Date(payout.created * 1e3).toISOString(),
          description: payout.description,
          method: payout.method,
          type: payout.type
        },
        transactions: transactions.map((t) => ({
          id: t.id,
          amount: t.amount / 100,
          currency: t.currency,
          description: t.description,
          fee: t.fee / 100,
          net: t.net / 100,
          status: t.status,
          type: t.type,
          created: new Date(t.created * 1e3).toISOString()
        })),
        bookings: bookingsResult.rows.map((row) => ({
          id: row.id,
          bookingDate: row.booking_date,
          startTime: row.start_time,
          endTime: row.end_time,
          totalPrice: (parseInt(row.total_price) || 0) / 100,
          serviceFee: (parseInt(row.service_fee) || 0) / 100,
          paymentStatus: row.payment_status,
          paymentIntentId: row.payment_intent_id,
          kitchenName: row.kitchen_name,
          locationName: row.location_name,
          chefName: row.chef_name || "Guest",
          chefEmail: row.chef_email
        }))
      });
    } catch (error) {
      console.error("Error getting payout details:", error);
      res.status(500).json({ error: error.message || "Failed to get payout details" });
    }
  });
  app3.get("/api/manager/revenue/payouts/:payoutId/statement", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const managerId = req.neonUser.id;
      const payoutId = req.params.payoutId;
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const userResult = await pool.query(
        "SELECT id, username, stripe_connect_account_id FROM users WHERE id = $1",
        [managerId]
      );
      if (!userResult.rows[0]?.stripe_connect_account_id) {
        return res.status(404).json({ error: "No Stripe Connect account linked" });
      }
      const manager = userResult.rows[0];
      const accountId = manager.stripe_connect_account_id;
      const { getPayout: getPayout2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
      const payout = await getPayout2(accountId, payoutId);
      if (!payout) {
        return res.status(404).json({ error: "Payout not found" });
      }
      const payoutDate = new Date(payout.created * 1e3);
      const periodStart = new Date(payoutDate);
      periodStart.setDate(periodStart.getDate() - 7);
      const bookingsResult = await pool.query(`
        SELECT 
          kb.id,
          kb.booking_date,
          kb.start_time,
          kb.end_time,
          kb.total_price,
          kb.service_fee,
          kb.payment_status,
          kb.payment_intent_id,
          k.name as kitchen_name,
          l.name as location_name,
          u.username as chef_name,
          u.email as chef_email
        FROM kitchen_bookings kb
        JOIN kitchens k ON kb.kitchen_id = k.id
        JOIN locations l ON k.location_id = l.id
        LEFT JOIN users u ON kb.chef_id = u.id
        WHERE l.manager_id = $1
          AND kb.payment_status = 'paid'
          AND kb.booking_date >= $2::date
          AND kb.booking_date <= $3::date
        ORDER BY kb.booking_date DESC
      `, [managerId, periodStart.toISOString().split("T")[0], payoutDate.toISOString().split("T")[0]]);
      const { getBalanceTransactions: getBalanceTransactions2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
      const transactions = await getBalanceTransactions2(
        accountId,
        periodStart,
        payoutDate,
        100
      );
      const { generatePayoutStatementPDF: generatePayoutStatementPDF2 } = await Promise.resolve().then(() => (init_payout_statement_service(), payout_statement_service_exports));
      const pdfBuffer = await generatePayoutStatementPDF2(
        managerId,
        manager.username || "Manager",
        manager.email || "",
        payout,
        transactions,
        bookingsResult.rows,
        pool
      );
      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Content-Disposition", `attachment; filename="payout-statement-${payoutId.substring(3)}.pdf"`);
      res.send(pdfBuffer);
    } catch (error) {
      console.error("Error generating payout statement PDF:", error);
      res.status(500).json({ error: error.message || "Failed to generate payout statement" });
    }
  });
  app3.get("/api/manager/kitchens/:locationId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const locationId = parseInt(req.params.locationId);
      if (isNaN(locationId) || locationId <= 0) {
        return res.status(400).json({ error: "Invalid location ID" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this location" });
      }
      const kitchens2 = await firebaseStorage.getKitchensByLocation(locationId);
      res.json(kitchens2);
    } catch (error) {
      console.error("Error fetching kitchens:", error);
      res.status(500).json({ error: error.message || "Failed to fetch kitchens" });
    }
  });
  app3.post("/api/manager/kitchens", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const { locationId, name, description } = req.body;
      if (!locationId || !name) {
        return res.status(400).json({ error: "Location ID and name are required" });
      }
      const locationIdNum = parseInt(locationId.toString());
      if (isNaN(locationIdNum) || locationIdNum <= 0) {
        return res.status(400).json({ error: "Invalid location ID format" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === locationIdNum);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this location" });
      }
      const location = await firebaseStorage.getLocationById(locationIdNum);
      if (!location) {
        return res.status(400).json({ error: `Location with ID ${locationIdNum} does not exist` });
      }
      const kitchen = await firebaseStorage.createKitchen({
        locationId: locationIdNum,
        name,
        description: description || void 0,
        isActive: true
      });
      console.log(`\u2705 Kitchen created by manager ${user.id} for location ${locationIdNum}`);
      res.status(201).json(kitchen);
    } catch (error) {
      console.error("Error creating kitchen:", error);
      console.error("Error details:", error.message, error.stack);
      if (error.code === "23503") {
        return res.status(400).json({ error: "The selected location does not exist or is invalid." });
      } else if (error.code === "23505") {
        return res.status(400).json({ error: "A kitchen with this name already exists in this location." });
      }
      res.status(500).json({ error: error.message || "Failed to create kitchen" });
    }
  });
  app3.put("/api/manager/kitchens/:kitchenId/image", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const kitchenId = parseInt(req.params.kitchenId);
      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      const kitchen = await firebaseStorage.getKitchenById(kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this kitchen" });
      }
      const { imageUrl } = req.body;
      if (!imageUrl && kitchen.imageUrl) {
        try {
          const { deleteFromR2: deleteFromR22 } = await Promise.resolve().then(() => (init_r2_storage(), r2_storage_exports));
          const { isR2Configured: isR2Configured2 } = await Promise.resolve().then(() => (init_r2_storage(), r2_storage_exports));
          const isProduction2 = process.env.NODE_ENV === "production";
          if (isProduction2 && isR2Configured2()) {
            await deleteFromR22(kitchen.imageUrl);
            console.log(`\u{1F5D1}\uFE0F Deleted kitchen image from R2: ${kitchen.imageUrl}`);
          }
        } catch (error) {
          console.error("Error deleting image from R2:", error);
        }
      }
      const updated = await firebaseStorage.updateKitchen(kitchenId, { imageUrl: imageUrl || null });
      console.log(`\u2705 Kitchen ${kitchenId} image updated by manager ${user.id}`);
      res.json(updated);
    } catch (error) {
      console.error("Error updating kitchen image:", error);
      res.status(500).json({ error: error.message || "Failed to update kitchen image" });
    }
  });
  app3.put("/api/manager/kitchens/:kitchenId/gallery", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const kitchenId = parseInt(req.params.kitchenId);
      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      const kitchen = await firebaseStorage.getKitchenById(kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this kitchen" });
      }
      const { galleryImages } = req.body;
      if (galleryImages !== void 0 && !Array.isArray(galleryImages)) {
        return res.status(400).json({ error: "galleryImages must be an array" });
      }
      if (galleryImages && Array.isArray(galleryImages) && kitchen.galleryImages && Array.isArray(kitchen.galleryImages)) {
        const removedImages = kitchen.galleryImages.filter((img) => !galleryImages.includes(img));
        if (removedImages.length > 0) {
          try {
            const { deleteFromR2: deleteFromR22 } = await Promise.resolve().then(() => (init_r2_storage(), r2_storage_exports));
            const { isR2Configured: isR2Configured2 } = await Promise.resolve().then(() => (init_r2_storage(), r2_storage_exports));
            const isProduction2 = process.env.NODE_ENV === "production";
            if (isProduction2 && isR2Configured2()) {
              for (const imageUrl of removedImages) {
                await deleteFromR22(imageUrl);
                console.log(`\u{1F5D1}\uFE0F Deleted gallery image from R2: ${imageUrl}`);
              }
            }
          } catch (error) {
            console.error("Error deleting gallery images from R2:", error);
          }
        }
      }
      const updated = await firebaseStorage.updateKitchen(kitchenId, { galleryImages: galleryImages || [] });
      console.log(`\u2705 Kitchen ${kitchenId} gallery images updated by manager ${user.id}`);
      res.json(updated);
    } catch (error) {
      console.error("Error updating kitchen gallery images:", error);
      res.status(500).json({ error: error.message || "Failed to update kitchen gallery images" });
    }
  });
  app3.delete("/api/manager/files", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const { fileUrl } = req.body;
      if (!fileUrl || typeof fileUrl !== "string") {
        return res.status(400).json({ error: "fileUrl is required and must be a string" });
      }
      try {
        const { deleteFromR2: deleteFromR22, isR2Configured: isR2Configured2 } = await Promise.resolve().then(() => (init_r2_storage(), r2_storage_exports));
        const isProduction2 = process.env.NODE_ENV === "production";
        const r2Configured = isR2Configured2();
        if (!r2Configured) {
          console.error("\u274C R2 not configured. Required env vars:", {
            hasAccountId: !!process.env.CLOUDFLARE_ACCOUNT_ID,
            hasAccessKey: !!process.env.CLOUDFLARE_R2_ACCESS_KEY_ID,
            hasSecretKey: !!process.env.CLOUDFLARE_R2_SECRET_ACCESS_KEY,
            hasBucketName: !!process.env.CLOUDFLARE_R2_BUCKET_NAME
          });
          return res.status(500).json({
            error: "R2 storage not configured",
            message: "Cloudflare R2 is not properly configured. Please check environment variables."
          });
        }
        if (isProduction2 || process.env.ALLOW_R2_DELETE_IN_DEV === "true") {
          const deleted = await deleteFromR22(fileUrl);
          if (deleted) {
            console.log(`\u2705 File deleted from R2 by manager ${user.id}: ${fileUrl}`);
            return res.json({ success: true, message: "File deleted successfully" });
          } else {
            console.error(`\u274C Failed to delete file from R2: ${fileUrl}`);
            return res.status(500).json({
              error: "Failed to delete file from R2",
              message: "The file could not be deleted from R2 storage. Check server logs for details."
            });
          }
        } else {
          console.log(`\u{1F4BB} Development mode: File deletion skipped for ${fileUrl}. Set ALLOW_R2_DELETE_IN_DEV=true to enable.`);
          return res.json({ success: true, message: "File deletion skipped (development mode)" });
        }
      } catch (error) {
        console.error("\u274C Error deleting file from R2:", {
          error: error.message,
          fileUrl,
          stack: error.stack
        });
        return res.status(500).json({
          error: error.message || "Failed to delete file",
          message: "An error occurred while deleting the file. Check server logs for details."
        });
      }
    } catch (error) {
      console.error("Error in delete file endpoint:", error);
      res.status(500).json({ error: error.message || "Failed to delete file" });
    }
  });
  app3.put("/api/manager/kitchens/:kitchenId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const kitchenId = parseInt(req.params.kitchenId);
      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      const kitchen = await firebaseStorage.getKitchenById(kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this kitchen" });
      }
      const { name, description } = req.body;
      const updates = {};
      if (name !== void 0) updates.name = name;
      if (description !== void 0) updates.description = description || null;
      const updated = await firebaseStorage.updateKitchen(kitchenId, updates);
      console.log(`\u2705 Kitchen ${kitchenId} details updated by manager ${user.id}`);
      res.json(updated);
    } catch (error) {
      console.error("Error updating kitchen details:", error);
      res.status(500).json({ error: error.message || "Failed to update kitchen details" });
    }
  });
  app3.get("/api/manager/kitchens/:kitchenId/pricing", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const kitchenId = parseInt(req.params.kitchenId);
      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      const kitchen = await firebaseStorage.getKitchenById(kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this kitchen" });
      }
      const pricing = await firebaseStorage.getKitchenPricing(kitchenId);
      if (!pricing) {
        return res.status(404).json({ error: "Pricing not found" });
      }
      res.json(pricing);
    } catch (error) {
      console.error("Error getting kitchen pricing:", error);
      res.status(500).json({ error: error.message || "Failed to get kitchen pricing" });
    }
  });
  app3.put("/api/manager/kitchens/:kitchenId/pricing", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const kitchenId = parseInt(req.params.kitchenId);
      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      const kitchen = await firebaseStorage.getKitchenById(kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this kitchen" });
      }
      const { hourlyRate, currency, minimumBookingHours, pricingModel } = req.body;
      if (hourlyRate !== void 0 && hourlyRate !== null && (typeof hourlyRate !== "number" || hourlyRate < 0)) {
        return res.status(400).json({ error: "Hourly rate must be a positive number or null" });
      }
      if (currency !== void 0 && typeof currency !== "string") {
        return res.status(400).json({ error: "Currency must be a string" });
      }
      if (minimumBookingHours !== void 0 && (typeof minimumBookingHours !== "number" || minimumBookingHours < 1)) {
        return res.status(400).json({ error: "Minimum booking hours must be at least 1" });
      }
      if (pricingModel !== void 0 && !["hourly", "daily", "weekly"].includes(pricingModel)) {
        return res.status(400).json({ error: "Pricing model must be 'hourly', 'daily', or 'weekly'" });
      }
      const pricing = {};
      if (hourlyRate !== void 0) {
        pricing.hourlyRate = hourlyRate === null ? null : hourlyRate;
      }
      if (currency !== void 0) pricing.currency = currency;
      if (minimumBookingHours !== void 0) pricing.minimumBookingHours = minimumBookingHours;
      if (pricingModel !== void 0) pricing.pricingModel = pricingModel;
      const updated = await firebaseStorage.updateKitchenPricing(kitchenId, pricing);
      console.log(`\u2705 Kitchen ${kitchenId} pricing updated by manager ${user.id}`);
      res.json(updated);
    } catch (error) {
      console.error("Error updating kitchen pricing:", error);
      res.status(500).json({ error: error.message || "Failed to update kitchen pricing" });
    }
  });
  app3.get("/api/manager/kitchens/:kitchenId/storage-listings", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const kitchenId = parseInt(req.params.kitchenId);
      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      const kitchen = await firebaseStorage.getKitchenById(kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this kitchen" });
      }
      const listings = await firebaseStorage.getStorageListingsByKitchen(kitchenId);
      res.json(listings);
    } catch (error) {
      console.error("Error getting storage listings:", error);
      res.status(500).json({ error: error.message || "Failed to get storage listings" });
    }
  });
  app3.get("/api/manager/storage-listings/:listingId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const listingId = parseInt(req.params.listingId);
      if (isNaN(listingId) || listingId <= 0) {
        return res.status(400).json({ error: "Invalid listing ID" });
      }
      const listing = await firebaseStorage.getStorageListingById(listingId);
      if (!listing) {
        return res.status(404).json({ error: "Storage listing not found" });
      }
      const kitchen = await firebaseStorage.getKitchenById(listing.kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this listing" });
      }
      res.json(listing);
    } catch (error) {
      console.error("Error getting storage listing:", error);
      res.status(500).json({ error: error.message || "Failed to get storage listing" });
    }
  });
  app3.post("/api/manager/storage-listings", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const { kitchenId, ...listingData } = req.body;
      if (!kitchenId || isNaN(parseInt(kitchenId))) {
        return res.status(400).json({ error: "Valid kitchen ID is required" });
      }
      const kitchen = await firebaseStorage.getKitchenById(parseInt(kitchenId));
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this kitchen" });
      }
      if (!listingData.name || !listingData.storageType || !listingData.pricingModel || !listingData.basePrice) {
        return res.status(400).json({ error: "Name, storage type, pricing model, and base price are required" });
      }
      const created = await firebaseStorage.createStorageListing({
        kitchenId: parseInt(kitchenId),
        ...listingData
      });
      console.log(`\u2705 Storage listing created by manager ${user.id}`);
      res.status(201).json(created);
    } catch (error) {
      console.error("Error creating storage listing:", error);
      res.status(500).json({ error: error.message || "Failed to create storage listing" });
    }
  });
  app3.put("/api/manager/storage-listings/:listingId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const listingId = parseInt(req.params.listingId);
      if (isNaN(listingId) || listingId <= 0) {
        return res.status(400).json({ error: "Invalid listing ID" });
      }
      const existingListing = await firebaseStorage.getStorageListingById(listingId);
      if (!existingListing) {
        return res.status(404).json({ error: "Storage listing not found" });
      }
      const kitchen = await firebaseStorage.getKitchenById(existingListing.kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this listing" });
      }
      const updated = await firebaseStorage.updateStorageListing(listingId, req.body);
      console.log(`\u2705 Storage listing ${listingId} updated by manager ${user.id}`);
      res.json(updated);
    } catch (error) {
      console.error("Error updating storage listing:", error);
      res.status(500).json({ error: error.message || "Failed to update storage listing" });
    }
  });
  app3.delete("/api/manager/storage-listings/:listingId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const listingId = parseInt(req.params.listingId);
      if (isNaN(listingId) || listingId <= 0) {
        return res.status(400).json({ error: "Invalid listing ID" });
      }
      const existingListing = await firebaseStorage.getStorageListingById(listingId);
      if (!existingListing) {
        return res.status(404).json({ error: "Storage listing not found" });
      }
      const kitchen = await firebaseStorage.getKitchenById(existingListing.kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this listing" });
      }
      await firebaseStorage.deleteStorageListing(listingId);
      console.log(`\u2705 Storage listing ${listingId} deleted by manager ${user.id}`);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting storage listing:", error);
      res.status(500).json({ error: error.message || "Failed to delete storage listing" });
    }
  });
  app3.get("/api/manager/kitchens/:kitchenId/equipment-listings", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const kitchenId = parseInt(req.params.kitchenId);
      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      const kitchen = await firebaseStorage.getKitchenById(kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this kitchen" });
      }
      const listings = await firebaseStorage.getEquipmentListingsByKitchen(kitchenId);
      res.json(listings);
    } catch (error) {
      console.error("Error getting equipment listings:", error);
      res.status(500).json({ error: error.message || "Failed to get equipment listings" });
    }
  });
  app3.get("/api/manager/equipment-listings/:listingId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const listingId = parseInt(req.params.listingId);
      if (isNaN(listingId) || listingId <= 0) {
        return res.status(400).json({ error: "Invalid listing ID" });
      }
      const listing = await firebaseStorage.getEquipmentListingById(listingId);
      if (!listing) {
        return res.status(404).json({ error: "Equipment listing not found" });
      }
      const kitchen = await firebaseStorage.getKitchenById(listing.kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this listing" });
      }
      res.json(listing);
    } catch (error) {
      console.error("Error getting equipment listing:", error);
      res.status(500).json({ error: error.message || "Failed to get equipment listing" });
    }
  });
  app3.post("/api/manager/equipment-listings", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const { kitchenId, ...listingData } = req.body;
      if (!kitchenId || isNaN(parseInt(kitchenId))) {
        return res.status(400).json({ error: "Valid kitchen ID is required" });
      }
      const kitchen = await firebaseStorage.getKitchenById(parseInt(kitchenId));
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this kitchen" });
      }
      if (!listingData.equipmentType || !listingData.category || !listingData.condition) {
        return res.status(400).json({ error: "Equipment type, category, and condition are required" });
      }
      if (!listingData.availabilityType || !["included", "rental"].includes(listingData.availabilityType)) {
        return res.status(400).json({ error: "Availability type must be 'included' or 'rental'" });
      }
      if (listingData.availabilityType === "rental") {
        if (!listingData.sessionRate || listingData.sessionRate <= 0) {
          return res.status(400).json({ error: "Session rate is required for rental equipment" });
        }
      }
      const created = await firebaseStorage.createEquipmentListing({
        kitchenId: parseInt(kitchenId),
        ...listingData
      });
      console.log(`\u2705 Equipment listing created by manager ${user.id}`);
      res.status(201).json(created);
    } catch (error) {
      console.error("Error creating equipment listing:", error);
      res.status(500).json({ error: error.message || "Failed to create equipment listing" });
    }
  });
  app3.put("/api/manager/equipment-listings/:listingId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const listingId = parseInt(req.params.listingId);
      if (isNaN(listingId) || listingId <= 0) {
        return res.status(400).json({ error: "Invalid listing ID" });
      }
      const existingListing = await firebaseStorage.getEquipmentListingById(listingId);
      if (!existingListing) {
        return res.status(404).json({ error: "Equipment listing not found" });
      }
      const kitchen = await firebaseStorage.getKitchenById(existingListing.kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this listing" });
      }
      const updated = await firebaseStorage.updateEquipmentListing(listingId, req.body);
      console.log(`\u2705 Equipment listing ${listingId} updated by manager ${user.id}`);
      res.json(updated);
    } catch (error) {
      console.error("Error updating equipment listing:", error);
      res.status(500).json({ error: error.message || "Failed to update equipment listing" });
    }
  });
  app3.delete("/api/manager/equipment-listings/:listingId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const listingId = parseInt(req.params.listingId);
      if (isNaN(listingId) || listingId <= 0) {
        return res.status(400).json({ error: "Invalid listing ID" });
      }
      const existingListing = await firebaseStorage.getEquipmentListingById(listingId);
      if (!existingListing) {
        return res.status(404).json({ error: "Equipment listing not found" });
      }
      const kitchen = await firebaseStorage.getKitchenById(existingListing.kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locations2 = await firebaseStorage.getLocationsByManager(user.id);
      const hasAccess = locations2.some((loc) => loc.id === kitchen.locationId);
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this listing" });
      }
      await firebaseStorage.deleteEquipmentListing(listingId);
      console.log(`\u2705 Equipment listing ${listingId} deleted by manager ${user.id}`);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting equipment listing:", error);
      res.status(500).json({ error: error.message || "Failed to delete equipment listing" });
    }
  });
  app3.post("/api/manager/availability", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const { kitchenId, dayOfWeek, startTime, endTime, isAvailable } = req.body;
      await firebaseStorage.setKitchenAvailability(kitchenId, { dayOfWeek, startTime, endTime, isAvailable });
      try {
        const kitchen = await firebaseStorage.getKitchenById(kitchenId);
        if (kitchen) {
          const location = await firebaseStorage.getLocationById(kitchen.locationId);
          const bookings = await firebaseStorage.getBookingsByKitchen(kitchenId);
          const uniqueChefIds = Array.from(new Set(bookings.map((b) => b.chefId)));
          for (const chefId of uniqueChefIds) {
            try {
              const chef = await storage2.getUser(chefId);
              if (chef) {
                const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
                const changeType = isAvailable ? "Availability Updated" : "Kitchen Closed";
                const details = isAvailable ? `The kitchen is now available on ${dayNames[dayOfWeek]} from ${startTime} to ${endTime}.` : `The kitchen is now closed on ${dayNames[dayOfWeek]}.`;
                const email = generateKitchenAvailabilityChangeEmail({
                  chefEmail: chef.username,
                  chefName: chef.displayName || chef.username || "Chef",
                  kitchenName: kitchen.name,
                  changeType,
                  details
                });
                await sendEmail(email);
                console.log(`\u2705 Availability change email sent to chef: ${chef.username}`);
              }
            } catch (emailError) {
              console.error(`Error sending email to chef ${chefId}:`, emailError);
            }
          }
          if (location?.managerId) {
            try {
              const manager = await storage2.getUser(location.managerId);
              if (manager) {
                const notificationEmail = location.notificationEmail || location.notification_email || manager.username;
                const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
                const changes = `Kitchen availability updated: ${dayNames[dayOfWeek]} ${isAvailable ? `is now available from ${startTime} to ${endTime}` : "is now closed"}.`;
                const email = generateKitchenSettingsChangeEmail({
                  email: notificationEmail,
                  name: manager.username,
                  kitchenName: kitchen.name,
                  changes,
                  isChef: false
                });
                await sendEmail(email);
                console.log(`\u2705 Availability change email sent to manager: ${notificationEmail}`);
              }
            } catch (emailError) {
              console.error(`Error sending email to manager:`, emailError);
            }
          }
        }
      } catch (emailError) {
        console.error("Error sending availability change emails:", emailError);
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error setting availability:", error);
      res.status(500).json({ error: error.message || "Failed to set availability" });
    }
  });
  app3.get("/api/manager/availability/:kitchenId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const kitchenId = parseInt(req.params.kitchenId);
      const availability = await firebaseStorage.getKitchenAvailability(kitchenId);
      res.json(availability);
    } catch (error) {
      console.error("Error fetching availability:", error);
      res.status(500).json({ error: "Failed to fetch availability" });
    }
  });
  app3.get("/api/manager/bookings", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const bookings = await firebaseStorage.getBookingsByManager(user.id);
      res.json(bookings);
    } catch (error) {
      console.error("Error fetching bookings:", error);
      res.status(500).json({ error: error.message || "Failed to fetch bookings" });
    }
  });
  app3.get("/api/manager/profile", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      if (!pool) {
        return res.status(500).json({ error: "Database not available" });
      }
      const result = await pool.query(
        `SELECT 
          COALESCE((manager_profile_data->>'profileImageUrl')::text, NULL) as "profileImageUrl",
          COALESCE((manager_profile_data->>'phone')::text, NULL) as phone,
          COALESCE((manager_profile_data->>'displayName')::text, NULL) as "displayName"
        FROM users 
        WHERE id = $1`,
        [user.id]
      );
      if (result.rows.length === 0) {
        return res.status(404).json({ error: "Manager profile not found" });
      }
      const profile = result.rows[0];
      res.json({
        profileImageUrl: profile.profileImageUrl,
        phone: profile.phone,
        displayName: profile.displayName
      });
    } catch (error) {
      console.error("Error getting manager profile:", error);
      if (error.message?.includes("does not exist") || error.message?.includes("column")) {
        return res.json({ profileImageUrl: null, phone: null, displayName: null });
      }
      res.status(500).json({ error: error.message || "Failed to get profile" });
    }
  });
  app3.put("/api/manager/profile", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      if (!pool) {
        return res.status(500).json({ error: "Database not available" });
      }
      const { username, displayName, phone, profileImageUrl } = req.body;
      try {
        await pool.query(`
          DO $$ 
          BEGIN
            IF NOT EXISTS (
              SELECT 1 FROM information_schema.columns 
              WHERE table_name = 'users' AND column_name = 'manager_profile_data'
            ) THEN
              ALTER TABLE users ADD COLUMN manager_profile_data JSONB DEFAULT '{}'::jsonb;
            END IF;
          END $$;
        `);
      } catch (alterError) {
        console.log("Column check result:", alterError.message);
      }
      const profileUpdates = {};
      if (displayName !== void 0) profileUpdates.displayName = displayName;
      if (phone !== void 0) {
        if (phone && phone.trim() !== "") {
          const normalized = normalizePhoneForStorage(phone);
          if (!normalized) {
            return res.status(400).json({
              error: "Invalid phone number format. Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
            });
          }
          profileUpdates.phone = normalized;
        } else {
          profileUpdates.phone = null;
        }
      }
      if (profileImageUrl !== void 0) profileUpdates.profileImageUrl = profileImageUrl;
      if (username !== void 0 && username !== user.username) {
        const existingUser = await firebaseStorage.getUserByUsername(username);
        if (existingUser && existingUser.id !== user.id) {
          return res.status(400).json({ error: "Username already exists" });
        }
        await firebaseStorage.updateUser(user.id, { username });
      }
      if (Object.keys(profileUpdates).length > 0) {
        await pool.query(
          `UPDATE users 
           SET manager_profile_data = COALESCE(manager_profile_data, '{}'::jsonb) || $1::jsonb
           WHERE id = $2
           RETURNING manager_profile_data`,
          [JSON.stringify(profileUpdates), user.id]
        );
      }
      const result = await pool.query(
        `SELECT 
          COALESCE((manager_profile_data->>'profileImageUrl')::text, NULL) as "profileImageUrl",
          COALESCE((manager_profile_data->>'phone')::text, NULL) as phone,
          COALESCE((manager_profile_data->>'displayName')::text, NULL) as "displayName"
        FROM users 
        WHERE id = $1`,
        [user.id]
      );
      res.json({
        profileImageUrl: result.rows[0]?.profileImageUrl || null,
        phone: result.rows[0]?.phone || null,
        displayName: result.rows[0]?.displayName || null
      });
    } catch (error) {
      console.error("Error updating manager profile:", error);
      res.status(500).json({ error: error.message || "Failed to update profile" });
    }
  });
  app3.get("/api/manager/chef-profiles", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const profiles = await firebaseStorage.getChefProfilesForManager(user.id);
      res.json(profiles);
    } catch (error) {
      console.error("Error getting chef profiles for manager:", error);
      res.status(500).json({ error: error.message || "Failed to get profiles" });
    }
  });
  app3.get("/api/manager/portal-applications", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const { users: users2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      console.log(`[Manager Portal Applications] Fetching for manager ID: ${user.id}`);
      const managedLocations = await db.select().from(locations).where(eq4(locations.managerId, user.id));
      console.log(`[Manager Portal Applications] Found ${managedLocations.length} managed locations`);
      if (managedLocations.length === 0) {
        console.log(`[Manager Portal Applications] No locations found for manager ${user.id}`);
        return res.json([]);
      }
      const locationIds = managedLocations.map((loc) => loc.id);
      console.log(`[Manager Portal Applications] Location IDs: ${locationIds.join(", ")}`);
      const applications2 = await db.select({
        application: portalUserApplications,
        location: locations,
        user: users2
      }).from(portalUserApplications).innerJoin(locations, eq4(portalUserApplications.locationId, locations.id)).innerJoin(users2, eq4(portalUserApplications.userId, users2.id)).where(
        inArray2(portalUserApplications.locationId, locationIds)
      );
      console.log(`[Manager Portal Applications] Found ${applications2.length} total applications`);
      const formatted = applications2.map((app4) => ({
        id: app4.application.id,
        userId: app4.application.userId,
        locationId: app4.application.locationId,
        fullName: app4.application.fullName,
        email: app4.application.email,
        phone: app4.application.phone,
        company: app4.application.company,
        status: app4.application.status,
        feedback: app4.application.feedback,
        reviewedBy: app4.application.reviewedBy,
        reviewedAt: app4.application.reviewedAt,
        createdAt: app4.application.createdAt,
        location: {
          id: app4.location.id,
          name: app4.location.name,
          address: app4.location.address
        },
        user: {
          id: app4.user.id,
          username: app4.user.username
        }
      }));
      console.log(`[Manager Portal Applications] Returning ${formatted.length} applications (statuses: ${formatted.map((a) => a.status).join(", ")})`);
      const accessRecords = await db.select().from(portalUserLocationAccess).where(inArray2(portalUserLocationAccess.locationId, locationIds));
      console.log(`[Manager Portal Applications] Found ${accessRecords.length} access records`);
      res.json({
        applications: formatted,
        accessCount: accessRecords.length
        // Actual number of users with access
      });
    } catch (error) {
      console.error("Error getting portal applications for manager:", error);
      res.status(500).json({ error: error.message || "Failed to get applications" });
    }
  });
  app3.put("/api/manager/portal-applications/:id/status", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const applicationId = parseInt(req.params.id);
      const { status, feedback } = req.body;
      if (!status || !["approved", "rejected"].includes(status)) {
        return res.status(400).json({ error: "Invalid status. Must be 'approved' or 'rejected'" });
      }
      const { users: users2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const applicationRecords = await db.select({
        application: portalUserApplications,
        location: locations
      }).from(portalUserApplications).innerJoin(locations, eq4(portalUserApplications.locationId, locations.id)).where(eq4(portalUserApplications.id, applicationId)).limit(1);
      if (applicationRecords.length === 0) {
        return res.status(404).json({ error: "Application not found" });
      }
      const applicationData = applicationRecords[0];
      const location = applicationData.location;
      const application = applicationData.application;
      if (location.managerId !== user.id) {
        return res.status(403).json({ error: "You don't have permission to manage this application" });
      }
      const updatedApplication = await db.update(portalUserApplications).set({
        status,
        feedback: feedback || null,
        reviewedBy: user.id,
        reviewedAt: /* @__PURE__ */ new Date()
      }).where(eq4(portalUserApplications.id, applicationId)).returning();
      if (status === "approved") {
        const existingAccess = await db.select().from(portalUserLocationAccess).where(
          and4(
            eq4(portalUserLocationAccess.portalUserId, application.userId),
            eq4(portalUserLocationAccess.locationId, application.locationId)
          )
        ).limit(1);
        if (existingAccess.length === 0) {
          await db.insert(portalUserLocationAccess).values({
            portalUserId: application.userId,
            locationId: application.locationId,
            grantedBy: user.id,
            applicationId
          });
        }
        try {
          const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
          const portalUser = await firebaseStorage.getUser(application.userId);
          if (portalUser && portalUser.username) {
            const userEmail = portalUser.username;
            const emailContent = {
              to: userEmail,
              subject: `Portal Access Approved - ${location.name}`,
              text: `Your application for portal access has been approved!

Location: ${location.name}
Address: ${location.address}
${feedback ? `
Manager Feedback: ${feedback}
` : ""}
You can now log in to the portal and book kitchens at this location.`,
              html: `<h2>Portal Access Approved</h2><p>Your application for portal access has been approved!</p><p><strong>Location:</strong> ${location.name}</p><p><strong>Address:</strong> ${location.address}</p>${feedback ? `<p><strong>Manager Feedback:</strong> ${feedback}</p>` : ""}<p>You can now log in to the portal and book kitchens at this location.</p>`
            };
            await sendEmail2(emailContent);
          }
        } catch (emailError) {
          console.error("Error sending portal approval email:", emailError);
        }
      } else if (status === "rejected") {
        try {
          const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
          const portalUser = await firebaseStorage.getUser(application.userId);
          if (portalUser && portalUser.username) {
            const userEmail = portalUser.username;
            const emailContent = {
              to: userEmail,
              subject: `Portal Access Application - ${location.name}`,
              text: `Your application for portal access has been reviewed.

Location: ${location.name}
Status: Rejected
${feedback ? `
Manager Feedback: ${feedback}
` : ""}
If you have questions, please contact the location manager.`,
              html: `<h2>Portal Access Application</h2><p>Your application for portal access has been reviewed.</p><p><strong>Location:</strong> ${location.name}</p><p><strong>Status:</strong> Rejected</p>${feedback ? `<p><strong>Manager Feedback:</strong> ${feedback}</p>` : ""}<p>If you have questions, please contact the location manager.</p>`
            };
            await sendEmail2(emailContent);
          }
        } catch (emailError) {
          console.error("Error sending portal rejection email:", emailError);
        }
      }
      res.json(updatedApplication[0]);
    } catch (error) {
      console.error("Error updating portal application status:", error);
      res.status(500).json({ error: error.message || "Failed to update application status" });
    }
  });
  app3.put("/api/manager/chef-profiles/:id/status", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const profileId = parseInt(req.params.id);
      const { status, reviewFeedback } = req.body;
      if (!status || !["approved", "rejected"].includes(status)) {
        return res.status(400).json({ error: "Invalid status. Must be 'approved' or 'rejected'" });
      }
      const updated = await firebaseStorage.updateChefLocationProfileStatus(
        profileId,
        status,
        user.id,
        reviewFeedback
      );
      if (status === "approved") {
        try {
          const location = await firebaseStorage.getLocationById(updated.locationId);
          if (!location) {
            console.warn(`\u26A0\uFE0F Location ${updated.locationId} not found for email notification`);
          } else {
            const chef = await storage2.getUser(updated.chefId);
            if (!chef) {
              console.warn(`\u26A0\uFE0F Chef ${updated.chefId} not found for email notification`);
            } else {
              try {
                const chefEmail = generateChefLocationAccessApprovedEmail({
                  chefEmail: chef.username || "",
                  chefName: chef.username || "Chef",
                  locationName: location.name || "Location",
                  locationId: updated.locationId
                });
                await sendEmail(chefEmail);
                console.log(`\u2705 Chef location access approved email sent to chef: ${chef.username}`);
              } catch (emailError) {
                console.error("Error sending chef approval email:", emailError);
                console.error("Chef email error details:", emailError instanceof Error ? emailError.message : emailError);
              }
            }
          }
        } catch (emailError) {
          console.error("Error sending chef approval emails:", emailError);
        }
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating chef profile status:", error);
      res.status(500).json({ error: error.message || "Failed to update profile status" });
    }
  });
  app3.delete("/api/manager/chef-location-access", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const { chefId, locationId } = req.body;
      if (!chefId || !locationId) {
        return res.status(400).json({ error: "chefId and locationId are required" });
      }
      const location = await firebaseStorage.getLocationById(locationId);
      if (!location) {
        return res.status(404).json({ error: "Location not found" });
      }
      if (location.managerId !== user.id) {
        return res.status(403).json({ error: "You don't have permission to manage this location" });
      }
      await firebaseStorage.revokeChefLocationAccess(chefId, locationId);
      try {
        const profiles = await db.select().from(chefLocationProfiles).where(
          and4(
            eq4(chefLocationProfiles.chefId, chefId),
            eq4(chefLocationProfiles.locationId, locationId)
          )
        );
        if (profiles.length > 0) {
          await db.update(chefLocationProfiles).set({
            status: "rejected",
            reviewedBy: user.id,
            reviewedAt: /* @__PURE__ */ new Date(),
            reviewFeedback: "Access revoked by manager"
          }).where(
            and4(
              eq4(chefLocationProfiles.chefId, chefId),
              eq4(chefLocationProfiles.locationId, locationId)
            )
          );
        }
      } catch (error) {
        console.log("Note: Could not update chef profile status:", error instanceof Error ? error.message : error);
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error revoking chef location access:", error);
      res.status(500).json({ error: error.message || "Failed to revoke access" });
    }
  });
  app3.get("/api/manager/kitchens/:kitchenId/bookings", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const kitchenId = parseInt(req.params.kitchenId);
      console.log(`\u{1F4CB} Fetching bookings for kitchen ${kitchenId}`);
      const bookings = await firebaseStorage.getBookingsByKitchen(kitchenId);
      console.log(`\u2705 Found ${bookings.length} bookings for kitchen ${kitchenId}`);
      res.json(bookings);
    } catch (error) {
      console.error("Error fetching kitchen bookings:", error);
      res.status(500).json({ error: error.message || "Failed to fetch kitchen bookings" });
    }
  });
  app3.get("/api/manager/bookings/:id", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const id = parseInt(req.params.id);
      if (isNaN(id) || id <= 0) {
        return res.status(400).json({ error: "Invalid booking ID" });
      }
      const booking = await firebaseStorage.getBookingById(id);
      if (!booking) {
        return res.status(404).json({ error: "Booking not found" });
      }
      const kitchen = await firebaseStorage.getKitchenById(booking.kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const kitchenLocationId = kitchen.locationId || kitchen.location_id;
      const location = await firebaseStorage.getLocationById(kitchenLocationId);
      if (!location || location.managerId !== user.id) {
        return res.status(403).json({ error: "You don't have permission to view this booking" });
      }
      const storageBookings2 = await firebaseStorage.getStorageBookingsByKitchenBooking(id);
      const equipmentBookings2 = await firebaseStorage.getEquipmentBookingsByKitchenBooking(id);
      const chef = booking.chefId ? await storage2.getUser(booking.chefId) : null;
      let chefFullName = null;
      let chefEmail = null;
      let chefPhone = null;
      if (chef && booking.chefId) {
        try {
          const appResult = await pool.query(
            "SELECT full_name, email, phone FROM applications WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1",
            [booking.chefId]
          );
          if (appResult.rows.length > 0) {
            chefFullName = appResult.rows[0].full_name;
            chefEmail = appResult.rows[0].email;
            chefPhone = appResult.rows[0].phone;
          }
        } catch (error) {
          console.error("Error fetching chef details from applications:", error);
        }
      }
      res.json({
        ...booking,
        kitchen,
        location,
        chef: chef ? {
          id: chef.id,
          username: chef.username,
          fullName: chefFullName,
          email: chefEmail,
          phone: chefPhone
        } : null,
        storageBookings: storageBookings2,
        equipmentBookings: equipmentBookings2
      });
    } catch (error) {
      console.error("Error fetching booking details:", error);
      res.status(500).json({ error: error.message || "Failed to fetch booking details" });
    }
  });
  app3.put("/api/manager/bookings/:id/status", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const id = parseInt(req.params.id);
      const { status } = req.body;
      const booking = await firebaseStorage.getBookingById(id);
      await firebaseStorage.updateKitchenBookingStatus(id, status);
      if (booking) {
        try {
          const kitchen = await firebaseStorage.getKitchenById(booking.kitchenId);
          const chef = await storage2.getUser(booking.chefId);
          if (chef && kitchen) {
            const kitchenLocationId = kitchen.locationId || kitchen.location_id;
            let location = null;
            let manager = null;
            if (kitchenLocationId && pool) {
              const locationData = await pool.query(`
                SELECT l.id, l.name, l.manager_id, l.notification_email, l.timezone
                FROM locations l
                WHERE l.id = $1
              `, [kitchenLocationId]);
              if (locationData.rows.length > 0) {
                location = locationData.rows[0];
                const managerId = location.manager_id;
                if (managerId) {
                  const managerData = await pool.query(`
                    SELECT id, username
                    FROM users
                    WHERE id = $1
                  `, [managerId]);
                  if (managerData.rows.length > 0) {
                    manager = managerData.rows[0];
                  }
                }
              }
            }
            let chefName = chef.username || "Chef";
            let chefPhone = null;
            if (pool && booking.chefId) {
              chefPhone = await getChefPhone(booking.chefId, pool);
              try {
                const appResult = await pool.query(
                  "SELECT full_name FROM applications WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1",
                  [booking.chefId]
                );
                if (appResult.rows.length > 0 && appResult.rows[0].full_name) {
                  chefName = appResult.rows[0].full_name;
                }
                console.log(`\u{1F4CB} Using application full name "${chefName}" for chef ${booking.chefId} in confirmation email${chefPhone ? `, phone: ${chefPhone}` : ""}`);
              } catch (error) {
                console.debug(`Could not get full name for chef ${booking.chefId} from applications, using username`);
              }
            }
            const chefEmailAddress = chef.username;
            if (!chefEmailAddress) {
              console.warn(`\u26A0\uFE0F Chef ${booking.chefId} has no email address, skipping status update email`);
            } else {
              if (status === "confirmed") {
                try {
                  const locationTimezone = location ? location.timezone || DEFAULT_TIMEZONE : DEFAULT_TIMEZONE;
                  const locationName = location ? location.name || kitchen.name : kitchen.name;
                  const confirmationEmail = generateBookingConfirmationEmail({
                    chefEmail: chefEmailAddress,
                    chefName,
                    kitchenName: kitchen.name,
                    bookingDate: booking.bookingDate,
                    startTime: booking.startTime,
                    endTime: booking.endTime,
                    specialNotes: booking.specialNotes,
                    timezone: locationTimezone,
                    locationName
                  });
                  const emailSent = await sendEmail(confirmationEmail);
                  if (emailSent) {
                    console.log(`\u2705 Booking confirmation email sent to chef: ${chefEmailAddress}`);
                  } else {
                    console.error(`\u274C Failed to send booking confirmation email to chef: ${chefEmailAddress}`);
                  }
                } catch (confirmationEmailError) {
                  console.error(`\u274C Error sending booking confirmation email to chef ${chefEmailAddress}:`, confirmationEmailError);
                  console.error("Confirmation email error details:", confirmationEmailError instanceof Error ? confirmationEmailError.message : String(confirmationEmailError));
                }
                if (chefPhone) {
                  try {
                    const smsMessage = generateChefBookingConfirmationSMS({
                      kitchenName: kitchen.name,
                      bookingDate: booking.bookingDate,
                      startTime: booking.startTime,
                      endTime: booking.endTime
                    });
                    await sendSMS(chefPhone, smsMessage, { trackingId: `booking_${id}_chef_confirmed` });
                    console.log(`\u2705 Booking confirmation SMS sent to chef: ${chefPhone}`);
                  } catch (smsError) {
                    console.error(`\u274C Error sending booking confirmation SMS to chef:`, smsError);
                  }
                }
                const notificationEmailAddress = location ? location.notification_email || (manager ? manager.username : null) : null;
                if (notificationEmailAddress) {
                  try {
                    const locationTimezone = location ? location.timezone || DEFAULT_TIMEZONE : DEFAULT_TIMEZONE;
                    const locationName = location ? location.name || kitchen.name : kitchen.name;
                    const managerEmail = generateBookingStatusChangeNotificationEmail({
                      managerEmail: notificationEmailAddress,
                      chefName,
                      kitchenName: kitchen.name || "Kitchen",
                      bookingDate: booking.bookingDate,
                      startTime: booking.startTime,
                      endTime: booking.endTime,
                      status: "confirmed",
                      timezone: locationTimezone,
                      locationName
                    });
                    const emailSent = await sendEmail(managerEmail);
                    if (emailSent) {
                      console.log(`\u2705 Booking confirmation notification email sent to manager: ${notificationEmailAddress}`);
                    } else {
                      console.error(`\u274C Failed to send booking confirmation notification email to manager: ${notificationEmailAddress}`);
                    }
                  } catch (managerEmailError) {
                    console.error(`\u274C Error sending manager confirmation email:`, managerEmailError);
                  }
                }
                try {
                  const bookingData = await firebaseStorage.getBookingById(id);
                  const isPortalBooking = bookingData && (bookingData.bookingType === "external" || bookingData.externalContact);
                  if (isPortalBooking && kitchenLocationId && booking.chefId && pool) {
                    try {
                      const portalUserPhone = await getPortalUserPhone(booking.chefId, kitchenLocationId, pool);
                      if (portalUserPhone) {
                        const smsMessage = generatePortalUserBookingConfirmationSMS({
                          kitchenName: kitchen.name || "Kitchen",
                          bookingDate: booking.bookingDate,
                          startTime: booking.startTime,
                          endTime: booking.endTime
                        });
                        await sendSMS(portalUserPhone, smsMessage, { trackingId: `booking_${id}_portal_confirmed` });
                        console.log(`\u2705 Booking confirmation SMS sent to portal user: ${portalUserPhone}`);
                      } else {
                        console.log(`\u{1F4F1} No phone number found in portal_user_applications for user ${booking.chefId} and location ${kitchenLocationId}`);
                      }
                    } catch (portalAppError) {
                      console.error(`\u274C Error querying portal_user_applications for SMS:`, portalAppError);
                    }
                  }
                } catch (portalSmsError) {
                  console.error(`\u274C Error sending booking confirmation SMS to portal user:`, portalSmsError);
                }
              } else if (status === "cancelled") {
                try {
                  const cancellationEmail = generateBookingCancellationEmail({
                    chefEmail: chefEmailAddress,
                    chefName,
                    kitchenName: kitchen.name,
                    bookingDate: booking.bookingDate,
                    startTime: booking.startTime,
                    endTime: booking.endTime,
                    cancellationReason: "The manager has cancelled this booking"
                  });
                  const emailSent = await sendEmail(cancellationEmail);
                  if (emailSent) {
                    console.log(`\u2705 Booking cancellation email sent to chef: ${chefEmailAddress}`);
                  } else {
                    console.error(`\u274C Failed to send booking cancellation email to chef: ${chefEmailAddress}`);
                  }
                } catch (cancellationEmailError) {
                  console.error(`\u274C Error sending booking cancellation email to chef ${chefEmailAddress}:`, cancellationEmailError);
                  console.error("Cancellation email error details:", cancellationEmailError instanceof Error ? cancellationEmailError.message : String(cancellationEmailError));
                }
                if (chefPhone) {
                  try {
                    const smsMessage = generateChefBookingCancellationSMS({
                      kitchenName: kitchen.name,
                      bookingDate: booking.bookingDate,
                      startTime: booking.startTime,
                      endTime: booking.endTime,
                      reason: "The manager has cancelled this booking"
                    });
                    await sendSMS(chefPhone, smsMessage, { trackingId: `booking_${id}_chef_cancelled` });
                    console.log(`\u2705 Booking cancellation SMS sent to chef: ${chefPhone}`);
                  } catch (smsError) {
                    console.error(`\u274C Error sending booking cancellation SMS to chef:`, smsError);
                  }
                }
                const notificationEmailAddress = location ? location.notification_email || (manager ? manager.username : null) : null;
                if (notificationEmailAddress) {
                  try {
                    const locationTimezone = location ? location.timezone || DEFAULT_TIMEZONE : DEFAULT_TIMEZONE;
                    const locationName = location ? location.name || kitchen.name : kitchen.name;
                    const managerEmail = generateBookingStatusChangeNotificationEmail({
                      managerEmail: notificationEmailAddress,
                      chefName,
                      kitchenName: kitchen.name || "Kitchen",
                      bookingDate: booking.bookingDate,
                      startTime: booking.startTime,
                      endTime: booking.endTime,
                      status: "cancelled",
                      timezone: locationTimezone,
                      locationName
                    });
                    const emailSent = await sendEmail(managerEmail);
                    if (emailSent) {
                      console.log(`\u2705 Booking cancellation notification email sent to manager: ${notificationEmailAddress}`);
                    } else {
                      console.error(`\u274C Failed to send booking cancellation notification email to manager: ${notificationEmailAddress}`);
                    }
                  } catch (managerEmailError) {
                    console.error(`\u274C Error sending manager cancellation email:`, managerEmailError);
                  }
                }
                try {
                  const bookingData = await firebaseStorage.getBookingById(id);
                  const isPortalBooking = bookingData && (bookingData.bookingType === "external" || bookingData.externalContact);
                  if (isPortalBooking && kitchenLocationId && booking.chefId && pool) {
                    const portalUserPhone = await getPortalUserPhone(booking.chefId, kitchenLocationId, pool);
                    if (portalUserPhone) {
                      const smsMessage = generatePortalUserBookingCancellationSMS({
                        kitchenName: kitchen.name || "Kitchen",
                        bookingDate: booking.bookingDate,
                        startTime: booking.startTime,
                        endTime: booking.endTime,
                        reason: "The manager has cancelled this booking"
                      });
                      await sendSMS(portalUserPhone, smsMessage, { trackingId: `booking_${id}_portal_cancelled` });
                      console.log(`\u2705 Booking cancellation SMS sent to portal user: ${portalUserPhone}`);
                    } else {
                      console.log(`\u{1F4F1} No phone number found in portal_user_applications for user ${booking.chefId} and location ${kitchenLocationId}`);
                    }
                  }
                } catch (portalAppError) {
                  console.error(`\u274C Error querying portal_user_applications for SMS:`, portalAppError);
                }
              }
            }
          }
        } catch (emailError) {
          console.error("Error sending booking status email:", emailError);
        }
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error updating booking status:", error);
      res.status(500).json({ error: error.message || "Failed to update booking status" });
    }
  });
  app3.get("/api/manager/kitchens/:kitchenId/date-overrides", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const kitchenId = parseInt(req.params.kitchenId);
      const { startDate, endDate } = req.query;
      const start = startDate ? new Date(startDate) : void 0;
      const end = endDate ? new Date(endDate) : void 0;
      const overrides = await firebaseStorage.getKitchenDateOverrides(kitchenId, start, end);
      res.json(overrides);
    } catch (error) {
      console.error("Error fetching date overrides:", error);
      res.status(500).json({ error: error.message || "Failed to fetch date overrides" });
    }
  });
  app3.post("/api/manager/kitchens/:kitchenId/date-overrides", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const kitchenId = parseInt(req.params.kitchenId);
      const { specificDate, startTime, endTime, isAvailable, reason } = req.body;
      if (!specificDate) {
        return res.status(400).json({ error: "Date is required" });
      }
      if (isAvailable) {
        if (!startTime || !endTime) {
          return res.status(400).json({
            error: "Start time and end time are required when kitchen is available"
          });
        }
        if (startTime >= endTime) {
          return res.status(400).json({
            error: "End time must be after start time"
          });
        }
      }
      const parseDateString = (dateStr) => {
        const [year, month, day] = dateStr.split("-").map(Number);
        return new Date(Date.UTC(year, month - 1, day, 12, 0, 0));
      };
      const parsedDate = parseDateString(specificDate);
      if (!isAvailable) {
        const bookings = await firebaseStorage.getBookingsByKitchen(kitchenId);
        const dateStr = specificDate;
        const bookingsOnDate = bookings.filter((b) => {
          const bookingDateStr = new Date(b.bookingDate).toISOString().split("T")[0];
          return bookingDateStr === dateStr && b.status === "confirmed";
        });
        if (bookingsOnDate.length > 0) {
          return res.status(400).json({
            error: "Cannot close kitchen on this date",
            message: `There are ${bookingsOnDate.length} confirmed booking(s) on this date. Please cancel or reschedule them first.`,
            bookings: bookingsOnDate
          });
        }
      }
      const override = await firebaseStorage.createKitchenDateOverride({
        kitchenId,
        specificDate: parsedDate,
        startTime,
        endTime,
        isAvailable,
        reason
      });
      try {
        const kitchen = await firebaseStorage.getKitchenById(kitchenId);
        if (kitchen) {
          const location = await firebaseStorage.getLocationById(kitchen.locationId);
          const dateStr = new Date(specificDate).toLocaleDateString();
          const bookings = await firebaseStorage.getBookingsByKitchen(kitchenId);
          const uniqueChefIds = Array.from(new Set(bookings.map((b) => b.chefId)));
          const changeType = isAvailable ? "Special Availability Added" : "Kitchen Closed for Date";
          const details = isAvailable ? `Special availability on ${dateStr} from ${startTime} to ${endTime}.${reason ? ` Reason: ${reason}` : ""}` : `Kitchen will be closed on ${dateStr}.${reason ? ` Reason: ${reason}` : ""}`;
          for (const chefId of uniqueChefIds) {
            try {
              const chef = await storage2.getUser(chefId);
              if (chef) {
                const email = generateKitchenAvailabilityChangeEmail({
                  chefEmail: chef.username,
                  chefName: chef.displayName || chef.username || "Chef",
                  kitchenName: kitchen.name,
                  changeType,
                  details
                });
                await sendEmail(email);
                console.log(`\u2705 Date override email sent to chef: ${chef.username}`);
              }
            } catch (emailError) {
              console.error(`Error sending email to chef ${chefId}:`, emailError);
            }
          }
          if (location?.managerId) {
            try {
              const manager = await storage2.getUser(location.managerId);
              if (manager) {
                const notificationEmail = location.notificationEmail || location.notification_email || manager.username;
                const changes = `Date override created: ${dateStr} - ${isAvailable ? `special availability from ${startTime} to ${endTime}` : "kitchen closed"}.${reason ? ` Reason: ${reason}` : ""}`;
                const email = generateKitchenSettingsChangeEmail({
                  email: notificationEmail,
                  name: manager.username,
                  kitchenName: kitchen.name,
                  changes,
                  isChef: false
                });
                await sendEmail(email);
                console.log(`\u2705 Date override email sent to manager: ${notificationEmail}`);
              }
            } catch (emailError) {
              console.error(`Error sending email to manager:`, emailError);
            }
          }
        }
      } catch (emailError) {
        console.error("Error sending date override emails:", emailError);
      }
      res.json(override);
    } catch (error) {
      console.error("Error creating date override:", error);
      res.status(500).json({ error: error.message || "Failed to create date override" });
    }
  });
  app3.put("/api/manager/date-overrides/:id", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const id = parseInt(req.params.id);
      const { startTime, endTime, isAvailable, reason } = req.body;
      if (isAvailable === true) {
        if (!startTime || !endTime) {
          return res.status(400).json({
            error: "Start time and end time are required when kitchen is available"
          });
        }
        if (startTime >= endTime) {
          return res.status(400).json({
            error: "End time must be after start time"
          });
        }
      }
      if (isAvailable === false) {
        const override = await firebaseStorage.getKitchenDateOverrideById(id);
        if (override) {
          const bookings = await firebaseStorage.getBookingsByKitchen(override.kitchenId);
          const dateStr = new Date(override.specificDate).toISOString().split("T")[0];
          const bookingsOnDate = bookings.filter((b) => {
            const bookingDateStr = new Date(b.bookingDate).toISOString().split("T")[0];
            return bookingDateStr === dateStr && b.status === "confirmed";
          });
          if (bookingsOnDate.length > 0) {
            return res.status(400).json({
              error: "Cannot close kitchen on this date",
              message: `There are ${bookingsOnDate.length} confirmed booking(s) on this date. Please cancel or reschedule them first.`,
              bookings: bookingsOnDate
            });
          }
        }
      }
      const updated = await firebaseStorage.updateKitchenDateOverride(id, {
        startTime,
        endTime,
        isAvailable,
        reason
      });
      try {
        const override = await firebaseStorage.getKitchenDateOverrideById(id);
        if (override) {
          const kitchen = await firebaseStorage.getKitchenById(override.kitchenId);
          if (kitchen) {
            const location = await firebaseStorage.getLocationById(kitchen.locationId);
            const dateStr = new Date(override.specificDate).toLocaleDateString();
            const bookings = await firebaseStorage.getBookingsByKitchen(override.kitchenId);
            const uniqueChefIds = Array.from(new Set(bookings.map((b) => b.chefId)));
            const changeType = isAvailable !== void 0 ? isAvailable ? "Date Override Updated - Special Availability" : "Date Override Updated - Kitchen Closed" : "Date Override Updated";
            const details = isAvailable !== void 0 ? isAvailable ? `Date override updated: ${dateStr} is now available${startTime && endTime ? ` from ${startTime} to ${endTime}` : ""}.${reason ? ` Reason: ${reason}` : ""}` : `Date override updated: ${dateStr} is now closed.${reason ? ` Reason: ${reason}` : ""}` : `Date override updated for ${dateStr}.${startTime && endTime ? ` Time: ${startTime} to ${endTime}` : ""}${reason ? ` Reason: ${reason}` : ""}`;
            for (const chefId of uniqueChefIds) {
              try {
                const chef = await storage2.getUser(chefId);
                if (chef) {
                  const email = generateKitchenAvailabilityChangeEmail({
                    chefEmail: chef.username,
                    chefName: chef.displayName || chef.username || "Chef",
                    kitchenName: kitchen.name,
                    changeType,
                    details
                  });
                  await sendEmail(email);
                  console.log(`\u2705 Date override update email sent to chef: ${chef.username}`);
                }
              } catch (emailError) {
                console.error(`Error sending email to chef ${chefId}:`, emailError);
              }
            }
            if (location?.managerId) {
              try {
                const manager = await storage2.getUser(location.managerId);
                if (manager) {
                  const notificationEmail = location.notificationEmail || location.notification_email || manager.username;
                  const changes = `Date override updated for ${dateStr}.${isAvailable !== void 0 ? isAvailable ? ` Special availability${startTime && endTime ? ` from ${startTime} to ${endTime}` : ""}` : " Kitchen closed" : ""}${reason ? `. Reason: ${reason}` : ""}`;
                  const email = generateKitchenSettingsChangeEmail({
                    email: notificationEmail,
                    name: manager.username,
                    kitchenName: kitchen.name,
                    changes,
                    isChef: false
                  });
                  await sendEmail(email);
                  console.log(`\u2705 Date override update email sent to manager: ${notificationEmail}`);
                }
              } catch (emailError) {
                console.error(`Error sending email to manager:`, emailError);
              }
            }
          }
        }
      } catch (emailError) {
        console.error("Error sending date override update emails:", emailError);
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating date override:", error);
      res.status(500).json({ error: error.message || "Failed to update date override" });
    }
  });
  app3.delete("/api/manager/date-overrides/:id", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const id = parseInt(req.params.id);
      await firebaseStorage.deleteKitchenDateOverride(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting date override:", error);
      res.status(500).json({ error: error.message || "Failed to delete date override" });
    }
  });
  async function requireChef(req, res, next) {
    try {
      const authHeader = req.headers.authorization;
      if (authHeader && authHeader.startsWith("Bearer ")) {
        const token = authHeader.substring(7);
        const decodedToken = await verifyFirebaseToken(token);
        if (decodedToken) {
          const neonUser = await firebaseStorage.getUserByFirebaseUid(decodedToken.uid);
          if (neonUser && neonUser.isChef) {
            req.firebaseUser = {
              uid: decodedToken.uid,
              email: decodedToken.email,
              email_verified: decodedToken.email_verified
            };
            req.user = neonUser;
            console.log(`\u2705 Chef authenticated via Firebase: ${neonUser.username} (ID: ${neonUser.id})`);
            return next();
          } else if (neonUser && !neonUser.isChef) {
            return res.status(403).json({ error: "Chef access required" });
          }
        }
      }
      if (req.isAuthenticated && req.isAuthenticated() && req.user?.isChef) {
        console.log(`\u2705 Chef authenticated via session: ${req.user.username} (ID: ${req.user.id})`);
        return next();
      }
      return res.status(401).json({ error: "Authentication required. Please sign in as a chef." });
    } catch (error) {
      console.error("Error in requireChef middleware:", error);
      return res.status(401).json({ error: "Authentication failed" });
    }
  }
  app3.get("/api/chef/kitchens", requireChef, async (req, res) => {
    try {
      const allKitchens = await firebaseStorage.getAllKitchensWithLocationAndManager();
      const activeKitchens = allKitchens.filter((kitchen) => {
        const isActive = kitchen.isActive !== void 0 ? kitchen.isActive : kitchen.is_active;
        return isActive !== false && isActive !== null;
      });
      const normalizedKitchens = activeKitchens.map((kitchen) => {
        const normalizedImageUrl = normalizeImageUrl(kitchen.imageUrl || kitchen.image_url || null, req);
        const normalizedGalleryImages = (kitchen.galleryImages || kitchen.gallery_images || []).map(
          (img) => normalizeImageUrl(img, req)
        ).filter((url) => url !== null);
        const normalizedLocationBrandImageUrl = normalizeImageUrl(kitchen.locationBrandImageUrl || kitchen.location_brand_image_url || null, req);
        const normalizedLocationLogoUrl = normalizeImageUrl(kitchen.locationLogoUrl || kitchen.location_logo_url || null, req);
        return {
          ...kitchen,
          imageUrl: normalizedImageUrl,
          image_url: normalizedImageUrl,
          // Also set snake_case for compatibility
          galleryImages: normalizedGalleryImages,
          gallery_images: normalizedGalleryImages,
          // Also set snake_case for compatibility
          locationBrandImageUrl: normalizedLocationBrandImageUrl,
          location_brand_image_url: normalizedLocationBrandImageUrl,
          // Also set snake_case for compatibility
          locationLogoUrl: normalizedLocationLogoUrl,
          location_logo_url: normalizedLocationLogoUrl
          // Also set snake_case for compatibility
        };
      });
      console.log(`[API] /api/chef/kitchens - Returning ${normalizedKitchens.length} active kitchens (all locations for marketing)`);
      res.json(normalizedKitchens);
    } catch (error) {
      console.error("Error fetching kitchens:", error);
      res.status(500).json({ error: "Failed to fetch kitchens", details: error.message });
    }
  });
  app3.get("/api/chef/kitchens/:kitchenId/pricing", requireChef, async (req, res) => {
    try {
      const kitchenId = parseInt(req.params.kitchenId);
      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      const pricing = await firebaseStorage.getKitchenPricing(kitchenId);
      if (!pricing) {
        return res.status(404).json({ error: "Pricing not found" });
      }
      res.json(pricing);
    } catch (error) {
      console.error("Error getting kitchen pricing:", error);
      res.status(500).json({ error: error.message || "Failed to get kitchen pricing" });
    }
  });
  app3.get("/api/chef/kitchens/:kitchenId/policy", requireChef, async (req, res) => {
    try {
      const kitchenId = parseInt(req.params.kitchenId);
      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      const kitchen = await firebaseStorage.getKitchenById(kitchenId);
      if (!kitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const locationId = kitchen.locationId || kitchen.location_id;
      if (!locationId) {
        return res.status(404).json({ error: "Location not found for this kitchen" });
      }
      const location = await firebaseStorage.getLocationById(locationId);
      if (!location) {
        return res.status(404).json({ error: "Location not found" });
      }
      const maxSlotsPerChef = location.default_daily_booking_limit || location.defaultDailyBookingLimit || 2;
      res.json({ maxSlotsPerChef });
    } catch (error) {
      console.error("Error getting kitchen policy:", error);
      res.status(500).json({ error: error.message || "Failed to get kitchen policy" });
    }
  });
  app3.get("/api/chef/kitchens/:kitchenId/storage-listings", requireChef, async (req, res) => {
    try {
      const kitchenId = parseInt(req.params.kitchenId);
      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      const allListings = await firebaseStorage.getStorageListingsByKitchen(kitchenId);
      const visibleListings = allListings.filter(
        (listing) => (listing.status === "approved" || listing.status === "active") && listing.isActive === true
      );
      console.log(`[API] /api/chef/kitchens/${kitchenId}/storage-listings - Returning ${visibleListings.length} visible listings (out of ${allListings.length} total)`);
      res.json(visibleListings);
    } catch (error) {
      console.error("Error getting storage listings for chef:", error);
      res.status(500).json({ error: error.message || "Failed to get storage listings" });
    }
  });
  app3.get("/api/chef/kitchens/:kitchenId/equipment-listings", requireChef, async (req, res) => {
    try {
      const kitchenId = parseInt(req.params.kitchenId);
      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      const allListings = await firebaseStorage.getEquipmentListingsByKitchen(kitchenId);
      const visibleListings = allListings.filter(
        (listing) => (listing.status === "approved" || listing.status === "active") && listing.isActive === true
      );
      const includedEquipment = visibleListings.filter((l) => l.availabilityType === "included");
      const rentalEquipment = visibleListings.filter((l) => l.availabilityType === "rental");
      console.log(`[API] /api/chef/kitchens/${kitchenId}/equipment-listings - Returning ${visibleListings.length} visible listings (${includedEquipment.length} included, ${rentalEquipment.length} rental)`);
      res.json({
        all: visibleListings,
        included: includedEquipment,
        rental: rentalEquipment
      });
    } catch (error) {
      console.error("Error getting equipment listings for chef:", error);
      res.status(500).json({ error: error.message || "Failed to get equipment listings" });
    }
  });
  app3.get("/api/chef/locations", requireChef, async (req, res) => {
    try {
      const allLocations = await firebaseStorage.getAllLocations();
      const allKitchens = await firebaseStorage.getAllKitchensWithLocationAndManager();
      const activeKitchens = allKitchens.filter((kitchen) => {
        const isActive = kitchen.isActive !== void 0 ? kitchen.isActive : kitchen.is_active;
        return isActive !== false && isActive !== null;
      });
      const locationIdsWithKitchens = new Set(
        activeKitchens.map((kitchen) => kitchen.locationId || kitchen.location_id).filter(Boolean)
      );
      const locationsWithKitchens = allLocations.filter(
        (location) => locationIdsWithKitchens.has(location.id)
      );
      console.log(`[API] /api/chef/locations - Returning ${locationsWithKitchens.length} locations with active kitchens`);
      res.json(locationsWithKitchens);
    } catch (error) {
      console.error("Error fetching locations:", error);
      res.status(500).json({ error: "Failed to fetch locations" });
    }
  });
  app3.get("/api/chef/kitchens/:kitchenId/slots", requireChef, async (req, res) => {
    try {
      const kitchenId = parseInt(req.params.kitchenId);
      const { date: date2 } = req.query;
      if (!date2) {
        return res.status(400).json({ error: "Date parameter is required" });
      }
      const bookingDate = new Date(date2);
      if (isNaN(bookingDate.getTime())) {
        return res.status(400).json({ error: "Invalid date format" });
      }
      const slotsInfo = await firebaseStorage.getAllTimeSlotsWithBookingInfo(kitchenId, bookingDate);
      res.json(slotsInfo);
    } catch (error) {
      console.error("Error fetching time slots:", error);
      res.status(500).json({
        error: "Failed to fetch time slots",
        message: error.message
      });
    }
  });
  app3.get("/api/chef/kitchens/:kitchenId/availability", requireChef, async (req, res) => {
    try {
      const kitchenId = parseInt(req.params.kitchenId);
      const { date: date2 } = req.query;
      if (!date2) {
        return res.status(400).json({ error: "Date parameter is required" });
      }
      const bookingDate = new Date(date2);
      if (isNaN(bookingDate.getTime())) {
        return res.status(400).json({ error: "Invalid date format" });
      }
      console.log(`\u{1F50D} Fetching available slots for kitchen ${kitchenId} on ${date2}`);
      const slots = await firebaseStorage.getAvailableTimeSlots(kitchenId, bookingDate);
      console.log(`\u2705 Returning ${slots.length} available slots`);
      res.json(slots);
    } catch (error) {
      console.error("Error fetching available slots:", error);
      res.status(500).json({
        error: "Failed to fetch available slots",
        message: error.message
      });
    }
  });
  app3.post("/api/payments/create-intent", requireChef, async (req, res) => {
    try {
      const { kitchenId, bookingDate, startTime, endTime, selectedStorage, selectedEquipmentIds, expectedAmountCents } = req.body;
      const chefId = req.user.id;
      if (!kitchenId || !bookingDate || !startTime || !endTime) {
        return res.status(400).json({ error: "Missing required booking fields" });
      }
      const { createPaymentIntent: createPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
      const { calculateKitchenBookingPrice: calculateKitchenBookingPrice2, calculatePlatformFeeDynamic: calculatePlatformFeeDynamic2, calculateTotalWithFees: calculateTotalWithFees2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
      const kitchenPricing = await calculateKitchenBookingPrice2(kitchenId, startTime, endTime, pool);
      let totalPriceCents = kitchenPricing.totalPriceCents;
      if (selectedStorage && Array.isArray(selectedStorage) && selectedStorage.length > 0 && pool) {
        for (const storage3 of selectedStorage) {
          try {
            const storageResult = await pool.query(
              `SELECT id, pricing_model, base_price, minimum_booking_duration FROM storage_listings WHERE id = $1`,
              [storage3.storageListingId]
            );
            if (storageResult.rows.length > 0) {
              const storageListing = storageResult.rows[0];
              const basePriceCents = storageListing.base_price ? Math.round(parseFloat(String(storageListing.base_price))) : 0;
              const minDays = storageListing.minimum_booking_duration || 1;
              const startDate = new Date(storage3.startDate);
              const endDate = new Date(storage3.endDate);
              const days = Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24));
              const effectiveDays = Math.max(days, minDays);
              let storagePrice = basePriceCents * effectiveDays;
              if (storageListing.pricing_model === "hourly") {
                const durationHours = Math.max(1, Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60)));
                storagePrice = basePriceCents * durationHours;
              } else if (storageListing.pricing_model === "monthly-flat") {
                storagePrice = basePriceCents;
              }
              totalPriceCents += storagePrice;
            }
          } catch (error) {
            console.error("Error calculating storage price:", error);
          }
        }
      }
      if (selectedEquipmentIds && Array.isArray(selectedEquipmentIds) && selectedEquipmentIds.length > 0 && pool) {
        for (const equipmentListingId of selectedEquipmentIds) {
          try {
            const equipmentResult = await pool.query(
              `SELECT id, session_rate, damage_deposit FROM equipment_listings WHERE id = $1 AND availability_type != 'included'`,
              [equipmentListingId]
            );
            if (equipmentResult.rows.length > 0) {
              const equipmentListing = equipmentResult.rows[0];
              const sessionRateCents = equipmentListing.session_rate ? Math.round(parseFloat(String(equipmentListing.session_rate))) : 0;
              const damageDepositCents = equipmentListing.damage_deposit ? Math.round(parseFloat(String(equipmentListing.damage_deposit))) : 0;
              totalPriceCents += sessionRateCents + damageDepositCents;
            }
          } catch (error) {
            console.error("Error calculating equipment price:", error);
          }
        }
      }
      const serviceFeeCents = await calculatePlatformFeeDynamic2(totalPriceCents, pool);
      const stripeProcessingFeeCents = 30;
      const totalServiceFeeCents = serviceFeeCents + stripeProcessingFeeCents;
      const totalWithFeesCents = calculateTotalWithFees2(totalPriceCents, totalServiceFeeCents, 0);
      let managerConnectAccountId;
      if (pool) {
        try {
          const managerResult = await pool.query(`
            SELECT 
              u.stripe_connect_account_id,
              u.stripe_connect_onboarding_status
            FROM kitchens k
            JOIN locations l ON k.location_id = l.id
            JOIN users u ON l.manager_id = u.id
            WHERE k.id = $1
              AND u.stripe_connect_account_id IS NOT NULL
              AND u.stripe_connect_onboarding_status = 'complete'
          `, [kitchenId]);
          if (managerResult.rows.length > 0 && managerResult.rows[0].stripe_connect_account_id) {
            managerConnectAccountId = managerResult.rows[0].stripe_connect_account_id;
            console.log("Using Stripe Connect for manager:", managerConnectAccountId);
          }
        } catch (error) {
          console.error("Error fetching manager Connect account:", error);
        }
      }
      console.log("Payment intent calculation:", {
        kitchenPriceCents: kitchenPricing.totalPriceCents,
        totalPriceCents,
        serviceFeeCents,
        totalWithFeesCents,
        totalWithFeesDollars: totalWithFeesCents / 100,
        expectedAmountCents,
        expectedAmountDollars: expectedAmountCents ? expectedAmountCents / 100 : null,
        currency: kitchenPricing.currency,
        usingConnect: !!managerConnectAccountId,
        managerAccountId: managerConnectAccountId
      });
      if (totalWithFeesCents <= 0) {
        return res.status(400).json({ error: "Booking total is zero. Payment not required." });
      }
      let finalAmountCents = totalWithFeesCents;
      if (expectedAmountCents && typeof expectedAmountCents === "number" && expectedAmountCents > 0) {
        finalAmountCents = expectedAmountCents;
        const difference = Math.abs(expectedAmountCents - totalWithFeesCents);
        if (difference > 100) {
          console.warn("Using frontend amount despite backend mismatch (likely database unit issue):", {
            backend: totalWithFeesCents,
            backendDollars: (totalWithFeesCents / 100).toFixed(2),
            frontend: expectedAmountCents,
            frontendDollars: (expectedAmountCents / 100).toFixed(2),
            difference,
            differenceDollars: (difference / 100).toFixed(2),
            breakdown: {
              kitchenBase: kitchenPricing.totalPriceCents,
              kitchenBaseDollars: (kitchenPricing.totalPriceCents / 100).toFixed(2),
              storageEquipmentAddons: totalPriceCents - kitchenPricing.totalPriceCents,
              storageEquipmentAddonsDollars: ((totalPriceCents - kitchenPricing.totalPriceCents) / 100).toFixed(2),
              serviceFee: serviceFeeCents,
              serviceFeeDollars: (serviceFeeCents / 100).toFixed(2)
            },
            selectedStorage: selectedStorage?.length || 0,
            selectedEquipment: selectedEquipmentIds?.length || 0
          });
        } else {
          console.log("Using frontend-calculated amount:", {
            amount: expectedAmountCents,
            amountDollars: (expectedAmountCents / 100).toFixed(2)
          });
        }
      }
      const paymentIntent = await createPaymentIntent2({
        amount: finalAmountCents,
        currency: kitchenPricing.currency.toLowerCase(),
        chefId,
        kitchenId,
        managerConnectAccountId,
        applicationFeeAmount: managerConnectAccountId ? serviceFeeCents : void 0,
        enableACSS: false,
        // Disable ACSS - only use card payments with automatic capture
        enableCards: true,
        // Enable card payments only
        metadata: {
          booking_date: bookingDate,
          start_time: startTime,
          end_time: endTime,
          expected_amount: finalAmountCents.toString()
          // Store expected amount for verification
        }
      });
      res.json({
        paymentIntentId: paymentIntent.id,
        clientSecret: paymentIntent.clientSecret,
        amount: finalAmountCents,
        currency: kitchenPricing.currency
      });
    } catch (error) {
      console.error("Error creating payment intent:", error);
      res.status(500).json({
        error: "Failed to create payment intent",
        message: error.message
      });
    }
  });
  app3.post("/api/payments/confirm", requireChef, async (req, res) => {
    try {
      const { paymentIntentId, paymentMethodId } = req.body;
      const chefId = req.user.id;
      if (!paymentIntentId || !paymentMethodId) {
        return res.status(400).json({ error: "Missing paymentIntentId or paymentMethodId" });
      }
      const { confirmPaymentIntent: confirmPaymentIntent2, getPaymentIntent: getPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
      const paymentIntent = await getPaymentIntent2(paymentIntentId);
      if (!paymentIntent) {
        return res.status(404).json({ error: "Payment intent not found" });
      }
      const confirmed = await confirmPaymentIntent2(paymentIntentId, paymentMethodId);
      res.json({
        paymentIntentId: confirmed.id,
        status: confirmed.status
      });
    } catch (error) {
      console.error("Error confirming payment:", error);
      res.status(500).json({
        error: "Failed to confirm payment",
        message: error.message
      });
    }
  });
  app3.get("/api/payments/intent/:id/status", requireChef, async (req, res) => {
    try {
      const { id } = req.params;
      const chefId = req.user.id;
      const { getPaymentIntent: getPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
      const paymentIntent = await getPaymentIntent2(id);
      if (!paymentIntent) {
        return res.status(404).json({ error: "Payment intent not found" });
      }
      res.json({
        paymentIntentId: paymentIntent.id,
        status: paymentIntent.status
      });
    } catch (error) {
      console.error("Error getting payment intent status:", error);
      res.status(500).json({
        error: "Failed to get payment intent status",
        message: error.message
      });
    }
  });
  app3.post("/api/payments/capture", requireChef, async (req, res) => {
    res.status(410).json({
      error: "This endpoint is deprecated. Payments are now automatically captured when confirmed.",
      message: "With automatic capture enabled, payments are processed immediately. No manual capture is needed."
    });
  });
  app3.post("/api/payments/cancel", requireChef, async (req, res) => {
    try {
      const { paymentIntentId } = req.body;
      const chefId = req.user.id;
      if (!paymentIntentId) {
        return res.status(400).json({ error: "Missing paymentIntentId" });
      }
      const { cancelPaymentIntent: cancelPaymentIntent2, getPaymentIntent: getPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
      const paymentIntent = await getPaymentIntent2(paymentIntentId);
      if (!paymentIntent) {
        return res.status(404).json({ error: "Payment intent not found" });
      }
      const cancellableStatuses = ["requires_payment_method", "requires_capture", "requires_confirmation"];
      if (!cancellableStatuses.includes(paymentIntent.status)) {
        return res.status(400).json({
          error: `Payment intent cannot be cancelled. Current status: ${paymentIntent.status}`
        });
      }
      const canceled = await cancelPaymentIntent2(paymentIntentId);
      res.json({
        success: true,
        paymentIntentId: canceled.id,
        status: canceled.status,
        message: "Payment intent cancelled. Note: For captured payments, use refunds instead."
      });
    } catch (error) {
      console.error("Error canceling payment intent:", error);
      res.status(500).json({
        error: "Failed to cancel payment intent",
        message: error.message
      });
    }
  });
  app3.post("/api/chef/bookings", requireChef, async (req, res) => {
    try {
      const { kitchenId, bookingDate, startTime, endTime, specialNotes, selectedStorageIds, selectedStorage, selectedEquipmentIds, paymentIntentId } = req.body;
      const chefId = req.user.id;
      const kitchenLocationId1 = await firebaseStorage.getKitchenLocation(kitchenId);
      if (!kitchenLocationId1) {
        return res.status(400).json({ error: "Kitchen location not found" });
      }
      const applicationStatus = await firebaseStorage.getChefKitchenApplicationStatus(chefId, kitchenLocationId1);
      if (!applicationStatus.canBook) {
        return res.status(403).json({
          error: applicationStatus.message,
          hasApplication: applicationStatus.hasApplication,
          applicationStatus: applicationStatus.status
        });
      }
      const bookingDateObj = new Date(bookingDate);
      const availabilityCheck = await firebaseStorage.validateBookingAvailability(
        kitchenId,
        bookingDateObj,
        startTime,
        endTime
      );
      if (!availabilityCheck.valid) {
        return res.status(400).json({ error: availabilityCheck.error || "Booking is not within manager-set available hours" });
      }
      const kitchenLocationId2 = await firebaseStorage.getKitchenLocation(kitchenId);
      let location = null;
      let timezone = DEFAULT_TIMEZONE;
      let minimumBookingWindowHours = 1;
      if (kitchenLocationId2) {
        location = await firebaseStorage.getLocationById(kitchenLocationId2);
        if (location) {
          timezone = location.timezone || DEFAULT_TIMEZONE;
          const minWindow = location.minimumBookingWindowHours ?? location.minimum_booking_window_hours;
          if (minWindow !== null && minWindow !== void 0) {
            minimumBookingWindowHours = Number(minWindow);
            console.log(`[Booking Window] Using location minimum booking window: ${minimumBookingWindowHours} hours for kitchen ${kitchenId}`);
          } else {
            console.log(`[Booking Window] Location has no minimum booking window set, using default: 1 hour`);
          }
        }
      }
      const bookingDateStr = typeof bookingDate === "string" ? bookingDate.split("T")[0] : bookingDateObj.toISOString().split("T")[0];
      if (isBookingTimePast(bookingDateStr, startTime, timezone)) {
        return res.status(400).json({ error: "Cannot book a time slot that has already passed" });
      }
      const hoursUntilBooking = getHoursUntilBooking(bookingDateStr, startTime, timezone);
      if (hoursUntilBooking < minimumBookingWindowHours) {
        return res.status(400).json({
          error: `Bookings must be made at least ${minimumBookingWindowHours} hour${minimumBookingWindowHours !== 1 ? "s" : ""} in advance`
        });
      }
      const hasConflict = await firebaseStorage.checkBookingConflict(kitchenId, bookingDateObj, startTime, endTime);
      if (hasConflict) {
        return res.status(409).json({ error: "Time slot is already booked" });
      }
      const { pool: pool3 } = await Promise.resolve().then(() => (init_db(), db_exports));
      const [sH, sM] = String(startTime).split(":").map(Number);
      const [eH, eM] = String(endTime).split(":").map(Number);
      const requestedSlots = Math.max(1, Math.ceil((eH * 60 + eM - (sH * 60 + sM)) / 60));
      let maxSlotsPerChef = 2;
      if (pool3) {
        try {
          const overrideResult = await pool3.query(`
            SELECT max_slots_per_chef
            FROM kitchen_date_overrides
            WHERE kitchen_id = $1 AND DATE(specific_date) = $2::date
            ORDER BY updated_at DESC
            LIMIT 1
          `, [kitchenId, bookingDateStr]);
          if (overrideResult.rows.length > 0) {
            const val = Number(overrideResult.rows[0].max_slots_per_chef);
            if (Number.isFinite(val) && val > 0) {
              maxSlotsPerChef = val;
              console.log(`[Booking Limit] Using date override: ${maxSlotsPerChef} hours for kitchen ${kitchenId} on ${bookingDateStr}`);
            }
          } else {
            const locationLimitResult = await pool3.query(`
              SELECT l.default_daily_booking_limit, l.id as location_id, l.name as location_name
              FROM locations l
              INNER JOIN kitchens k ON k.location_id = l.id
              WHERE k.id = $1
            `, [kitchenId]);
            console.log(`[Booking Limit] Location query result for kitchen ${kitchenId}:`, {
              rowCount: locationLimitResult.rows.length,
              rawValue: locationLimitResult.rows[0]?.default_daily_booking_limit,
              locationId: locationLimitResult.rows[0]?.location_id,
              locationName: locationLimitResult.rows[0]?.location_name
            });
            if (locationLimitResult.rows.length > 0) {
              const rawValue = locationLimitResult.rows[0].default_daily_booking_limit;
              const locVal = rawValue !== null && rawValue !== void 0 ? Number(rawValue) : null;
              console.log(`[Booking Limit] Parsed location default value:`, {
                rawValue,
                locVal,
                isFinite: Number.isFinite(locVal),
                isPositive: locVal !== null && locVal > 0
              });
              if (locVal !== null && Number.isFinite(locVal) && locVal > 0) {
                maxSlotsPerChef = locVal;
                console.log(`[Booking Limit] \u2705 Using location default: ${maxSlotsPerChef} hours for kitchen ${kitchenId} (location: ${locationLimitResult.rows[0].location_name || locationLimitResult.rows[0].location_id})`);
              } else {
                console.warn(`[Booking Limit] \u26A0\uFE0F Invalid location default value: ${locVal} (raw: ${rawValue}), using fallback: 2`);
                maxSlotsPerChef = 2;
              }
            } else {
              console.warn(`[Booking Limit] \u26A0\uFE0F No location found for kitchen ${kitchenId}, using fallback: 2`);
            }
          }
        } catch (error) {
          console.error("Error fetching daily booking limit:", error);
          maxSlotsPerChef = 2;
        }
        const existingBookings = await pool3.query(`
          SELECT start_time, end_time
          FROM kitchen_bookings
          WHERE chef_id = $1
            AND kitchen_id = $2
            AND DATE(booking_date) = $3::date
            AND status IN ('pending','confirmed')
        `, [chefId, kitchenId, bookingDateStr]);
        let existingSlots = 0;
        for (const b of existingBookings.rows) {
          const [bsH, bsM] = String(b.start_time).split(":").map(Number);
          const [beH, beM] = String(b.end_time).split(":").map(Number);
          const span = Math.max(1, Math.ceil((beH * 60 + beM - (bsH * 60 + bsM)) / 60));
          existingSlots += span;
        }
        if (existingSlots + requestedSlots > maxSlotsPerChef) {
          return res.status(400).json({
            error: `Booking exceeds daily limit. Allowed: ${maxSlotsPerChef} hour(s).`
          });
        }
      }
      let paymentStatus = "pending";
      if (paymentIntentId) {
        console.log(`\u{1F4B3} STEP 0: Verifying payment intent ${paymentIntentId}...`);
        const { verifyPaymentIntentForBooking: verifyPaymentIntentForBooking2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
        const { calculateKitchenBookingPrice: calculateKitchenBookingPrice2, calculatePlatformFeeDynamic: calculatePlatformFeeDynamic2, calculateTotalWithFees: calculateTotalWithFees2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
        const kitchenPricing = await calculateKitchenBookingPrice2(kitchenId, startTime, endTime, pool3);
        let expectedTotal = kitchenPricing.totalPriceCents;
        if (pool3 && selectedStorage && Array.isArray(selectedStorage) && selectedStorage.length > 0) {
          for (const storage3 of selectedStorage) {
            try {
              const storageResult = await pool3.query(
                `SELECT base_price, pricing_model, minimum_booking_duration FROM storage_listings WHERE id = $1`,
                [storage3.storageListingId]
              );
              if (storageResult.rows.length > 0) {
                const sl = storageResult.rows[0];
                const basePrice = parseInt(sl.base_price || "0");
                const startDate = new Date(storage3.startDate);
                const endDate = new Date(storage3.endDate);
                const days = Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24));
                const effectiveDays = Math.max(days, sl.minimum_booking_duration || 1);
                let storagePrice = basePrice * effectiveDays;
                if (sl.pricing_model === "hourly") {
                  const hours = Math.max(1, Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60)));
                  storagePrice = basePrice * hours;
                } else if (sl.pricing_model === "monthly-flat") {
                  storagePrice = basePrice;
                }
                expectedTotal += storagePrice;
              }
            } catch (e) {
              console.error("Error calculating storage for verification:", e);
            }
          }
        }
        if (pool3 && selectedEquipmentIds && Array.isArray(selectedEquipmentIds)) {
          for (const equipmentId of selectedEquipmentIds) {
            try {
              const equipmentResult = await pool3.query(
                `SELECT session_rate, damage_deposit FROM equipment_listings WHERE id = $1 AND availability_type != 'included'`,
                [equipmentId]
              );
              if (equipmentResult.rows.length > 0) {
                const eq5 = equipmentResult.rows[0];
                expectedTotal += parseInt(eq5.session_rate || "0") + parseInt(eq5.damage_deposit || "0");
              }
            } catch (e) {
              console.error("Error calculating equipment for verification:", e);
            }
          }
        }
        const serviceFee = await calculatePlatformFeeDynamic2(expectedTotal, pool3);
        const stripeProcessingFeeCents = 30;
        const totalServiceFee = serviceFee + stripeProcessingFeeCents;
        expectedTotal = calculateTotalWithFees2(expectedTotal, totalServiceFee, 0);
        const verification = await verifyPaymentIntentForBooking2(paymentIntentId, chefId, expectedTotal);
        if (!verification.valid) {
          return res.status(400).json({
            error: verification.error || "Payment verification failed",
            paymentStatus: verification.status
          });
        }
        paymentStatus = verification.status === "succeeded" || verification.status === "processing" ? "paid" : "pending";
        console.log(`\u2705 STEP 0 COMPLETE: Payment verified with status: ${paymentStatus} (Stripe status: ${verification.status})`);
      } else {
        const { calculateKitchenBookingPrice: calculateKitchenBookingPrice2, calculatePlatformFeeDynamic: calculatePlatformFeeDynamic2, calculateTotalWithFees: calculateTotalWithFees2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
        const kitchenPricing = await calculateKitchenBookingPrice2(kitchenId, startTime, endTime, pool3);
        const serviceFee = await calculatePlatformFeeDynamic2(kitchenPricing.totalPriceCents, pool3);
        const stripeProcessingFeeCents = 30;
        const totalServiceFee = serviceFee + stripeProcessingFeeCents;
        const total = calculateTotalWithFees2(kitchenPricing.totalPriceCents, totalServiceFee, 0);
        if (total > 0) {
          return res.status(400).json({
            error: "Payment required for this booking. Please complete payment first.",
            requiresPayment: true
          });
        }
      }
      console.log(`\u{1F4DD} STEP 1: Creating booking in database...`);
      const bookingData = {
        chefId: req.user.id,
        kitchenId,
        bookingDate: new Date(bookingDate),
        startTime,
        endTime,
        specialNotes
      };
      if (paymentIntentId) {
        bookingData.paymentIntentId = paymentIntentId;
      }
      if (paymentStatus) {
        bookingData.paymentStatus = paymentStatus;
      }
      const booking = await firebaseStorage.createKitchenBooking(bookingData);
      console.log(`\u2705 STEP 1 COMPLETE: Booking ${booking.id} created successfully`);
      const storageBookingsCreated = [];
      const equipmentBookingsCreated = [];
      if (pool3 && (selectedStorage && Array.isArray(selectedStorage) && selectedStorage.length > 0 || selectedStorageIds?.length > 0 || selectedEquipmentIds?.length > 0)) {
        console.log(`\u{1F4E6} STEP 1.5: Creating add-on bookings...`);
        const bookingStartDateTime = /* @__PURE__ */ new Date(`${bookingDateStr}T${startTime}`);
        const bookingEndDateTime = /* @__PURE__ */ new Date(`${bookingDateStr}T${endTime}`);
        if (selectedStorage && Array.isArray(selectedStorage) && selectedStorage.length > 0) {
          for (const storage3 of selectedStorage) {
            try {
              const storageListingId = storage3.storageListingId;
              const startDate = new Date(storage3.startDate);
              const endDate = new Date(storage3.endDate);
              if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                console.error(`   \u26A0\uFE0F Invalid dates for storage booking ${storageListingId}`);
                continue;
              }
              if (startDate >= endDate) {
                console.error(`   \u26A0\uFE0F Storage booking ${storageListingId}: End date must be after start date`);
                continue;
              }
              const storageResult = await pool3.query(
                `SELECT id, pricing_model, base_price, minimum_booking_duration, currency FROM storage_listings WHERE id = $1`,
                [storageListingId]
              );
              if (storageResult.rows.length > 0) {
                const storageListing = storageResult.rows[0];
                const basePriceCents = storageListing.base_price ? parseInt(storageListing.base_price) : 0;
                const minDays = storageListing.minimum_booking_duration || 1;
                const days = Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24));
                const effectiveDays = Math.max(days, minDays);
                if (days < minDays) {
                  console.error(`   \u26A0\uFE0F Storage booking ${storageListingId}: Requires minimum ${minDays} days, got ${days}`);
                  continue;
                }
                let totalPrice = basePriceCents * effectiveDays;
                if (storageListing.pricing_model === "hourly") {
                  const durationHours = Math.max(1, Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60)));
                  totalPrice = basePriceCents * durationHours;
                } else if (storageListing.pricing_model === "monthly-flat") {
                  totalPrice = basePriceCents;
                }
                const { calculatePlatformFeeDynamic: calculatePlatformFeeDynamic2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
                const serviceFeeBase = await calculatePlatformFeeDynamic2(totalPrice, pool3);
                const stripeProcessingFeeCents = 30;
                const serviceFee = serviceFeeBase + stripeProcessingFeeCents;
                const insertResult = await pool3.query(
                  `INSERT INTO storage_bookings 
                    (storage_listing_id, kitchen_booking_id, chef_id, start_date, end_date, status, total_price, pricing_model, payment_status, service_fee, currency)
                   VALUES ($1, $2, $3, $4, $5, 'pending', $6, $7, 'pending', $8, $9)
                   RETURNING id`,
                  [
                    storageListingId,
                    booking.id,
                    chefId,
                    startDate,
                    endDate,
                    totalPrice.toString(),
                    storageListing.pricing_model,
                    serviceFee.toString(),
                    storageListing.currency || "CAD"
                  ]
                );
                storageBookingsCreated.push({
                  id: insertResult.rows[0].id,
                  storageListingId,
                  totalPrice: totalPrice / 100
                  // Return in dollars
                });
                console.log(`   \u2705 Storage booking created: listing ${storageListingId}, ${effectiveDays} days, price: $${(totalPrice / 100).toFixed(2)}`);
              }
            } catch (storageError) {
              console.error(`   \u26A0\uFE0F Failed to create storage booking:`, storageError);
            }
          }
        }
        if (selectedStorageIds && Array.isArray(selectedStorageIds) && selectedStorageIds.length > 0) {
          for (const storageListingId of selectedStorageIds) {
            try {
              const storageResult = await pool3.query(
                `SELECT id, pricing_model, base_price, currency FROM storage_listings WHERE id = $1`,
                [storageListingId]
              );
              if (storageResult.rows.length > 0) {
                const storageListing = storageResult.rows[0];
                const basePriceCents = storageListing.base_price ? parseInt(storageListing.base_price) : 0;
                let totalPrice = basePriceCents;
                const durationHours = Math.max(1, Math.ceil((bookingEndDateTime.getTime() - bookingStartDateTime.getTime()) / (1e3 * 60 * 60)));
                if (storageListing.pricing_model === "hourly") {
                  totalPrice = basePriceCents * durationHours;
                } else if (storageListing.pricing_model === "daily") {
                  totalPrice = basePriceCents * Math.ceil(durationHours / 24);
                }
                const { calculatePlatformFeeDynamic: calcFee2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
                const serviceFeeBase = await calcFee2(totalPrice, pool3);
                const stripeProcessingFeeCents = 30;
                const serviceFee = serviceFeeBase + stripeProcessingFeeCents;
                const insertResult = await pool3.query(
                  `INSERT INTO storage_bookings 
                    (storage_listing_id, kitchen_booking_id, chef_id, start_date, end_date, status, total_price, pricing_model, payment_status, service_fee, currency)
                   VALUES ($1, $2, $3, $4, $5, 'pending', $6, $7, 'pending', $8, $9)
                   RETURNING id`,
                  [
                    storageListingId,
                    booking.id,
                    chefId,
                    bookingStartDateTime,
                    bookingEndDateTime,
                    totalPrice.toString(),
                    storageListing.pricing_model,
                    serviceFee.toString(),
                    storageListing.currency || "CAD"
                  ]
                );
                storageBookingsCreated.push({
                  id: insertResult.rows[0].id,
                  storageListingId,
                  totalPrice: totalPrice / 100
                  // Return in dollars
                });
                console.log(`   \u2705 Storage booking created: listing ${storageListingId}, price: $${(totalPrice / 100).toFixed(2)}`);
              }
            } catch (storageError) {
              console.error(`   \u26A0\uFE0F Failed to create storage booking for listing ${storageListingId}:`, storageError);
            }
          }
        }
        if (selectedEquipmentIds && Array.isArray(selectedEquipmentIds)) {
          for (const equipmentListingId of selectedEquipmentIds) {
            try {
              const equipmentResult = await pool3.query(
                `SELECT id, availability_type, session_rate, damage_deposit, currency 
                 FROM equipment_listings WHERE id = $1`,
                [equipmentListingId]
              );
              if (equipmentResult.rows.length > 0) {
                const equipmentListing = equipmentResult.rows[0];
                if (equipmentListing.availability_type === "included") {
                  console.log(`   \u2139\uFE0F Skipping equipment ${equipmentListingId} - it's included with kitchen`);
                  continue;
                }
                const sessionRateCents = equipmentListing.session_rate ? parseInt(equipmentListing.session_rate) : 0;
                const totalPrice = sessionRateCents;
                const damageDepositCents = equipmentListing.damage_deposit ? parseInt(equipmentListing.damage_deposit) : 0;
                const { calculatePlatformFeeDynamic: calcEquipFee2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
                const serviceFeeBase = await calcEquipFee2(totalPrice, pool3);
                const stripeProcessingFeeCents = 30;
                const serviceFee = serviceFeeBase + stripeProcessingFeeCents;
                const insertResult = await pool3.query(
                  `INSERT INTO equipment_bookings 
                    (equipment_listing_id, kitchen_booking_id, chef_id, start_date, end_date, status, total_price, pricing_model, damage_deposit, payment_status, service_fee, currency)
                   VALUES ($1, $2, $3, $4, $5, 'pending', $6, $7, $8, 'pending', $9, $10)
                   RETURNING id`,
                  [
                    equipmentListingId,
                    booking.id,
                    chefId,
                    bookingStartDateTime,
                    bookingEndDateTime,
                    totalPrice.toString(),
                    "hourly",
                    // Equipment uses session_rate (flat fee), but pricing_model field requires a value
                    damageDepositCents.toString(),
                    serviceFee.toString(),
                    equipmentListing.currency || "CAD"
                  ]
                );
                equipmentBookingsCreated.push({
                  id: insertResult.rows[0].id,
                  equipmentListingId,
                  totalPrice: totalPrice / 100
                  // Return in dollars
                });
                console.log(`   \u2705 Equipment booking created: listing ${equipmentListingId}, price: $${(totalPrice / 100).toFixed(2)}`);
              }
            } catch (equipmentError) {
              console.error(`   \u26A0\uFE0F Failed to create equipment booking for listing ${equipmentListingId}:`, equipmentError);
            }
          }
        }
        console.log(`\u2705 STEP 1.5 COMPLETE: Created ${storageBookingsCreated.length} storage and ${equipmentBookingsCreated.length} equipment bookings`);
      }
      console.log(`\u{1F4E7} STEP 2: Starting sequential email notification process for booking ${booking.id}`);
      let emailResults = {
        chefEmailSent: false,
        managerEmailSent: false,
        errors: []
      };
      try {
        console.log(`\u{1F4E7} STEP 2.1: Fetching kitchen details...`);
        const kitchen = await firebaseStorage.getKitchenById(kitchenId);
        if (!kitchen) {
          const errorMsg = `Kitchen ${kitchenId} not found`;
          console.error(`\u274C STEP 2.1 FAILED: ${errorMsg}`);
          emailResults.errors.push(errorMsg);
          throw new Error(errorMsg);
        }
        console.log(`\u2705 STEP 2.1 COMPLETE: Kitchen found - ${kitchen.name || kitchenId}`);
        console.log(`\u{1F4E7} STEP 2.2: Fetching location details from database...`);
        const kitchenLocationId = kitchen.locationId || kitchen.location_id;
        if (!kitchenLocationId) {
          const errorMsg = `Kitchen ${kitchenId} has no locationId`;
          console.error(`\u274C STEP 2.2 FAILED: ${errorMsg}`);
          emailResults.errors.push(errorMsg);
          throw new Error(errorMsg);
        }
        console.log(`\u2705 STEP 2.2 PROGRESS: Kitchen locationId is ${kitchenLocationId}`);
        if (!pool3) {
          const errorMsg = `Database pool not available`;
          console.error(`\u274C STEP 2.2 FAILED: ${errorMsg}`);
          emailResults.errors.push(errorMsg);
          throw new Error(errorMsg);
        }
        const locationData = await pool3.query(`
          SELECT l.id, l.name, l.manager_id, l.notification_email, l.timezone
          FROM locations l
          WHERE l.id = $1
        `, [kitchenLocationId]);
        if (locationData.rows.length === 0) {
          const errorMsg = `Location ${kitchenLocationId} not found`;
          console.error(`\u274C STEP 2.2 FAILED: ${errorMsg}`);
          emailResults.errors.push(errorMsg);
          throw new Error(errorMsg);
        }
        const location2 = locationData.rows[0];
        console.log(`\u2705 STEP 2.2 COMPLETE: Location found - ${location2.name}, Notification Email: ${location2.notification_email || "NOT SET"}`);
        console.log(`\u{1F4E7} STEP 2.3: Fetching chef details...`);
        const chef = await storage2.getUser(req.user.id);
        if (!chef) {
          const errorMsg = `Chef ${req.user.id} not found`;
          console.error(`\u274C STEP 2.3 FAILED: ${errorMsg}`);
          emailResults.errors.push(errorMsg);
          throw new Error(errorMsg);
        }
        console.log(`\u2705 STEP 2.3 COMPLETE: Chef found - ${chef.username || "unknown"}`);
        console.log(`\u{1F4E7} STEP 2.4: Fetching manager details from database...`);
        const managerId = location2.manager_id;
        console.log(`\u{1F4CB} STEP 2.4 PROGRESS: Manager ID from location: ${managerId || "NOT SET"}`);
        let manager = null;
        if (managerId) {
          const managerData = await pool3.query(`
            SELECT id, username
            FROM users
            WHERE id = $1
          `, [managerId]);
          if (managerData.rows.length > 0) {
            manager = managerData.rows[0];
            console.log(`\u2705 STEP 2.4 COMPLETE: Manager found - ${manager.username || "unknown"}`);
          } else {
            console.warn(`\u26A0\uFE0F STEP 2.4 WARNING: Manager ${managerId} not found in database, will use notification email only`);
          }
        } else {
          console.log(`\u2705 STEP 2.4 COMPLETE: No manager ID set, will rely on location notification email`);
        }
        console.log(`\u{1F4E7} STEP 2.5: Enriching chef name and phone from application...`);
        let chefName = chef.username || "Chef";
        let chefPhone = null;
        if (pool3 && req.user.id) {
          chefPhone = await getChefPhone(req.user.id, pool3);
          try {
            const appResult = await pool3.query(
              "SELECT full_name FROM applications WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1",
              [req.user.id]
            );
            if (appResult.rows.length > 0 && appResult.rows[0].full_name) {
              chefName = appResult.rows[0].full_name;
            }
            console.log(`\u2705 STEP 2.5 COMPLETE: Using application full name "${chefName}"${chefPhone ? `, phone: ${chefPhone}` : ""}`);
          } catch (error) {
            console.debug(`Could not get full name for chef ${req.user.id} from applications, using username`);
          }
          if (!chefPhone) {
            console.log(`\u2705 STEP 2.5 COMPLETE: No application found, using username`);
          }
        } else {
          console.log(`\u2705 STEP 2.5 COMPLETE: Pool not available, using username`);
        }
        console.log(`\u{1F4E7} STEP 2.6: Sending booking request email to chef...`);
        const chefEmailAddress = chef.username;
        if (!chefEmailAddress) {
          const errorMsg = `Chef ${req.user.id} has no email address (username)`;
          console.error(`\u274C STEP 2.6 FAILED: ${errorMsg}`);
          emailResults.errors.push(errorMsg);
        } else {
          console.log(`\u{1F4E7} STEP 2.6 PROGRESS: Attempting to send to chef: ${chefEmailAddress}`);
          try {
            const chefEmail = generateBookingRequestEmail({
              chefEmail: chefEmailAddress,
              chefName,
              kitchenName: kitchen.name || "Kitchen",
              bookingDate,
              startTime,
              endTime,
              specialNotes: specialNotes || "",
              timezone: location2.timezone || timezone,
              locationName: location2.name || kitchen.name || "Kitchen"
            });
            console.log(`\u{1F4E7} STEP 2.6 PROGRESS: Generated chef email - To: ${chefEmail.to}, Subject: ${chefEmail.subject}`);
            const emailSent = await sendEmail(chefEmail);
            if (emailSent) {
              console.log(`\u2705 STEP 2.6 COMPLETE: Booking request email sent successfully to chef: ${chefEmailAddress}`);
              emailResults.chefEmailSent = true;
            } else {
              const errorMsg = `sendEmail() returned false for chef email: ${chefEmailAddress}`;
              console.error(`\u274C STEP 2.6 FAILED: ${errorMsg}`);
              emailResults.errors.push(errorMsg);
            }
          } catch (chefEmailError) {
            const errorMsg = `Exception sending chef email: ${chefEmailError instanceof Error ? chefEmailError.message : String(chefEmailError)}`;
            console.error(`\u274C STEP 2.6 FAILED: ${errorMsg}`);
            console.error("Chef email error stack:", chefEmailError instanceof Error ? chefEmailError.stack : "No stack trace");
            emailResults.errors.push(errorMsg);
          }
        }
        console.log(`\u{1F4E7} STEP 2.7: Sending booking notification email to manager...`);
        const notificationEmailAddress = location2.notification_email || (manager ? manager.username : null);
        if (!notificationEmailAddress) {
          const errorMsg = `No notification email available - location.notification_email: ${location2.notification_email || "NOT SET"}, manager.username: ${manager?.username || "N/A"}`;
          console.error(`\u274C STEP 2.7 FAILED: ${errorMsg}`);
          console.error(`   Location ID: ${kitchenLocationId}, Manager ID from location: ${managerId || "NOT SET"}`);
          emailResults.errors.push(errorMsg);
        } else {
          console.log(`\u{1F4E7} STEP 2.7 PROGRESS: Attempting to send to manager: ${notificationEmailAddress}`);
          console.log(`   Email source: ${location2.notification_email ? "location.notification_email" : "manager.username"}`);
          try {
            const managerEmail = generateBookingNotificationEmail({
              managerEmail: notificationEmailAddress,
              chefName,
              kitchenName: kitchen.name || "Kitchen",
              bookingDate,
              startTime,
              endTime,
              specialNotes: specialNotes || "",
              timezone: location2.timezone || timezone,
              locationName: location2.name || kitchen.name || "Kitchen"
            });
            console.log(`\u{1F4E7} STEP 2.7 PROGRESS: Generated manager email - To: ${managerEmail.to}, Subject: ${managerEmail.subject}`);
            const emailSent = await sendEmail(managerEmail);
            if (emailSent) {
              console.log(`\u2705 STEP 2.7 COMPLETE: Booking notification email sent successfully to manager: ${notificationEmailAddress}`);
              emailResults.managerEmailSent = true;
            } else {
              const errorMsg = `sendEmail() returned false for manager email: ${notificationEmailAddress}`;
              console.error(`\u274C STEP 2.7 FAILED: ${errorMsg}`);
              console.error(`   This indicates the email sending failed silently. Check EMAIL_USER and EMAIL_PASS environment variables.`);
              emailResults.errors.push(errorMsg);
            }
          } catch (managerEmailError) {
            const errorMsg = `Exception sending manager email: ${managerEmailError instanceof Error ? managerEmailError.message : String(managerEmailError)}`;
            console.error(`\u274C STEP 2.7 FAILED: ${errorMsg}`);
            console.error("Manager email error stack:", managerEmailError instanceof Error ? managerEmailError.stack : "No stack trace");
            emailResults.errors.push(errorMsg);
          }
        }
        console.log(`\u{1F4F1} STEP 2.8: Sending booking notification SMS to manager...`);
        try {
          const locationForSMS = {
            ...location2,
            managerId: location2.manager_id,
            notificationEmail: location2.notification_email
          };
          const managerPhone = await getManagerPhone(locationForSMS, managerId, pool3);
          if (managerPhone) {
            const smsMessage = generateManagerBookingSMS({
              chefName,
              kitchenName: kitchen.name || "Kitchen",
              bookingDate,
              startTime,
              endTime
            });
            const smsSent = await sendSMS(managerPhone, smsMessage, { trackingId: `booking_${booking.id}_manager` });
            if (smsSent) {
              console.log(`\u2705 STEP 2.8 COMPLETE: Booking notification SMS sent successfully to manager: ${managerPhone}`);
            } else {
              console.warn(`\u26A0\uFE0F STEP 2.8 WARNING: SMS sending failed for manager: ${managerPhone}`);
            }
          } else {
            console.log(`\u{1F4F1} STEP 2.8 SKIPPED: No manager phone number available`);
          }
        } catch (smsError) {
          console.error(`\u274C STEP 2.8 ERROR: Exception sending manager SMS:`, smsError);
        }
        console.log(`\u{1F4E7} STEP 2 COMPLETE: Email notification process finished for booking ${booking.id}`);
        console.log(`   Chef email: ${emailResults.chefEmailSent ? "\u2705 SENT" : "\u274C FAILED"}`);
        console.log(`   Manager email: ${emailResults.managerEmailSent ? "\u2705 SENT" : "\u274C FAILED"}`);
        if (emailResults.errors.length > 0) {
          console.log(`   Errors encountered: ${emailResults.errors.length}`);
          emailResults.errors.forEach((error, index) => {
            console.log(`     ${index + 1}. ${error}`);
          });
        }
      } catch (emailError) {
        const errorMsg = emailError instanceof Error ? emailError.message : String(emailError);
        console.error(`\u274C STEP 2 CRITICAL ERROR: ${errorMsg}`);
        console.error("Email error details:", errorMsg);
        console.error("Email error stack:", emailError instanceof Error ? emailError.stack : "No stack trace");
        emailResults.errors.push(`Critical error: ${errorMsg}`);
      }
      console.log(`\u{1F4DD} FINAL: Booking ${booking.id} created. Email status: Chef=${emailResults.chefEmailSent ? "sent" : "failed"}, Manager=${emailResults.managerEmailSent ? "sent" : "failed"}`);
      res.status(201).json({
        ...booking,
        storageBookings: storageBookingsCreated,
        equipmentBookings: equipmentBookingsCreated
      });
    } catch (error) {
      console.error("Error creating booking:", error);
      res.status(500).json({ error: "Failed to create booking" });
    }
  });
  app3.get("/api/chef/bookings", requireChef, async (req, res) => {
    try {
      const chefId = req.user.id;
      console.log(`[CHEF BOOKINGS] Fetching bookings for chef ID: ${chefId}`);
      console.log(`[CHEF BOOKINGS] User object:`, { id: req.user.id, username: req.user.username, isChef: req.user.isChef });
      const bookings = await firebaseStorage.getBookingsByChef(chefId);
      console.log(`[CHEF BOOKINGS] Found ${bookings.length} bookings for chef ${chefId}`);
      if (bookings.length > 0) {
        console.log(`[CHEF BOOKINGS] First booking sample:`, {
          id: bookings[0].id,
          chefId: bookings[0].chefId || bookings[0].chef_id,
          kitchenId: bookings[0].kitchenId || bookings[0].kitchen_id,
          bookingDate: bookings[0].bookingDate || bookings[0].booking_date
        });
      }
      res.json(bookings);
    } catch (error) {
      console.error("Error fetching bookings:", error);
      res.status(500).json({ error: "Failed to fetch bookings" });
    }
  });
  app3.post("/api/bookings/checkout", async (req, res) => {
    try {
      const { bookingId, managerStripeAccountId, bookingPrice, customerEmail } = req.body;
      if (!bookingId || !managerStripeAccountId || !bookingPrice || !customerEmail) {
        return res.status(400).json({
          error: "Missing required fields: bookingId, managerStripeAccountId, bookingPrice, and customerEmail are required"
        });
      }
      const bookingPriceNum = parseFloat(bookingPrice);
      if (isNaN(bookingPriceNum) || bookingPriceNum <= 0) {
        return res.status(400).json({
          error: "bookingPrice must be a positive number"
        });
      }
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(customerEmail)) {
        return res.status(400).json({
          error: "Invalid email format"
        });
      }
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const bookingResult = await pool.query(
        "SELECT id, kitchen_id FROM kitchen_bookings WHERE id = $1",
        [bookingId]
      );
      if (bookingResult.rows.length === 0) {
        return res.status(404).json({ error: "Booking not found" });
      }
      const booking = bookingResult.rows[0];
      const { calculateCheckoutFees: calculateCheckoutFees2 } = await Promise.resolve().then(() => (init_stripe_checkout_fee_service(), stripe_checkout_fee_service_exports));
      const feeCalculation = calculateCheckoutFees2(bookingPriceNum);
      const protocol = req.get("x-forwarded-proto") || req.protocol || "https";
      const host = req.get("x-forwarded-host") || req.get("host") || "localhost:3000";
      const baseUrl = `${protocol}://${host}`;
      const { createCheckoutSession: createCheckoutSession2 } = await Promise.resolve().then(() => (init_stripe_checkout_service(), stripe_checkout_service_exports));
      const checkoutSession = await createCheckoutSession2({
        bookingPriceInCents: feeCalculation.bookingPriceInCents,
        platformFeeInCents: feeCalculation.totalPlatformFeeInCents,
        managerStripeAccountId,
        customerEmail,
        bookingId,
        currency: "cad",
        successUrl: `${baseUrl}/booking-success?session_id={CHECKOUT_SESSION_ID}`,
        cancelUrl: `${baseUrl}/booking-cancel?booking_id=${bookingId}`,
        metadata: {
          booking_id: bookingId.toString(),
          kitchen_id: booking.kitchen_id.toString()
        }
      });
      const { createTransaction: createTransaction2 } = await Promise.resolve().then(() => (init_stripe_checkout_transactions_service(), stripe_checkout_transactions_service_exports));
      await createTransaction2(
        {
          bookingId,
          stripeSessionId: checkoutSession.sessionId,
          customerEmail,
          bookingAmountCents: feeCalculation.bookingPriceInCents,
          platformFeePercentageCents: feeCalculation.percentageFeeInCents,
          platformFeeFlatCents: feeCalculation.flatFeeInCents,
          totalPlatformFeeCents: feeCalculation.totalPlatformFeeInCents,
          totalCustomerChargedCents: feeCalculation.totalChargeInCents,
          managerReceivesCents: feeCalculation.bookingPriceInCents,
          // Manager receives the booking amount
          metadata: {
            booking_id: bookingId,
            kitchen_id: booking.kitchen_id,
            manager_account_id: managerStripeAccountId
          }
        },
        pool
      );
      res.json({
        sessionUrl: checkoutSession.sessionUrl,
        sessionId: checkoutSession.sessionId,
        booking: {
          price: bookingPriceNum,
          platformFee: feeCalculation.totalPlatformFeeInCents / 100,
          total: feeCalculation.totalChargeInCents / 100
        }
      });
    } catch (error) {
      console.error("Error creating checkout session:", error);
      res.status(500).json({
        error: error.message || "Failed to create checkout session"
      });
    }
  });
  app3.get("/api/chef/storage-bookings", requireChef, async (req, res) => {
    try {
      const storageBookings2 = await firebaseStorage.getStorageBookingsByChef(req.user.id);
      res.json(storageBookings2);
    } catch (error) {
      console.error("Error fetching storage bookings:", error);
      res.status(500).json({ error: "Failed to fetch storage bookings" });
    }
  });
  app3.get("/api/chef/storage-bookings/:id", requireChef, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id) || id <= 0) {
        return res.status(400).json({ error: "Invalid storage booking ID" });
      }
      const booking = await firebaseStorage.getStorageBookingById(id);
      if (!booking) {
        return res.status(404).json({ error: "Storage booking not found" });
      }
      if (booking.chefId !== req.user.id) {
        return res.status(403).json({ error: "You don't have permission to view this booking" });
      }
      res.json(booking);
    } catch (error) {
      console.error("Error fetching storage booking:", error);
      res.status(500).json({ error: error.message || "Failed to fetch storage booking" });
    }
  });
  app3.post("/api/admin/storage-bookings/process-overstayer-penalties", async (req, res) => {
    try {
      const { maxDaysToCharge } = req.body;
      const processed = await firebaseStorage.processOverstayerPenalties(maxDaysToCharge || 7);
      res.json({
        success: true,
        processed: processed.length,
        bookings: processed,
        message: `Processed ${processed.length} overstayer penalty charges`
      });
    } catch (error) {
      console.error("Error processing overstayer penalties:", error);
      res.status(500).json({ error: error.message || "Failed to process overstayer penalties" });
    }
  });
  app3.put("/api/chef/storage-bookings/:id/extend", requireChef, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id) || id <= 0) {
        return res.status(400).json({ error: "Invalid storage booking ID" });
      }
      const { newEndDate } = req.body;
      if (!newEndDate) {
        return res.status(400).json({ error: "newEndDate is required" });
      }
      const booking = await firebaseStorage.getStorageBookingById(id);
      if (!booking) {
        return res.status(404).json({ error: "Storage booking not found" });
      }
      if (booking.chefId !== req.user.id) {
        return res.status(403).json({ error: "You don't have permission to extend this booking" });
      }
      if (booking.status === "cancelled") {
        return res.status(400).json({ error: "Cannot extend a cancelled booking" });
      }
      const newEndDateObj = new Date(newEndDate);
      if (isNaN(newEndDateObj.getTime())) {
        return res.status(400).json({ error: "Invalid date format for newEndDate" });
      }
      const extendedBooking = await firebaseStorage.extendStorageBooking(id, newEndDateObj);
      res.json({
        success: true,
        booking: extendedBooking,
        message: `Storage booking extended successfully. Additional cost: $${extendedBooking.extensionDetails.extensionTotalPrice.toFixed(2)} CAD`
      });
    } catch (error) {
      console.error("Error extending storage booking:", error);
      res.status(500).json({ error: error.message || "Failed to extend storage booking" });
    }
  });
  app3.get("/api/chef/bookings/:id", requireChef, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id) || id <= 0) {
        return res.status(400).json({ error: "Invalid booking ID" });
      }
      const booking = await firebaseStorage.getBookingById(id);
      if (!booking) {
        return res.status(404).json({ error: "Booking not found" });
      }
      if (booking.chefId !== req.user.id) {
        return res.status(403).json({ error: "You don't have permission to view this booking" });
      }
      const storageBookings2 = await firebaseStorage.getStorageBookingsByKitchenBooking(id);
      const equipmentBookings2 = await firebaseStorage.getEquipmentBookingsByKitchenBooking(id);
      const kitchen = await firebaseStorage.getKitchenById(booking.kitchenId);
      res.json({
        ...booking,
        kitchen,
        storageBookings: storageBookings2,
        equipmentBookings: equipmentBookings2
      });
    } catch (error) {
      console.error("Error fetching booking details:", error);
      res.status(500).json({ error: error.message || "Failed to fetch booking details" });
    }
  });
  app3.get("/api/bookings/:id/invoice", requireChef, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id) || id <= 0) {
        return res.status(400).json({ error: "Invalid booking ID" });
      }
      const booking = await firebaseStorage.getBookingById(id);
      if (!booking) {
        return res.status(404).json({ error: "Booking not found" });
      }
      if (booking.chefId !== req.user.id) {
        return res.status(403).json({ error: "You don't have permission to view this invoice" });
      }
      const chef = await storage2.getUser(booking.chefId);
      const kitchen = await firebaseStorage.getKitchenById(booking.kitchenId);
      const storageBookings2 = await firebaseStorage.getStorageBookingsByKitchenBooking(id);
      const equipmentBookings2 = await firebaseStorage.getEquipmentBookingsByKitchenBooking(id);
      let location = null;
      if (kitchen && kitchen.locationId) {
        const locationId = kitchen.locationId || kitchen.location_id;
        if (pool) {
          const locationResult = await pool.query(
            "SELECT id, name, address FROM locations WHERE id = $1",
            [locationId]
          );
          if (locationResult.rows.length > 0) {
            location = locationResult.rows[0];
          }
        }
      }
      const paymentIntentId = booking.paymentIntentId || booking.payment_intent_id || null;
      const { generateInvoicePDF: generateInvoicePDF2 } = await Promise.resolve().then(() => (init_invoice_service(), invoice_service_exports));
      const pdfBuffer = await generateInvoicePDF2(
        booking,
        chef,
        kitchen,
        location,
        storageBookings2,
        equipmentBookings2,
        paymentIntentId,
        pool
      );
      res.setHeader("Content-Type", "application/pdf");
      const bookingDate = booking.bookingDate ? new Date(booking.bookingDate).toISOString().split("T")[0] : "unknown";
      res.setHeader("Content-Disposition", `attachment; filename="LocalCooks-Invoice-${id}-${bookingDate}.pdf"`);
      res.setHeader("Content-Length", pdfBuffer.length);
      res.send(pdfBuffer);
    } catch (error) {
      console.error("Error generating invoice:", error);
      res.status(500).json({ error: error.message || "Failed to generate invoice" });
    }
  });
  app3.put("/api/chef/bookings/:id/cancel", requireChef, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (!pool) {
        return res.status(500).json({ error: "Database not available" });
      }
      const bookingResult = await pool.query(`
        SELECT 
          kb.*,
          l.cancellation_policy_hours,
          l.cancellation_policy_message
        FROM kitchen_bookings kb
        JOIN kitchens k ON kb.kitchen_id = k.id
        JOIN locations l ON k.location_id = l.id
        WHERE kb.id = $1 AND kb.chef_id = $2
      `, [id, req.user.id]);
      if (bookingResult.rows.length === 0) {
        return res.status(404).json({ error: "Booking not found" });
      }
      const booking = bookingResult.rows[0];
      const bookingDateTime = /* @__PURE__ */ new Date(`${booking.booking_date.toISOString().split("T")[0]}T${booking.start_time}`);
      const now = /* @__PURE__ */ new Date();
      const hoursUntilBooking = (bookingDateTime.getTime() - now.getTime()) / (1e3 * 60 * 60);
      const cancellationHours = booking.cancellation_policy_hours || 24;
      if (booking.payment_intent_id && hoursUntilBooking >= cancellationHours && booking.payment_status === "paid") {
        try {
          const { createRefund: createRefund2, getPaymentIntent: getPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
          const paymentIntent = await getPaymentIntent2(booking.payment_intent_id);
          if (paymentIntent && (paymentIntent.status === "succeeded" || paymentIntent.status === "processing")) {
            const refund = await createRefund2(booking.payment_intent_id, void 0, "requested_by_customer");
            console.log(`[Cancel Booking] Created refund for booking ${id} (PaymentIntent: ${booking.payment_intent_id}, Refund: ${refund.id})`);
            await pool.query(`
              UPDATE kitchen_bookings 
              SET payment_status = 'refunded'
              WHERE id = $1
            `, [id]);
          }
        } catch (error) {
          console.error(`[Cancel Booking] Error creating refund for booking ${id}:`, error);
        }
      }
      await firebaseStorage.cancelKitchenBooking(id, req.user.id);
      try {
        const kitchen = await firebaseStorage.getKitchenById(booking.kitchenId);
        if (!kitchen) {
          console.warn(`\u26A0\uFE0F Kitchen ${booking.kitchenId} not found for email notification`);
        } else {
          const kitchenLocationId = kitchen.locationId || kitchen.location_id;
          if (!kitchenLocationId) {
            console.warn(`\u26A0\uFE0F Kitchen ${booking.kitchenId} has no locationId`);
          } else if (!pool) {
            console.warn(`\u26A0\uFE0F Database pool not available for email notification`);
          } else {
            const locationData = await pool.query(`
              SELECT l.id, l.name, l.manager_id, l.notification_email
              FROM locations l
              WHERE l.id = $1
            `, [kitchenLocationId]);
            if (locationData.rows.length === 0) {
              console.warn(`\u26A0\uFE0F Location ${kitchenLocationId} not found for email notification`);
            } else {
              const location = locationData.rows[0];
              const chef = await storage2.getUser(booking.chefId);
              if (!chef) {
                console.warn(`\u26A0\uFE0F Chef ${booking.chefId} not found for email notification`);
              } else {
                const managerId = location.manager_id;
                let manager = null;
                if (managerId) {
                  const managerData = await pool.query(`
                    SELECT id, username
                    FROM users
                    WHERE id = $1
                  `, [managerId]);
                  if (managerData.rows.length > 0) {
                    manager = managerData.rows[0];
                  }
                }
                const chefPhone = await getChefPhone(booking.chefId, pool);
                const { sendEmail: sendEmail2, generateBookingCancellationEmail: generateBookingCancellationEmail2, generateBookingCancellationNotificationEmail: generateBookingCancellationNotificationEmail3 } = await Promise.resolve().then(() => (init_email(), email_exports));
                try {
                  const chefEmail = generateBookingCancellationEmail2({
                    chefEmail: chef.username || "",
                    chefName: chef.username || "Chef",
                    kitchenName: kitchen.name || "Kitchen",
                    bookingDate: booking.bookingDate,
                    startTime: booking.startTime,
                    endTime: booking.endTime,
                    cancellationReason: "You cancelled this booking"
                  });
                  await sendEmail2(chefEmail);
                  console.log(`\u2705 Booking cancellation email sent to chef: ${chef.username}`);
                } catch (emailError) {
                  console.error("Error sending chef cancellation email:", emailError);
                }
                if (chefPhone) {
                  try {
                    const smsMessage = generateChefSelfCancellationSMS({
                      kitchenName: kitchen.name || "Kitchen",
                      bookingDate: booking.bookingDate,
                      startTime: booking.startTime,
                      endTime: booking.endTime
                    });
                    await sendSMS(chefPhone, smsMessage, { trackingId: `booking_${id}_chef_self_cancelled` });
                    console.log(`\u2705 Booking cancellation SMS sent to chef: ${chefPhone}`);
                  } catch (smsError) {
                    console.error("Error sending chef cancellation SMS:", smsError);
                  }
                }
                const notificationEmailAddress = location.notification_email || (manager ? manager.username : null);
                if (notificationEmailAddress) {
                  try {
                    const managerEmail = generateBookingCancellationNotificationEmail3({
                      managerEmail: notificationEmailAddress,
                      chefName: chef.username || "Chef",
                      kitchenName: kitchen.name || "Kitchen",
                      bookingDate: booking.bookingDate,
                      startTime: booking.startTime,
                      endTime: booking.endTime,
                      cancellationReason: "Cancelled by chef"
                    });
                    await sendEmail2(managerEmail);
                    console.log(`\u2705 Booking cancellation notification email sent to manager: ${notificationEmailAddress}`);
                  } catch (emailError) {
                    console.error("Error sending manager cancellation email:", emailError);
                    console.error("Manager email error details:", emailError instanceof Error ? emailError.message : emailError);
                  }
                } else {
                  console.warn(`\u26A0\uFE0F No notification email found for location ${kitchenLocationId}`);
                }
                try {
                  const managerPhone = await getManagerPhone(location, managerId, pool);
                  if (managerPhone) {
                    const smsMessage = generateManagerBookingCancellationSMS({
                      chefName: chef.username || "Chef",
                      kitchenName: kitchen.name || "Kitchen",
                      bookingDate: booking.bookingDate,
                      startTime: booking.startTime,
                      endTime: booking.endTime
                    });
                    await sendSMS(managerPhone, smsMessage, { trackingId: `booking_${id}_manager_cancelled` });
                    console.log(`\u2705 Booking cancellation SMS sent to manager: ${managerPhone}`);
                  }
                } catch (smsError) {
                  console.error("Error sending manager cancellation SMS:", smsError);
                }
              }
            }
          }
        }
      } catch (emailError) {
        console.error("Error sending booking cancellation emails:", emailError);
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error cancelling booking:", error);
      res.status(500).json({ error: error instanceof Error ? error.message : "Failed to cancel booking" });
    }
  });
  app3.post("/api/chef/share-profile", requireChef, async (req, res) => {
    try {
      const { locationId } = req.body;
      const chefId = req.user.id;
      if (!locationId) {
        return res.status(400).json({ error: "locationId is required" });
      }
      const hasLocationAccess = await firebaseStorage.chefHasLocationAccess(chefId, locationId);
      if (!hasLocationAccess) {
        return res.status(403).json({ error: "You don't have access to this location. Please contact an administrator." });
      }
      const chef = await storage2.getUser(chefId);
      if (!chef) {
        return res.status(404).json({ error: "Chef not found" });
      }
      const location = await firebaseStorage.getLocationById(locationId);
      if (!location) {
        return res.status(404).json({ error: "Location not found" });
      }
      const chefApp = await db.select().from(applications).where(and4(
        eq4(applications.userId, chefId),
        eq4(applications.status, "approved")
      )).orderBy(desc2(applications.createdAt)).limit(1);
      const profile = await firebaseStorage.shareChefProfileWithLocation(chefId, locationId);
      if (profile && profile.status === "pending") {
        try {
          const managerEmail = location.notificationEmail || location.notification_email;
          if (managerEmail) {
            const chefName = chefApp.length > 0 && chefApp[0].fullName ? chefApp[0].fullName : chef.username || "Chef";
            const chefEmail = chefApp.length > 0 && chefApp[0].email ? chefApp[0].email : chef.email || chef.username || "chef@example.com";
            const emailContent = generateChefProfileRequestEmail({
              managerEmail,
              chefName,
              chefEmail,
              locationName: location.name || "Location",
              locationId
            });
            await sendEmail(emailContent);
            console.log(`\u2705 Chef profile request notification sent to manager: ${managerEmail}`);
          }
        } catch (emailError) {
          console.error("Error sending chef profile request notification:", emailError);
        }
      }
      res.status(201).json(profile);
    } catch (error) {
      console.error("Error sharing chef profile:", error);
      res.status(500).json({ error: error.message || "Failed to share profile" });
    }
  });
  app3.get("/api/chef/profiles", requireChef, async (req, res) => {
    try {
      const chefId = req.user.id;
      const locationAccessRecords = await db.select().from(chefLocationAccess).where(eq4(chefLocationAccess.chefId, chefId));
      const locationIds = locationAccessRecords.map((access) => access.locationId);
      if (locationIds.length === 0) {
        return res.json([]);
      }
      const allLocations = await db.select().from(locations).where(inArray2(locations.id, locationIds));
      const profiles = await Promise.all(
        locationIds.map(async (locationId) => {
          const profile = await firebaseStorage.getChefLocationProfile(chefId, locationId);
          const location = allLocations.find((l) => l.id === locationId);
          return { locationId, location, profile };
        })
      );
      res.json(profiles);
    } catch (error) {
      console.error("Error getting chef profiles:", error);
      res.status(500).json({ error: error.message || "Failed to get profiles" });
    }
  });
  app3.get("/api/admin/revenue/all-managers", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
    try {
      if (res.headersSent) {
        return;
      }
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const { startDate, endDate } = req.query;
      const { getServiceFeeRate: getServiceFeeRate2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
      const serviceFeeRate = await getServiceFeeRate2(pool);
      let bookingWhereClause = `AND kb.status != 'cancelled'`;
      const params = [];
      let paramIndex = 1;
      if (startDate) {
        bookingWhereClause += ` AND kb.booking_date >= $${paramIndex}::date`;
        params.push(startDate);
        paramIndex++;
      }
      if (endDate) {
        bookingWhereClause += ` AND kb.booking_date <= $${paramIndex}::date`;
        params.push(endDate);
        paramIndex++;
      }
      const result = await pool.query(`
        SELECT 
          u.id as manager_id,
          u.username as manager_name,
          u.username as manager_email,
          l.id as location_id,
          l.name as location_name,
          COALESCE(SUM(CASE WHEN kb.id IS NOT NULL THEN kb.total_price ELSE 0 END), 0)::bigint as total_revenue,
          COALESCE(SUM(CASE WHEN kb.id IS NOT NULL THEN kb.service_fee ELSE 0 END), 0)::bigint as platform_fee,
          COUNT(kb.id)::int as booking_count,
          COUNT(CASE WHEN kb.payment_status = 'paid' THEN 1 END)::int as paid_count
        FROM users u
        LEFT JOIN locations l ON l.manager_id = u.id
        LEFT JOIN kitchens k ON k.location_id = l.id
        LEFT JOIN kitchen_bookings kb ON kb.kitchen_id = k.id ${bookingWhereClause}
        WHERE u.role = $${paramIndex}
        GROUP BY u.id, u.username, l.id, l.name
        ORDER BY u.username ASC, total_revenue DESC
      `, [...params, "manager"]);
      const managerMap = /* @__PURE__ */ new Map();
      result.rows.forEach((row) => {
        const managerId = parseInt(row.manager_id);
        const totalRevenue = parseInt(row.total_revenue) || 0;
        const platformFee = parseInt(row.platform_fee) || 0;
        const managerRevenue = totalRevenue - platformFee;
        if (!managerMap.has(managerId)) {
          managerMap.set(managerId, {
            managerId,
            managerName: row.manager_name,
            managerEmail: row.manager_email,
            totalRevenue: 0,
            platformFee: 0,
            managerRevenue: 0,
            bookingCount: 0,
            paidBookingCount: 0,
            locations: []
          });
        }
        const manager = managerMap.get(managerId);
        manager.totalRevenue += totalRevenue;
        manager.platformFee += parseInt(row.platform_fee) || 0;
        manager.managerRevenue += managerRevenue;
        manager.bookingCount += parseInt(row.booking_count) || 0;
        manager.paidBookingCount += parseInt(row.paid_count) || 0;
        if (row.location_id) {
          manager.locations.push({
            locationId: parseInt(row.location_id),
            locationName: row.location_name || "Unnamed Location",
            totalRevenue,
            platformFee: parseInt(row.platform_fee) || 0,
            managerRevenue,
            bookingCount: parseInt(row.booking_count) || 0,
            paidBookingCount: parseInt(row.paid_count) || 0
          });
        }
      });
      const managers = Array.from(managerMap.values()).map((m) => ({
        ...m,
        totalRevenue: m.totalRevenue / 100,
        platformFee: m.platformFee / 100,
        managerRevenue: m.managerRevenue / 100,
        locations: m.locations.map((loc) => ({
          ...loc,
          totalRevenue: loc.totalRevenue / 100,
          platformFee: loc.platformFee / 100,
          managerRevenue: loc.managerRevenue / 100
        })),
        _raw: {
          totalRevenue: m.totalRevenue,
          platformFee: m.platformFee,
          managerRevenue: m.managerRevenue
        }
      }));
      res.json({ managers, total: managers.length });
    } catch (error) {
      console.error("Error getting all managers revenue:", error);
      res.status(500).json({ error: error.message || "Failed to get all managers revenue" });
    }
  });
  app3.get("/api/admin/revenue/platform-overview", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
    try {
      if (res.headersSent) {
        return;
      }
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const { startDate, endDate } = req.query;
      const managerCountResult = await pool.query(
        "SELECT COUNT(*)::int as total_managers FROM users WHERE role = $1",
        ["manager"]
      );
      const totalManagers = parseInt(managerCountResult.rows[0]?.total_managers || "0");
      let bookingWhereClause = `WHERE kb.status != 'cancelled'`;
      const params = [];
      let paramIndex = 1;
      if (startDate) {
        bookingWhereClause += ` AND kb.booking_date >= $${paramIndex}::date`;
        params.push(startDate);
        paramIndex++;
      }
      if (endDate) {
        bookingWhereClause += ` AND kb.booking_date <= $${paramIndex}::date`;
        params.push(endDate);
        paramIndex++;
      }
      const result = await pool.query(`
        SELECT 
          COALESCE(SUM(kb.total_price), 0)::bigint as total_revenue,
          COALESCE(SUM(kb.service_fee), 0)::bigint as platform_fee,
          COUNT(*)::int as booking_count,
          COUNT(CASE WHEN kb.payment_status = 'paid' THEN 1 END)::int as paid_count,
          COUNT(CASE WHEN kb.payment_status = 'pending' THEN 1 END)::int as pending_count
        FROM kitchen_bookings kb
        JOIN kitchens k ON kb.kitchen_id = k.id
        JOIN locations l ON k.location_id = l.id
        ${bookingWhereClause}
      `, params);
      const row = result.rows[0];
      res.json({
        totalPlatformRevenue: (parseInt(row.total_revenue) || 0) / 100,
        totalPlatformFees: (parseInt(row.platform_fee) || 0) / 100,
        activeManagers: totalManagers,
        // Use total managers count, not just those with bookings
        totalBookings: parseInt(row.booking_count) || 0,
        paidBookingCount: parseInt(row.paid_count) || 0,
        pendingBookingCount: parseInt(row.pending_count) || 0,
        _raw: {
          totalRevenue: parseInt(row.total_revenue) || 0,
          platformFee: parseInt(row.platform_fee) || 0
        }
      });
    } catch (error) {
      console.error("Error getting platform overview:", error);
      res.status(500).json({ error: error.message || "Failed to get platform overview" });
    }
  });
  app3.get("/api/admin/revenue/manager/:managerId", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
    try {
      if (res.headersSent) {
        return;
      }
      const managerId = parseInt(req.params.managerId);
      if (isNaN(managerId) || managerId <= 0) {
        return res.status(400).json({ error: "Invalid manager ID" });
      }
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const { startDate, endDate } = req.query;
      const { getCompleteRevenueMetrics: getCompleteRevenueMetrics2, getRevenueByLocation: getRevenueByLocation2 } = await Promise.resolve().then(() => (init_revenue_service(), revenue_service_exports));
      const metrics = await getCompleteRevenueMetrics2(
        managerId,
        pool,
        startDate ? new Date(startDate) : void 0,
        endDate ? new Date(endDate) : void 0
      );
      const revenueByLocation = await getRevenueByLocation2(
        managerId,
        pool,
        startDate ? new Date(startDate) : void 0,
        endDate ? new Date(endDate) : void 0
      );
      const managerResult = await pool.query(
        "SELECT id, username FROM users WHERE id = $1",
        [managerId]
      );
      res.json({
        manager: managerResult.rows[0] || null,
        metrics: {
          ...metrics,
          totalRevenue: metrics.totalRevenue / 100,
          platformFee: metrics.platformFee / 100,
          managerRevenue: metrics.managerRevenue / 100,
          pendingPayments: metrics.pendingPayments / 100,
          completedPayments: metrics.completedPayments / 100,
          averageBookingValue: metrics.averageBookingValue / 100,
          refundedAmount: metrics.refundedAmount / 100
        },
        revenueByLocation: revenueByLocation.map((loc) => ({
          ...loc,
          totalRevenue: loc.totalRevenue / 100,
          platformFee: loc.platformFee / 100,
          managerRevenue: loc.managerRevenue / 100
        }))
      });
    } catch (error) {
      console.error("Error getting manager revenue details:", error);
      res.status(500).json({ error: error.message || "Failed to get manager revenue details" });
    }
  });
  app3.post("/api/admin/chef-location-access", async (req, res) => {
    try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      if (user.role !== "admin") {
        return res.status(403).json({ error: "Admin access required" });
      }
      const { chefId, locationId } = req.body;
      if (!chefId || !locationId) {
        return res.status(400).json({ error: "chefId and locationId are required" });
      }
      const access = await firebaseStorage.grantChefLocationAccess(chefId, locationId, user.id);
      try {
        const location = await firebaseStorage.getLocationById(locationId);
        if (!location) {
          console.warn(`\u26A0\uFE0F Location ${locationId} not found for email notification`);
        } else {
          const chef = await storage2.getUser(chefId);
          if (!chef) {
            console.warn(`\u26A0\uFE0F Chef ${chefId} not found for email notification`);
          } else {
            try {
              const chefEmail = generateChefLocationAccessApprovedEmail({
                chefEmail: chef.username || "",
                chefName: chef.username || "Chef",
                locationName: location.name || "Location",
                locationId
              });
              await sendEmail(chefEmail);
              console.log(`\u2705 Chef location access granted email sent to chef: ${chef.username}`);
            } catch (emailError) {
              console.error("Error sending chef access email:", emailError);
              console.error("Chef email error details:", emailError instanceof Error ? emailError.message : emailError);
            }
          }
        }
      } catch (emailError) {
        console.error("Error sending chef access emails:", emailError);
      }
      res.status(201).json(access);
    } catch (error) {
      console.error("Error granting chef location access:", error);
      res.status(500).json({ error: error.message || "Failed to grant access" });
    }
  });
  app3.delete("/api/admin/chef-location-access", async (req, res) => {
    try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      if (user.role !== "admin") {
        return res.status(403).json({ error: "Admin access required" });
      }
      const { chefId, locationId } = req.body;
      if (!chefId || !locationId) {
        return res.status(400).json({ error: "chefId and locationId are required" });
      }
      await firebaseStorage.revokeChefLocationAccess(chefId, locationId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error revoking chef location access:", error);
      res.status(500).json({ error: error.message || "Failed to revoke access" });
    }
  });
  app3.get("/api/admin/chef-location-access", async (req, res) => {
    try {
      console.log("[Admin Chef Access] GET request received");
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      console.log("[Admin Chef Access] Auth check:", { hasSession: !!sessionUser, hasFirebase: !!isFirebaseAuth });
      if (!sessionUser && !isFirebaseAuth) {
        console.log("[Admin Chef Access] Not authenticated");
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      console.log("[Admin Chef Access] User:", { id: user.id, role: user.role });
      if (user.role !== "admin") {
        console.log("[Admin Chef Access] Not admin");
        return res.status(403).json({ error: "Admin access required" });
      }
      const allUsers = await db.select({
        id: users.id,
        username: users.username,
        role: users.role,
        isChef: users.isChef
      }).from(users);
      const chefs = allUsers.filter((u) => {
        const role = u.role;
        const isChef = u.isChef ?? u.is_chef;
        return role === "chef" || isChef === true;
      });
      console.log(`[Admin Chef Access] Total users: ${allUsers.length}, Found ${chefs.length} chefs in database`);
      console.log(`[Admin Chef Access] Chefs:`, chefs.map((c) => ({ id: c.id, username: c.username, role: c.role, isChef: c.isChef ?? c.is_chef })));
      const allLocations = await db.select().from(locations);
      console.log(`[Admin Chef Access] Found ${allLocations.length} locations`);
      let allAccess = [];
      try {
        allAccess = await db.select().from(chefLocationAccess);
        console.log(`[Admin Chef Access] Found ${allAccess.length} location access records`);
      } catch (error) {
        console.error(`[Admin Chef Access] Error querying chef_location_access table:`, error.message);
        if (error.message?.includes("does not exist") || error.message?.includes("relation") || error.code === "42P01") {
          console.log(`[Admin Chef Access] Table doesn't exist yet, returning empty access`);
          allAccess = [];
        } else {
          throw error;
        }
      }
      const response = chefs.map((chef) => {
        const chefAccess = allAccess.filter((a) => {
          const accessChefId = a.chefId ?? a.chef_id;
          return accessChefId === chef.id;
        });
        const accessibleLocations = chefAccess.map((access) => {
          const accessLocationId = access.locationId ?? access.location_id;
          const location = allLocations.find((l) => l.id === accessLocationId);
          if (location) {
            const grantedAt = access.grantedAt ?? access.granted_at;
            return {
              id: location.id,
              name: location.name,
              address: location.address ?? null,
              accessGrantedAt: grantedAt ? typeof grantedAt === "string" ? grantedAt : new Date(grantedAt).toISOString() : void 0
            };
          }
          return null;
        }).filter((l) => l !== null);
        return {
          chef: {
            id: chef.id,
            username: chef.username
          },
          accessibleLocations
        };
      });
      console.log(`[Admin Chef Access] Returning ${response.length} chefs with location access info`);
      res.json(response);
    } catch (error) {
      console.error("[Admin Chef Access] Error:", error);
      console.error("[Admin Chef Access] Error stack:", error.stack);
      res.status(500).json({ error: error.message || "Failed to get access" });
    }
  });
  app3.post("/api/admin/managers", async (req, res) => {
    try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      if (user.role !== "admin") {
        return res.status(403).json({ error: "Admin access required" });
      }
      const { username, password, email, name } = req.body;
      if (!username || !password) {
        return res.status(400).json({ error: "Username and password are required" });
      }
      const existingUser = await firebaseStorage.getUserByUsername(username);
      if (existingUser) {
        return res.status(400).json({ error: "Username already exists" });
      }
      const hashedPassword = await hashPassword(password);
      const manager = await firebaseStorage.createUser({
        username,
        password: hashedPassword,
        role: "manager",
        isChef: false,
        isManager: true,
        isPortalUser: false,
        has_seen_welcome: false
        // Manager must change password on first login
      });
      try {
        const managerEmail = email || username;
        const welcomeEmail = generateManagerCredentialsEmail({
          email: managerEmail,
          name: name || "Manager",
          username,
          password
        });
        await sendEmail(welcomeEmail);
        console.log(`\u2705 Welcome email with credentials sent to manager: ${managerEmail}`);
      } catch (emailError) {
        console.error("Error sending manager welcome email:", emailError);
        console.error("Email error details:", emailError instanceof Error ? emailError.message : emailError);
      }
      res.status(201).json({ success: true, managerId: manager.id });
    } catch (error) {
      console.error("Error creating manager:", error);
      console.error("Error details:", error.message, error.stack);
      res.status(500).json({ error: error.message || "Failed to create manager" });
    }
  });
  app3.get("/api/admin/managers", async (req, res) => {
    try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      if (user.role !== "admin") {
        return res.status(403).json({ error: "Admin access required" });
      }
      const { pool: pool3, db: db3 } = await Promise.resolve().then(() => (init_db(), db_exports));
      console.log("\u{1F50D} GET /api/admin/managers - Pool available?", !!pool3);
      console.log("\u{1F50D} GET /api/admin/managers - DB available?", !!db3);
      if (pool3) {
        console.log("\u2705 Using pool query for GET /api/admin/managers");
        const result = await pool3.query(
          `SELECT 
            u.id, 
            u.username, 
            u.role,
            COALESCE(
              json_agg(
                json_build_object(
                  'locationId', l.id,
                  'locationName', l.name,
                  'notificationEmail', l.notification_email
                )
              ) FILTER (WHERE l.id IS NOT NULL),
              '[]'::json
            ) as locations
          FROM users u
          LEFT JOIN locations l ON l.manager_id = u.id
          WHERE u.role = $1
          GROUP BY u.id, u.username, u.role
          ORDER BY u.username ASC`,
          ["manager"]
        );
        console.log("\u{1F4CA} Database query executed, rows returned:", result.rows.length);
        if (result.rows.length > 0) {
          console.log("\u{1F4CA} First row from database:", {
            id: result.rows[0].id,
            username: result.rows[0].username,
            role: result.rows[0].role,
            locations: result.rows[0].locations,
            locationsType: typeof result.rows[0].locations,
            locationsIsArray: Array.isArray(result.rows[0].locations)
          });
        }
        console.log(`\u{1F4CA} Raw database result - ${result.rows.length} manager(s) found`);
        if (result.rows.length > 0) {
          console.log(`\u{1F4CA} First row keys:`, Object.keys(result.rows[0]));
          console.log(`\u{1F4CA} First row locations property:`, result.rows[0].locations);
          console.log(`\u{1F4CA} First row locations type:`, typeof result.rows[0].locations);
        }
        const managersWithEmails = result.rows.map((row) => {
          let locations2 = row.locations;
          console.log(`\u{1F50D} Manager ${row.id} (${row.username}): raw locations =`, typeof locations2, locations2);
          console.log(`\u{1F50D} Manager ${row.id}: row object keys:`, Object.keys(row));
          if (locations2 === null || locations2 === void 0) {
            console.log(`\u26A0\uFE0F Manager ${row.id}: locations is null/undefined, using empty array`);
            locations2 = [];
          } else if (typeof locations2 === "string") {
            try {
              const trimmed = locations2.trim();
              if (trimmed === "[]" || trimmed === "" || trimmed === "null") {
                locations2 = [];
                console.log(`\u2705 Manager ${row.id}: Empty locations string converted to array`);
              } else {
                locations2 = JSON.parse(locations2);
                console.log(`\u2705 Manager ${row.id}: Parsed JSON string, got ${Array.isArray(locations2) ? locations2.length : "non-array"} items`);
              }
            } catch (e) {
              console.error(`\u274C Error parsing locations JSON for manager ${row.id}:`, e, "Raw value:", locations2);
              locations2 = [];
            }
          } else if (typeof locations2 === "object") {
            console.log(`\u2705 Manager ${row.id}: locations is already object, isArray=${Array.isArray(locations2)}`);
          }
          if (!Array.isArray(locations2)) {
            console.warn(`\u26A0\uFE0F Manager ${row.id} locations is not an array after processing:`, typeof locations2, locations2);
            if (locations2 && typeof locations2 === "object" && "0" in locations2) {
              locations2 = Object.values(locations2);
            } else {
              locations2 = [];
            }
          }
          console.log(`\u2705 Manager ${row.id} (${row.username}) FINAL: ${locations2.length} location(s):`, JSON.stringify(locations2, null, 2));
          const notificationEmails = locations2.map((loc) => loc.notificationEmail || loc.notification_email).filter((email) => email && email.trim() !== "");
          const mappedLocations = locations2.map((loc) => {
            const locationId = loc.locationId || loc.location_id || loc.id;
            const locationName = loc.locationName || loc.location_name || loc.name;
            const notificationEmail = loc.notificationEmail || loc.notification_email || null;
            return {
              locationId,
              locationName,
              notificationEmail
            };
          });
          const managerData = {
            id: row.id,
            username: row.username,
            role: row.role
          };
          managerData.locations = mappedLocations;
          console.log(`\u{1F4E6} Manager ${row.id} FINAL structure (BEFORE return):`, {
            id: managerData.id,
            username: managerData.username,
            role: managerData.role,
            hasLocationsProperty: "locations" in managerData,
            locationsCount: managerData.locations?.length || 0,
            locationsIsArray: Array.isArray(managerData.locations),
            locationsValue: managerData.locations,
            fullObject: JSON.stringify(managerData, null, 2)
          });
          if (!("locations" in managerData)) {
            console.error(`\u274C CRITICAL ERROR: Manager ${row.id} object missing locations property!`);
            managerData.locations = [];
          }
          return managerData;
        });
        console.log("\u{1F4E4} GET /api/admin/managers - managersWithEmails.length:", managersWithEmails.length);
        if (managersWithEmails.length > 0) {
          const firstManager = managersWithEmails[0];
          console.log("\u{1F4E4} managersWithEmails[0] keys:", Object.keys(firstManager));
          console.log("\u{1F4E4} managersWithEmails[0] has locations?", "locations" in firstManager);
          console.log("\u{1F4E4} managersWithEmails[0].locations:", firstManager.locations);
          console.log("\u{1F4E4} managersWithEmails[0].locations type:", typeof firstManager.locations);
          console.log("\u{1F4E4} managersWithEmails[0].locations is array?", Array.isArray(firstManager.locations));
          console.log("\u{1F4E4} managersWithEmails[0] FULL OBJECT:", JSON.stringify(firstManager, null, 2));
        }
        const verifiedManagers = managersWithEmails.map((manager) => {
          if (!manager.hasOwnProperty("locations")) {
            console.error(`\u274C Manager ${manager.id} is missing locations property! Adding it.`);
            manager.locations = [];
          } else if (!Array.isArray(manager.locations)) {
            console.warn(`\u26A0\uFE0F Manager ${manager.id} has locations but it's not an array (${typeof manager.locations}), converting`);
            manager.locations = Array.isArray(manager.locations) ? manager.locations : [];
          }
          return {
            id: manager.id,
            username: manager.username,
            role: manager.role,
            locations: Array.isArray(manager.locations) ? manager.locations : []
          };
        });
        console.log("\u{1F4E4} FINAL VERIFIED - First manager structure:", {
          id: verifiedManagers[0]?.id,
          username: verifiedManagers[0]?.username,
          role: verifiedManagers[0]?.role,
          hasLocations: "locations" in verifiedManagers[0],
          locationsCount: verifiedManagers[0]?.locations?.length || 0,
          locationsIsArray: Array.isArray(verifiedManagers[0]?.locations),
          locations: verifiedManagers[0]?.locations,
          fullJSON: JSON.stringify(verifiedManagers[0], null, 2)
        });
        console.log(`\u{1F4E4} GET /api/admin/managers - Returning ${verifiedManagers.length} managers to client`);
        console.log("\u{1F4E4} SENDING RESPONSE - Full response array:", JSON.stringify(verifiedManagers, null, 2));
        return res.json(verifiedManagers);
      } else {
        try {
          console.log("\u26A0\uFE0F Using Drizzle fallback for GET /api/admin/managers");
          const { users: users2, locations: locations2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const { eq: eq5 } = await import("drizzle-orm");
          const managerRows = await db3.select({ id: users2.id, username: users2.username, role: users2.role }).from(users2).where(eq5(users2.role, "manager"));
          console.log(`Found ${managerRows.length} managers with Drizzle`);
          const managersWithLocations = await Promise.all(
            managerRows.map(async (manager) => {
              const managerLocations = await db3.select().from(locations2).where(eq5(locations2.managerId, manager.id));
              console.log(`Manager ${manager.id} has ${managerLocations.length} locations`);
              const notificationEmails = managerLocations.map((loc) => loc.notificationEmail || loc.notification_email).filter((email) => email && email.trim() !== "");
              const managerData = {
                id: manager.id,
                username: manager.username,
                role: manager.role
              };
              managerData.locations = managerLocations.map((loc) => ({
                locationId: loc.id,
                locationName: loc.name,
                notificationEmail: loc.notificationEmail || loc.notification_email || null
              }));
              console.log(`\u{1F4E4} Drizzle Manager ${manager.id} final structure:`, {
                id: managerData.id,
                username: managerData.username,
                role: managerData.role,
                hasLocations: "locations" in managerData,
                locationCount: managerData.locations.length,
                locations: managerData.locations,
                fullJSON: JSON.stringify(managerData, null, 2)
              });
              return managerData;
            })
          );
          console.log("\u{1F4E4} Drizzle fallback returning", managersWithLocations.length, "managers");
          if (managersWithLocations.length > 0) {
            console.log("\u{1F4E4} Drizzle managersWithLocations[0] FULL:", JSON.stringify(managersWithLocations[0], null, 2));
          }
          return res.json(managersWithLocations);
        } catch (e) {
          console.error("\u274C Error fetching managers with Drizzle:", e);
          return res.json([]);
        }
      }
    } catch (error) {
      console.error("Error fetching managers:", error);
      res.status(500).json({ error: error.message || "Failed to fetch managers" });
    }
  });
  app3.post("/api/manager/change-password", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
    try {
      const user = req.neonUser;
      const { currentPassword, newPassword } = req.body;
      if (!currentPassword || !newPassword) {
        return res.status(400).json({ error: "Current password and new password are required" });
      }
      if (newPassword.length < 8) {
        return res.status(400).json({ error: "New password must be at least 8 characters long" });
      }
      const fullUser = await storage2.getUser(user.id);
      if (!fullUser) {
        return res.status(404).json({ error: "User not found" });
      }
      const passwordMatches = await comparePasswords(currentPassword, fullUser.password);
      if (!passwordMatches) {
        return res.status(400).json({ error: "Current password is incorrect" });
      }
      const hashedNewPassword = await hashPassword(newPassword);
      const { pool: pool3 } = await Promise.resolve().then(() => (init_db(), db_exports));
      if (pool3) {
        await pool3.query(
          "UPDATE users SET password = $1 WHERE id = $2",
          [hashedNewPassword, user.id]
        );
      } else {
        const memUser = await storage2.getUser(user.id);
        if (memUser) {
          memUser.password = hashedNewPassword;
        }
      }
      await storage2.setUserHasSeenWelcome(user.id);
      res.json({ success: true, message: "Password changed successfully" });
    } catch (error) {
      console.error("Error changing password:", error);
      res.status(500).json({ error: error.message || "Failed to change password" });
    }
  });
  app3.get("/api/admin/locations", async (req, res) => {
    try {
      const isSessionAuth = req.isAuthenticated?.();
      const isFirebaseAuth = req.neonUser;
      if (!isSessionAuth && !isFirebaseAuth) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : req.user;
      if (user.role !== "admin") {
        return res.status(403).json({ error: "Admin access required" });
      }
      const locations2 = await firebaseStorage.getAllLocations();
      console.log(`\u{1F4CD} GET /api/admin/locations - Found ${locations2.length} locations in database`);
      if (locations2.length > 0) {
        console.log(`\u{1F4CD} First location:`, {
          id: locations2[0].id,
          name: locations2[0].name,
          managerId: locations2[0].managerId || locations2[0].manager_id
        });
      }
      const mappedLocations = locations2.map((loc) => ({
        ...loc,
        managerId: loc.managerId || loc.manager_id || null,
        notificationEmail: loc.notificationEmail || loc.notification_email || null,
        cancellationPolicyHours: loc.cancellationPolicyHours || loc.cancellation_policy_hours || 24,
        cancellationPolicyMessage: loc.cancellationPolicyMessage || loc.cancellation_policy_message || "Bookings cannot be cancelled within {hours} hours of the scheduled time.",
        defaultDailyBookingLimit: loc.defaultDailyBookingLimit || loc.default_daily_booking_limit || 2,
        createdAt: loc.createdAt || loc.created_at,
        updatedAt: loc.updatedAt || loc.updated_at
      }));
      console.log(`\u{1F4CD} GET /api/admin/locations - Returning ${mappedLocations.length} locations to client`);
      res.json(mappedLocations);
    } catch (error) {
      console.error("Error fetching locations:", error);
      res.status(500).json({ error: "Failed to fetch locations" });
    }
  });
  app3.post("/api/admin/locations", async (req, res) => {
    try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      if (user.role !== "admin") {
        return res.status(403).json({ error: "Admin access required" });
      }
      const { name, address, managerId } = req.body;
      let managerIdNum = void 0;
      if (managerId !== void 0 && managerId !== null && managerId !== "") {
        managerIdNum = parseInt(managerId.toString());
        if (isNaN(managerIdNum) || managerIdNum <= 0) {
          return res.status(400).json({ error: "Invalid manager ID format" });
        }
        const manager = await firebaseStorage.getUser(managerIdNum);
        if (!manager) {
          return res.status(400).json({ error: `Manager with ID ${managerIdNum} does not exist` });
        }
        if (manager.role !== "manager") {
          return res.status(400).json({ error: `User with ID ${managerIdNum} is not a manager` });
        }
      }
      let normalizedNotificationPhone = void 0;
      if (req.body.notificationPhone && req.body.notificationPhone.trim() !== "") {
        const normalized = normalizePhoneForStorage(req.body.notificationPhone);
        if (!normalized) {
          return res.status(400).json({
            error: "Invalid notification phone number format. Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
          });
        }
        normalizedNotificationPhone = normalized;
      }
      console.log("Creating location with:", { name, address, managerId: managerIdNum, notificationPhone: normalizedNotificationPhone });
      const location = await firebaseStorage.createLocation({
        name,
        address,
        managerId: managerIdNum,
        notificationEmail: req.body.notificationEmail || void 0,
        notificationPhone: normalizedNotificationPhone
      });
      const mappedLocation = {
        ...location,
        managerId: location.managerId || location.manager_id || null,
        notificationEmail: location.notificationEmail || location.notification_email || null,
        notificationPhone: location.notificationPhone || location.notification_phone || null,
        cancellationPolicyHours: location.cancellationPolicyHours || location.cancellation_policy_hours || 24,
        cancellationPolicyMessage: location.cancellationPolicyMessage || location.cancellation_policy_message || "Bookings cannot be cancelled within {hours} hours of the scheduled time.",
        defaultDailyBookingLimit: location.defaultDailyBookingLimit || location.default_daily_booking_limit || 2,
        createdAt: location.createdAt || location.created_at,
        updatedAt: location.updatedAt || location.updated_at
      };
      res.status(201).json(mappedLocation);
    } catch (error) {
      console.error("Error creating location:", error);
      console.error("Error details:", error.message, error.stack);
      res.status(500).json({ error: error.message || "Failed to create location" });
    }
  });
  app3.get("/api/admin/kitchens/:locationId", async (req, res) => {
    try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      if (user.role !== "admin") {
        return res.status(403).json({ error: "Admin access required" });
      }
      const locationId = parseInt(req.params.locationId);
      if (isNaN(locationId) || locationId <= 0) {
        return res.status(400).json({ error: "Invalid location ID" });
      }
      const kitchens2 = await firebaseStorage.getKitchensByLocation(locationId);
      res.json(kitchens2);
    } catch (error) {
      console.error("Error fetching kitchens:", error);
      res.status(500).json({ error: error.message || "Failed to fetch kitchens" });
    }
  });
  app3.post("/api/admin/kitchens", async (req, res) => {
    try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      if (user.role !== "admin") {
        return res.status(403).json({ error: "Admin access required" });
      }
      const { locationId, name, description } = req.body;
      if (!locationId || !name) {
        return res.status(400).json({ error: "Location ID and name are required" });
      }
      const locationIdNum = parseInt(locationId.toString());
      if (isNaN(locationIdNum) || locationIdNum <= 0) {
        return res.status(400).json({ error: "Invalid location ID format" });
      }
      const location = await firebaseStorage.getLocationById(locationIdNum);
      if (!location) {
        return res.status(400).json({ error: `Location with ID ${locationIdNum} does not exist` });
      }
      const kitchen = await firebaseStorage.createKitchen({ locationId: locationIdNum, name, description, isActive: true });
      res.status(201).json(kitchen);
    } catch (error) {
      console.error("Error creating kitchen:", error);
      console.error("Error details:", error.message, error.stack);
      if (error.code === "23503") {
        return res.status(400).json({ error: "The selected location does not exist or is invalid." });
      }
      res.status(500).json({ error: error.message || "Failed to create kitchen" });
    }
  });
  app3.put("/api/admin/locations/:id", async (req, res) => {
    try {
      console.log(`\u{1F4CD} PUT /api/admin/locations/:id - Request received for location ID: ${req.params.id}`);
      console.log(`\u{1F4CD} Request body:`, JSON.stringify(req.body, null, 2));
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        console.error("\u274C PUT /api/admin/locations/:id - Not authenticated");
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      if (user.role !== "admin") {
        console.error(`\u274C PUT /api/admin/locations/:id - User ${user.id} is not admin (role: ${user.role})`);
        return res.status(403).json({ error: "Admin access required" });
      }
      const locationId = parseInt(req.params.id);
      if (isNaN(locationId) || locationId <= 0) {
        console.error(`\u274C Invalid location ID: ${req.params.id}`);
        return res.status(400).json({ error: "Invalid location ID" });
      }
      console.log(`\u2705 Validated - updating location ${locationId} for admin user ${user.id}`);
      const { name, address, managerId, notificationEmail, notificationPhone } = req.body;
      let managerIdNum = void 0;
      if (managerId !== void 0 && managerId !== null && managerId !== "") {
        managerIdNum = parseInt(managerId.toString());
        if (isNaN(managerIdNum) || managerIdNum <= 0) {
          return res.status(400).json({ error: "Invalid manager ID format" });
        }
        const manager = await firebaseStorage.getUser(managerIdNum);
        if (!manager) {
          return res.status(400).json({ error: `Manager with ID ${managerIdNum} does not exist` });
        }
        if (manager.role !== "manager") {
          return res.status(400).json({ error: `User with ID ${managerIdNum} is not a manager` });
        }
      } else if (managerId === null || managerId === "") {
        managerIdNum = null;
      }
      const updates = {};
      if (name !== void 0) updates.name = name;
      if (address !== void 0) updates.address = address;
      if (managerIdNum !== void 0) updates.managerId = managerIdNum;
      if (notificationEmail !== void 0) updates.notificationEmail = notificationEmail || null;
      if (notificationPhone !== void 0) {
        if (notificationPhone && notificationPhone.trim() !== "") {
          const normalized = normalizePhoneForStorage(notificationPhone);
          if (!normalized) {
            return res.status(400).json({
              error: "Invalid phone number format. Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
            });
          }
          updates.notificationPhone = normalized;
        } else {
          updates.notificationPhone = null;
        }
      }
      console.log(`\u{1F4BE} Updating location ${locationId} with:`, updates);
      const updated = await firebaseStorage.updateLocation(locationId, updates);
      if (!updated) {
        console.error(`\u274C Location ${locationId} not found in database`);
        return res.status(404).json({ error: "Location not found" });
      }
      console.log(`\u2705 Location ${locationId} updated successfully`);
      const mappedLocation = {
        ...updated,
        managerId: updated.managerId || updated.manager_id || null,
        notificationEmail: updated.notificationEmail || updated.notification_email || null,
        cancellationPolicyHours: updated.cancellationPolicyHours || updated.cancellation_policy_hours || 24,
        cancellationPolicyMessage: updated.cancellationPolicyMessage || updated.cancellation_policy_message || "Bookings cannot be cancelled within {hours} hours of the scheduled time.",
        defaultDailyBookingLimit: updated.defaultDailyBookingLimit || updated.default_daily_booking_limit || 2,
        createdAt: updated.createdAt || updated.created_at,
        updatedAt: updated.updatedAt || updated.updated_at
      };
      return res.json(mappedLocation);
    } catch (error) {
      console.error("\u274C Error updating location:", error);
      console.error("Error stack:", error.stack);
      res.status(500).json({ error: error.message || "Failed to update location" });
    }
  });
  app3.delete("/api/admin/locations/:id", async (req, res) => {
    try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      if (user.role !== "admin") {
        return res.status(403).json({ error: "Admin access required" });
      }
      const locationId = parseInt(req.params.id);
      if (isNaN(locationId) || locationId <= 0) {
        return res.status(400).json({ error: "Invalid location ID" });
      }
      await firebaseStorage.deleteLocation(locationId);
      res.json({ success: true, message: "Location deleted successfully" });
    } catch (error) {
      console.error("Error deleting location:", error);
      res.status(500).json({ error: error.message || "Failed to delete location" });
    }
  });
  app3.put("/api/admin/kitchens/:id", async (req, res) => {
    try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      if (user.role !== "admin") {
        return res.status(403).json({ error: "Admin access required" });
      }
      const kitchenId = parseInt(req.params.id);
      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      const currentKitchen = await firebaseStorage.getKitchenById(kitchenId);
      if (!currentKitchen) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const { name, description, isActive, locationId } = req.body;
      const updates = {};
      const changesList = [];
      if (name !== void 0 && name !== currentKitchen.name) {
        updates.name = name;
        changesList.push(`Name changed to "${name}"`);
      }
      if (description !== void 0 && description !== currentKitchen.description) {
        updates.description = description;
        changesList.push(`Description updated`);
      }
      if (isActive !== void 0 && isActive !== currentKitchen.isActive) {
        updates.isActive = isActive;
        changesList.push(`Status changed to ${isActive ? "Active" : "Inactive"}`);
      }
      if (locationId !== void 0) {
        const locationIdNum = parseInt(locationId.toString());
        if (isNaN(locationIdNum) || locationIdNum <= 0) {
          return res.status(400).json({ error: "Invalid location ID format" });
        }
        const location = await firebaseStorage.getLocationById(locationIdNum);
        if (!location) {
          return res.status(400).json({ error: `Location with ID ${locationIdNum} does not exist` });
        }
        if (locationIdNum !== currentKitchen.locationId) {
          updates.locationId = locationIdNum;
          changesList.push(`Location changed to "${location.name}"`);
        }
      }
      if (Object.keys(updates).length === 0) {
        return res.json(currentKitchen);
      }
      const updated = await firebaseStorage.updateKitchen(kitchenId, updates);
      if (!updated) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      if (changesList.length > 0) {
        try {
          const kitchen = await firebaseStorage.getKitchenById(kitchenId);
          if (kitchen) {
            const location = await firebaseStorage.getLocationById(kitchen.locationId);
            const bookings = await firebaseStorage.getBookingsByKitchen(kitchenId);
            const uniqueChefIds = Array.from(new Set(bookings.map((b) => b.chefId)));
            const changes = changesList.join(", ");
            for (const chefId of uniqueChefIds) {
              try {
                const chef = await storage2.getUser(chefId);
                if (chef) {
                  const email = generateKitchenSettingsChangeEmail({
                    email: chef.username,
                    name: chef.displayName || chef.username || "Chef",
                    kitchenName: kitchen.name,
                    changes,
                    isChef: true
                  });
                  await sendEmail(email);
                  console.log(`\u2705 Kitchen settings change email sent to chef: ${chef.username}`);
                }
              } catch (emailError) {
                console.error(`Error sending email to chef ${chefId}:`, emailError);
              }
            }
            if (location?.managerId) {
              try {
                const manager = await storage2.getUser(location.managerId);
                if (manager) {
                  const notificationEmail = location.notificationEmail || location.notification_email || manager.username;
                  const email = generateKitchenSettingsChangeEmail({
                    email: notificationEmail,
                    name: manager.username,
                    kitchenName: kitchen.name,
                    changes,
                    isChef: false
                  });
                  await sendEmail(email);
                  console.log(`\u2705 Kitchen settings change email sent to manager: ${notificationEmail}`);
                }
              } catch (emailError) {
                console.error(`Error sending email to manager:`, emailError);
              }
            }
          }
        } catch (emailError) {
          console.error("Error sending kitchen settings change emails:", emailError);
        }
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating kitchen:", error);
      res.status(500).json({ error: error.message || "Failed to update kitchen" });
    }
  });
  app3.delete("/api/admin/kitchens/:id", async (req, res) => {
    try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      if (user.role !== "admin") {
        return res.status(403).json({ error: "Admin access required" });
      }
      const kitchenId = parseInt(req.params.id);
      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      await firebaseStorage.deleteKitchen(kitchenId);
      res.json({ success: true, message: "Kitchen deleted successfully" });
    } catch (error) {
      console.error("Error deleting kitchen:", error);
      res.status(500).json({ error: error.message || "Failed to delete kitchen" });
    }
  });
  app3.put("/api/admin/managers/:id", async (req, res) => {
    try {
      console.log(`\u{1F4CD} PUT /api/admin/managers/:id - Request received for manager ID: ${req.params.id}`);
      console.log(`\u{1F4CD} Request body:`, JSON.stringify(req.body, null, 2));
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        console.error("\u274C PUT /api/admin/managers/:id - Not authenticated");
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      if (user.role !== "admin") {
        console.error(`\u274C PUT /api/admin/managers/:id - User ${user.id} is not admin (role: ${user.role})`);
        return res.status(403).json({ error: "Admin access required" });
      }
      const managerId = parseInt(req.params.id);
      if (isNaN(managerId) || managerId <= 0) {
        console.error(`\u274C Invalid manager ID: ${req.params.id}`);
        return res.status(400).json({ error: "Invalid manager ID" });
      }
      console.log(`\u2705 Validated - updating manager ${managerId} for admin user ${user.id}`);
      const { username, role, isManager, locationNotificationEmails } = req.body;
      const manager = await firebaseStorage.getUser(managerId);
      if (!manager) {
        return res.status(404).json({ error: "Manager not found" });
      }
      if (manager.role !== "manager") {
        return res.status(400).json({ error: "User is not a manager" });
      }
      const updates = {};
      if (username !== void 0) {
        const existingUser = await firebaseStorage.getUserByUsername(username);
        if (existingUser && existingUser.id !== managerId) {
          return res.status(400).json({ error: "Username already exists" });
        }
        updates.username = username;
      }
      if (role !== void 0) updates.role = role;
      if (isManager !== void 0) updates.isManager = isManager;
      const updated = await firebaseStorage.updateUser(managerId, updates);
      if (!updated) {
        return res.status(404).json({ error: "Failed to update manager" });
      }
      if (locationNotificationEmails && Array.isArray(locationNotificationEmails)) {
        const { db: db3 } = await Promise.resolve().then(() => (init_db(), db_exports));
        const { locations: locations3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
        const { eq: eq6 } = await import("drizzle-orm");
        const managedLocations2 = await db3.select().from(locations3).where(eq6(locations3.managerId, managerId));
        for (const emailUpdate of locationNotificationEmails) {
          if (emailUpdate.locationId && emailUpdate.notificationEmail !== void 0) {
            const locationId = parseInt(emailUpdate.locationId.toString());
            if (!isNaN(locationId)) {
              const email = emailUpdate.notificationEmail?.trim() || "";
              if (email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                console.warn(`Invalid email format for location ${locationId}: ${email}`);
                continue;
              }
              await db3.update(locations3).set({
                notificationEmail: email || null,
                updatedAt: /* @__PURE__ */ new Date()
              }).where(eq6(locations3.id, locationId));
              console.log(`\u2705 Updated notification email for location ${locationId}: ${email || "null"}`);
            }
          }
        }
      }
      const { locations: locations2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const { eq: eq5 } = await import("drizzle-orm");
      const managedLocations = await db.select().from(locations2).where(eq5(locations2.managerId, managerId));
      const notificationEmails = managedLocations.map((loc) => loc.notificationEmail || loc.notification_email).filter((email) => email && email.trim() !== "");
      const response = {
        ...updated,
        locations: managedLocations.map((loc) => ({
          locationId: loc.id,
          locationName: loc.name,
          notificationEmail: loc.notificationEmail || loc.notification_email || null
        })),
        notificationEmails,
        primaryNotificationEmail: notificationEmails.length > 0 ? notificationEmails[0] : null
      };
      res.json(response);
    } catch (error) {
      console.error("Error updating manager:", error);
      res.status(500).json({ error: error.message || "Failed to update manager" });
    }
  });
  app3.delete("/api/admin/managers/:id", async (req, res) => {
    try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      if (user.role !== "admin") {
        return res.status(403).json({ error: "Admin access required" });
      }
      const managerId = parseInt(req.params.id);
      if (isNaN(managerId) || managerId <= 0) {
        return res.status(400).json({ error: "Invalid manager ID" });
      }
      if (managerId === user.id) {
        return res.status(400).json({ error: "You cannot delete your own account" });
      }
      const manager = await firebaseStorage.getUser(managerId);
      if (!manager) {
        return res.status(404).json({ error: "Manager not found" });
      }
      if (manager.role !== "manager") {
        return res.status(400).json({ error: "User is not a manager" });
      }
      await firebaseStorage.deleteUser(managerId);
      res.json({ success: true, message: "Manager deleted successfully" });
    } catch (error) {
      console.error("Error deleting manager:", error);
      res.status(500).json({ error: error.message || "Failed to delete manager" });
    }
  });
  app3.post("/api/portal-login", async (req, res) => {
    try {
      const { username, password } = req.body;
      if (!username || !password) {
        return res.status(400).json({ error: "Username and password are required" });
      }
      console.log("Portal user login attempt for:", username);
      const portalUser = await firebaseStorage.getUserByUsername(username);
      if (!portalUser) {
        console.log("Portal user not found:", username);
        return res.status(401).json({ error: "Incorrect username or password" });
      }
      const isPortalUser = portalUser.isPortalUser || portalUser.is_portal_user;
      if (!isPortalUser) {
        console.log("User is not a portal user:", username);
        return res.status(403).json({ error: "Not authorized - portal user access required" });
      }
      const passwordMatches = await comparePasswords(password, portalUser.password);
      if (!passwordMatches) {
        console.log("Password mismatch for portal user:", username);
        return res.status(401).json({ error: "Incorrect username or password" });
      }
      const subdomain = getSubdomainFromHeaders(req.headers);
      const isChef = portalUser.isChef || portalUser.is_chef || false;
      const isManager = portalUser.isManager || portalUser.is_manager || false;
      if (!isRoleAllowedForSubdomain(portalUser.role, subdomain, isPortalUser || false, isChef, isManager)) {
        console.log(`Portal user ${username} attempted login from wrong subdomain: ${subdomain}`);
        return res.status(403).json({
          error: "Access denied. Portal users must login from the kitchen subdomain.",
          requiredSubdomain: "kitchen"
        });
      }
      req.login(portalUser, (err) => {
        if (err) {
          console.error("Login error:", err);
          return res.status(500).json({ error: "Login failed" });
        }
        const getPortalUserLocation = async () => {
          try {
            const { portalUserLocationAccess: portalUserLocationAccess2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
            const { eq: eq5 } = await import("drizzle-orm");
            const accessRecords = await db.select().from(portalUserLocationAccess2).where(eq5(portalUserLocationAccess2.portalUserId, portalUser.id));
            if (accessRecords.length > 0) {
              return accessRecords[0].locationId;
            }
            return null;
          } catch (error) {
            console.error("Error fetching portal user location:", error);
            return null;
          }
        };
        getPortalUserLocation().then((locationId) => {
          res.json({
            id: portalUser.id,
            username: portalUser.username,
            role: portalUser.role,
            isPortalUser: true,
            locationId
          });
        });
      });
    } catch (error) {
      console.error("Portal login error:", error);
      res.status(500).json({ error: error.message || "Portal login failed" });
    }
  });
  console.log("[Routes] Registering /api/portal-register route");
  app3.post("/api/portal-register", async (req, res) => {
    console.log("[Routes] /api/portal-register called");
    try {
      const { username, password, locationId, fullName, email, phone, company } = req.body;
      if (!username || !password || !locationId || !fullName || !email || !phone) {
        return res.status(400).json({ error: "Username, password, locationId, fullName, email, and phone are required" });
      }
      const location = await firebaseStorage.getLocationById(parseInt(locationId));
      if (!location) {
        return res.status(400).json({ error: "Location not found" });
      }
      let user = await firebaseStorage.getUserByUsername(username);
      let isNewUser = false;
      if (!user) {
        const hashedPassword = await hashPassword(password);
        user = await firebaseStorage.createUser({
          username,
          password: hashedPassword,
          role: "chef",
          // Default role, but portal user flag takes precedence
          isChef: false,
          isManager: false,
          isPortalUser: true
        });
        isNewUser = true;
      } else {
        const isPortalUser = user.isPortalUser || user.is_portal_user;
        if (!isPortalUser) {
          return res.status(400).json({ error: "Username already exists with different account type" });
        }
      }
      let existingApplications = [];
      try {
        existingApplications = await db.select().from(portalUserApplications).where(
          and4(
            eq4(portalUserApplications.userId, user.id),
            eq4(portalUserApplications.locationId, parseInt(locationId))
          )
        );
      } catch (dbError) {
        console.error("Error checking existing applications:", dbError);
        if (dbError.message && dbError.message.includes("does not exist")) {
          return res.status(500).json({
            error: "Database migration required. Please run the migration to create portal_user_applications table.",
            details: "Run: migrations/0005_add_portal_user_tables.sql"
          });
        }
        throw dbError;
      }
      if (existingApplications.length > 0) {
        const existingApp = existingApplications[0];
        if (existingApp.status === "inReview" || existingApp.status === "approved") {
          return res.status(400).json({
            error: "You already have an application for this location",
            applicationId: existingApp.id,
            status: existingApp.status
          });
        }
      }
      let application;
      try {
        const normalizedPhone = normalizePhoneForStorage(phone);
        if (!normalizedPhone) {
          return res.status(400).json({ error: "Invalid phone number format. Please enter a valid phone number." });
        }
        application = await db.insert(portalUserApplications).values({
          userId: user.id,
          locationId: parseInt(locationId),
          fullName,
          email,
          phone: normalizedPhone,
          // Store normalized phone number
          company: company || null,
          status: "inReview"
        }).returning();
      } catch (dbError) {
        console.error("Error creating application:", dbError);
        if (dbError.message && dbError.message.includes("does not exist")) {
          return res.status(500).json({
            error: "Database migration required. Please run the migration to create portal_user_applications table.",
            details: "Run: migrations/0005_add_portal_user_tables.sql"
          });
        }
        throw dbError;
      }
      return new Promise((resolve, reject) => {
        req.login(user, (err) => {
          if (err) {
            console.error("Login error after registration:", err);
            return res.status(500).json({ error: "Login failed after registration" });
          }
          (async () => {
            try {
              const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
              let managerEmail = location.notificationEmail || location.notification_email;
              if (!managerEmail) {
                const managerId = location.managerId || location.manager_id;
                if (managerId) {
                  const manager = await firebaseStorage.getUser(managerId);
                  if (manager && manager.username) {
                    managerEmail = manager.username;
                  }
                }
              }
              if (managerEmail) {
                const emailContent = {
                  to: managerEmail,
                  subject: `New Portal User Application - ${location.name}`,
                  text: `A new portal user has applied for access to your location:

Location: ${location.name}
Applicant Name: ${fullName}
Email: ${email}
Phone: ${phone}
${company ? `Company: ${company}
` : ""}
Please log in to your manager dashboard to review and approve this application.`,
                  html: `<h2>New Portal User Application</h2><p><strong>Location:</strong> ${location.name}</p><p><strong>Applicant Name:</strong> ${fullName}</p><p><strong>Email:</strong> ${email}</p><p><strong>Phone:</strong> ${phone}</p>${company ? `<p><strong>Company:</strong> ${company}</p>` : ""}<p>Please log in to your manager dashboard to review and approve this application.</p>`
                };
                await sendEmail2(emailContent);
                console.log(`\u2705 Portal user application notification sent to manager: ${managerEmail}`);
              } else {
                console.log("\u26A0\uFE0F No manager email found for location - skipping email notification");
              }
            } catch (emailError) {
              console.error("Error sending application notification email:", emailError);
            }
            res.status(201).json({
              id: user.id,
              username: user.username,
              role: user.role,
              isPortalUser: true,
              application: {
                id: application[0].id,
                status: application[0].status,
                message: "Your application has been submitted. You are now logged in. The location manager will review it shortly."
              }
            });
          })();
        });
      });
    } catch (error) {
      console.error("Portal registration error:", error);
      res.status(500).json({ error: error.message || "Portal registration failed" });
    }
  });
  async function requirePortalUser(req, res, next) {
    try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error: "Authentication required. Please sign in." });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      const isPortalUser = user.isPortalUser || user.is_portal_user;
      if (!isPortalUser) {
        return res.status(403).json({ error: "Portal user access required" });
      }
      const accessRecords = await db.select().from(portalUserLocationAccess).where(eq4(portalUserLocationAccess.portalUserId, user.id)).limit(1);
      if (accessRecords.length === 0) {
        const applications2 = await db.select().from(portalUserApplications).where(eq4(portalUserApplications.userId, user.id)).limit(1);
        if (applications2.length > 0) {
          const app4 = applications2[0];
          return res.status(403).json({
            error: "Access denied. Your application is pending approval by the location manager.",
            applicationStatus: app4.status,
            awaitingApproval: true
          });
        }
        return res.status(403).json({
          error: "Access denied. Your application is pending approval by the location manager.",
          awaitingApproval: true
        });
      }
      req.user = user;
      console.log(`\u2705 Portal user authenticated: ${user.username} (ID: ${user.id})`);
      return next();
    } catch (error) {
      console.error("Error in requirePortalUser middleware:", error);
      return res.status(401).json({ error: "Authentication failed" });
    }
  }
  app3.get("/api/portal/my-location", requirePortalUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { portalUserLocationAccess: portalUserLocationAccess2, locations: locations2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const { eq: eq5 } = await import("drizzle-orm");
      const accessRecords = await db.select().from(portalUserLocationAccess2).where(eq5(portalUserLocationAccess2.portalUserId, userId)).limit(1);
      if (accessRecords.length === 0) {
        return res.status(404).json({ error: "No location assigned to this portal user" });
      }
      const locationId = accessRecords[0].locationId;
      const locationRecords = await db.select().from(locations2).where(eq5(locations2.id, locationId)).limit(1);
      if (locationRecords.length === 0) {
        return res.status(404).json({ error: "Location not found" });
      }
      const location = locationRecords[0];
      const slug = location.name.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
      res.json({
        id: location.id,
        name: location.name,
        address: location.address,
        logoUrl: location.logoUrl || location.logo_url || null,
        slug
      });
    } catch (error) {
      console.error("Error fetching portal user location:", error);
      res.status(500).json({ error: error.message || "Failed to fetch location" });
    }
  });
  app3.get("/api/portal/application-status", async (req, res) => {
    try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error: "Authentication required" });
      }
      const user = isFirebaseAuth ? req.neonUser : sessionUser;
      const isPortalUser = user.isPortalUser || user.is_portal_user;
      if (!isPortalUser) {
        return res.status(403).json({ error: "Portal user access required" });
      }
      const accessRecords = await db.select().from(portalUserLocationAccess).where(eq4(portalUserLocationAccess.portalUserId, user.id)).limit(1);
      if (accessRecords.length > 0) {
        return res.json({
          hasAccess: true,
          status: "approved"
        });
      }
      const applications2 = await db.select().from(portalUserApplications).where(eq4(portalUserApplications.userId, user.id)).orderBy(desc2(portalUserApplications.createdAt)).limit(1);
      if (applications2.length > 0) {
        const app4 = applications2[0];
        return res.json({
          hasAccess: false,
          status: app4.status,
          applicationId: app4.id,
          locationId: app4.locationId,
          awaitingApproval: app4.status === "inReview"
        });
      }
      return res.json({
        hasAccess: false,
        status: "no_application",
        awaitingApproval: false
      });
    } catch (error) {
      console.error("Error getting portal application status:", error);
      res.status(500).json({ error: error.message || "Failed to get application status" });
    }
  });
  app3.get("/api/portal/locations", requirePortalUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { portalUserLocationAccess: portalUserLocationAccess2, locations: locations2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const { eq: eq5 } = await import("drizzle-orm");
      const accessRecords = await db.select().from(portalUserLocationAccess2).where(eq5(portalUserLocationAccess2.portalUserId, userId)).limit(1);
      if (accessRecords.length === 0) {
        return res.status(404).json({ error: "No location assigned to this portal user" });
      }
      const locationId = accessRecords[0].locationId;
      const locationRecords = await db.select().from(locations2).where(eq5(locations2.id, locationId)).limit(1);
      if (locationRecords.length === 0) {
        return res.status(404).json({ error: "Location not found" });
      }
      const location = locationRecords[0];
      const slug = location.name.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
      res.json([{
        id: location.id,
        name: location.name,
        address: location.address,
        logoUrl: location.logoUrl || location.logo_url || null,
        slug
      }]);
    } catch (error) {
      console.error("Error fetching portal user location:", error);
      res.status(500).json({ error: error.message || "Failed to fetch location" });
    }
  });
  app3.get("/api/portal/locations/:locationSlug", requirePortalUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const locationSlug = req.params.locationSlug;
      const { portalUserLocationAccess: portalUserLocationAccess2, locations: locations2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const { eq: eq5 } = await import("drizzle-orm");
      const accessRecords = await db.select().from(portalUserLocationAccess2).where(eq5(portalUserLocationAccess2.portalUserId, userId)).limit(1);
      if (accessRecords.length === 0) {
        return res.status(404).json({ error: "No location assigned to this portal user" });
      }
      const userLocationId = accessRecords[0].locationId;
      const locationRecords = await db.select().from(locations2).where(eq5(locations2.id, userLocationId)).limit(1);
      if (locationRecords.length === 0) {
        return res.status(404).json({ error: "Location not found" });
      }
      const location = locationRecords[0];
      const slug = location.name.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
      if (slug !== locationSlug) {
        return res.status(403).json({ error: "Access denied. You can only access your assigned location." });
      }
      res.json({
        id: location.id,
        name: location.name,
        address: location.address,
        logoUrl: location.logoUrl || location.logo_url || null
      });
    } catch (error) {
      console.error("Error fetching portal location:", error);
      res.status(500).json({ error: error.message || "Failed to fetch location" });
    }
  });
  app3.get("/api/portal/locations/:locationSlug/kitchens", requirePortalUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const locationSlug = req.params.locationSlug;
      const accessRecords = await db.select().from(portalUserLocationAccess).where(eq4(portalUserLocationAccess.portalUserId, userId)).limit(1);
      if (accessRecords.length === 0) {
        return res.status(404).json({ error: "No location assigned to this portal user" });
      }
      const userLocationId = accessRecords[0].locationId;
      const locationRecords = await db.select().from(locations).where(eq4(locations.id, userLocationId)).limit(1);
      if (locationRecords.length === 0) {
        return res.status(404).json({ error: "Location not found" });
      }
      const location = locationRecords[0];
      const slug = location.name.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
      if (slug !== locationSlug) {
        return res.status(403).json({ error: "Access denied. You can only access kitchens at your assigned location." });
      }
      const kitchens2 = await firebaseStorage.getKitchensByLocation(userLocationId);
      const publicKitchens = kitchens2.filter((kitchen) => kitchen.isActive !== false).map((kitchen) => ({
        id: kitchen.id,
        name: kitchen.name,
        description: kitchen.description,
        locationId: kitchen.locationId || kitchen.location_id
      }));
      res.json(publicKitchens);
    } catch (error) {
      console.error("Error fetching portal kitchens:", error);
      res.status(500).json({ error: error.message || "Failed to fetch kitchens" });
    }
  });
  app3.get("/api/portal/kitchens/:kitchenId/availability", requirePortalUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const kitchenId = parseInt(req.params.kitchenId);
      const date2 = req.query.date;
      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      if (!date2) {
        return res.status(400).json({ error: "Date parameter is required" });
      }
      const { portalUserLocationAccess: portalUserLocationAccess2, kitchens: kitchens2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const { eq: eq5 } = await import("drizzle-orm");
      const accessRecords = await db.select().from(portalUserLocationAccess2).where(eq5(portalUserLocationAccess2.portalUserId, userId)).limit(1);
      if (accessRecords.length === 0) {
        return res.status(404).json({ error: "No location assigned to this portal user" });
      }
      const userLocationId = accessRecords[0].locationId;
      const kitchenRecords = await db.select().from(kitchens2).where(eq5(kitchens2.id, kitchenId)).limit(1);
      if (kitchenRecords.length === 0) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const kitchen = kitchenRecords[0];
      const kitchenLocationId = kitchen.locationId || kitchen.location_id;
      if (kitchenLocationId !== userLocationId) {
        return res.status(403).json({ error: "Access denied. You can only access kitchens at your assigned location." });
      }
      const slots = await firebaseStorage.getAvailableSlots(kitchenId, date2);
      res.json({ slots });
    } catch (error) {
      console.error("Error fetching portal availability:", error);
      res.status(500).json({ error: error.message || "Failed to fetch availability" });
    }
  });
  app3.post("/api/public/bookings", async (req, res) => {
    try {
      const {
        locationId,
        kitchenId,
        bookingDate,
        startTime,
        endTime,
        bookingName,
        bookingEmail,
        bookingPhone,
        bookingCompany,
        specialNotes
      } = req.body;
      if (!locationId || !kitchenId || !bookingDate || !startTime || !endTime || !bookingName || !bookingEmail) {
        return res.status(400).json({ error: "Missing required fields" });
      }
      const bookingDateObj = new Date(bookingDate);
      const now = /* @__PURE__ */ new Date();
      if (bookingDateObj < now) {
        return res.status(400).json({ error: "Cannot book a time slot that has already passed" });
      }
      const availabilityCheck = await firebaseStorage.validateBookingAvailability(
        kitchenId,
        bookingDateObj,
        startTime,
        endTime
      );
      if (!availabilityCheck.valid) {
        return res.status(400).json({ error: availabilityCheck.error || "Time slot not available" });
      }
      const location = await firebaseStorage.getLocationById(locationId);
      const minimumBookingWindowHours = location?.minimumBookingWindowHours ?? 1;
      const isToday = bookingDateObj.toDateString() === now.toDateString();
      if (isToday) {
        const [startHours, startMins] = startTime.split(":").map(Number);
        const slotTime = new Date(bookingDateObj);
        slotTime.setHours(startHours, startMins, 0, 0);
        const hoursUntilBooking = (slotTime.getTime() - now.getTime()) / (1e3 * 60 * 60);
        if (hoursUntilBooking < minimumBookingWindowHours) {
          return res.status(400).json({
            error: `Bookings must be made at least ${minimumBookingWindowHours} hour(s) in advance`
          });
        }
      }
      const booking = await firebaseStorage.createBooking({
        kitchenId,
        bookingDate: bookingDateObj,
        startTime,
        endTime,
        specialNotes: specialNotes || `Third-party booking from ${bookingName}${bookingCompany ? ` (${bookingCompany})` : ""}. Email: ${bookingEmail}${bookingPhone ? `, Phone: ${bookingPhone}` : ""}`,
        bookingType: "external",
        createdBy: null,
        // No authenticated user
        externalContact: {
          name: bookingName,
          email: bookingEmail,
          phone: bookingPhone || null,
          company: bookingCompany || null
        }
      });
      try {
        const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        if (location?.notificationEmail) {
          const emailContent = {
            to: location.notificationEmail,
            subject: `New Third-Party Booking Request - ${location.name}`,
            text: `A new booking request has been submitted:

Kitchen: ${booking.kitchenName || "Kitchen"}
Date: ${bookingDate}
Time: ${startTime} - ${endTime}

Contact Information:
Name: ${bookingName}
Email: ${bookingEmail}
${bookingPhone ? `Phone: ${bookingPhone}
` : ""}${bookingCompany ? `Company: ${bookingCompany}
` : ""}${specialNotes ? `
Notes: ${specialNotes}` : ""}

Please log in to your manager dashboard to confirm or manage this booking.`,
            html: `<h2>New Third-Party Booking Request</h2><p><strong>Location:</strong> ${location.name}</p><p><strong>Kitchen:</strong> ${booking.kitchenName || "Kitchen"}</p><p><strong>Date:</strong> ${bookingDate}</p><p><strong>Time:</strong> ${startTime} - ${endTime}</p><h3>Contact Information:</h3><ul><li><strong>Name:</strong> ${bookingName}</li><li><strong>Email:</strong> ${bookingEmail}</li>${bookingPhone ? `<li><strong>Phone:</strong> ${bookingPhone}</li>` : ""}${bookingCompany ? `<li><strong>Company:</strong> ${bookingCompany}</li>` : ""}</ul>${specialNotes ? `<p><strong>Notes:</strong> ${specialNotes}</p>` : ""}<p>Please log in to your manager dashboard to confirm or manage this booking.</p>`
          };
          await sendEmail2(emailContent);
        }
      } catch (emailError) {
        console.error("Error sending booking notification email:", emailError);
      }
      res.status(201).json({
        success: true,
        booking: {
          id: booking.id,
          bookingDate,
          startTime,
          endTime,
          status: "pending"
        },
        message: "Booking request submitted successfully. The kitchen manager will contact you shortly."
      });
    } catch (error) {
      console.error("Error creating public booking:", error);
      res.status(500).json({ error: error.message || "Failed to create booking" });
    }
  });
  app3.post("/api/portal/bookings", requirePortalUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const {
        locationId,
        kitchenId,
        bookingDate,
        startTime,
        endTime,
        bookingName,
        bookingEmail,
        bookingPhone,
        bookingCompany,
        specialNotes
      } = req.body;
      if (!locationId || !kitchenId || !bookingDate || !startTime || !endTime || !bookingName || !bookingEmail) {
        return res.status(400).json({ error: "Missing required fields" });
      }
      const { portalUserLocationAccess: portalUserLocationAccess2, kitchens: kitchens2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const { eq: eq5 } = await import("drizzle-orm");
      const { db: db3 } = await Promise.resolve().then(() => (init_db(), db_exports));
      const accessRecords = await db3.select().from(portalUserLocationAccess2).where(eq5(portalUserLocationAccess2.portalUserId, userId)).limit(1);
      if (accessRecords.length === 0) {
        return res.status(404).json({ error: "No location assigned to this portal user" });
      }
      const userLocationId = accessRecords[0].locationId;
      if (parseInt(locationId) !== userLocationId) {
        return res.status(403).json({ error: "Access denied. You can only book kitchens at your assigned location." });
      }
      const kitchenRecords = await db3.select().from(kitchens2).where(eq5(kitchens2.id, parseInt(kitchenId))).limit(1);
      if (kitchenRecords.length === 0) {
        return res.status(404).json({ error: "Kitchen not found" });
      }
      const kitchen = kitchenRecords[0];
      const kitchenLocationId = kitchen.locationId || kitchen.location_id;
      if (kitchenLocationId !== userLocationId) {
        return res.status(403).json({ error: "Access denied. You can only book kitchens at your assigned location." });
      }
      const bookingDateObj = new Date(bookingDate);
      const now = /* @__PURE__ */ new Date();
      if (bookingDateObj < now) {
        return res.status(400).json({ error: "Cannot book a time slot that has already passed" });
      }
      const availabilityCheck = await firebaseStorage.validateBookingAvailability(
        parseInt(kitchenId),
        bookingDateObj,
        startTime,
        endTime
      );
      if (!availabilityCheck.valid) {
        return res.status(400).json({ error: availabilityCheck.error || "Time slot not available" });
      }
      const location = await firebaseStorage.getLocationById(userLocationId);
      const minimumBookingWindowHours = location?.minimumBookingWindowHours ?? 1;
      const isToday = bookingDateObj.toDateString() === now.toDateString();
      if (isToday) {
        const [startHours, startMins] = startTime.split(":").map(Number);
        const slotTime = new Date(bookingDateObj);
        slotTime.setHours(startHours, startMins, 0, 0);
        const hoursUntilBooking = (slotTime.getTime() - now.getTime()) / (1e3 * 60 * 60);
        if (hoursUntilBooking < minimumBookingWindowHours) {
          return res.status(400).json({
            error: `Bookings must be made at least ${minimumBookingWindowHours} hour(s) in advance`
          });
        }
      }
      const { pool: pool3 } = await Promise.resolve().then(() => (init_db(), db_exports));
      if (pool3) {
        const [sH, sM] = startTime.split(":").map(Number);
        const [eH, eM] = endTime.split(":").map(Number);
        const requestedSlots = Math.max(1, Math.ceil((eH * 60 + eM - (sH * 60 + sM)) / 60));
        let maxSlotsPerChef = 2;
        const dateStr = bookingDateObj.toISOString().split("T")[0];
        try {
          const overrideResult = await pool3.query(`
            SELECT max_slots_per_chef
            FROM kitchen_date_overrides
            WHERE kitchen_id = $1 AND DATE(specific_date) = $2::date
            ORDER BY updated_at DESC
            LIMIT 1
          `, [kitchenId, dateStr]);
          if (overrideResult.rows.length > 0) {
            const val = Number(overrideResult.rows[0].max_slots_per_chef);
            if (Number.isFinite(val) && val > 0) {
              maxSlotsPerChef = val;
              console.log(`[Booking Limit] Using date override: ${maxSlotsPerChef} hours for kitchen ${kitchenId} on ${dateStr}`);
            }
          } else {
            const locationLimitResult = await pool3.query(`
              SELECT l.default_daily_booking_limit, l.id as location_id, l.name as location_name
              FROM locations l
              INNER JOIN kitchens k ON k.location_id = l.id
              WHERE k.id = $1
            `, [kitchenId]);
            console.log(`[Booking Limit] Location query result for kitchen ${kitchenId}:`, {
              rowCount: locationLimitResult.rows.length,
              rawValue: locationLimitResult.rows[0]?.default_daily_booking_limit,
              locationId: locationLimitResult.rows[0]?.location_id,
              locationName: locationLimitResult.rows[0]?.location_name
            });
            if (locationLimitResult.rows.length > 0) {
              const rawValue = locationLimitResult.rows[0].default_daily_booking_limit;
              const locVal = rawValue !== null && rawValue !== void 0 ? Number(rawValue) : null;
              console.log(`[Booking Limit] Parsed location default value:`, {
                rawValue,
                locVal,
                isFinite: Number.isFinite(locVal),
                isPositive: locVal !== null && locVal > 0
              });
              if (locVal !== null && Number.isFinite(locVal) && locVal > 0) {
                maxSlotsPerChef = locVal;
                console.log(`[Booking Limit] \u2705 Using location default: ${maxSlotsPerChef} hours for kitchen ${kitchenId} (location: ${locationLimitResult.rows[0].location_name || locationLimitResult.rows[0].location_id})`);
              } else {
                console.warn(`[Booking Limit] \u26A0\uFE0F Invalid location default value: ${locVal} (raw: ${rawValue}), using fallback: 2`);
                maxSlotsPerChef = 2;
              }
            } else {
              console.warn(`[Booking Limit] \u26A0\uFE0F No location found for kitchen ${kitchenId}, using fallback: 2`);
            }
          }
        } catch (error) {
          console.error("Error fetching daily booking limit:", error);
          maxSlotsPerChef = 2;
        }
        const existingBookings = await pool3.query(`
          SELECT start_time, end_time
          FROM kitchen_bookings
          WHERE chef_id = $1
            AND kitchen_id = $2
            AND DATE(booking_date) = $3::date
            AND status IN ('pending','confirmed')
        `, [userId, kitchenId, dateStr]);
        let existingSlots = 0;
        for (const b of existingBookings.rows) {
          const [bsH, bsM] = String(b.start_time).split(":").map(Number);
          const [beH, beM] = String(b.end_time).split(":").map(Number);
          const span = Math.max(1, Math.ceil((beH * 60 + beM - (bsH * 60 + bsM)) / 60));
          existingSlots += span;
        }
        if (existingSlots + requestedSlots > maxSlotsPerChef) {
          return res.status(400).json({
            error: `Booking exceeds daily limit. Allowed: ${maxSlotsPerChef} hour(s).`
          });
        }
      }
      const booking = await firebaseStorage.createBooking({
        kitchenId: parseInt(kitchenId),
        chefId: userId,
        // Portal user ID
        bookingDate: bookingDateObj,
        startTime,
        endTime,
        specialNotes: specialNotes || `Portal user booking from ${bookingName}${bookingCompany ? ` (${bookingCompany})` : ""}. Email: ${bookingEmail}${bookingPhone ? `, Phone: ${bookingPhone}` : ""}`,
        bookingType: "external",
        createdBy: userId,
        // Portal user who created the booking
        externalContact: {
          name: bookingName,
          email: bookingEmail,
          phone: bookingPhone || null,
          company: bookingCompany || null
        }
      });
      try {
        const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        if (location?.notificationEmail) {
          const emailContent = {
            to: location.notificationEmail,
            subject: `New Portal User Booking Request - ${location.name}`,
            text: `A new booking request has been submitted by a portal user:

Kitchen: ${booking.kitchenName || "Kitchen"}
Date: ${bookingDate}
Time: ${startTime} - ${endTime}

Contact Information:
Name: ${bookingName}
Email: ${bookingEmail}
${bookingPhone ? `Phone: ${bookingPhone}
` : ""}${bookingCompany ? `Company: ${bookingCompany}
` : ""}${specialNotes ? `
Notes: ${specialNotes}` : ""}

Please log in to your manager dashboard to confirm or manage this booking.`,
            html: `<h2>New Portal User Booking Request</h2><p><strong>Location:</strong> ${location.name}</p><p><strong>Kitchen:</strong> ${booking.kitchenName || "Kitchen"}</p><p><strong>Date:</strong> ${bookingDate}</p><p><strong>Time:</strong> ${startTime} - ${endTime}</p><h3>Contact Information:</h3><ul><li><strong>Name:</strong> ${bookingName}</li><li><strong>Email:</strong> ${bookingEmail}</li>${bookingPhone ? `<li><strong>Phone:</strong> ${bookingPhone}</li>` : ""}${bookingCompany ? `<li><strong>Company:</strong> ${bookingCompany}</li>` : ""}</ul>${specialNotes ? `<p><strong>Notes:</strong> ${specialNotes}</p>` : ""}<p>Please log in to your manager dashboard to confirm or manage this booking.</p>`
          };
          await sendEmail2(emailContent);
        }
        try {
          const { db: db4, pool: pool4 } = await Promise.resolve().then(() => (init_db(), db_exports));
          const { locations: locations2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const { eq: eq6 } = await import("drizzle-orm");
          const locationRecord = await db4.select().from(locations2).where(eq6(locations2.id, userLocationId)).limit(1);
          const locationData = locationRecord[0];
          const managerPhone = await getManagerPhone(locationData, locationData?.managerId, pool4);
          if (managerPhone) {
            const smsMessage = generateManagerPortalBookingSMS({
              portalUserName: bookingName,
              kitchenName: booking.kitchenName || "Kitchen",
              bookingDate,
              startTime,
              endTime
            });
            await sendSMS(managerPhone, smsMessage, { trackingId: `portal_booking_${booking.id}_manager` });
            console.log(`\u2705 Portal booking SMS sent to manager: ${managerPhone}`);
          }
        } catch (smsError) {
          console.error("Error sending booking SMS to manager:", smsError);
        }
      } catch (emailError) {
        console.error("Error sending booking notification email:", emailError);
      }
      res.status(201).json({
        success: true,
        booking: {
          id: booking.id,
          bookingDate,
          startTime,
          endTime,
          status: "pending"
        },
        message: "Booking request submitted successfully. The kitchen manager will contact you shortly."
      });
    } catch (error) {
      console.error("Error creating portal booking:", error);
      res.status(500).json({ error: error.message || "Failed to create booking" });
    }
  });
  app3.get("/api/public/kitchens", async (req, res) => {
    try {
      const kitchens2 = await firebaseStorage.getAllKitchensWithLocationAndManager();
      console.log(`[API] /api/public/kitchens - Found ${kitchens2.length} total kitchens`);
      const activeKitchens = kitchens2.filter((kitchen) => {
        const isActive = kitchen.isActive !== void 0 ? kitchen.isActive : kitchen.is_active;
        return isActive !== false && isActive !== null;
      });
      console.log(`[API] /api/public/kitchens - ${activeKitchens.length} active kitchens after filtering`);
      const publicKitchens = activeKitchens.map((kitchen) => {
        const locationId = kitchen.locationId || kitchen.location_id;
        const locationName = kitchen.locationName || kitchen.location_name;
        const locationAddress = kitchen.locationAddress || kitchen.location_address;
        const imageUrl = kitchen.imageUrl || kitchen.image_url || null;
        const locationBrandImageUrl = kitchen.locationBrandImageUrl || kitchen.location_brand_image_url || null;
        const locationLogoUrl = kitchen.locationLogoUrl || kitchen.location_logo_url || null;
        if (locationId && !locationName) {
          console.warn(`[API] Kitchen ${kitchen.id} has locationId ${locationId} but no locationName`);
        }
        const normalizedImageUrl = normalizeImageUrl(imageUrl, req);
        const normalizedBrandImageUrl = normalizeImageUrl(locationBrandImageUrl, req);
        const normalizedLogoUrl = normalizeImageUrl(locationLogoUrl, req);
        return {
          id: kitchen.id,
          name: kitchen.name,
          description: kitchen.description,
          imageUrl: normalizedImageUrl,
          locationId: locationId || null,
          locationName: locationName || null,
          locationAddress: locationAddress || null,
          locationBrandImageUrl: normalizedBrandImageUrl,
          locationLogoUrl: normalizedLogoUrl
        };
      });
      console.log(`[API] /api/public/kitchens - Returning ${publicKitchens.length} kitchens (all active for marketing)`);
      console.log(`[API] Sample kitchen data:`, publicKitchens[0] || "No kitchens");
      res.json(publicKitchens);
    } catch (error) {
      console.error("Error fetching public kitchens:", error);
      console.error("Error stack:", error.stack);
      res.status(500).json({ error: "Failed to fetch kitchens", details: error.message });
    }
  });
  app3.get("/api/public/locations", async (req, res) => {
    try {
      const allLocations = await firebaseStorage.getAllLocations();
      const allKitchens = await firebaseStorage.getAllKitchensWithLocationAndManager();
      const activeKitchens = allKitchens.filter((kitchen) => {
        const isActive = kitchen.isActive !== void 0 ? kitchen.isActive : kitchen.is_active;
        return isActive !== false && isActive !== null;
      });
      const locationIdsWithKitchens = new Set(
        activeKitchens.map((kitchen) => kitchen.locationId || kitchen.location_id).filter(Boolean)
      );
      const locationsWithKitchens = allLocations.filter((location) => locationIdsWithKitchens.has(location.id)).map((location) => {
        const kitchenCount = activeKitchens.filter(
          (kitchen) => (kitchen.locationId || kitchen.location_id) === location.id
        ).length;
        const kitchenLicenseStatus = location.kitchenLicenseStatus || location.kitchen_license_status || "pending";
        const locationKitchens = activeKitchens.filter(
          (kitchen) => (kitchen.locationId || kitchen.location_id) === location.id
        );
        if (locationKitchens.length > 0) {
          console.log(`[API] Debug - Location ${location.id} (${location.name}) kitchens data structure:`, {
            kitchenCount: locationKitchens.length,
            firstKitchenKeys: Object.keys(locationKitchens[0] || {}),
            firstKitchenSample: {
              id: locationKitchens[0]?.id,
              name: locationKitchens[0]?.name,
              imageUrl: locationKitchens[0]?.imageUrl,
              image_url: locationKitchens[0]?.image_url,
              hasImageUrl: !!locationKitchens[0]?.imageUrl,
              hasImage_url: !!locationKitchens[0]?.image_url,
              allKeys: Object.keys(locationKitchens[0] || {})
            }
          });
        }
        let featuredKitchenImage = null;
        for (const kitchen of locationKitchens) {
          const kitchenImage = kitchen.imageUrl || kitchen.image_url || kitchen.imageUrl || kitchen.image_url;
          if (kitchenImage && typeof kitchenImage === "string" && kitchenImage.trim() !== "") {
            featuredKitchenImage = normalizeImageUrl(kitchenImage, req);
            console.log(`[API] Found kitchen image for location ${location.id}:`, {
              raw: kitchenImage,
              normalized: featuredKitchenImage,
              kitchenId: kitchen.id,
              kitchenName: kitchen.name
            });
            break;
          }
          const galleryImages = kitchen.galleryImages || kitchen.gallery_images || [];
          if (Array.isArray(galleryImages) && galleryImages.length > 0) {
            const firstGalleryImage = galleryImages[0];
            if (firstGalleryImage && typeof firstGalleryImage === "string" && firstGalleryImage.trim() !== "") {
              featuredKitchenImage = normalizeImageUrl(firstGalleryImage, req);
              console.log(`[API] Found kitchen gallery image for location ${location.id}:`, {
                raw: firstGalleryImage,
                normalized: featuredKitchenImage,
                kitchenId: kitchen.id,
                kitchenName: kitchen.name,
                source: "galleryImages"
              });
              break;
            }
          }
        }
        if (!featuredKitchenImage && locationKitchens.length > 0) {
          console.warn(
            `[API] No kitchen image found for location ${location.id} (${location.name}). Kitchens checked:`,
            locationKitchens.map((k) => ({
              id: k.id,
              name: k.name,
              imageUrl: k.imageUrl || k.image_url || "none",
              galleryImagesCount: (k.galleryImages || k.gallery_images || []).length
            }))
          );
        }
        const normalizedLogoUrl = normalizeImageUrl(location.logoUrl || location.logo_url || null, req);
        const normalizedBrandImageUrl = normalizeImageUrl(location.brandImageUrl || location.brand_image_url || null, req);
        console.log(`[API] Location ${location.id} (${location.name}) images:`, {
          logoUrl: normalizedLogoUrl,
          brandImageUrl: normalizedBrandImageUrl,
          featuredKitchenImage,
          locationKitchensCount: locationKitchens.length,
          firstKitchenRawImage: locationKitchens[0]?.imageUrl || locationKitchens[0]?.image_url || "none",
          firstKitchenNormalizedImage: locationKitchens[0] ? normalizeImageUrl(locationKitchens[0]?.imageUrl || locationKitchens[0]?.image_url || null, req) : "none"
        });
        return {
          id: location.id,
          name: location.name,
          address: location.address,
          kitchenCount,
          logoUrl: normalizedLogoUrl,
          brandImageUrl: normalizedBrandImageUrl,
          featuredKitchenImage,
          // Already normalized above
          kitchenLicenseStatus
        };
      });
      console.log(`[API] /api/public/locations - Returning ${locationsWithKitchens.length} locations with active kitchens`);
      res.json(locationsWithKitchens);
    } catch (error) {
      console.error("Error fetching public locations:", error);
      console.error("Error stack:", error.stack);
      res.status(500).json({ error: "Failed to fetch locations", details: error.message });
    }
  });
  app3.get("/api/public/locations/:locationId/details", async (req, res) => {
    try {
      const locationId = parseInt(req.params.locationId);
      if (isNaN(locationId)) {
        return res.status(400).json({ error: "Invalid location ID" });
      }
      const allLocations = await firebaseStorage.getAllLocations();
      const location = allLocations.find((loc) => loc.id === locationId);
      if (!location) {
        return res.status(404).json({ error: "Location not found" });
      }
      const allKitchens = await firebaseStorage.getAllKitchensWithLocationAndManager();
      const locationKitchens = allKitchens.filter((kitchen) => {
        const kitchenLocationId = kitchen.locationId || kitchen.location_id;
        const isActive = kitchen.isActive !== void 0 ? kitchen.isActive : kitchen.is_active;
        return kitchenLocationId === locationId && isActive !== false;
      }).map((kitchen) => {
        const normalizedImageUrl = normalizeImageUrl(kitchen.imageUrl || kitchen.image_url || null, req);
        const normalizedGalleryImages = (kitchen.galleryImages || kitchen.gallery_images || []).map(
          (img) => normalizeImageUrl(img, req)
        ).filter((url) => url !== null);
        const normalizedLocationBrandImageUrl2 = normalizeImageUrl(kitchen.locationBrandImageUrl || kitchen.location_brand_image_url || null, req);
        const normalizedLocationLogoUrl2 = normalizeImageUrl(kitchen.locationLogoUrl || kitchen.location_logo_url || null, req);
        return {
          id: kitchen.id,
          name: kitchen.name,
          description: kitchen.description,
          imageUrl: normalizedImageUrl,
          galleryImages: normalizedGalleryImages,
          amenities: kitchen.amenities || [],
          locationId: kitchen.locationId || kitchen.location_id,
          locationName: kitchen.locationName || kitchen.location_name || location.name,
          locationAddress: kitchen.locationAddress || kitchen.location_address || location.address,
          locationBrandImageUrl: normalizedLocationBrandImageUrl2,
          locationLogoUrl: normalizedLocationLogoUrl2
        };
      });
      console.log(`[API] /api/public/locations/${locationId}/details - Found location with ${locationKitchens.length} kitchens`);
      const normalizedLocationLogoUrl = normalizeImageUrl(location.logoUrl || location.logo_url || null, req);
      const normalizedLocationBrandImageUrl = normalizeImageUrl(location.brandImageUrl || location.brand_image_url || null, req);
      res.json({
        location: {
          id: location.id,
          name: location.name,
          address: location.address,
          logoUrl: normalizedLocationLogoUrl,
          brandImageUrl: normalizedLocationBrandImageUrl,
          kitchenLicenseStatus: location.kitchenLicenseStatus || location.kitchen_license_status || "pending"
        },
        kitchens: locationKitchens
      });
    } catch (error) {
      console.error("Error fetching public location details:", error);
      res.status(500).json({ error: "Failed to fetch location details", details: error.message });
    }
  });
  app3.get("/api/public/kitchens/:kitchenId/availability-preview", async (req, res) => {
    try {
      const kitchenId = parseInt(req.params.kitchenId);
      const date2 = req.query.date;
      if (isNaN(kitchenId)) {
        return res.status(400).json({ error: "Invalid kitchen ID" });
      }
      const availabilities = await firebaseStorage.getKitchenAvailability(kitchenId);
      const operatingDays = Array.from(new Set(availabilities.map((a) => a.dayOfWeek)));
      const sampleSlots = [];
      let dayOfWeek = (/* @__PURE__ */ new Date()).getDay();
      if (date2) {
        const [year, month, day] = date2.split("-").map(Number);
        dayOfWeek = new Date(year, month - 1, day).getDay();
      }
      const dayAvailability = availabilities.find((a) => a.dayOfWeek === dayOfWeek);
      if (dayAvailability) {
        const startTime = dayAvailability.startTime || "08:00";
        const endTime = dayAvailability.endTime || "18:00";
        const [startHour] = startTime.split(":").map(Number);
        const [endHour] = endTime.split(":").map(Number);
        for (let hour = startHour; hour < endHour; hour++) {
          const timeStr = `${hour.toString().padStart(2, "0")}:00`;
          const seed = kitchenId * 100 + hour;
          const available = seed % 3 === 0 ? 0 : seed % 2 === 0 ? 1 : 2;
          sampleSlots.push({
            time: timeStr,
            available,
            capacity: 2,
            isFullyBooked: available === 0
          });
        }
      } else {
        for (let hour = 8; hour < 18; hour++) {
          const timeStr = `${hour.toString().padStart(2, "0")}:00`;
          const seed = kitchenId * 100 + hour;
          const available = seed % 3 === 0 ? 0 : seed % 2 === 0 ? 1 : 2;
          sampleSlots.push({
            time: timeStr,
            available,
            capacity: 2,
            isFullyBooked: available === 0
          });
        }
      }
      console.log(`[API] /api/public/kitchens/${kitchenId}/availability-preview - Returning ${sampleSlots.length} sample slots`);
      res.json({
        operatingDays,
        sampleSlots,
        hasAvailability: availabilities.length > 0
      });
    } catch (error) {
      console.error("Error fetching public kitchen availability preview:", error);
      res.status(500).json({ error: "Failed to fetch availability preview", details: error.message });
    }
  });
  app3.get("/api/public/stats", async (req, res) => {
    try {
      if (!db) {
        return res.status(500).json({ error: "Database not available" });
      }
      const [
        chefCountResult,
        applicationCountResult,
        approvedApplicationCountResult,
        locationCountResult,
        kitchenCountResult
      ] = await Promise.all([
        db.select({ count: count() }).from(users).where(eq4(users.isChef, true)),
        db.select({ count: count() }).from(applications),
        db.select({ count: count() }).from(applications).where(eq4(applications.status, "approved")),
        db.select({ count: count() }).from(locations),
        db.select({ count: count() }).from(kitchens).where(eq4(kitchens.isActive, true))
      ]);
      const stats = {
        totalChefs: Number(chefCountResult[0]?.count ?? 0),
        totalApplications: Number(applicationCountResult[0]?.count ?? 0),
        approvedChefs: Number(approvedApplicationCountResult[0]?.count ?? 0),
        totalLocations: Number(locationCountResult[0]?.count ?? 0),
        totalKitchens: Number(kitchenCountResult[0]?.count ?? 0)
      };
      res.json(stats);
    } catch (error) {
      console.error("Error fetching public stats:", error);
      res.status(500).json({ error: "Failed to fetch statistics" });
    }
  });
  app3.get("/api/health", async (req, res) => {
    let dbStatus = "disconnected";
    let tables = [];
    if (pool) {
      try {
        await pool.query("SELECT 1");
        dbStatus = "connected";
        const tableResult = await pool.query(`
          SELECT table_name
          FROM information_schema.tables
          WHERE table_schema = 'public'
        `);
        tables = tableResult.rows.map((r) => r.table_name);
      } catch (error) {
        dbStatus = `error: ${error.message}`;
      }
    }
    res.status(200).json({
      status: "ok",
      dbStatus,
      tables,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      env: {
        NODE_ENV: process.env.NODE_ENV || "not set",
        DATABASE_URL: process.env.DATABASE_URL ? "set" : "not set"
      },
      session: {
        id: req.session?.id || "no-session",
        active: !!req.session?.userId,
        userId: req.session?.userId || req.neonUser?.id || null
      }
    });
  });
  app3.post("/api/admin-migrate-login", async (req, res) => {
    try {
      const { username, password } = req.body;
      if (!username || !password) {
        return res.status(400).json({ error: "Username and password are required" });
      }
      if (!pool) {
        return res.status(500).json({ error: "Database not available" });
      }
      console.log("\u{1F504} Admin migration login attempt for:", username);
      const userResult = await pool.query(
        "SELECT * FROM users WHERE username = $1 AND role = $2",
        [username, "admin"]
      );
      if (userResult.rows.length === 0) {
        return res.status(401).json({ error: "Incorrect username or password" });
      }
      const admin2 = userResult.rows[0];
      if (!admin2.password) {
        return res.status(401).json({ error: "Incorrect username or password" });
      }
      const passwordMatches = await comparePasswords(password, admin2.password);
      if (!passwordMatches) {
        return res.status(401).json({ error: "Incorrect username or password" });
      }
      console.log("\u2705 Password verified for admin:", admin2.id);
      if (admin2.firebase_uid) {
        console.log("\u2705 Admin already has Firebase UID:", admin2.firebase_uid);
        const { initializeFirebaseAdmin: initializeFirebaseAdmin3 } = await Promise.resolve().then(() => (init_firebase_admin(), firebase_admin_exports));
        const firebaseAdmin3 = initializeFirebaseAdmin3();
        if (!firebaseAdmin3) {
          return res.status(500).json({
            error: "Firebase Admin not available",
            message: "Cannot generate login token. Please contact support."
          });
        }
        const { getAuth: getAuth3 } = await import("firebase-admin/auth");
        const auth3 = getAuth3(firebaseAdmin3);
        try {
          const firebaseUser2 = await auth3.getUser(admin2.firebase_uid);
          const customToken = await auth3.createCustomToken(admin2.firebase_uid);
          let email2 = admin2.email;
          if (!email2) {
            email2 = firebaseUser2.email || `${admin2.username}@localcooks.com`;
          }
          console.log("\u2705 Returning custom token for migrated admin");
          return res.json({
            success: true,
            message: "Login successful",
            customToken,
            user: {
              id: admin2.id,
              username: admin2.username,
              email: email2,
              firebaseUid: admin2.firebase_uid,
              role: "admin"
            }
          });
        } catch (firebaseError) {
          console.error("Error getting Firebase user:", firebaseError);
        }
      }
      let email = admin2.email;
      if (!email) {
        if (admin2.username && admin2.username.includes("@")) {
          email = admin2.username;
        } else {
          email = `${admin2.username}@localcooks.com`;
        }
      }
      const { initializeFirebaseAdmin: initializeFirebaseAdmin2 } = await Promise.resolve().then(() => (init_firebase_admin(), firebase_admin_exports));
      const firebaseAdmin2 = initializeFirebaseAdmin2();
      if (!firebaseAdmin2) {
        return res.status(500).json({
          error: "Firebase Admin not configured",
          message: "Cannot create Firebase account. Please contact support."
        });
      }
      const { getAuth: getAuth2 } = await import("firebase-admin/auth");
      const auth2 = getAuth2(firebaseAdmin2);
      let firebaseUser;
      try {
        try {
          firebaseUser = await auth2.getUserByEmail(email);
          console.log("\u26A0\uFE0F  Firebase user already exists with email:", email);
        } catch (error) {
          console.log("\u2795 Creating Firebase account for admin:", email);
          firebaseUser = await auth2.createUser({
            email,
            password,
            displayName: admin2.display_name || admin2.username,
            emailVerified: admin2.is_verified || false
          });
          console.log("\u2705 Firebase account created:", firebaseUser.uid);
        }
        await auth2.setCustomUserClaims(firebaseUser.uid, {
          role: "admin",
          isAdmin: true
        });
        await pool.query(
          "UPDATE users SET firebase_uid = $1 WHERE id = $2",
          [firebaseUser.uid, admin2.id]
        );
        console.log("\u2705 Admin migration complete:", {
          neonUserId: admin2.id,
          firebaseUid: firebaseUser.uid,
          email
        });
        const customToken = await auth2.createCustomToken(firebaseUser.uid);
        res.json({
          success: true,
          message: "Account migrated successfully. You can now use Firebase authentication.",
          customToken,
          user: {
            id: admin2.id,
            username: admin2.username,
            email,
            firebaseUid: firebaseUser.uid,
            role: "admin"
          }
        });
      } catch (firebaseError) {
        console.error("\u274C Firebase account creation error:", firebaseError);
        return res.status(500).json({
          error: "Failed to create Firebase account",
          message: firebaseError.message || "Unknown error occurred",
          code: firebaseError.code
        });
      }
    } catch (error) {
      console.error("Admin migration login error:", error);
      res.status(500).json({
        error: "Migration login failed",
        message: error.message
      });
    }
  });
  app3.post("/api/manager-migrate-login", async (req, res) => {
    try {
      const { username, password } = req.body;
      if (!username || !password) {
        return res.status(400).json({ error: "Username and password are required" });
      }
      if (!pool) {
        return res.status(500).json({ error: "Database not available" });
      }
      console.log("\u{1F504} Manager migration login attempt for:", username);
      const userResult = await pool.query(
        "SELECT * FROM users WHERE username = $1 AND role = $2",
        [username, "manager"]
      );
      if (userResult.rows.length === 0) {
        return res.status(401).json({ error: "Incorrect username or password" });
      }
      const manager = userResult.rows[0];
      if (!manager.password) {
        return res.status(401).json({ error: "Incorrect username or password" });
      }
      const passwordMatches = await comparePasswords(password, manager.password);
      if (!passwordMatches) {
        return res.status(401).json({ error: "Incorrect username or password" });
      }
      console.log("\u2705 Password verified for manager:", manager.id);
      if (manager.firebase_uid) {
        console.log("\u2705 Manager already has Firebase UID:", manager.firebase_uid);
        const { initializeFirebaseAdmin: initializeFirebaseAdmin3 } = await Promise.resolve().then(() => (init_firebase_admin(), firebase_admin_exports));
        const firebaseAdmin3 = initializeFirebaseAdmin3();
        if (!firebaseAdmin3) {
          return res.status(500).json({
            error: "Firebase Admin not available",
            message: "Cannot generate login token. Please contact support."
          });
        }
        const { getAuth: getAuth3 } = await import("firebase-admin/auth");
        const auth3 = getAuth3(firebaseAdmin3);
        try {
          const firebaseUser2 = await auth3.getUser(manager.firebase_uid);
          const customToken = await auth3.createCustomToken(manager.firebase_uid);
          let email2 = manager.email;
          if (!email2) {
            email2 = firebaseUser2.email || `${manager.username}@localcooks.com`;
          }
          console.log("\u2705 Returning custom token for migrated manager");
          return res.json({
            success: true,
            message: "Login successful",
            customToken,
            user: {
              id: manager.id,
              username: manager.username,
              email: email2,
              firebaseUid: manager.firebase_uid,
              role: "manager"
            }
          });
        } catch (firebaseError) {
          console.error("Error getting Firebase user:", firebaseError);
        }
      }
      let email = manager.email;
      if (!email) {
        if (manager.username && manager.username.includes("@")) {
          email = manager.username;
        } else {
          email = `${manager.username}@localcooks.com`;
        }
      }
      const { initializeFirebaseAdmin: initializeFirebaseAdmin2 } = await Promise.resolve().then(() => (init_firebase_admin(), firebase_admin_exports));
      const firebaseAdmin2 = initializeFirebaseAdmin2();
      if (!firebaseAdmin2) {
        return res.status(500).json({
          error: "Firebase Admin not configured",
          message: "Cannot create Firebase account. Please contact support."
        });
      }
      const { getAuth: getAuth2 } = await import("firebase-admin/auth");
      const auth2 = getAuth2(firebaseAdmin2);
      let firebaseUser;
      try {
        try {
          firebaseUser = await auth2.getUserByEmail(email);
          console.log("\u26A0\uFE0F  Firebase user already exists with email:", email);
        } catch (error) {
          console.log("\u2795 Creating Firebase account for manager:", email);
          firebaseUser = await auth2.createUser({
            email,
            password,
            displayName: manager.display_name || manager.username,
            emailVerified: manager.is_verified || false
          });
          console.log("\u2705 Firebase account created:", firebaseUser.uid);
        }
        await auth2.setCustomUserClaims(firebaseUser.uid, {
          role: "manager",
          isManager: true
        });
        await pool.query(
          "UPDATE users SET firebase_uid = $1 WHERE id = $2",
          [firebaseUser.uid, manager.id]
        );
        console.log("\u2705 Manager migration complete:", {
          neonUserId: manager.id,
          firebaseUid: firebaseUser.uid,
          email
        });
        const customToken = await auth2.createCustomToken(firebaseUser.uid);
        res.json({
          success: true,
          message: "Account migrated successfully. You can now use Firebase authentication.",
          customToken,
          user: {
            id: manager.id,
            username: manager.username,
            email,
            firebaseUid: firebaseUser.uid,
            role: "manager"
          }
        });
      } catch (firebaseError) {
        console.error("\u274C Firebase account creation error:", firebaseError);
        return res.status(500).json({
          error: "Failed to create Firebase account",
          message: firebaseError.message || "Unknown error occurred",
          code: firebaseError.code
        });
      }
    } catch (error) {
      console.error("Manager migration login error:", error);
      res.status(500).json({
        error: "Migration login failed",
        message: error.message
      });
    }
  });
  app3.get("/api/admin/locations/pending-licenses", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
    try {
      if (!pool) {
        return res.status(500).json({ error: "Database not available" });
      }
      const result = await pool.query(`
        SELECT 
          l.id,
          l.name,
          l.address,
          l.kitchen_license_url as "kitchenLicenseUrl",
          l.kitchen_license_status as "kitchenLicenseStatus",
          l.kitchen_license_feedback as "kitchenLicenseFeedback",
          l.kitchen_license_approved_at as "kitchenLicenseApprovedAt",
          l.kitchen_license_expiry as "kitchenLicenseExpiry",
          l.kitchen_license_uploaded_at as "kitchenLicenseUploadedAt",
          u.username as "managerUsername",
          u.id as "managerId"
        FROM locations l
        LEFT JOIN users u ON l.manager_id = u.id
        WHERE l.kitchen_license_url IS NOT NULL
          AND (l.kitchen_license_status = 'pending' OR l.kitchen_license_status IS NULL)
        ORDER BY l.created_at DESC
      `);
      res.json(result.rows);
    } catch (error) {
      console.error("Error fetching pending licenses:", error);
      res.status(500).json({ error: error.message || "Failed to fetch pending licenses" });
    }
  });
  app3.put("/api/admin/locations/:locationId/kitchen-license", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
    try {
      const locationId = parseInt(req.params.locationId);
      const { status, feedback } = req.body;
      if (!["approved", "rejected"].includes(status)) {
        return res.status(400).json({ error: "Invalid status. Must be 'approved' or 'rejected'" });
      }
      if (status === "rejected" && !feedback) {
        return res.status(400).json({ error: "Feedback is required when rejecting a license" });
      }
      if (!pool) {
        return res.status(500).json({ error: "Database not available" });
      }
      const isApproved = status === "approved";
      const updateResult = await pool.query(`
        UPDATE locations
        SET 
          kitchen_license_status = $1::document_verification_status,
          kitchen_license_feedback = $2,
          kitchen_license_approved_at = CASE WHEN $3::boolean THEN NOW() ELSE NULL END,
          kitchen_license_approved_by = $4
        WHERE id = $5::integer
        RETURNING 
          id,
          name,
          kitchen_license_status as "kitchenLicenseStatus",
          kitchen_license_feedback as "kitchenLicenseFeedback",
          kitchen_license_approved_at as "kitchenLicenseApprovedAt"
      `, [status, feedback || null, isApproved, req.neonUser.id, locationId]);
      if (updateResult.rows.length === 0) {
        return res.status(404).json({ error: "Location not found" });
      }
      try {
        const managerResult = await pool.query(
          "SELECT u.username, u.firebase_uid FROM users u INNER JOIN locations l ON l.manager_id = u.id WHERE l.id = $1",
          [locationId]
        );
        if (managerResult.rows.length > 0) {
          const manager = managerResult.rows[0];
          const location = updateResult.rows[0];
          const { generateLocationEmailChangedEmail: generateLocationEmailChangedEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
          const emailContent = generateLocationEmailChangedEmail2({
            email: manager.username,
            locationName: location.name,
            locationId
          });
          await sendEmail(emailContent, {
            trackingId: `license_${status}_${locationId}_${Date.now()}`
          });
          console.log(`\u2705 License ${status} notification sent to manager: ${manager.username}`);
        }
      } catch (emailError) {
        console.error("Error sending license status email:", emailError);
      }
      res.json(updateResult.rows[0]);
    } catch (error) {
      console.error("Error updating license status:", error);
      res.status(500).json({ error: error.message || "Failed to update license status" });
    }
  });
  app3.post("/api/manager/forgot-password", async (req, res) => {
    try {
      const { username } = req.body;
      if (!username) {
        return res.status(400).json({ message: "Username is required" });
      }
      console.log(`\u{1F510} Manager password reset requested for username: ${username}`);
      if (!pool) {
        return res.status(500).json({
          message: "Password reset service unavailable. Please try again later."
        });
      }
      const manager = await storage2.getUserByUsername(username);
      if (!manager) {
        console.log(`\u274C Manager not found: ${username}`);
        return res.status(200).json({
          message: "If an account with this username exists, you will receive a password reset link."
        });
      }
      if (manager.role !== "manager") {
        console.log(`\u274C User is not a manager: ${username}, role: ${manager.role}`);
        return res.status(200).json({
          message: "If an account with this username exists, you will receive a password reset link."
        });
      }
      const crypto = await import("crypto");
      const resetToken = crypto.randomBytes(32).toString("hex");
      const resetTokenExpiry = /* @__PURE__ */ new Date();
      resetTokenExpiry.setHours(resetTokenExpiry.getHours() + 1);
      try {
        await pool.query(
          `INSERT INTO password_reset_tokens (user_id, token, expires_at, created_at) 
           VALUES ($1, $2, $3, NOW()) 
           ON CONFLICT (user_id) 
           DO UPDATE SET token = $2, expires_at = $3, created_at = NOW()`,
          [manager.id, resetToken, resetTokenExpiry]
        );
        console.log(`\u2705 Password reset token stored for manager: ${manager.id}`);
      } catch (dbError) {
        console.error("Error storing password reset token:", dbError);
        return res.status(500).json({
          message: "Error processing password reset request. Please try again later."
        });
      }
      const baseDomain = process.env.BASE_DOMAIN || "localcooks.ca";
      const baseUrl = process.env.NODE_ENV === "production" ? `https://kitchen.${baseDomain}` : process.env.BASE_URL || "http://localhost:5000";
      const resetUrl = `${baseUrl}/password-reset?token=${resetToken}&role=manager`;
      try {
        const { generatePasswordResetEmail: generatePasswordResetEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        const emailContent = generatePasswordResetEmail2({
          fullName: manager.username || username,
          email: username,
          // Username is the email for managers
          resetToken,
          resetUrl
        });
        const emailSent = await sendEmail(emailContent, {
          trackingId: `manager_password_reset_${manager.id}_${Date.now()}`
        });
        if (emailSent) {
          console.log(`\u2705 Password reset email sent successfully to manager: ${username}`);
        } else {
          console.error(`\u274C Failed to send password reset email to manager: ${username}`);
          return res.status(500).json({
            message: "Error sending password reset email. Please try again later."
          });
        }
      } catch (emailError) {
        console.error(`\u274C Error sending password reset email:`, emailError);
        return res.status(500).json({
          message: "Error sending password reset email. Please try again later."
        });
      }
      return res.status(200).json({
        message: "If an account with this username exists, you will receive a password reset link."
      });
    } catch (error) {
      console.error("Error in manager forgot password:", error);
      return res.status(500).json({
        message: "Internal server error. Please try again later."
      });
    }
  });
  app3.post("/api/manager/reset-password", async (req, res) => {
    try {
      const { token, newPassword } = req.body;
      if (!token || !newPassword) {
        return res.status(400).json({ message: "Token and new password are required" });
      }
      if (newPassword.length < 8) {
        return res.status(400).json({ message: "Password must be at least 8 characters long" });
      }
      console.log(`\u{1F510} Manager password reset attempt with token: ${token.substring(0, 8)}...`);
      if (!pool) {
        return res.status(500).json({
          message: "Password reset service unavailable. Please try again later."
        });
      }
      const result = await pool.query(`
        SELECT u.* FROM users u 
        JOIN password_reset_tokens prt ON u.id = prt.user_id 
        WHERE prt.token = $1 AND prt.expires_at > NOW() AND u.role = 'manager'
      `, [token]);
      if (result.rows.length === 0) {
        console.log(`\u274C Invalid or expired reset token`);
        return res.status(400).json({ message: "Invalid or expired reset token" });
      }
      const manager = result.rows[0];
      const hashedPassword = await hashPassword(newPassword);
      try {
        await pool.query(
          "UPDATE users SET password = $1 WHERE id = $2",
          [hashedPassword, manager.id]
        );
        console.log(`\u2705 Password updated for manager: ${manager.id}`);
        await pool.query(
          "DELETE FROM password_reset_tokens WHERE user_id = $1",
          [manager.id]
        );
        console.log(`\u2705 Reset token cleared for manager: ${manager.id}`);
      } catch (dbError) {
        console.error("Error updating password:", dbError);
        return res.status(500).json({
          message: "Error updating password. Please try again later."
        });
      }
      console.log(`\u2705 Password successfully reset for manager: ${manager.id}`);
      return res.status(200).json({
        message: "Password reset successfully. You can now log in with your new password."
      });
    } catch (error) {
      console.error("Error in manager reset password:", error);
      return res.status(500).json({
        message: "Internal server error. Please try again later."
      });
    }
  });
  app3.post("/api/process-payouts", async (req, res) => {
    const authHeader = req.headers.authorization;
    const cronSecret = process.env.CRON_SECRET;
    if (cronSecret && authHeader !== `Bearer ${cronSecret}`) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    try {
      if (!pool) {
        return res.status(500).json({ error: "Database connection not available" });
      }
      const { processWeeklyPayouts: processWeeklyPayouts2, getPayoutSummary: getPayoutSummary2 } = await Promise.resolve().then(() => (init_payout_processing_service(), payout_processing_service_exports));
      const summary = await getPayoutSummary2(pool);
      const results = await processWeeklyPayouts2(pool, true);
      const successCount = results.filter((r) => r.success).length;
      const errorCount = results.filter((r) => !r.success).length;
      const totalAmount = results.reduce((sum, r) => sum + (r.amount || 0), 0);
      console.log(`Payout processing completed: ${successCount} successful, ${errorCount} errors, $${totalAmount.toFixed(2)} total`);
      res.status(200).json({
        success: true,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        summary: {
          ...summary,
          processedManagers: results.length,
          successfulPayouts: successCount,
          failedPayouts: errorCount,
          totalAmount
        },
        results: results.map((r) => ({
          managerId: r.managerId,
          success: r.success,
          amount: r.amount,
          error: r.error
        }))
      });
    } catch (error) {
      console.error("Error processing payouts:", error);
      res.status(500).json({
        success: false,
        error: error.message || "Failed to process payouts",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
  });
  const httpServer = createServer(app3);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs4 from "fs";
import { nanoid } from "nanoid";
import path3 from "path";
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app3, server) {
  const { createLogger, createServer: createViteServer } = await import("vite");
  const viteConfigPath = "../vite.config";
  const viteConfigModule = await import(viteConfigPath);
  const viteConfig = viteConfigModule.default;
  const viteLogger = createLogger();
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app3.use(vite.middlewares);
  app3.use("*", async (req, res, next) => {
    if (req.originalUrl.startsWith("/api/")) {
      return next();
    }
    const url = req.originalUrl;
    try {
      const clientTemplate = path3.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs4.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app3) {
  const distPath = path3.resolve(import.meta.dirname, "public");
  if (!fs4.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app3.use(express.static(distPath));
  app3.use("*", (_req, res) => {
    res.sendFile(path3.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app2 = express2();
app2.set("env", process.env.NODE_ENV || "development");
app2.use(express2.json({ limit: "12mb" }));
app2.use(express2.urlencoded({ limit: "12mb", extended: true }));
initializeFirebaseAdmin();
app2.use((req, res, next) => {
  const start = Date.now();
  const path4 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path4.startsWith("/api")) {
      let logLine = `${req.method} ${path4} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
var routesInitialized = false;
var initPromise = (async () => {
  if (routesInitialized) return;
  try {
    log("[INIT] Starting route registration...");
    await registerRoutes(app2);
    registerFirebaseRoutes(app2);
    app2.use((err, _req, res, _next) => {
      const status = err.status || err.statusCode || 500;
      const message = err.message || "Internal Server Error";
      res.status(status).json({ message });
      console.error(err);
    });
    routesInitialized = true;
    log("[ROUTES] All routes registered successfully");
    if (process.env.VERCEL) {
      log("[SERVERLESS] Running on Vercel - routes registered");
    } else {
      const { createServer: createServer2 } = await import("http");
      const server = createServer2(app2);
      const port = process.env.PORT || (app2.get("env") === "development" ? 5001 : 5e3);
      if (app2.get("env") === "development") {
        await setupVite(app2, server);
      } else {
        serveStatic(app2);
      }
      server.listen(port, () => {
        log(`[LOCAL] Server running on http://localhost:${port}`);
      });
    }
  } catch (error) {
    console.error("Failed to register routes:", error);
    throw error;
  }
})();
app2.use(async (req, res, next) => {
  if (!routesInitialized) {
    await initPromise;
  }
  next();
});
var index_default = app2;
export {
  index_default as default
};
