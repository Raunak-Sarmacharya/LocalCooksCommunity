var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// server/logger.ts
import pino from "pino";
import * as Sentry2 from "@sentry/node";
function getLogLevel() {
  if (isVercelProduction2) return "warn";
  if (isVercelPreview) return "info";
  if (isLocalDev) return "debug";
  return "info";
}
function getTransport() {
  if (isLocalDev) {
    return {
      target: "pino-pretty",
      options: {
        colorize: true,
        translateTime: "HH:MM:ss.l",
        ignore: "pid,hostname",
        customLevels: "operational:45",
        customColors: "operational:bgCyan",
        useOnlyCustomProps: false
      }
    };
  }
  return void 0;
}
function logOperational(instance, msg, data) {
  if (data) {
    instance.operational(data, msg);
  } else {
    instance.operational(msg);
  }
}
var isVercelProduction2, isVercelPreview, isLocalDev, customLevels, pinoLogger, logger, pinoInstance;
var init_logger = __esm({
  "server/logger.ts"() {
    "use strict";
    isVercelProduction2 = process.env.VERCEL_ENV === "production";
    isVercelPreview = process.env.VERCEL_ENV === "preview";
    isLocalDev = process.env.NODE_ENV === "development" && !process.env.VERCEL;
    customLevels = { operational: 45 };
    pinoLogger = pino({
      level: getLogLevel(),
      customLevels,
      // Ensure our custom level is included when filtering
      useOnlyCustomLevels: false,
      // In production/preview, use raw JSON (no transport = direct stdout)
      // In local dev, use pino-pretty for human-readable output
      transport: getTransport(),
      // Base fields attached to every log line
      base: {
        env: process.env.VERCEL_ENV || process.env.NODE_ENV || "unknown",
        region: process.env.VERCEL_REGION || void 0
      },
      // Format the level as a string label instead of a number
      formatters: {
        level(label) {
          return { level: label };
        }
      },
      // ISO timestamp for structured log aggregation
      timestamp: pino.stdTimeFunctions.isoTime
    });
    logger = {
      info(msg, ...args) {
        if (args.length === 0) {
          pinoLogger.info(msg);
        } else if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && !(args[0] instanceof Error)) {
          pinoLogger.info(args[0], msg);
        } else {
          pinoLogger.info({ args }, msg);
        }
      },
      warn(msg, ...args) {
        if (args.length === 0) {
          pinoLogger.warn(msg);
        } else if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && !(args[0] instanceof Error)) {
          pinoLogger.warn(args[0], msg);
        } else {
          pinoLogger.warn({ args }, msg);
        }
      },
      error(msg, error) {
        if (error instanceof Error) {
          pinoLogger.error({ err: error }, msg);
          Sentry2.addBreadcrumb({
            category: "logger",
            message: msg,
            level: "error",
            data: { errorMessage: error.message }
          });
        } else if (error && typeof error === "object") {
          pinoLogger.error(error, msg);
          Sentry2.addBreadcrumb({
            category: "logger",
            message: msg,
            level: "error",
            data: { detail: JSON.stringify(error) }
          });
        } else if (error) {
          pinoLogger.error({ detail: String(error) }, msg);
          Sentry2.addBreadcrumb({
            category: "logger",
            message: msg,
            level: "error",
            data: { detail: String(error) }
          });
        } else {
          pinoLogger.error(msg);
          Sentry2.addBreadcrumb({
            category: "logger",
            message: msg,
            level: "error"
          });
        }
      },
      debug(msg, ...args) {
        if (args.length === 0) {
          pinoLogger.debug(msg);
        } else if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && !(args[0] instanceof Error)) {
          pinoLogger.debug(args[0], msg);
        } else {
          pinoLogger.debug({ args }, msg);
        }
      },
      operational(msg, data) {
        logOperational(pinoLogger, msg, data);
      },
      fatal(msg, data) {
        if (data) {
          pinoLogger.fatal(data, msg);
        } else {
          pinoLogger.fatal(msg);
        }
        Sentry2.captureMessage(msg, "fatal");
      },
      /**
       * Create a child logger with bound context fields.
       * Every log from the child automatically includes these fields.
       * 
       * Usage:
       *   const reqLog = logger.child({ requestId, userId, bookingId });
       *   reqLog.info('Processing booking');
       *   // â†’ {"level":"info","requestId":"abc","userId":42,"bookingId":183,"msg":"Processing booking"}
       */
      child(bindings) {
        const childPino = pinoLogger.child(bindings);
        return {
          info: (msg, data) => data ? childPino.info(data, msg) : childPino.info(msg),
          warn: (msg, data) => data ? childPino.warn(data, msg) : childPino.warn(msg),
          error: (msg, error) => {
            if (error instanceof Error) {
              childPino.error({ err: error }, msg);
              Sentry2.addBreadcrumb({
                category: "logger",
                message: msg,
                level: "error",
                data: { errorMessage: error.message, ...bindings }
              });
            } else if (error && typeof error === "object") {
              childPino.error(error, msg);
              Sentry2.addBreadcrumb({
                category: "logger",
                message: msg,
                level: "error",
                data: { detail: JSON.stringify(error), ...bindings }
              });
            } else if (error) {
              childPino.error({ detail: String(error) }, msg);
              Sentry2.addBreadcrumb({
                category: "logger",
                message: msg,
                level: "error",
                data: { detail: String(error), ...bindings }
              });
            } else {
              childPino.error(msg);
              Sentry2.addBreadcrumb({
                category: "logger",
                message: msg,
                level: "error",
                data: { ...bindings }
              });
            }
          },
          debug: (msg, data) => data ? childPino.debug(data, msg) : childPino.debug(msg),
          operational: (msg, data) => {
            logOperational(childPino, msg, data);
          }
        };
      }
    };
    pinoInstance = pinoLogger;
  }
});

// server/firebase-setup.ts
var firebase_setup_exports = {};
__export(firebase_setup_exports, {
  firebaseAdmin: () => firebaseAdmin,
  getFirebaseUserByEmail: () => getFirebaseUserByEmail,
  initializeFirebaseAdmin: () => initializeFirebaseAdmin,
  isFirebaseAdminConfigured: () => isFirebaseAdminConfigured,
  verifyFirebaseToken: () => verifyFirebaseToken
});
import { initializeApp, cert } from "firebase-admin/app";
import { getAuth } from "firebase-admin/auth";
function initializeFirebaseAdmin() {
  if (firebaseAdmin) {
    return firebaseAdmin;
  }
  try {
    if (process.env.FIREBASE_PROJECT_ID && process.env.FIREBASE_CLIENT_EMAIL && process.env.FIREBASE_PRIVATE_KEY) {
      logger.info("\u{1F525} Initializing Firebase Admin with service account credentials...");
      try {
        firebaseAdmin = initializeApp({
          credential: cert({
            projectId: process.env.FIREBASE_PROJECT_ID,
            clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
            privateKey: process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, "\n")
          }),
          projectId: process.env.FIREBASE_PROJECT_ID
        });
        logger.info("\u2705 Firebase Admin initialized with service account for project:", process.env.FIREBASE_PROJECT_ID);
        return firebaseAdmin;
      } catch (error) {
        logger.error("\u274C Failed to initialize Firebase Admin with service account:", error.message);
      }
    }
    if (!process.env.VITE_FIREBASE_PROJECT_ID) {
      logger.warn("Firebase Admin not configured - Firebase auth verification will be disabled (missing both service account and VITE_FIREBASE_PROJECT_ID)");
      return null;
    }
    try {
      firebaseAdmin = initializeApp({
        projectId: process.env.VITE_FIREBASE_PROJECT_ID
      });
      logger.info("\u{1F525} Firebase Admin initialized with default credentials for project:", process.env.VITE_FIREBASE_PROJECT_ID);
    } catch (error) {
      logger.info("\u{1F525} Firebase Admin initialization failed, will rely on client-side checks:", error.message || "Unknown error");
      return null;
    }
    return firebaseAdmin;
  } catch (error) {
    logger.error("\u274C Failed to initialize Firebase Admin:", error);
    return null;
  }
}
async function verifyFirebaseToken(token) {
  try {
    const app2 = initializeFirebaseAdmin();
    if (!app2) {
      logger.warn("Firebase Admin not initialized - cannot verify token");
      return null;
    }
    const decodedToken = await getAuth(app2).verifyIdToken(token);
    return decodedToken;
  } catch (error) {
    logger.error("Error verifying Firebase token:", error);
    return null;
  }
}
function isFirebaseAdminConfigured() {
  return !!(process.env.FIREBASE_PROJECT_ID || process.env.VITE_FIREBASE_PROJECT_ID);
}
async function getFirebaseUserByEmail(email) {
  try {
    const app2 = initializeFirebaseAdmin();
    if (!app2) {
      logger.warn("Firebase Admin not initialized - cannot get user by email");
      return null;
    }
    const userRecord = await getAuth(app2).getUserByEmail(email);
    return userRecord;
  } catch (error) {
    if (error.code === "auth/user-not-found") {
      logger.info(`Firebase user not found for email: ${email}`);
      return null;
    }
    logger.error("Error getting Firebase user by email:", error);
    return null;
  }
}
var firebaseAdmin;
var init_firebase_setup = __esm({
  "server/firebase-setup.ts"() {
    "use strict";
    init_logger();
    firebaseAdmin = null;
  }
});

// shared/phone-validation.ts
var phone_validation_exports = {};
__export(phone_validation_exports, {
  formatPhoneForDisplay: () => formatPhoneForDisplay,
  isValidNorthAmericanPhone: () => isValidNorthAmericanPhone,
  normalizePhoneNumber: () => normalizePhoneNumber,
  optionalPhoneNumberSchema: () => optionalPhoneNumberSchema,
  phoneNumberSchema: () => phoneNumberSchema,
  validateAndNormalizePhone: () => validateAndNormalizePhone
});
import { z } from "zod";
var normalizePhoneNumber, isValidNorthAmericanPhone, formatPhoneForDisplay, phoneNumberSchema, optionalPhoneNumberSchema, validateAndNormalizePhone;
var init_phone_validation = __esm({
  "shared/phone-validation.ts"() {
    "use strict";
    normalizePhoneNumber = (phone) => {
      if (!phone) return null;
      const trimmed = phone.trim();
      if (!trimmed) return null;
      const cleaned = trimmed.replace(/[^\d+]/g, "");
      if (cleaned.startsWith("+")) {
        const digitsAfterPlus = cleaned.substring(1);
        if (digitsAfterPlus.length >= 1 && digitsAfterPlus.length <= 15 && /^\d+$/.test(digitsAfterPlus)) {
          if (digitsAfterPlus.startsWith("1") && digitsAfterPlus.length === 11) {
            return cleaned;
          }
          if (digitsAfterPlus.length === 10) {
            return `+1${digitsAfterPlus}`;
          }
          return null;
        }
        return null;
      }
      const digitsOnly = cleaned.replace(/\D/g, "");
      if (digitsOnly.length === 11 && digitsOnly.startsWith("1")) {
        return `+${digitsOnly}`;
      }
      if (digitsOnly.length === 10) {
        return `+1${digitsOnly}`;
      }
      return null;
    };
    isValidNorthAmericanPhone = (phone) => {
      if (!phone) return false;
      let normalized;
      if (phone.startsWith("+1") && phone.length === 12) {
        normalized = phone;
      } else {
        normalized = normalizePhoneNumber(phone);
      }
      if (!normalized) return false;
      if (!normalized.startsWith("+1") || normalized.length !== 12) {
        return false;
      }
      const digits = normalized.substring(2);
      if (digits.length !== 10 || !/^\d{10}$/.test(digits)) {
        return false;
      }
      const areaCodeFirstDigit = parseInt(digits[0]);
      if (areaCodeFirstDigit < 2 || areaCodeFirstDigit > 9) return false;
      const exchangeCodeFirstDigit = parseInt(digits[3]);
      if (exchangeCodeFirstDigit < 2 || exchangeCodeFirstDigit > 9) return false;
      return true;
    };
    formatPhoneForDisplay = (phone) => {
      const normalized = normalizePhoneNumber(phone);
      if (!normalized) return phone || "";
      if (normalized.startsWith("+1") && normalized.length === 12) {
        const digits = normalized.substring(2);
        return `(${digits.substring(0, 3)}) ${digits.substring(3, 6)}-${digits.substring(6)}`;
      }
      return normalized;
    };
    phoneNumberSchema = z.string().min(1, "Phone number is required").refine(
      (val) => {
        const normalized = normalizePhoneNumber(val);
        return normalized !== null && isValidNorthAmericanPhone(normalized);
      },
      {
        message: "Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
      }
    ).transform((val) => {
      const normalized = normalizePhoneNumber(val);
      return normalized || val;
    });
    optionalPhoneNumberSchema = z.string().optional().refine(
      (val) => {
        if (!val || val.trim() === "") return true;
        const normalized = normalizePhoneNumber(val);
        return normalized !== null && isValidNorthAmericanPhone(normalized);
      },
      {
        message: "Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
      }
    ).transform((val) => {
      if (!val || val.trim() === "") return null;
      const normalized = normalizePhoneNumber(val);
      return normalized || val;
    });
    validateAndNormalizePhone = (phone) => {
      if (!phone) return null;
      return normalizePhoneNumber(phone);
    };
  }
});

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  adminDamageClaimDecisionSchema: () => adminDamageClaimDecisionSchema,
  applicationStatusEnum: () => applicationStatusEnum,
  applicationTypeEnum: () => applicationTypeEnum,
  applications: () => applications,
  bookingDurationUnitEnum: () => bookingDurationUnitEnum,
  bookingStatusEnum: () => bookingStatusEnum,
  bookingTypeEnum: () => bookingTypeEnum,
  certificationStatusEnum: () => certificationStatusEnum,
  checkoutStatusEnum: () => checkoutStatusEnum,
  chefDamageClaimResponseSchema: () => chefDamageClaimResponseSchema,
  chefKitchenAccess: () => chefKitchenAccess,
  chefKitchenApplications: () => chefKitchenApplications,
  chefKitchenProfiles: () => chefKitchenProfiles,
  chefLocationAccess: () => chefLocationAccess,
  chefLocationProfiles: () => chefLocationProfiles,
  customFieldSchema: () => customFieldSchema,
  damageClaimHistory: () => damageClaimHistory,
  damageClaimStatusEnum: () => damageClaimStatusEnum,
  damageClaims: () => damageClaims,
  damageEvidence: () => damageEvidence,
  damagedItemSchema: () => damagedItemSchema,
  documentVerificationStatusEnum: () => documentVerificationStatusEnum,
  emailVerificationTokens: () => emailVerificationTokens,
  equipmentAvailabilityTypeEnum: () => equipmentAvailabilityTypeEnum,
  equipmentBookings: () => equipmentBookings,
  equipmentCategoryEnum: () => equipmentCategoryEnum,
  equipmentConditionEnum: () => equipmentConditionEnum,
  equipmentListings: () => equipmentListings,
  equipmentPricingModelEnum: () => equipmentPricingModelEnum,
  evidenceTypeEnum: () => evidenceTypeEnum,
  insertApplicationSchema: () => insertApplicationSchema,
  insertChefKitchenAccessSchema: () => insertChefKitchenAccessSchema,
  insertChefKitchenApplicationSchema: () => insertChefKitchenApplicationSchema,
  insertChefKitchenProfileSchema: () => insertChefKitchenProfileSchema,
  insertChefLocationAccessSchema: () => insertChefLocationAccessSchema,
  insertChefLocationProfileSchema: () => insertChefLocationProfileSchema,
  insertDamageClaimSchema: () => insertDamageClaimSchema,
  insertDamageEvidenceSchema: () => insertDamageEvidenceSchema,
  insertEquipmentBookingSchema: () => insertEquipmentBookingSchema,
  insertEquipmentListingSchema: () => insertEquipmentListingSchema,
  insertKitchenAvailabilitySchema: () => insertKitchenAvailabilitySchema,
  insertKitchenBookingSchema: () => insertKitchenBookingSchema,
  insertKitchenDateOverrideSchema: () => insertKitchenDateOverrideSchema,
  insertKitchenSchema: () => insertKitchenSchema,
  insertLocationRequirementsSchema: () => insertLocationRequirementsSchema,
  insertLocationSchema: () => insertLocationSchema,
  insertMicrolearningCompletionSchema: () => insertMicrolearningCompletionSchema,
  insertPaymentTransactionSchema: () => insertPaymentTransactionSchema,
  insertPlatformSettingSchema: () => insertPlatformSettingSchema,
  insertPortalUserApplicationSchema: () => insertPortalUserApplicationSchema,
  insertPortalUserLocationAccessSchema: () => insertPortalUserLocationAccessSchema,
  insertStorageBookingSchema: () => insertStorageBookingSchema,
  insertStorageListingSchema: () => insertStorageListingSchema,
  insertStorageOverstayRecordSchema: () => insertStorageOverstayRecordSchema,
  insertUserSchema: () => insertUserSchema,
  insertVideoProgressSchema: () => insertVideoProgressSchema,
  kitchenAvailability: () => kitchenAvailability,
  kitchenBookings: () => kitchenBookings,
  kitchenDateOverrides: () => kitchenDateOverrides,
  kitchenPreferenceEnum: () => kitchenPreferenceEnum,
  kitchens: () => kitchens,
  listingStatusEnum: () => listingStatusEnum,
  locationRequirements: () => locationRequirements,
  locations: () => locations,
  microlearningCompletions: () => microlearningCompletions,
  overstayStatusEnum: () => overstayStatusEnum,
  paymentHistory: () => paymentHistory,
  paymentStatusEnum: () => paymentStatusEnum,
  paymentTransactions: () => paymentTransactions,
  pendingStorageExtensions: () => pendingStorageExtensions,
  platformSettings: () => platformSettings,
  portalUserApplications: () => portalUserApplications,
  portalUserLocationAccess: () => portalUserLocationAccess,
  storageBookings: () => storageBookings,
  storageCheckoutApprovalSchema: () => storageCheckoutApprovalSchema,
  storageCheckoutRequestSchema: () => storageCheckoutRequestSchema,
  storageListings: () => storageListings,
  storageOverstayHistory: () => storageOverstayHistory,
  storageOverstayRecords: () => storageOverstayRecords,
  storagePricingModelEnum: () => storagePricingModelEnum,
  storageTypeEnum: () => storageTypeEnum,
  transactionStatusEnum: () => transactionStatusEnum,
  updateApplicationDocumentsSchema: () => updateApplicationDocumentsSchema,
  updateApplicationStatusSchema: () => updateApplicationStatusSchema,
  updateApplicationTierSchema: () => updateApplicationTierSchema,
  updateChefKitchenApplicationDocumentsSchema: () => updateChefKitchenApplicationDocumentsSchema,
  updateChefKitchenApplicationSchema: () => updateChefKitchenApplicationSchema,
  updateChefKitchenApplicationStatusSchema: () => updateChefKitchenApplicationStatusSchema,
  updateChefKitchenProfileSchema: () => updateChefKitchenProfileSchema,
  updateChefLocationProfileSchema: () => updateChefLocationProfileSchema,
  updateDamageClaimSchema: () => updateDamageClaimSchema,
  updateDocumentVerificationSchema: () => updateDocumentVerificationSchema,
  updateEquipmentBookingSchema: () => updateEquipmentBookingSchema,
  updateEquipmentBookingStatusSchema: () => updateEquipmentBookingStatusSchema,
  updateEquipmentListingSchema: () => updateEquipmentListingSchema,
  updateEquipmentListingStatusSchema: () => updateEquipmentListingStatusSchema,
  updateKitchenBookingSchema: () => updateKitchenBookingSchema,
  updateKitchenDateOverrideSchema: () => updateKitchenDateOverrideSchema,
  updateKitchenSchema: () => updateKitchenSchema,
  updateLocationRequirementsSchema: () => updateLocationRequirementsSchema,
  updateLocationSchema: () => updateLocationSchema,
  updatePaymentTransactionSchema: () => updatePaymentTransactionSchema,
  updatePlatformSettingSchema: () => updatePlatformSettingSchema,
  updatePortalUserApplicationStatusSchema: () => updatePortalUserApplicationStatusSchema,
  updateStorageBookingSchema: () => updateStorageBookingSchema,
  updateStorageBookingStatusSchema: () => updateStorageBookingStatusSchema,
  updateStorageListingSchema: () => updateStorageListingSchema,
  updateStorageListingStatusSchema: () => updateStorageListingStatusSchema,
  updateStorageOverstayRecordSchema: () => updateStorageOverstayRecordSchema,
  userRoleEnum: () => userRoleEnum,
  users: () => users,
  videoProgress: () => videoProgress
});
import { boolean, date, integer, jsonb, numeric, pgEnum, pgTable, serial, text, timestamp } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z as z2 } from "zod";
var kitchenPreferenceEnum, certificationStatusEnum, applicationStatusEnum, userRoleEnum, documentVerificationStatusEnum, applicationTypeEnum, bookingStatusEnum, storageTypeEnum, checkoutStatusEnum, storagePricingModelEnum, bookingDurationUnitEnum, listingStatusEnum, equipmentCategoryEnum, equipmentConditionEnum, equipmentPricingModelEnum, equipmentAvailabilityTypeEnum, paymentStatusEnum, transactionStatusEnum, bookingTypeEnum, users, applications, insertApplicationSchema, updateApplicationStatusSchema, updateApplicationDocumentsSchema, updateDocumentVerificationSchema, insertUserSchema, emailVerificationTokens, microlearningCompletions, videoProgress, insertMicrolearningCompletionSchema, insertVideoProgressSchema, locations, locationRequirements, kitchens, kitchenAvailability, kitchenDateOverrides, kitchenBookings, chefLocationAccess, chefKitchenAccess, chefKitchenProfiles, chefLocationProfiles, portalUserApplications, portalUserLocationAccess, insertLocationSchema, updateLocationSchema, insertLocationRequirementsSchema, customFieldSchema, updateLocationRequirementsSchema, insertKitchenSchema, updateKitchenSchema, insertKitchenAvailabilitySchema, insertKitchenDateOverrideSchema, updateKitchenDateOverrideSchema, insertKitchenBookingSchema, updateKitchenBookingSchema, insertChefLocationAccessSchema, insertChefKitchenAccessSchema, insertChefKitchenProfileSchema, updateChefKitchenProfileSchema, insertChefLocationProfileSchema, updateChefLocationProfileSchema, insertPortalUserApplicationSchema, updatePortalUserApplicationStatusSchema, insertPortalUserLocationAccessSchema, storageListings, insertStorageListingSchema, updateStorageListingSchema, updateStorageListingStatusSchema, equipmentListings, insertEquipmentListingSchema, updateEquipmentListingSchema, updateEquipmentListingStatusSchema, storageBookings, insertStorageBookingSchema, updateStorageBookingSchema, updateStorageBookingStatusSchema, storageCheckoutRequestSchema, storageCheckoutApprovalSchema, equipmentBookings, insertEquipmentBookingSchema, updateEquipmentBookingSchema, updateEquipmentBookingStatusSchema, platformSettings, insertPlatformSettingSchema, updatePlatformSettingSchema, chefKitchenApplications, insertChefKitchenApplicationSchema, updateChefKitchenApplicationSchema, updateChefKitchenApplicationStatusSchema, updateApplicationTierSchema, updateChefKitchenApplicationDocumentsSchema, paymentTransactions, paymentHistory, insertPaymentTransactionSchema, updatePaymentTransactionSchema, pendingStorageExtensions, overstayStatusEnum, storageOverstayRecords, storageOverstayHistory, insertStorageOverstayRecordSchema, updateStorageOverstayRecordSchema, damageClaimStatusEnum, evidenceTypeEnum, damageClaims, damageEvidence, damageClaimHistory, damageClaimStatusValues, evidenceTypeValues, damagedItemSchema, insertDamageClaimSchema, updateDamageClaimSchema, insertDamageEvidenceSchema, chefDamageClaimResponseSchema, adminDamageClaimDecisionSchema;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    init_phone_validation();
    kitchenPreferenceEnum = pgEnum("kitchen_preference", ["commercial", "home", "notSure"]);
    certificationStatusEnum = pgEnum("certification_status", ["yes", "no", "notSure"]);
    applicationStatusEnum = pgEnum("application_status", ["inReview", "approved", "rejected", "cancelled"]);
    userRoleEnum = pgEnum("user_role", ["admin", "chef", "manager"]);
    documentVerificationStatusEnum = pgEnum("document_verification_status", ["pending", "approved", "rejected", "expired"]);
    applicationTypeEnum = pgEnum("application_type", ["chef"]);
    bookingStatusEnum = pgEnum("booking_status", ["pending", "confirmed", "cancelled", "completed", "cancellation_requested"]);
    storageTypeEnum = pgEnum("storage_type", ["dry", "cold", "freezer"]);
    checkoutStatusEnum = pgEnum("checkout_status", ["active", "checkout_requested", "checkout_approved", "completed", "checkout_claim_filed"]);
    storagePricingModelEnum = pgEnum("storage_pricing_model", ["monthly-flat", "per-cubic-foot", "hourly", "daily"]);
    bookingDurationUnitEnum = pgEnum("booking_duration_unit", ["hourly", "daily", "monthly"]);
    listingStatusEnum = pgEnum("listing_status", ["draft", "pending", "approved", "rejected", "active", "inactive"]);
    equipmentCategoryEnum = pgEnum("equipment_category", ["food-prep", "cooking", "refrigeration", "cleaning", "specialty"]);
    equipmentConditionEnum = pgEnum("equipment_condition", ["excellent", "good", "fair", "needs-repair"]);
    equipmentPricingModelEnum = pgEnum("equipment_pricing_model", ["hourly", "daily", "weekly", "monthly"]);
    equipmentAvailabilityTypeEnum = pgEnum("equipment_availability_type", ["included", "rental"]);
    paymentStatusEnum = pgEnum("payment_status", ["pending", "authorized", "processing", "paid", "refunded", "failed", "partially_refunded"]);
    transactionStatusEnum = pgEnum("transaction_status", ["pending", "authorized", "processing", "succeeded", "failed", "canceled", "refunded", "partially_refunded"]);
    bookingTypeEnum = pgEnum("booking_type_enum", ["kitchen", "storage", "equipment", "bundle"]);
    users = pgTable("users", {
      id: serial("id").primaryKey(),
      username: text("username").notNull().unique(),
      password: text("password").notNull(),
      role: userRoleEnum("role"),
      // Allow null initially - user will choose role
      googleId: text("google_id").unique(),
      facebookId: text("facebook_id").unique(),
      firebaseUid: text("firebase_uid").unique(),
      isVerified: boolean("is_verified").default(false).notNull(),
      has_seen_welcome: boolean("has_seen_welcome").default(false).notNull(),
      welcomeEmailSentAt: timestamp("welcome_email_sent_at"),
      // Track when welcome email was sent (null = not sent, prevents duplicates)
      // Support dual roles - users can be both chef and manager
      isChef: boolean("is_chef").default(false).notNull(),
      isManager: boolean("is_manager").default(false).notNull(),
      isPortalUser: boolean("is_portal_user").default(false).notNull(),
      applicationType: applicationTypeEnum("application_type"),
      // DEPRECATED: kept for backward compatibility
      // Manager onboarding fields
      managerOnboardingCompleted: boolean("manager_onboarding_completed").default(false).notNull(),
      // Whether manager completed onboarding
      managerOnboardingSkipped: boolean("manager_onboarding_skipped").default(false).notNull(),
      // Whether manager skipped onboarding
      managerOnboardingStepsCompleted: jsonb("manager_onboarding_steps_completed").default({}).notNull(),
      // JSON object tracking completed onboarding steps
      // Chef onboarding fields (informative onboarding - no restrictions)
      chefOnboardingCompleted: boolean("chef_onboarding_completed").default(false).notNull(),
      // Whether chef completed informative onboarding
      chefOnboardingPaths: jsonb("chef_onboarding_paths").default([]).notNull(),
      // Selected paths: ['localcooks', 'kitchen']
      // Manager profile data (bespoke fields)
      managerProfileData: jsonb("manager_profile_data").default({}).notNull(),
      // Stripe Connect fields for manager payments
      stripeConnectAccountId: text("stripe_connect_account_id").unique(),
      // Stripe Connect Express account ID
      stripeConnectOnboardingStatus: text("stripe_connect_onboarding_status").default("not_started").notNull(),
      // Status: 'not_started', 'in_progress', 'complete', 'failed'
      // Stripe Customer ID for off-session payments (penalties, recurring charges)
      stripeCustomerId: text("stripe_customer_id").unique(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    applications = pgTable("applications", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").references(() => users.id),
      fullName: text("full_name").notNull(),
      email: text("email").notNull(),
      phone: text("phone").notNull(),
      foodSafetyLicense: certificationStatusEnum("food_safety_license").notNull(),
      foodEstablishmentCert: certificationStatusEnum("food_establishment_cert").notNull(),
      kitchenPreference: kitchenPreferenceEnum("kitchen_preference").notNull(),
      feedback: text("feedback"),
      status: applicationStatusEnum("status").default("inReview").notNull(),
      // Document verification fields
      foodSafetyLicenseUrl: text("food_safety_license_url"),
      foodEstablishmentCertUrl: text("food_establishment_cert_url"),
      foodSafetyLicenseStatus: documentVerificationStatusEnum("food_safety_license_status").default("pending"),
      foodEstablishmentCertStatus: documentVerificationStatusEnum("food_establishment_cert_status").default("pending"),
      documentsAdminFeedback: text("documents_admin_feedback"),
      documentsReviewedBy: integer("documents_reviewed_by").references(() => users.id),
      documentsReviewedAt: timestamp("documents_reviewed_at"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    insertApplicationSchema = createInsertSchema(applications, {
      fullName: z2.string().min(2, "Name must be at least 2 characters"),
      email: z2.string().email("Please enter a valid email address"),
      phone: phoneNumberSchema,
      // Uses shared phone validation
      foodSafetyLicense: z2.enum(["yes", "no", "notSure"]),
      foodEstablishmentCert: z2.enum(["yes", "no", "notSure"]),
      kitchenPreference: z2.enum(["commercial", "home", "notSure"]),
      feedback: z2.string().optional(),
      userId: z2.number().optional(),
      // Document fields are optional during initial application submission
      foodSafetyLicenseUrl: z2.string().optional(),
      foodEstablishmentCertUrl: z2.string().optional(),
      // Allow setting document status during creation
      foodSafetyLicenseStatus: z2.enum(["pending", "approved", "rejected"]).optional(),
      foodEstablishmentCertStatus: z2.enum(["pending", "approved", "rejected"]).optional()
    }).omit({
      id: true,
      status: true,
      createdAt: true,
      documentsAdminFeedback: true,
      documentsReviewedBy: true,
      documentsReviewedAt: true
    });
    updateApplicationStatusSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["inReview", "approved", "rejected", "cancelled"])
    });
    updateApplicationDocumentsSchema = z2.object({
      id: z2.number(),
      foodSafetyLicenseUrl: z2.string().optional(),
      foodEstablishmentCertUrl: z2.string().optional()
    });
    updateDocumentVerificationSchema = z2.object({
      id: z2.number(),
      foodSafetyLicenseStatus: z2.enum(["pending", "approved", "rejected"]).optional(),
      foodEstablishmentCertStatus: z2.enum(["pending", "approved", "rejected"]).optional(),
      documentsAdminFeedback: z2.string().optional(),
      documentsReviewedBy: z2.number().optional()
    });
    insertUserSchema = z2.object({
      username: z2.string().min(3, "Username must be at least 3 characters"),
      password: z2.string().min(6, "Password must be at least 6 characters"),
      role: z2.enum(["admin", "chef", "manager"]).default("chef"),
      googleId: z2.string().optional(),
      facebookId: z2.string().optional(),
      firebaseUid: z2.string().optional(),
      isChef: z2.boolean().default(false),
      isManager: z2.boolean().default(false),
      isPortalUser: z2.boolean().default(false),
      managerProfileData: z2.record(z2.any()).default({})
    });
    emailVerificationTokens = pgTable("email_verification_tokens", {
      id: serial("id").primaryKey(),
      email: text("email").notNull().unique(),
      token: text("token").notNull(),
      expiresAt: timestamp("expires_at").notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    microlearningCompletions = pgTable("microlearning_completions", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").references(() => users.id).notNull(),
      completedAt: timestamp("completed_at").defaultNow().notNull(),
      confirmed: boolean("confirmed").default(false).notNull(),
      certificateGenerated: boolean("certificate_generated").default(false).notNull(),
      videoProgress: jsonb("video_progress"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    videoProgress = pgTable("video_progress", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").references(() => users.id).notNull(),
      videoId: text("video_id").notNull(),
      progress: numeric("progress", { precision: 5, scale: 2 }).default("0").notNull(),
      completed: boolean("completed").default(false).notNull(),
      completedAt: timestamp("completed_at"),
      updatedAt: timestamp("updated_at").defaultNow().notNull(),
      watchedPercentage: numeric("watched_percentage", { precision: 5, scale: 2 }).default("0").notNull(),
      isRewatching: boolean("is_rewatching").default(false).notNull()
    });
    insertMicrolearningCompletionSchema = createInsertSchema(microlearningCompletions, {
      userId: z2.number(),
      confirmed: z2.boolean().optional(),
      certificateGenerated: z2.boolean().optional(),
      videoProgress: z2.any().optional()
    }).omit({
      id: true,
      completedAt: true,
      createdAt: true,
      updatedAt: true
    });
    insertVideoProgressSchema = createInsertSchema(videoProgress, {
      userId: z2.number(),
      videoId: z2.string().min(1, "Video ID is required"),
      progress: z2.number().min(0).max(100).optional(),
      completed: z2.boolean().optional(),
      watchedPercentage: z2.number().min(0).max(100).optional(),
      isRewatching: z2.boolean().optional()
    }).omit({
      id: true,
      completedAt: true,
      updatedAt: true
    });
    locations = pgTable("locations", {
      id: serial("id").primaryKey(),
      name: text("name").notNull(),
      address: text("address").notNull(),
      managerId: integer("manager_id").references(() => users.id),
      notificationEmail: text("notification_email"),
      // Email where notifications will be sent
      notificationPhone: text("notification_phone"),
      // Phone number where SMS notifications will be sent
      contactEmail: text("contact_email"),
      // Primary business contact email
      contactPhone: text("contact_phone"),
      // Primary business contact phone
      preferredContactMethod: text("preferred_contact_method").default("email").notNull(),
      // email, phone, or both
      cancellationPolicyHours: integer("cancellation_policy_hours").default(24).notNull(),
      cancellationPolicyMessage: text("cancellation_policy_message").default("Bookings cannot be cancelled within {hours} hours of the scheduled time.").notNull(),
      defaultDailyBookingLimit: integer("default_daily_booking_limit").default(2).notNull(),
      minimumBookingWindowHours: integer("minimum_booking_window_hours").default(1).notNull(),
      logoUrl: text("logo_url"),
      // Logo URL for the location (for manager header)
      brandImageUrl: text("brand_image_url"),
      // Brand image URL for the location (displayed on public kitchen listings)
      timezone: text("timezone").default("America/St_Johns").notNull(),
      // Timezone for this location (default: Newfoundland)
      // Kitchen license fields for manager onboarding
      kitchenLicenseUrl: text("kitchen_license_url"),
      // URL to uploaded kitchen license document
      kitchenLicenseStatus: text("kitchen_license_status").default("pending"),
      // pending, approved, rejected
      kitchenLicenseApprovedBy: integer("kitchen_license_approved_by").references(() => users.id),
      // Admin who approved/rejected
      kitchenLicenseApprovedAt: timestamp("kitchen_license_approved_at"),
      // When license was approved/rejected
      kitchenLicenseFeedback: text("kitchen_license_feedback"),
      // Admin feedback on license
      kitchenLicenseExpiry: date("kitchen_license_expiry"),
      // Expiration date of the kitchen license
      // Kitchen terms and policies (uploaded alongside license)
      kitchenTermsUrl: text("kitchen_terms_url"),
      // URL to uploaded kitchen terms & policies document
      kitchenTermsUploadedAt: timestamp("kitchen_terms_uploaded_at"),
      // When terms were uploaded
      description: text("description"),
      // Description of the location
      customOnboardingLink: text("custom_onboarding_link"),
      // Custom link for onboarding
      // Location-level overstay penalty defaults (manager-controlled, used when storage listing doesn't have custom values)
      overstayGracePeriodDays: integer("overstay_grace_period_days"),
      // Days before penalties apply
      overstayPenaltyRate: numeric("overstay_penalty_rate"),
      // Penalty rate as decimal (0.10 = 10%)
      overstayMaxPenaltyDays: integer("overstay_max_penalty_days"),
      // Max days penalties can accrue
      overstayPolicyText: text("overstay_policy_text"),
      // Default policy text for all storage at this location
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    locationRequirements = pgTable("location_requirements", {
      id: serial("id").primaryKey(),
      locationId: integer("location_id").references(() => locations.id, { onDelete: "cascade" }).notNull().unique(),
      // Personal Information
      requireFirstName: boolean("require_first_name").default(true).notNull(),
      requireLastName: boolean("require_last_name").default(true).notNull(),
      requireEmail: boolean("require_email").default(true).notNull(),
      requirePhone: boolean("require_phone").default(true).notNull(),
      // Business Information
      requireBusinessName: boolean("require_business_name").default(true).notNull(),
      requireBusinessType: boolean("require_business_type").default(true).notNull(),
      requireExperience: boolean("require_experience").default(true).notNull(),
      requireBusinessDescription: boolean("require_business_description").default(false).notNull(),
      // Certifications
      requireFoodHandlerCert: boolean("require_food_handler_cert").default(true).notNull(),
      requireFoodHandlerExpiry: boolean("require_food_handler_expiry").default(true).notNull(),
      // Kitchen Usage
      requireUsageFrequency: boolean("require_usage_frequency").default(true).notNull(),
      requireSessionDuration: boolean("require_session_duration").default(true).notNull(),
      // Agreements
      requireTermsAgree: boolean("require_terms_agree").default(true).notNull(),
      requireAccuracyAgree: boolean("require_accuracy_agree").default(true).notNull(),
      // Tier 1 Requirements (Submit Application)
      tier1_years_experience_required: boolean("tier1_years_experience_required").default(false).notNull(),
      tier1_years_experience_minimum: integer("tier1_years_experience_minimum").default(0).notNull(),
      tier1_custom_fields: jsonb("tier1_custom_fields").default([]),
      // Tier 2 Requirements (Kitchen Coordination)
      tier2_food_establishment_cert_required: boolean("tier2_food_establishment_cert_required").default(false).notNull(),
      tier2_food_establishment_expiry_required: boolean("tier2_food_establishment_expiry_required").default(false).notNull(),
      tier2_insurance_document_required: boolean("tier2_insurance_document_required").default(false).notNull(),
      tier2_insurance_minimum_amount: integer("tier2_insurance_minimum_amount").default(0).notNull(),
      tier2_kitchen_experience_required: boolean("tier2_kitchen_experience_required").default(false).notNull(),
      tier2_custom_fields: jsonb("tier2_custom_fields").default([]),
      // Facility Information (auto-shared with chefs)
      floor_plans_url: text("floor_plans_url"),
      ventilation_specs: text("ventilation_specs"),
      ventilation_specs_url: text("ventilation_specs_url"),
      equipment_list: jsonb("equipment_list").default([]),
      // Array of equipment names
      materials_description: text("materials_description"),
      // Custom Fields (JSONB array of field definitions)
      customFields: jsonb("custom_fields").default([]),
      // Array of { id, label, type, required, options?, placeholder? }
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    kitchens = pgTable("kitchens", {
      id: serial("id").primaryKey(),
      locationId: integer("location_id").references(() => locations.id).notNull(),
      name: text("name").notNull(),
      description: text("description"),
      imageUrl: text("image_url"),
      // Image URL for the kitchen (displayed on public kitchen listings)
      galleryImages: jsonb("gallery_images").default([]),
      // Array of image URLs for kitchen gallery carousel
      amenities: jsonb("amenities").default([]),
      // Array of amenities/features for the kitchen
      isActive: boolean("is_active").default(true).notNull(),
      // Pricing fields (all prices stored as integers in cents to avoid floating-point precision issues)
      hourlyRate: numeric("hourly_rate"),
      // Base hourly rate in cents (e.g., 5000 = $50.00/hour)
      currency: text("currency").default("CAD").notNull(),
      // Currency code (ISO 4217)
      minimumBookingHours: integer("minimum_booking_hours").default(1).notNull(),
      // Minimum booking duration
      pricingModel: text("pricing_model").default("hourly").notNull(),
      // Pricing structure ('hourly', 'daily', 'weekly')
      taxRatePercent: numeric("tax_rate_percent"),
      // Optional tax percentage (e.g., 13 for 13%)
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    kitchenAvailability = pgTable("kitchen_availability", {
      id: serial("id").primaryKey(),
      kitchenId: integer("kitchen_id").references(() => kitchens.id).notNull(),
      dayOfWeek: integer("day_of_week").notNull(),
      // 0-6, Sunday is 0
      startTime: text("start_time").notNull(),
      // HH:MM format
      endTime: text("end_time").notNull(),
      // HH:MM format
      isAvailable: boolean("is_available").default(true).notNull()
    });
    kitchenDateOverrides = pgTable("kitchen_date_overrides", {
      id: serial("id").primaryKey(),
      kitchenId: integer("kitchen_id").references(() => kitchens.id).notNull(),
      specificDate: timestamp("specific_date").notNull(),
      // Specific date for override
      startTime: text("start_time"),
      // HH:MM format, null if closed all day
      endTime: text("end_time"),
      // HH:MM format, null if closed all day
      isAvailable: boolean("is_available").default(false).notNull(),
      // false = closed, true = custom hours
      reason: text("reason"),
      // Optional reason (e.g., "Holiday", "Maintenance")
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    kitchenBookings = pgTable("kitchen_bookings", {
      id: serial("id").primaryKey(),
      referenceCode: text("reference_code").unique(),
      // Human-friendly reference e.g. KB-A7K9MX
      chefId: integer("chef_id").references(() => users.id),
      // Nullable for external/third-party bookings
      kitchenId: integer("kitchen_id").references(() => kitchens.id).notNull(),
      bookingDate: timestamp("booking_date").notNull(),
      startTime: text("start_time").notNull(),
      // HH:MM format - earliest slot start
      endTime: text("end_time").notNull(),
      // HH:MM format - latest slot end
      selectedSlots: jsonb("selected_slots").default([]),
      // Array of discrete 1-hour time slots, e.g., [{startTime: "09:00", endTime: "10:00"}, {startTime: "14:00", endTime: "15:00"}]
      status: bookingStatusEnum("status").default("pending").notNull(),
      specialNotes: text("special_notes"),
      bookingType: text("booking_type").default("chef").notNull(),
      // 'chef', 'external', 'manager_blocked'
      createdBy: integer("created_by").references(() => users.id),
      // Manager who created the booking (for external/manual bookings)
      externalContactName: text("external_contact_name"),
      // For third-party bookings
      externalContactEmail: text("external_contact_email"),
      // For third-party bookings
      externalContactPhone: text("external_contact_phone"),
      // For third-party bookings
      externalContactCompany: text("external_contact_company"),
      // For third-party bookings
      // Pricing fields (all prices stored as integers in cents)
      totalPrice: numeric("total_price"),
      // Total booking price in cents
      hourlyRate: numeric("hourly_rate"),
      // Rate used for this booking (in cents)
      durationHours: numeric("duration_hours"),
      // Calculated duration (decimal for partial hours)
      storageItems: jsonb("storage_items").default([]),
      // Array of storage booking IDs: [{storageBookingId: 1, storageListingId: 5}]
      equipmentItems: jsonb("equipment_items").default([]),
      // Array of equipment booking IDs: [{equipmentBookingId: 2, equipmentListingId: 8}]
      paymentStatus: paymentStatusEnum("payment_status").default("pending"),
      // Payment status
      paymentIntentId: text("payment_intent_id"),
      // Stripe PaymentIntent ID (nullable, unique)
      // Stripe fields for off-session damage claim charging
      stripePaymentMethodId: text("stripe_payment_method_id"),
      // Saved payment method for damage claims
      stripeCustomerId: text("stripe_customer_id"),
      // Denormalized for quick access
      damageDeposit: numeric("damage_deposit").default("0"),
      // Damage deposit amount (in cents)
      serviceFee: numeric("service_fee").default("0"),
      // Platform commission (in cents)
      currency: text("currency").default("CAD").notNull(),
      // Currency code
      // Chef cancellation request tracking
      cancellationRequestedAt: timestamp("cancellation_requested_at"),
      cancellationRequestReason: text("cancellation_request_reason"),
      cancellationRequestDeclinedAt: timestamp("cancellation_request_declined_at"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    chefLocationAccess = pgTable("chef_location_access", {
      id: serial("id").primaryKey(),
      chefId: integer("chef_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      locationId: integer("location_id").references(() => locations.id, { onDelete: "cascade" }).notNull(),
      grantedBy: integer("granted_by").references(() => users.id, { onDelete: "cascade" }).notNull(),
      // admin who granted access
      grantedAt: timestamp("granted_at").defaultNow().notNull()
    });
    chefKitchenAccess = pgTable("chef_kitchen_access", {
      id: serial("id").primaryKey(),
      chefId: integer("chef_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      kitchenId: integer("kitchen_id").references(() => kitchens.id, { onDelete: "cascade" }).notNull(),
      grantedBy: integer("granted_by").references(() => users.id, { onDelete: "cascade" }).notNull(),
      grantedAt: timestamp("granted_at").defaultNow().notNull()
    });
    chefKitchenProfiles = pgTable("chef_kitchen_profiles", {
      id: serial("id").primaryKey(),
      chefId: integer("chef_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      kitchenId: integer("kitchen_id").references(() => kitchens.id, { onDelete: "cascade" }).notNull(),
      status: text("status").default("pending").notNull(),
      // 'pending', 'approved', 'rejected'
      sharedAt: timestamp("shared_at").defaultNow().notNull(),
      reviewedBy: integer("reviewed_by").references(() => users.id, { onDelete: "set null" }),
      // manager who reviewed
      reviewedAt: timestamp("reviewed_at"),
      reviewFeedback: text("review_feedback")
      // optional feedback from manager
    });
    chefLocationProfiles = pgTable("chef_location_profiles", {
      id: serial("id").primaryKey(),
      chefId: integer("chef_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      locationId: integer("location_id").references(() => locations.id, { onDelete: "cascade" }).notNull(),
      status: text("status").default("pending").notNull(),
      // 'pending', 'approved', 'rejected'
      sharedAt: timestamp("shared_at").defaultNow().notNull(),
      reviewedBy: integer("reviewed_by").references(() => users.id, { onDelete: "set null" }),
      // manager who reviewed
      reviewedAt: timestamp("reviewed_at"),
      reviewFeedback: text("review_feedback")
      // optional feedback from manager
    });
    portalUserApplications = pgTable("portal_user_applications", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      locationId: integer("location_id").references(() => locations.id, { onDelete: "cascade" }).notNull(),
      fullName: text("full_name").notNull(),
      email: text("email").notNull(),
      phone: text("phone").notNull(),
      company: text("company"),
      // Optional company name
      status: applicationStatusEnum("status").default("inReview").notNull(),
      // 'inReview', 'approved', 'rejected', 'cancelled'
      feedback: text("feedback"),
      // Manager feedback
      reviewedBy: integer("reviewed_by").references(() => users.id, { onDelete: "set null" }),
      // manager who reviewed
      reviewedAt: timestamp("reviewed_at"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    portalUserLocationAccess = pgTable("portal_user_location_access", {
      id: serial("id").primaryKey(),
      portalUserId: integer("portal_user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      locationId: integer("location_id").references(() => locations.id, { onDelete: "cascade" }).notNull(),
      grantedBy: integer("granted_by").references(() => users.id, { onDelete: "cascade" }).notNull(),
      // manager who granted access
      grantedAt: timestamp("granted_at").defaultNow().notNull(),
      applicationId: integer("application_id").references(() => portalUserApplications.id, { onDelete: "set null" })
      // Link to original application
    });
    insertLocationSchema = createInsertSchema(locations, {
      name: z2.string().min(2, "Location name must be at least 2 characters"),
      address: z2.string().min(5, "Address must be at least 5 characters"),
      managerId: z2.number().optional(),
      notificationEmail: z2.string().email("Please enter a valid email address").optional(),
      notificationPhone: optionalPhoneNumberSchema,
      // Optional phone for SMS notifications
      description: z2.string().optional(),
      customOnboardingLink: z2.string().optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateLocationSchema = z2.object({
      id: z2.number(),
      name: z2.string().min(2).optional(),
      address: z2.string().min(5).optional(),
      managerId: z2.number().optional(),
      notificationEmail: z2.string().email("Please enter a valid email address").optional(),
      notificationPhone: optionalPhoneNumberSchema,
      // Optional phone for SMS notifications
      description: z2.string().optional(),
      customOnboardingLink: z2.string().optional()
    });
    insertLocationRequirementsSchema = createInsertSchema(locationRequirements, {
      locationId: z2.number()
    }).omit({ id: true, createdAt: true, updatedAt: true });
    customFieldSchema = z2.object({
      id: z2.string(),
      // Unique identifier for the field
      label: z2.string().min(1, "Label is required"),
      type: z2.enum(["text", "textarea", "number", "select", "checkbox", "date", "file", "cloudflare_upload"]),
      required: z2.boolean().default(false),
      placeholder: z2.string().optional(),
      options: z2.array(z2.string()).optional(),
      // For select fields
      tier: z2.number().min(1).max(3)
      // Tier assignment for the field
    });
    updateLocationRequirementsSchema = z2.object({
      requireFirstName: z2.boolean().optional(),
      requireLastName: z2.boolean().optional(),
      requireEmail: z2.boolean().optional(),
      requirePhone: z2.boolean().optional(),
      requireBusinessName: z2.boolean().optional(),
      requireBusinessType: z2.boolean().optional(),
      requireExperience: z2.boolean().optional(),
      requireBusinessDescription: z2.boolean().optional(),
      requireFoodHandlerCert: z2.boolean().optional(),
      requireFoodHandlerExpiry: z2.boolean().optional(),
      requireUsageFrequency: z2.boolean().optional(),
      requireSessionDuration: z2.boolean().optional(),
      requireTermsAgree: z2.boolean().optional(),
      requireAccuracyAgree: z2.boolean().optional(),
      customFields: z2.array(customFieldSchema).optional(),
      // Tier 1 Requirements
      tier1_years_experience_required: z2.boolean().optional(),
      tier1_years_experience_minimum: z2.number().int().min(0).optional(),
      tier1_custom_fields: z2.array(customFieldSchema).optional().default([]),
      // Tier 2 Requirements
      tier2_food_establishment_cert_required: z2.boolean().optional(),
      tier2_food_establishment_expiry_required: z2.boolean().optional(),
      tier2_insurance_document_required: z2.boolean().optional(),
      tier2_insurance_minimum_amount: z2.number().int().min(0).optional(),
      tier2_kitchen_experience_required: z2.boolean().optional(),
      tier2_allergen_plan_required: z2.boolean().optional(),
      tier2_supplier_list_required: z2.boolean().optional(),
      tier2_quality_control_required: z2.boolean().optional(),
      tier2_traceability_system_required: z2.boolean().optional(),
      tier2_custom_fields: z2.array(customFieldSchema).optional().default([]),
      // Facility Information
      floor_plans_url: z2.union([
        z2.null(),
        z2.literal(""),
        z2.string().url(),
        z2.string()
      ]).optional(),
      ventilation_specs: z2.union([
        z2.string(),
        z2.literal(""),
        z2.null()
      ]).optional(),
      ventilation_specs_url: z2.union([
        z2.null(),
        z2.literal(""),
        z2.string().url(),
        z2.string()
      ]).optional(),
      equipment_list: z2.array(z2.string()).optional(),
      materials_description: z2.string().optional()
    });
    insertKitchenSchema = createInsertSchema(kitchens, {
      locationId: z2.number(),
      name: z2.string().min(1, "Kitchen name is required"),
      description: z2.string().optional(),
      isActive: z2.boolean().optional(),
      hourlyRate: z2.number().int().positive("Hourly rate must be positive").optional(),
      currency: z2.string().min(3).max(3).optional(),
      minimumBookingHours: z2.number().int().min(0, "Minimum booking hours cannot be negative").max(24, "Minimum booking hours cannot exceed 24").optional(),
      pricingModel: z2.enum(["hourly", "daily", "weekly"]).optional(),
      taxRatePercent: z2.number().min(0).max(100).nullable().optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateKitchenSchema = z2.object({
      id: z2.number(),
      name: z2.string().min(1).optional(),
      description: z2.string().optional(),
      isActive: z2.boolean().optional(),
      hourlyRate: z2.number().int().positive("Hourly rate must be positive").optional(),
      currency: z2.string().min(3).max(3).optional(),
      minimumBookingHours: z2.number().int().min(0, "Minimum booking hours cannot be negative").max(24, "Minimum booking hours cannot exceed 24").optional(),
      pricingModel: z2.enum(["hourly", "daily", "weekly"]).optional(),
      taxRatePercent: z2.number().min(0).max(100).nullable().optional()
    });
    insertKitchenAvailabilitySchema = createInsertSchema(kitchenAvailability, {
      kitchenId: z2.number(),
      dayOfWeek: z2.number().min(0).max(6),
      startTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)"),
      endTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)"),
      isAvailable: z2.boolean().optional()
    }).omit({
      id: true
    });
    insertKitchenDateOverrideSchema = createInsertSchema(kitchenDateOverrides, {
      kitchenId: z2.number(),
      specificDate: z2.string().or(z2.date()),
      startTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)").optional(),
      endTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)").optional(),
      isAvailable: z2.boolean().optional(),
      reason: z2.string().optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateKitchenDateOverrideSchema = z2.object({
      id: z2.number(),
      startTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)").optional(),
      endTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)").optional(),
      isAvailable: z2.boolean().optional(),
      reason: z2.string().optional()
    });
    insertKitchenBookingSchema = createInsertSchema(kitchenBookings, {
      chefId: z2.number(),
      // REQUIRED - matches actual DB
      kitchenId: z2.number(),
      bookingDate: z2.string().or(z2.date()),
      startTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)"),
      endTime: z2.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format (HH:MM)"),
      status: z2.enum(["pending", "confirmed", "cancelled", "completed"]).optional(),
      specialNotes: z2.string().optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateKitchenBookingSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["pending", "confirmed", "cancelled", "completed", "cancellation_requested"]).optional(),
      specialNotes: z2.string().optional()
    });
    insertChefLocationAccessSchema = createInsertSchema(chefLocationAccess, {
      chefId: z2.number(),
      locationId: z2.number(),
      grantedBy: z2.number()
    }).omit({
      id: true,
      grantedAt: true
    });
    insertChefKitchenAccessSchema = createInsertSchema(chefKitchenAccess, {
      chefId: z2.number(),
      kitchenId: z2.number(),
      grantedBy: z2.number()
    }).omit({
      id: true,
      grantedAt: true
    });
    insertChefKitchenProfileSchema = createInsertSchema(chefKitchenProfiles, {
      chefId: z2.number(),
      kitchenId: z2.number(),
      status: z2.enum(["pending", "approved", "rejected"]).optional()
    }).omit({
      id: true,
      sharedAt: true,
      reviewedBy: true,
      reviewedAt: true,
      reviewFeedback: true
    });
    updateChefKitchenProfileSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["pending", "approved", "rejected"]),
      reviewFeedback: z2.string().optional()
    });
    insertChefLocationProfileSchema = createInsertSchema(chefLocationProfiles, {
      chefId: z2.number(),
      locationId: z2.number(),
      status: z2.enum(["pending", "approved", "rejected"]).optional()
    }).omit({
      id: true,
      sharedAt: true,
      reviewedBy: true,
      reviewedAt: true,
      reviewFeedback: true
    });
    updateChefLocationProfileSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["pending", "approved", "rejected"]),
      reviewFeedback: z2.string().optional()
    });
    insertPortalUserApplicationSchema = createInsertSchema(portalUserApplications, {
      userId: z2.number(),
      locationId: z2.number(),
      fullName: z2.string().min(2, "Name must be at least 2 characters"),
      email: z2.string().email("Please enter a valid email address"),
      phone: phoneNumberSchema,
      // Uses shared phone validation
      company: z2.string().optional()
    }).omit({
      id: true,
      status: true,
      createdAt: true,
      reviewedBy: true,
      reviewedAt: true,
      feedback: true
    });
    updatePortalUserApplicationStatusSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["inReview", "approved", "rejected", "cancelled"]),
      feedback: z2.string().optional()
    });
    insertPortalUserLocationAccessSchema = createInsertSchema(portalUserLocationAccess, {
      portalUserId: z2.number(),
      locationId: z2.number(),
      grantedBy: z2.number(),
      applicationId: z2.number().optional()
    }).omit({
      id: true,
      grantedAt: true
    });
    storageListings = pgTable("storage_listings", {
      id: serial("id").primaryKey(),
      kitchenId: integer("kitchen_id").references(() => kitchens.id, { onDelete: "cascade" }).notNull(),
      storageType: storageTypeEnum("storage_type").notNull(),
      name: text("name").notNull(),
      description: text("description"),
      // Physical specifications
      dimensionsLength: numeric("dimensions_length"),
      // feet/meters
      dimensionsWidth: numeric("dimensions_width"),
      dimensionsHeight: numeric("dimensions_height"),
      totalVolume: numeric("total_volume"),
      // cubic feet/meters (auto-calculated)
      shelfCount: integer("shelf_count"),
      shelfMaterial: text("shelf_material"),
      accessType: text("access_type"),
      // 'walk-in', 'shelving-unit', 'rack-system'
      // Features & amenities (JSONB for flexibility - following existing pattern)
      features: jsonb("features").default([]),
      securityFeatures: jsonb("security_features").default([]),
      climateControl: boolean("climate_control").default(false),
      temperatureRange: text("temperature_range"),
      // "35-40Â°F"
      humidityControl: boolean("humidity_control").default(false),
      powerOutlets: integer("power_outlets").default(0),
      // Pricing (all in cents)
      pricingModel: storagePricingModelEnum("pricing_model").notNull(),
      basePrice: numeric("base_price").notNull(),
      // Base price in cents (integer)
      pricePerCubicFoot: numeric("price_per_cubic_foot"),
      // For per-cubic-foot model (in cents)
      // Booking duration (flexible: hourly, daily, or monthly)
      minimumBookingDuration: integer("minimum_booking_duration").default(1).notNull(),
      // Minimum booking duration (number)
      bookingDurationUnit: bookingDurationUnitEnum("booking_duration_unit").default("monthly").notNull(),
      // Unit: hourly, daily, or monthly
      currency: text("currency").default("CAD").notNull(),
      // Locked to CAD
      // Status & moderation (admin approval workflow)
      status: listingStatusEnum("status").default("draft").notNull(),
      approvedBy: integer("approved_by").references(() => users.id, { onDelete: "set null" }),
      // Admin who approved
      approvedAt: timestamp("approved_at"),
      rejectionReason: text("rejection_reason"),
      // If rejected by admin
      // Availability
      isActive: boolean("is_active").default(true).notNull(),
      availabilityCalendar: jsonb("availability_calendar").default({}),
      // Blocked dates, maintenance windows
      // Compliance & documentation
      certifications: jsonb("certifications").default([]),
      photos: jsonb("photos").default([]),
      // Array of image URLs
      documents: jsonb("documents").default([]),
      // Array of document URLs
      // Rules & restrictions
      houseRules: jsonb("house_rules").default([]),
      prohibitedItems: jsonb("prohibited_items").default([]),
      insuranceRequired: boolean("insurance_required").default(false),
      // Overstay penalty configuration (manager-controlled)
      overstayGracePeriodDays: integer("overstay_grace_period_days").default(3).notNull(),
      // Days before penalties apply (industry standard: 3-5)
      overstayPenaltyRate: numeric("overstay_penalty_rate").default("0.10").notNull(),
      // Penalty rate as decimal (0.10 = 10% of daily rate per day)
      overstayMaxPenaltyDays: integer("overstay_max_penalty_days").default(30).notNull(),
      // Max days penalties can accrue
      overstayPolicyText: text("overstay_policy_text"),
      // Custom policy text shown to chefs
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertStorageListingSchema = createInsertSchema(storageListings, {
      kitchenId: z2.number(),
      name: z2.string().min(3, "Name must be at least 3 characters"),
      storageType: z2.enum(["dry", "cold", "freezer"]),
      pricingModel: z2.enum(["monthly-flat", "per-cubic-foot", "hourly", "daily"]),
      basePrice: z2.number().int().positive("Base price must be positive"),
      pricePerCubicFoot: z2.number().int().positive("Price per cubic foot must be positive").optional(),
      minimumBookingDuration: z2.number().int().positive("Minimum booking duration must be positive").optional(),
      bookingDurationUnit: z2.enum(["hourly", "daily", "monthly"]).optional(),
      dimensionsLength: z2.number().positive().optional(),
      dimensionsWidth: z2.number().positive().optional(),
      dimensionsHeight: z2.number().positive().optional(),
      totalVolume: z2.number().positive().optional(),
      shelfCount: z2.number().int().min(0).optional(),
      temperatureRange: z2.string().optional(),
      features: z2.array(z2.string()).optional(),
      securityFeatures: z2.array(z2.string()).optional(),
      certifications: z2.array(z2.string()).optional(),
      photos: z2.array(z2.string()).optional(),
      documents: z2.array(z2.string()).optional(),
      houseRules: z2.array(z2.string()).optional(),
      prohibitedItems: z2.array(z2.string()).optional(),
      availabilityCalendar: z2.record(z2.any()).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      status: true,
      approvedBy: true,
      approvedAt: true,
      rejectionReason: true,
      currency: true
      // Always CAD, not user-selectable
    });
    updateStorageListingSchema = z2.object({
      id: z2.number(),
      name: z2.string().min(3).optional(),
      description: z2.string().optional(),
      storageType: z2.enum(["dry", "cold", "freezer"]).optional(),
      pricingModel: z2.enum(["monthly-flat", "per-cubic-foot", "hourly", "daily"]).optional(),
      basePrice: z2.number().int().positive().optional(),
      pricePerCubicFoot: z2.number().int().positive().optional(),
      minimumBookingDuration: z2.number().int().positive().optional(),
      bookingDurationUnit: z2.enum(["hourly", "daily", "monthly"]).optional(),
      dimensionsLength: z2.number().positive().optional(),
      dimensionsWidth: z2.number().positive().optional(),
      dimensionsHeight: z2.number().positive().optional(),
      totalVolume: z2.number().positive().optional(),
      shelfCount: z2.number().int().min(0).optional(),
      shelfMaterial: z2.string().optional(),
      accessType: z2.string().optional(),
      temperatureRange: z2.string().optional(),
      climateControl: z2.boolean().optional(),
      humidityControl: z2.boolean().optional(),
      powerOutlets: z2.number().int().min(0).optional(),
      isActive: z2.boolean().optional(),
      insuranceRequired: z2.boolean().optional(),
      features: z2.array(z2.string()).optional(),
      securityFeatures: z2.array(z2.string()).optional(),
      certifications: z2.array(z2.string()).optional(),
      photos: z2.array(z2.string()).optional(),
      documents: z2.array(z2.string()).optional(),
      houseRules: z2.array(z2.string()).optional(),
      prohibitedItems: z2.array(z2.string()).optional(),
      availabilityCalendar: z2.record(z2.any()).optional()
    });
    updateStorageListingStatusSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["draft", "pending", "approved", "rejected", "active", "inactive"]),
      rejectionReason: z2.string().optional()
    });
    equipmentListings = pgTable("equipment_listings", {
      id: serial("id").primaryKey(),
      kitchenId: integer("kitchen_id").references(() => kitchens.id, { onDelete: "cascade" }).notNull(),
      // Category & type
      category: equipmentCategoryEnum("category").notNull(),
      equipmentType: text("equipment_type").notNull(),
      // 'mixer', 'oven', 'fryer', etc.
      brand: text("brand"),
      description: text("description"),
      condition: equipmentConditionEnum("condition").notNull(),
      // Availability type: included (free with kitchen) or rental (paid addon)
      availabilityType: equipmentAvailabilityTypeEnum("availability_type").default("included").notNull(),
      // Pricing - flat session rate (in cents)
      sessionRate: numeric("session_rate").default("0"),
      // Flat session rate in cents (e.g., 2500 = $25.00/session)
      currency: text("currency").default("CAD").notNull(),
      // Damage deposit (in cents)
      damageDeposit: numeric("damage_deposit").default("0"),
      // Refundable deposit (in cents)
      // Status
      status: listingStatusEnum("status").default("draft").notNull(),
      isActive: boolean("is_active").default(true).notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertEquipmentListingSchema = createInsertSchema(equipmentListings, {
      kitchenId: z2.number(),
      category: z2.enum(["food-prep", "cooking", "refrigeration", "cleaning", "specialty"]),
      equipmentType: z2.string().min(1, "Equipment type is required"),
      condition: z2.enum(["excellent", "good", "fair", "needs-repair"]),
      availabilityType: z2.enum(["included", "rental"]),
      damageDeposit: z2.number().int().min(0).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      status: true,
      currency: true
      // Always CAD, not user-selectable
    });
    updateEquipmentListingSchema = z2.object({
      id: z2.number(),
      category: z2.enum(["food-prep", "cooking", "refrigeration", "cleaning", "specialty"]).optional(),
      equipmentType: z2.string().min(1).optional(),
      brand: z2.string().optional(),
      description: z2.string().optional(),
      condition: z2.enum(["excellent", "good", "fair", "needs-repair"]).optional(),
      availabilityType: z2.enum(["included", "rental"]).optional(),
      sessionRate: z2.number().int().min(0).optional(),
      damageDeposit: z2.number().int().min(0).optional(),
      isActive: z2.boolean().optional()
    });
    updateEquipmentListingStatusSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["draft", "pending", "approved", "rejected", "active", "inactive"])
    });
    storageBookings = pgTable("storage_bookings", {
      id: serial("id").primaryKey(),
      referenceCode: text("reference_code").unique(),
      // Human-friendly reference e.g. SB-X3P2NR
      storageListingId: integer("storage_listing_id").references(() => storageListings.id, { onDelete: "cascade" }).notNull(),
      kitchenBookingId: integer("kitchen_booking_id").references(() => kitchenBookings.id, { onDelete: "cascade" }),
      // NULLABLE - storage can be booked independently
      chefId: integer("chef_id").references(() => users.id, { onDelete: "set null" }),
      // Chef making the booking
      startDate: timestamp("start_date").notNull(),
      endDate: timestamp("end_date").notNull(),
      status: bookingStatusEnum("status").default("pending").notNull(),
      totalPrice: numeric("total_price").notNull(),
      // In cents (daily_rate Ã— number_of_days)
      pricingModel: storagePricingModelEnum("pricing_model").notNull(),
      // Always 'daily' now
      paymentStatus: paymentStatusEnum("payment_status").default("pending"),
      paymentIntentId: text("payment_intent_id"),
      // Stripe PaymentIntent ID (shared across bundled items in same kitchen booking)
      serviceFee: numeric("service_fee").default("0"),
      // Platform commission in cents
      currency: text("currency").default("CAD").notNull(),
      // Stripe fields for off-session penalty charging
      stripePaymentMethodId: text("stripe_payment_method_id"),
      // Saved payment method for penalties
      stripeCustomerId: text("stripe_customer_id"),
      // Denormalized for quick access
      // Checkout workflow fields (hybrid verification system)
      // Chef initiates checkout -> Manager verifies -> Prevents unwarranted overstay penalties
      checkoutStatus: checkoutStatusEnum("checkout_status").default("active"),
      checkoutRequestedAt: timestamp("checkout_requested_at"),
      checkoutApprovedAt: timestamp("checkout_approved_at"),
      checkoutApprovedBy: integer("checkout_approved_by").references(() => users.id, { onDelete: "set null" }),
      checkoutNotes: text("checkout_notes"),
      checkoutPhotoUrls: jsonb("checkout_photo_urls").default([]),
      // R2 URLs for verification photos
      checkoutDeniedAt: timestamp("checkout_denied_at"),
      checkoutDeniedBy: integer("checkout_denied_by").references(() => users.id, { onDelete: "set null" }),
      checkoutDenialReason: text("checkout_denial_reason"),
      // Chef cancellation request tracking (mirrors kitchen_bookings pattern)
      cancellationRequestedAt: timestamp("cancellation_requested_at"),
      cancellationRequestReason: text("cancellation_request_reason"),
      cancellationRequestDeclinedAt: timestamp("cancellation_request_declined_at"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertStorageBookingSchema = createInsertSchema(storageBookings, {
      storageListingId: z2.number(),
      kitchenBookingId: z2.number().optional().nullable(),
      // Optional - for standalone storage bookings
      chefId: z2.number().optional(),
      startDate: z2.string().or(z2.date()),
      endDate: z2.string().or(z2.date()),
      status: z2.enum(["pending", "confirmed", "cancelled", "completed", "cancellation_requested"]).optional(),
      totalPrice: z2.number().int().positive("Total price must be positive"),
      pricingModel: z2.enum(["monthly-flat", "per-cubic-foot", "hourly", "daily"]),
      paymentStatus: z2.enum(["pending", "authorized", "processing", "paid", "refunded", "failed", "partially_refunded"]).optional(),
      paymentIntentId: z2.string().optional(),
      serviceFee: z2.number().int().min(0).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      currency: true
      // Always CAD, not user-selectable
    });
    updateStorageBookingSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["pending", "confirmed", "cancelled", "completed", "cancellation_requested"]).optional(),
      paymentStatus: z2.enum(["pending", "authorized", "processing", "paid", "refunded", "failed", "partially_refunded"]).optional(),
      paymentIntentId: z2.string().optional(),
      serviceFee: z2.number().int().min(0).optional(),
      // Checkout workflow fields
      checkoutStatus: z2.enum(["active", "checkout_requested", "checkout_approved", "completed", "checkout_claim_filed"]).optional(),
      checkoutNotes: z2.string().optional(),
      checkoutPhotoUrls: z2.array(z2.string()).optional()
    });
    updateStorageBookingStatusSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["pending", "confirmed", "cancelled", "completed", "cancellation_requested"])
    });
    storageCheckoutRequestSchema = z2.object({
      storageBookingId: z2.number(),
      checkoutNotes: z2.string().optional(),
      checkoutPhotoUrls: z2.array(z2.string()).optional()
      // R2 URLs for verification photos
    });
    storageCheckoutApprovalSchema = z2.object({
      storageBookingId: z2.number(),
      action: z2.enum(["approve", "deny"]),
      managerNotes: z2.string().optional(),
      denialReason: z2.string().optional()
      // Required if action is 'deny'
    });
    equipmentBookings = pgTable("equipment_bookings", {
      id: serial("id").primaryKey(),
      equipmentListingId: integer("equipment_listing_id").references(() => equipmentListings.id, { onDelete: "cascade" }).notNull(),
      kitchenBookingId: integer("kitchen_booking_id").references(() => kitchenBookings.id, { onDelete: "cascade" }).notNull(),
      // REQUIRED - no standalone bookings
      chefId: integer("chef_id").references(() => users.id, { onDelete: "set null" }),
      // Nullable for external bookings
      startDate: timestamp("start_date").notNull(),
      endDate: timestamp("end_date").notNull(),
      status: bookingStatusEnum("status").default("pending").notNull(),
      // Reuse existing enum
      totalPrice: numeric("total_price").notNull(),
      // In cents
      pricingModel: equipmentPricingModelEnum("pricing_model").notNull(),
      // Reuse enum
      damageDeposit: numeric("damage_deposit").default("0"),
      // In cents (only for rental)
      paymentStatus: paymentStatusEnum("payment_status").default("pending"),
      // Reuse enum
      paymentIntentId: text("payment_intent_id"),
      // Stripe PaymentIntent ID (shared across bundled items in same kitchen booking)
      serviceFee: numeric("service_fee").default("0"),
      // Platform commission in cents
      currency: text("currency").default("CAD").notNull(),
      // NOTE: No delivery/pickup fields - equipment stays in kitchen
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertEquipmentBookingSchema = createInsertSchema(equipmentBookings, {
      equipmentListingId: z2.number(),
      kitchenBookingId: z2.number(),
      chefId: z2.number().optional(),
      startDate: z2.string().or(z2.date()),
      endDate: z2.string().or(z2.date()),
      status: z2.enum(["pending", "confirmed", "cancelled", "completed"]).optional(),
      totalPrice: z2.number().int().positive("Total price must be positive"),
      pricingModel: z2.enum(["hourly", "daily", "weekly", "monthly"]),
      damageDeposit: z2.number().int().min(0).optional(),
      paymentStatus: z2.enum(["pending", "authorized", "processing", "paid", "refunded", "failed", "partially_refunded"]).optional(),
      paymentIntentId: z2.string().optional(),
      serviceFee: z2.number().int().min(0).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      currency: true
      // Always CAD, not user-selectable
    });
    updateEquipmentBookingSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["pending", "confirmed", "cancelled", "completed"]).optional(),
      paymentStatus: z2.enum(["pending", "authorized", "processing", "paid", "refunded", "failed", "partially_refunded"]).optional(),
      paymentIntentId: z2.string().optional(),
      damageDeposit: z2.number().int().min(0).optional(),
      serviceFee: z2.number().int().min(0).optional()
    });
    updateEquipmentBookingStatusSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["pending", "confirmed", "cancelled", "completed"])
    });
    platformSettings = pgTable("platform_settings", {
      id: serial("id").primaryKey(),
      key: text("key").notNull().unique(),
      value: text("value").notNull(),
      description: text("description"),
      updatedBy: integer("updated_by").references(() => users.id),
      updatedAt: timestamp("updated_at").defaultNow().notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    insertPlatformSettingSchema = createInsertSchema(platformSettings);
    updatePlatformSettingSchema = z2.object({
      value: z2.string().optional(),
      description: z2.string().optional()
    });
    chefKitchenApplications = pgTable("chef_kitchen_applications", {
      id: serial("id").primaryKey(),
      chefId: integer("chef_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      locationId: integer("location_id").references(() => locations.id, { onDelete: "cascade" }).notNull(),
      // Personal Info (collected per application)
      fullName: text("full_name").notNull(),
      email: text("email").notNull(),
      phone: text("phone").notNull(),
      // Business Info
      kitchenPreference: kitchenPreferenceEnum("kitchen_preference").notNull(),
      businessDescription: text("business_description"),
      cookingExperience: text("cooking_experience"),
      // Food Safety License
      foodSafetyLicense: certificationStatusEnum("food_safety_license").notNull(),
      foodSafetyLicenseUrl: text("food_safety_license_url"),
      foodSafetyLicenseStatus: documentVerificationStatusEnum("food_safety_license_status").default("pending"),
      foodSafetyLicenseExpiry: date("food_safety_license_expiry"),
      // Food Establishment Certificate (optional)
      foodEstablishmentCert: certificationStatusEnum("food_establishment_cert").notNull(),
      foodEstablishmentCertUrl: text("food_establishment_cert_url"),
      foodEstablishmentCertStatus: documentVerificationStatusEnum("food_establishment_cert_status").default("pending"),
      foodEstablishmentCertExpiry: date("food_establishment_cert_expiry"),
      // Application Status
      status: applicationStatusEnum("status").default("inReview").notNull(),
      feedback: text("feedback"),
      // Manager Review
      reviewedBy: integer("reviewed_by").references(() => users.id, { onDelete: "set null" }),
      reviewedAt: timestamp("reviewed_at"),
      // Tier Tracking
      current_tier: integer("current_tier").default(1).notNull(),
      tier1_completed_at: timestamp("tier1_completed_at"),
      tier2_completed_at: timestamp("tier2_completed_at"),
      tier3_submitted_at: timestamp("tier3_submitted_at"),
      tier4_completed_at: timestamp("tier4_completed_at"),
      government_license_number: text("government_license_number"),
      government_license_received_date: date("government_license_received_date"),
      government_license_expiry_date: date("government_license_expiry_date"),
      tier_data: jsonb("tier_data").default({}),
      chat_conversation_id: text("chat_conversation_id"),
      // Custom Fields Data (JSONB object storing values for custom fields)
      customFieldsData: jsonb("custom_fields_data").default({}),
      // { [fieldId]: value }
      // Timestamps
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    insertChefKitchenApplicationSchema = createInsertSchema(chefKitchenApplications, {
      chefId: z2.number(),
      locationId: z2.number(),
      fullName: z2.string().min(1, "Name is required"),
      // Minimum validation, but requirement checked in API
      email: z2.string().email("Please enter a valid email address"),
      // Email format validation, but requirement checked in API
      phone: z2.string(),
      // Accept any string (including empty) - requirement and format validation happens in API
      kitchenPreference: z2.enum(["commercial", "home", "notSure"]),
      businessDescription: z2.string().optional(),
      cookingExperience: z2.string().optional(),
      foodSafetyLicense: z2.enum(["yes", "no", "notSure"]),
      // Requirement checked in API
      foodSafetyLicenseUrl: z2.string().optional(),
      foodSafetyLicenseExpiry: z2.string().optional(),
      // Requirement checked in API
      foodEstablishmentCert: z2.enum(["yes", "no", "notSure"]).optional(),
      // Optional - defaults to "no" if not required
      foodEstablishmentCertUrl: z2.string().optional(),
      foodEstablishmentCertExpiry: z2.string().optional(),
      // Requirement checked in API
      customFieldsData: z2.record(z2.any()).optional()
      // Custom fields data as JSON object
    }).omit({
      id: true,
      status: true,
      createdAt: true,
      updatedAt: true,
      reviewedBy: true,
      reviewedAt: true,
      feedback: true,
      foodSafetyLicenseStatus: true,
      foodEstablishmentCertStatus: true
    });
    updateChefKitchenApplicationSchema = z2.object({
      id: z2.number(),
      fullName: z2.string().min(2).optional(),
      email: z2.string().email().optional(),
      phone: phoneNumberSchema.optional(),
      kitchenPreference: z2.enum(["commercial", "home", "notSure"]).optional(),
      businessDescription: z2.string().optional(),
      cookingExperience: z2.string().optional(),
      foodSafetyLicenseUrl: z2.string().optional(),
      foodEstablishmentCertUrl: z2.string().optional()
    });
    updateChefKitchenApplicationStatusSchema = z2.object({
      id: z2.number(),
      status: z2.enum(["inReview", "approved", "rejected", "cancelled"]),
      feedback: z2.string().optional(),
      current_tier: z2.number().min(1).max(4).optional(),
      tier_data: z2.record(z2.any()).optional()
    });
    updateApplicationTierSchema = z2.object({
      id: z2.number(),
      current_tier: z2.number().min(1).max(4),
      tier_data: z2.record(z2.any()).optional()
    });
    updateChefKitchenApplicationDocumentsSchema = z2.object({
      id: z2.number(),
      foodSafetyLicenseUrl: z2.string().optional(),
      foodEstablishmentCertUrl: z2.string().optional(),
      foodSafetyLicenseStatus: z2.enum(["pending", "approved", "rejected"]).optional(),
      foodEstablishmentCertStatus: z2.enum(["pending", "approved", "rejected"]).optional()
    });
    paymentTransactions = pgTable("payment_transactions", {
      id: serial("id").primaryKey(),
      bookingId: integer("booking_id").notNull(),
      // References kitchen_bookings.id, storage_bookings.id, or equipment_bookings.id
      bookingType: bookingTypeEnum("booking_type").notNull(),
      // Which booking table this transaction belongs to
      chefId: integer("chef_id").references(() => users.id, { onDelete: "set null" }),
      // Chef who made the payment
      managerId: integer("manager_id").references(() => users.id, { onDelete: "set null" }),
      // Manager who receives the payment
      // Payment amounts (all in cents)
      amount: numeric("amount").notNull(),
      // Total transaction amount (includes service fee)
      baseAmount: numeric("base_amount").notNull(),
      // Base amount before service fee
      serviceFee: numeric("service_fee").notNull().default("0"),
      // Platform service fee
      stripeProcessingFee: numeric("stripe_processing_fee").default("0"),
      // Actual Stripe processing fee from BalanceTransaction (in cents)
      managerRevenue: numeric("manager_revenue").notNull(),
      // Manager earnings (base_amount - service_fee)
      refundAmount: numeric("refund_amount").default("0"),
      // Total refunded amount
      netAmount: numeric("net_amount").notNull(),
      // Final amount after refunds (amount - refund_amount)
      currency: text("currency").notNull().default("CAD"),
      // Stripe integration
      paymentIntentId: text("payment_intent_id"),
      // Stripe PaymentIntent ID (nullable, unique when set)
      chargeId: text("charge_id"),
      // Stripe Charge ID
      refundId: text("refund_id"),
      // Stripe Refund ID
      paymentMethodId: text("payment_method_id"),
      // Stripe PaymentMethod ID
      // Status tracking
      status: transactionStatusEnum("status").notNull().default("pending"),
      stripeStatus: text("stripe_status"),
      // Raw Stripe status for comparison
      // Metadata and tracking
      metadata: jsonb("metadata").default({}),
      // Additional metadata
      refundReason: text("refund_reason"),
      // Reason for refund
      failureReason: text("failure_reason"),
      // Reason for payment failure
      webhookEventId: text("webhook_event_id"),
      // Stripe webhook event ID
      lastSyncedAt: timestamp("last_synced_at"),
      // Last time synced with Stripe
      // Timestamps
      createdAt: timestamp("created_at").notNull().defaultNow(),
      updatedAt: timestamp("updated_at").notNull().defaultNow(),
      paidAt: timestamp("paid_at"),
      // When payment was successfully captured
      refundedAt: timestamp("refunded_at")
      // When refund was issued
    });
    paymentHistory = pgTable("payment_history", {
      id: serial("id").primaryKey(),
      transactionId: integer("transaction_id").references(() => paymentTransactions.id, { onDelete: "cascade" }).notNull(),
      previousStatus: transactionStatusEnum("previous_status"),
      newStatus: transactionStatusEnum("new_status").notNull(),
      eventType: text("event_type").notNull(),
      // 'status_change', 'refund', 'webhook', 'manual_update', etc.
      eventSource: text("event_source"),
      // 'stripe_webhook', 'admin', 'system', 'sync', etc.
      stripeEventId: text("stripe_event_id"),
      // Stripe event ID if from webhook
      description: text("description"),
      // Human-readable description
      metadata: jsonb("metadata").default({}),
      // Additional event data
      createdAt: timestamp("created_at").notNull().defaultNow(),
      createdBy: integer("created_by").references(() => users.id, { onDelete: "set null" })
      // User who triggered the change
    });
    insertPaymentTransactionSchema = createInsertSchema(paymentTransactions);
    updatePaymentTransactionSchema = z2.object({
      status: z2.enum(["pending", "processing", "succeeded", "failed", "canceled", "refunded", "partially_refunded"]).optional(),
      stripeStatus: z2.string().optional(),
      refundAmount: z2.number().optional(),
      refundReason: z2.string().optional(),
      failureReason: z2.string().optional(),
      chargeId: z2.string().optional(),
      refundId: z2.string().optional(),
      paidAt: z2.date().optional(),
      refundedAt: z2.date().optional(),
      lastSyncedAt: z2.date().optional(),
      metadata: z2.record(z2.any()).optional()
    });
    pendingStorageExtensions = pgTable("pending_storage_extensions", {
      id: serial("id").primaryKey(),
      referenceCode: text("reference_code").unique(),
      // Human-friendly reference e.g. EXT-B4R7TY
      storageBookingId: integer("storage_booking_id").references(() => storageBookings.id, { onDelete: "cascade" }).notNull(),
      newEndDate: timestamp("new_end_date").notNull(),
      extensionDays: integer("extension_days").notNull(),
      extensionBasePriceCents: integer("extension_base_price_cents").notNull(),
      extensionServiceFeeCents: integer("extension_service_fee_cents").notNull(),
      extensionTotalPriceCents: integer("extension_total_price_cents").notNull(),
      stripeSessionId: text("stripe_session_id").notNull(),
      stripePaymentIntentId: text("stripe_payment_intent_id"),
      // Status flow: pending (awaiting payment) -> paid (awaiting approval) -> approved/rejected -> completed/refunded
      status: text("status").notNull().default("pending"),
      // pending, paid, approved, rejected, completed, refunded, failed, expired
      // Manager approval fields
      managerId: integer("manager_id").references(() => users.id),
      approvedAt: timestamp("approved_at"),
      rejectedAt: timestamp("rejected_at"),
      rejectionReason: text("rejection_reason"),
      createdAt: timestamp("created_at").notNull().defaultNow(),
      updatedAt: timestamp("updated_at").notNull().defaultNow(),
      completedAt: timestamp("completed_at")
    });
    overstayStatusEnum = pgEnum("overstay_status", [
      "detected",
      // System detected overstay
      "grace_period",
      // Within grace period, no penalty yet
      "pending_review",
      // Grace period ended, awaiting manager review
      "penalty_approved",
      // Manager approved penalty charge
      "penalty_waived",
      // Manager waived penalty
      "charge_pending",
      // Stripe charge initiated
      "charge_succeeded",
      // Stripe charge successful
      "charge_failed",
      // Stripe charge failed
      "resolved",
      // Chef extended or removed items
      "escalated"
      // Sent to legal/collections
    ]);
    storageOverstayRecords = pgTable("storage_overstay_records", {
      id: serial("id").primaryKey(),
      referenceCode: text("reference_code").unique(),
      // Human-friendly reference e.g. OP-C8M2WE
      storageBookingId: integer("storage_booking_id").references(() => storageBookings.id, { onDelete: "cascade" }).notNull(),
      // Detection info
      detectedAt: timestamp("detected_at").defaultNow().notNull(),
      endDate: timestamp("end_date").notNull(),
      // Original booking end date
      daysOverdue: integer("days_overdue").default(0).notNull(),
      gracePeriodEndsAt: timestamp("grace_period_ends_at").notNull(),
      // Status tracking
      status: overstayStatusEnum("status").default("detected").notNull(),
      // Calculated penalty (system suggestion)
      calculatedPenaltyCents: integer("calculated_penalty_cents").default(0).notNull(),
      dailyRateCents: integer("daily_rate_cents").notNull(),
      penaltyRate: numeric("penalty_rate").notNull(),
      // Rate used for calculation
      // Manager decision fields
      finalPenaltyCents: integer("final_penalty_cents"),
      // NULL until manager decides
      penaltyApprovedBy: integer("penalty_approved_by").references(() => users.id, { onDelete: "set null" }),
      penaltyApprovedAt: timestamp("penalty_approved_at"),
      penaltyWaived: boolean("penalty_waived").default(false).notNull(),
      waiveReason: text("waive_reason"),
      managerNotes: text("manager_notes"),
      // Stripe charge tracking
      stripePaymentIntentId: text("stripe_payment_intent_id"),
      stripeChargeId: text("stripe_charge_id"),
      chargeAttemptedAt: timestamp("charge_attempted_at"),
      chargeSucceededAt: timestamp("charge_succeeded_at"),
      chargeFailedAt: timestamp("charge_failed_at"),
      chargeFailureReason: text("charge_failure_reason"),
      // Resolution tracking
      resolvedAt: timestamp("resolved_at"),
      resolutionType: text("resolution_type"),
      // 'extended', 'removed', 'paid', 'waived', 'escalated'
      resolutionNotes: text("resolution_notes"),
      // Notification tracking
      chefWarningSentAt: timestamp("chef_warning_sent_at"),
      chefPenaltyNoticeSentAt: timestamp("chef_penalty_notice_sent_at"),
      managerNotifiedAt: timestamp("manager_notified_at"),
      // Idempotency key to prevent duplicate records
      idempotencyKey: text("idempotency_key").notNull().unique(),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    });
    storageOverstayHistory = pgTable("storage_overstay_history", {
      id: serial("id").primaryKey(),
      overstayRecordId: integer("overstay_record_id").references(() => storageOverstayRecords.id, { onDelete: "cascade" }).notNull(),
      previousStatus: overstayStatusEnum("previous_status"),
      newStatus: overstayStatusEnum("new_status").notNull(),
      eventType: text("event_type").notNull(),
      // 'status_change', 'penalty_adjusted', 'charge_attempt', 'notification_sent'
      eventSource: text("event_source").notNull(),
      // 'system', 'manager', 'chef', 'stripe_webhook', 'cron'
      description: text("description"),
      metadata: jsonb("metadata").default({}),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      createdBy: integer("created_by").references(() => users.id, { onDelete: "set null" })
    });
    insertStorageOverstayRecordSchema = z2.object({
      storageBookingId: z2.number(),
      endDate: z2.date(),
      gracePeriodEndsAt: z2.date(),
      dailyRateCents: z2.number().int().min(0),
      penaltyRate: z2.string(),
      idempotencyKey: z2.string(),
      status: z2.enum(["detected", "grace_period", "pending_review", "penalty_approved", "penalty_waived", "charge_pending", "charge_succeeded", "charge_failed", "resolved", "escalated"]).optional()
    });
    updateStorageOverstayRecordSchema = z2.object({
      status: z2.enum(["detected", "grace_period", "pending_review", "penalty_approved", "penalty_waived", "charge_pending", "charge_succeeded", "charge_failed", "resolved", "escalated"]).optional(),
      daysOverdue: z2.number().int().min(0).optional(),
      calculatedPenaltyCents: z2.number().int().min(0).optional(),
      finalPenaltyCents: z2.number().int().min(0).optional(),
      penaltyApprovedBy: z2.number().optional(),
      penaltyApprovedAt: z2.date().optional(),
      penaltyWaived: z2.boolean().optional(),
      waiveReason: z2.string().optional(),
      managerNotes: z2.string().optional(),
      stripePaymentIntentId: z2.string().optional(),
      stripeChargeId: z2.string().optional(),
      chargeAttemptedAt: z2.date().optional(),
      chargeSucceededAt: z2.date().optional(),
      chargeFailedAt: z2.date().optional(),
      chargeFailureReason: z2.string().optional(),
      resolvedAt: z2.date().optional(),
      resolutionType: z2.string().optional(),
      resolutionNotes: z2.string().optional(),
      chefWarningSentAt: z2.date().optional(),
      chefPenaltyNoticeSentAt: z2.date().optional(),
      managerNotifiedAt: z2.date().optional()
    });
    damageClaimStatusEnum = pgEnum("damage_claim_status", [
      "draft",
      // Manager started claim but hasn't submitted
      "submitted",
      // Claim submitted, awaiting chef response
      "chef_accepted",
      // Chef accepted responsibility
      "escalated",
      // Escalated after repeated charge failures â€” manual collection required
      "chef_disputed",
      // Chef disputes the claim
      "under_review",
      // Admin reviewing disputed claim
      "approved",
      // Claim approved (by chef acceptance or admin decision)
      "partially_approved",
      // Admin approved partial amount
      "rejected",
      // Claim rejected by admin
      "charge_pending",
      // Payment initiated
      "charge_succeeded",
      // Payment collected
      "charge_failed",
      // Payment failed
      "resolved",
      // Claim closed
      "expired"
      // Claim expired (no response within deadline)
    ]);
    evidenceTypeEnum = pgEnum("evidence_type", [
      "photo_before",
      // Photo taken before booking
      "photo_after",
      // Photo showing damage after booking
      "receipt",
      // Repair/replacement receipt
      "invoice",
      // Professional assessment invoice
      "video",
      // Video evidence
      "document",
      // Other supporting document
      "third_party_report"
      // Insurance or professional report
    ]);
    damageClaims = pgTable("damage_claims", {
      id: serial("id").primaryKey(),
      referenceCode: text("reference_code").unique(),
      // Human-friendly reference e.g. DC-D9F3QH
      // Booking reference (polymorphic for kitchen or storage bookings)
      bookingType: text("booking_type").notNull(),
      // 'kitchen' or 'storage'
      kitchenBookingId: integer("kitchen_booking_id").references(() => kitchenBookings.id, { onDelete: "set null" }),
      storageBookingId: integer("storage_booking_id").references(() => storageBookings.id, { onDelete: "set null" }),
      // Parties involved
      chefId: integer("chef_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      managerId: integer("manager_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      locationId: integer("location_id").notNull().references(() => locations.id, { onDelete: "cascade" }),
      // Claim details
      status: damageClaimStatusEnum("status").default("draft").notNull(),
      claimTitle: text("claim_title").notNull(),
      claimDescription: text("claim_description").notNull(),
      damageDate: date("damage_date").notNull(),
      // Financial
      claimedAmountCents: integer("claimed_amount_cents").notNull(),
      approvedAmountCents: integer("approved_amount_cents"),
      finalAmountCents: integer("final_amount_cents"),
      // Chef response
      chefResponse: text("chef_response"),
      chefRespondedAt: timestamp("chef_responded_at"),
      chefResponseDeadline: timestamp("chef_response_deadline").notNull(),
      // Admin review
      adminReviewerId: integer("admin_reviewer_id").references(() => users.id, { onDelete: "set null" }),
      adminReviewedAt: timestamp("admin_reviewed_at"),
      adminNotes: text("admin_notes"),
      adminDecisionReason: text("admin_decision_reason"),
      // Payment
      stripePaymentIntentId: text("stripe_payment_intent_id").unique(),
      stripeChargeId: text("stripe_charge_id"),
      paymentTransactionId: integer("payment_transaction_id").references(() => paymentTransactions.id, { onDelete: "set null" }),
      chargeAttemptedAt: timestamp("charge_attempted_at"),
      chargeSucceededAt: timestamp("charge_succeeded_at"),
      chargeFailedAt: timestamp("charge_failed_at"),
      chargeFailureReason: text("charge_failure_reason"),
      // Stripe IDs for off-session charging
      stripeCustomerId: text("stripe_customer_id"),
      stripePaymentMethodId: text("stripe_payment_method_id"),
      // Resolution
      resolvedAt: timestamp("resolved_at"),
      resolvedBy: integer("resolved_by").references(() => users.id, { onDelete: "set null" }),
      resolutionType: text("resolution_type"),
      // 'paid', 'waived', 'settled', 'expired', 'rejected'
      resolutionNotes: text("resolution_notes"),
      // Damaged equipment items (for kitchen bookings with equipment)
      damagedItems: jsonb("damaged_items").default([]),
      // Array of {equipmentBookingId?, equipmentListingId, equipmentType, brand?, description?}
      // Timestamps
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull(),
      submittedAt: timestamp("submitted_at")
    });
    damageEvidence = pgTable("damage_evidence", {
      id: serial("id").primaryKey(),
      damageClaimId: integer("damage_claim_id").notNull().references(() => damageClaims.id, { onDelete: "cascade" }),
      evidenceType: evidenceTypeEnum("evidence_type").notNull(),
      fileUrl: text("file_url").notNull(),
      fileName: text("file_name"),
      fileSize: integer("file_size"),
      mimeType: text("mime_type"),
      description: text("description"),
      uploadedBy: integer("uploaded_by").notNull().references(() => users.id, { onDelete: "cascade" }),
      uploadedAt: timestamp("uploaded_at").defaultNow().notNull(),
      // For receipts/invoices
      amountCents: integer("amount_cents"),
      vendorName: text("vendor_name"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    damageClaimHistory = pgTable("damage_claim_history", {
      id: serial("id").primaryKey(),
      damageClaimId: integer("damage_claim_id").notNull().references(() => damageClaims.id, { onDelete: "cascade" }),
      previousStatus: damageClaimStatusEnum("previous_status"),
      newStatus: damageClaimStatusEnum("new_status").notNull(),
      action: text("action").notNull(),
      // 'created', 'submitted', 'chef_response', 'admin_decision', 'charge_attempt', etc.
      actionBy: text("action_by").notNull(),
      // 'manager', 'chef', 'admin', 'system', 'stripe_webhook'
      actionByUserId: integer("action_by_user_id").references(() => users.id, { onDelete: "set null" }),
      notes: text("notes"),
      metadata: jsonb("metadata").default({}),
      createdAt: timestamp("created_at").defaultNow().notNull()
    });
    damageClaimStatusValues = ["draft", "submitted", "chef_accepted", "chef_disputed", "under_review", "approved", "partially_approved", "rejected", "charge_pending", "charge_succeeded", "charge_failed", "resolved", "expired", "escalated"];
    evidenceTypeValues = ["photo_before", "photo_after", "receipt", "invoice", "video", "document", "third_party_report"];
    damagedItemSchema = z2.object({
      equipmentBookingId: z2.number().nullable().optional(),
      // null for included equipment
      equipmentListingId: z2.number(),
      equipmentType: z2.string(),
      brand: z2.string().nullable().optional(),
      description: z2.string().nullable().optional()
      // damage description per item
    });
    insertDamageClaimSchema = z2.object({
      bookingType: z2.enum(["kitchen", "storage"]),
      kitchenBookingId: z2.number().optional(),
      storageBookingId: z2.number().optional(),
      chefId: z2.number(),
      managerId: z2.number(),
      locationId: z2.number(),
      claimTitle: z2.string().min(5).max(200),
      claimDescription: z2.string().min(50),
      damageDate: z2.string(),
      // ISO date string
      claimedAmountCents: z2.number().int().min(1e3),
      // Minimum $10
      chefResponseDeadline: z2.date(),
      damagedItems: z2.array(damagedItemSchema).optional()
      // Equipment items damaged (kitchen bookings)
    }).refine(
      (data) => {
        if (data.bookingType === "kitchen") return data.kitchenBookingId !== void 0;
        if (data.bookingType === "storage") return data.storageBookingId !== void 0;
        return false;
      },
      { message: "Must provide booking ID matching booking type" }
    );
    updateDamageClaimSchema = z2.object({
      status: z2.enum(damageClaimStatusValues).optional(),
      claimTitle: z2.string().min(5).max(200).optional(),
      claimDescription: z2.string().min(50).optional(),
      claimedAmountCents: z2.number().int().min(1e3).optional(),
      approvedAmountCents: z2.number().int().min(0).optional(),
      finalAmountCents: z2.number().int().min(0).optional(),
      chefResponse: z2.string().optional(),
      chefRespondedAt: z2.date().optional(),
      adminReviewerId: z2.number().optional(),
      adminReviewedAt: z2.date().optional(),
      adminNotes: z2.string().optional(),
      adminDecisionReason: z2.string().optional(),
      stripePaymentIntentId: z2.string().optional(),
      stripeChargeId: z2.string().optional(),
      paymentTransactionId: z2.number().optional(),
      chargeAttemptedAt: z2.date().optional(),
      chargeSucceededAt: z2.date().optional(),
      chargeFailedAt: z2.date().optional(),
      chargeFailureReason: z2.string().optional(),
      stripeCustomerId: z2.string().optional(),
      stripePaymentMethodId: z2.string().optional(),
      resolvedAt: z2.date().optional(),
      resolvedBy: z2.number().optional(),
      resolutionType: z2.string().optional(),
      resolutionNotes: z2.string().optional(),
      submittedAt: z2.date().optional()
    });
    insertDamageEvidenceSchema = z2.object({
      damageClaimId: z2.number(),
      evidenceType: z2.enum(evidenceTypeValues),
      fileUrl: z2.string().url(),
      fileName: z2.string().optional(),
      fileSize: z2.number().int().positive().optional(),
      mimeType: z2.string().optional(),
      description: z2.string().optional(),
      uploadedBy: z2.number(),
      amountCents: z2.number().int().min(0).optional(),
      vendorName: z2.string().optional()
    });
    chefDamageClaimResponseSchema = z2.object({
      action: z2.enum(["accept", "dispute"]),
      response: z2.string().min(10)
    });
    adminDamageClaimDecisionSchema = z2.object({
      decision: z2.enum(["approve", "partially_approve", "reject"]),
      approvedAmountCents: z2.number().int().min(0).optional(),
      decisionReason: z2.string().min(20),
      notes: z2.string().optional()
    });
  }
});

// server/db.ts
var db_exports = {};
__export(db_exports, {
  db: () => db,
  pool: () => pool
});
import { Pool } from "pg";
import { drizzle } from "drizzle-orm/node-postgres";
var pool, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    if (!process.env.DATABASE_URL) {
      throw new Error(
        "DATABASE_URL must be set. Did you forget to provision a database?"
      );
    }
    pool = new Pool({ connectionString: process.env.DATABASE_URL });
    db = drizzle(pool, { schema: schema_exports });
  }
});

// server/domains/users/user.repository.ts
import { eq } from "drizzle-orm";
var UserRepository;
var init_user_repository = __esm({
  "server/domains/users/user.repository.ts"() {
    "use strict";
    init_db();
    init_schema();
    UserRepository = class {
      async findById(id) {
        const [user] = await db.select().from(users).where(eq(users.id, id));
        return user || null;
      }
      async findByUsername(username) {
        const [user] = await db.select().from(users).where(eq(users.username, username));
        return user || null;
      }
      async findByFirebaseUid(firebaseUid) {
        const [user] = await db.select().from(users).where(eq(users.firebaseUid, firebaseUid));
        return user || null;
      }
      async usernameExists(username) {
        const [user] = await db.select({ id: users.id }).from(users).where(eq(users.username, username)).limit(1);
        return !!user;
      }
      async create(data) {
        const valuesToInsert = {
          ...data,
          password: data.password || `firebase_auth_${Date.now()}_${Math.random().toString(36).slice(2)}`
        };
        const [user] = await db.insert(users).values(valuesToInsert).returning();
        return user;
      }
      async update(id, data) {
        const [updated] = await db.update(users).set(data).where(eq(users.id, id)).returning();
        return updated || null;
      }
      async delete(id) {
        await db.delete(users).where(eq(users.id, id));
      }
    };
  }
});

// server/passwordUtils.ts
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
import bcrypt from "bcryptjs";
async function hashPassword(password) {
  const salt = randomBytes(16).toString("hex");
  const buf = await scryptAsync(password, salt, 64);
  return `${buf.toString("hex")}.${salt}`;
}
async function comparePasswords(password, hash) {
  const isBcrypt = hash && (hash.startsWith("$2a$") || hash.startsWith("$2b$") || hash.startsWith("$2y$") || hash.startsWith("$2$"));
  if (isBcrypt) {
    return await bcrypt.compare(password, hash);
  } else {
    const [hashedPassword, salt] = hash.split(".");
    const hashedPasswordBuf = Buffer.from(hashedPassword, "hex");
    const suppliedPasswordBuf = await scryptAsync(password, salt, 64);
    return timingSafeEqual(hashedPasswordBuf, suppliedPasswordBuf);
  }
}
var scryptAsync;
var init_passwordUtils = __esm({
  "server/passwordUtils.ts"() {
    "use strict";
    scryptAsync = promisify(scrypt);
  }
});

// server/shared/errors/domain-error.ts
var DomainError, UserErrorCodes, ApplicationErrorCodes, LocationErrorCodes, KitchenErrorCodes;
var init_domain_error = __esm({
  "server/shared/errors/domain-error.ts"() {
    "use strict";
    DomainError = class extends Error {
      constructor(code, message, statusCode = 400, details) {
        super(message);
        this.code = code;
        this.statusCode = statusCode;
        this.details = details;
        this.name = "DomainError";
      }
    };
    UserErrorCodes = {
      USER_NOT_FOUND: "USER_NOT_FOUND",
      USERNAME_TAKEN: "USERNAME_TAKEN",
      USERNAME_TOO_SHORT: "USERNAME_TOO_SHORT",
      USERNAME_TOO_LONG: "USERNAME_TOO_LONG",
      EMAIL_INVALID: "EMAIL_INVALID",
      PASSWORD_INVALID: "PASSWORD_INVALID",
      INVALID_CREDENTIALS: "INVALID_CREDENTIALS",
      UNAUTHORIZED: "UNAUTHORIZED",
      FORBIDDEN: "FORBIDDEN",
      VALIDATION_ERROR: "VALIDATION_ERROR"
    };
    ApplicationErrorCodes = {
      APPLICATION_NOT_FOUND: "APPLICATION_NOT_FOUND",
      INVALID_STATUS: "INVALID_STATUS",
      ALREADY_APPROVED: "ALREADY_APPROVED",
      ALREADY_REJECTED: "ALREADY_REJECTED",
      VALIDATION_ERROR: "VALIDATION_ERROR"
    };
    LocationErrorCodes = {
      LOCATION_NOT_FOUND: "LOCATION_NOT_FOUND",
      INVALID_ADDRESS: "INVALID_ADDRESS",
      NO_MANAGER_ASSIGNED: "NO_MANAGER_ASSIGNED"
    };
    KitchenErrorCodes = {
      KITCHEN_NOT_FOUND: "KITCHEN_NOT_FOUND",
      LOCATION_NOT_FOUND: "LOCATION_NOT_FOUND",
      INVALID_PRICING: "INVALID_PRICING"
    };
  }
});

// server/reference-code.ts
import crypto from "crypto";
import { sql } from "drizzle-orm";
function generateCode(prefix) {
  const bytes = crypto.randomBytes(CODE_LENGTH);
  let code = "";
  for (let i = 0; i < CODE_LENGTH; i++) {
    code += SAFE_CHARS[bytes[i] % SAFE_CHARS.length];
  }
  return `${prefix}-${code}`;
}
async function generateReferenceCode(type) {
  const prefix = REFERENCE_PREFIXES[type];
  for (let attempt = 0; attempt < 5; attempt++) {
    const code = generateCode(prefix);
    const result = await db.execute(sql`
      SELECT 1 FROM (
        SELECT reference_code FROM kitchen_bookings WHERE reference_code = ${code}
        UNION ALL
        SELECT reference_code FROM storage_bookings WHERE reference_code = ${code}
        UNION ALL
        SELECT reference_code FROM pending_storage_extensions WHERE reference_code = ${code}
        UNION ALL
        SELECT reference_code FROM storage_overstay_records WHERE reference_code = ${code}
        UNION ALL
        SELECT reference_code FROM damage_claims WHERE reference_code = ${code}
      ) AS refs LIMIT 1
    `);
    if (result.rows.length === 0) {
      return code;
    }
  }
  const fallback = `${prefix}-${Date.now().toString(36).toUpperCase().slice(-6)}`;
  return fallback;
}
var SAFE_CHARS, CODE_LENGTH, REFERENCE_PREFIXES;
var init_reference_code = __esm({
  "server/reference-code.ts"() {
    "use strict";
    init_db();
    SAFE_CHARS = "ABCDEFGHJKMNPQRSTUVWXYZ23456789";
    CODE_LENGTH = 6;
    REFERENCE_PREFIXES = {
      kitchen_booking: "KB",
      storage_booking: "SB",
      storage_extension: "EXT",
      overstay_penalty: "OP",
      damage_claim: "DC"
    };
  }
});

// server/services/overstay-defaults-service.ts
var overstay_defaults_service_exports = {};
__export(overstay_defaults_service_exports, {
  OVERSTAY_DEFAULTS: () => DEFAULTS,
  getEffectivePenaltyConfig: () => getEffectivePenaltyConfig,
  getOverstayLocationDefaults: () => getOverstayLocationDefaults,
  getOverstayPlatformDefaults: () => getOverstayPlatformDefaults
});
import { eq as eq2 } from "drizzle-orm";
async function getOverstayPlatformDefaults() {
  try {
    const [gracePeriodSetting] = await db.select().from(platformSettings).where(eq2(platformSettings.key, "overstay_grace_period_days")).limit(1);
    const [penaltyRateSetting] = await db.select().from(platformSettings).where(eq2(platformSettings.key, "overstay_penalty_rate")).limit(1);
    const [maxDaysSetting] = await db.select().from(platformSettings).where(eq2(platformSettings.key, "overstay_max_penalty_days")).limit(1);
    return {
      gracePeriodDays: gracePeriodSetting ? parseInt(gracePeriodSetting.value) : DEFAULTS.gracePeriodDays,
      penaltyRate: penaltyRateSetting ? parseFloat(penaltyRateSetting.value) : DEFAULTS.penaltyRate,
      maxPenaltyDays: maxDaysSetting ? parseInt(maxDaysSetting.value) : DEFAULTS.maxPenaltyDays
    };
  } catch (error) {
    logger.error("[OverstayDefaultsService] Error fetching platform defaults:", error);
    return DEFAULTS;
  }
}
async function getOverstayLocationDefaults(locationId) {
  try {
    const [location] = await db.select({
      overstayGracePeriodDays: locations.overstayGracePeriodDays,
      overstayPenaltyRate: locations.overstayPenaltyRate,
      overstayMaxPenaltyDays: locations.overstayMaxPenaltyDays,
      overstayPolicyText: locations.overstayPolicyText
    }).from(locations).where(eq2(locations.id, locationId)).limit(1);
    if (!location) {
      return { gracePeriodDays: null, penaltyRate: null, maxPenaltyDays: null, policyText: null };
    }
    return {
      gracePeriodDays: location.overstayGracePeriodDays,
      penaltyRate: location.overstayPenaltyRate ? parseFloat(location.overstayPenaltyRate.toString()) : null,
      maxPenaltyDays: location.overstayMaxPenaltyDays,
      policyText: location.overstayPolicyText
    };
  } catch (error) {
    logger.error("[OverstayDefaultsService] Error fetching location defaults:", error);
    return { gracePeriodDays: null, penaltyRate: null, maxPenaltyDays: null, policyText: null };
  }
}
async function getEffectivePenaltyConfig(listingGracePeriodDays, listingPenaltyRate, listingMaxPenaltyDays, locationId) {
  const platformDefaults = await getOverstayPlatformDefaults();
  const effectiveConfig = {
    gracePeriodDays: platformDefaults.gracePeriodDays,
    penaltyRate: platformDefaults.penaltyRate,
    maxPenaltyDays: platformDefaults.maxPenaltyDays,
    policyText: null
  };
  if (locationId) {
    const locationDefaults = await getOverstayLocationDefaults(locationId);
    if (locationDefaults.gracePeriodDays !== null) {
      effectiveConfig.gracePeriodDays = locationDefaults.gracePeriodDays;
    }
    if (locationDefaults.penaltyRate !== null) {
      effectiveConfig.penaltyRate = locationDefaults.penaltyRate;
    }
    if (locationDefaults.maxPenaltyDays !== null) {
      effectiveConfig.maxPenaltyDays = locationDefaults.maxPenaltyDays;
    }
    if (locationDefaults.policyText !== null) {
      effectiveConfig.policyText = locationDefaults.policyText;
    }
  }
  if (listingGracePeriodDays !== null && listingGracePeriodDays !== void 0) {
    effectiveConfig.gracePeriodDays = listingGracePeriodDays;
  }
  if (listingPenaltyRate !== null && listingPenaltyRate !== void 0) {
    effectiveConfig.penaltyRate = typeof listingPenaltyRate === "string" ? parseFloat(listingPenaltyRate) : listingPenaltyRate;
  }
  if (listingMaxPenaltyDays !== null && listingMaxPenaltyDays !== void 0) {
    effectiveConfig.maxPenaltyDays = listingMaxPenaltyDays;
  }
  return effectiveConfig;
}
var DEFAULTS;
var init_overstay_defaults_service = __esm({
  "server/services/overstay-defaults-service.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_schema();
    DEFAULTS = {
      gracePeriodDays: 3,
      penaltyRate: 0.1,
      maxPenaltyDays: 30
    };
  }
});

// server/services/notification.service.ts
var notification_service_exports = {};
__export(notification_service_exports, {
  notificationService: () => notificationService
});
import { sql as sql2 } from "drizzle-orm";
import { format } from "date-fns";
async function createNotification(params) {
  const {
    userId,
    target,
    locationId,
    type,
    priority = "normal",
    title,
    message,
    metadata = {},
    actionUrl,
    actionLabel,
    expiresAt
  } = params;
  try {
    let result;
    if (target === "manager") {
      result = await db.execute(sql2`
        INSERT INTO manager_notifications 
        (manager_id, location_id, type, priority, title, message, metadata, action_url, action_label, expires_at)
        VALUES (
          ${userId}, 
          ${locationId || null}, 
          ${type}::notification_type, 
          ${priority}::notification_priority, 
          ${title}, 
          ${message}, 
          ${JSON.stringify(metadata)}::jsonb, 
          ${actionUrl || null}, 
          ${actionLabel || null}, 
          ${expiresAt ? expiresAt.toISOString() : null}
        )
        RETURNING *
      `);
      logger.info(`[NotificationService] Created ${type} notification for manager ${userId}`);
    } else {
      result = await db.execute(sql2`
        INSERT INTO chef_notifications 
        (chef_id, type, priority, title, message, metadata, action_url, action_label, expires_at)
        VALUES (
          ${userId}, 
          ${type}::chef_notification_type, 
          ${priority}::chef_notification_priority, 
          ${title}, 
          ${message}, 
          ${JSON.stringify(metadata)}::jsonb, 
          ${actionUrl || null}, 
          ${actionLabel || null}, 
          ${expiresAt ? expiresAt.toISOString() : null}
        )
        RETURNING *
      `);
      logger.info(`[NotificationService] Created ${type} notification for chef ${userId}`);
    }
    return result.rows[0];
  } catch (error) {
    logger.error(`[NotificationService] Failed to create ${target} notification:`, error);
    throw error;
  }
}
async function createManagerNotification(params) {
  return createNotification({
    userId: params.managerId,
    target: "manager",
    locationId: params.locationId,
    type: params.type,
    priority: params.priority,
    title: params.title,
    message: params.message,
    metadata: params.metadata,
    actionUrl: params.actionUrl,
    actionLabel: params.actionLabel,
    expiresAt: params.expiresAt
  });
}
async function createChefNotification(params) {
  return createNotification({
    userId: params.chefId,
    target: "chef",
    type: params.type,
    priority: params.priority,
    title: params.title,
    message: params.message,
    metadata: params.metadata,
    actionUrl: params.actionUrl,
    actionLabel: params.actionLabel,
    expiresAt: params.expiresAt
  });
}
async function notifyNewBooking(data) {
  const actionUrl = `/manager/booking/${data.bookingId}`;
  logger.info(`[NotificationService] Creating booking_new notification with actionUrl: ${actionUrl}`);
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "booking_new",
    priority: "high",
    title: "New Booking Request",
    message: `${data.chefName} requested to book ${data.kitchenName} on ${data.bookingDate} from ${data.startTime} to ${data.endTime}. Awaiting your approval.`,
    metadata: {
      bookingId: data.bookingId,
      chefName: data.chefName,
      kitchenName: data.kitchenName,
      bookingDate: data.bookingDate,
      startTime: data.startTime,
      endTime: data.endTime
    },
    actionUrl: `/manager/booking/${data.bookingId}`,
    actionLabel: "Review Booking"
  });
}
async function notifyBookingConfirmed(data) {
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "booking_confirmed",
    priority: "normal",
    title: "Booking Confirmed",
    message: `You confirmed ${data.chefName}'s booking at ${data.kitchenName} on ${data.bookingDate}.`,
    metadata: {
      bookingId: data.bookingId,
      chefName: data.chefName,
      kitchenName: data.kitchenName
    },
    actionUrl: `/manager/booking/${data.bookingId}`,
    actionLabel: "View Booking"
  });
}
async function notifyBookingCancelled(data) {
  const isByChef = data.cancelledBy === "chef";
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "booking_cancelled",
    priority: "high",
    title: isByChef ? "Booking Cancelled by Chef" : "Booking Cancelled",
    message: isByChef ? `${data.chefName} cancelled their booking at ${data.kitchenName} on ${data.bookingDate}.` : `Booking at ${data.kitchenName} on ${data.bookingDate} was cancelled.`,
    metadata: {
      bookingId: data.bookingId,
      chefName: data.chefName,
      kitchenName: data.kitchenName,
      cancelledBy: data.cancelledBy
    },
    actionUrl: `/manager/booking/${data.bookingId}`,
    actionLabel: "View Details"
  });
}
async function notifyPaymentReceived(data) {
  const formattedAmount = (data.amount / 100).toFixed(2);
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "payment_received",
    priority: "normal",
    title: "Payment Received",
    message: `Received $${formattedAmount} ${data.currency} from ${data.chefName} for booking at ${data.kitchenName}.`,
    metadata: {
      bookingId: data.bookingId,
      amount: data.amount,
      currency: data.currency,
      chefName: data.chefName
    },
    actionUrl: `/manager/booking-dashboard?view=revenue`,
    actionLabel: "View Revenue"
  });
}
async function notifyPaymentFailed(data) {
  const formattedAmount = (data.amount / 100).toFixed(2);
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "payment_failed",
    priority: "urgent",
    title: "Payment Failed",
    message: `Payment of $${formattedAmount} ${data.currency} from ${data.chefName} failed.${data.reason ? ` Reason: ${data.reason}` : ""}`,
    metadata: {
      bookingId: data.bookingId,
      amount: data.amount,
      currency: data.currency,
      chefName: data.chefName,
      reason: data.reason
    },
    actionUrl: `/manager/booking/${data.bookingId}`,
    actionLabel: "View Booking"
  });
}
async function notifyNewApplication(data) {
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "application_new",
    priority: "high",
    title: "New Chef Application",
    message: `${data.chefName} (${data.chefEmail}) has applied to use your kitchen. Review their application to approve or reject.`,
    metadata: {
      applicationId: data.applicationId,
      chefName: data.chefName,
      chefEmail: data.chefEmail
    },
    actionUrl: `/manager/booking-dashboard?view=applications`,
    actionLabel: "Review Application"
  });
}
async function notifyApplicationApproved(data) {
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "application_approved",
    priority: "normal",
    title: "Application Approved",
    message: `You approved ${data.chefName}'s application. They can now book your kitchen.`,
    metadata: {
      applicationId: data.applicationId,
      chefName: data.chefName
    },
    actionUrl: `/manager/booking-dashboard?view=applications`,
    actionLabel: "View Applications"
  });
}
async function notifyStorageExpiring(data) {
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "storage_expiring",
    priority: "high",
    title: "Storage Booking Expiring",
    message: `${data.chefName}'s storage booking for "${data.storageName}" expires in ${data.daysUntilExpiry} day${data.daysUntilExpiry !== 1 ? "s" : ""} (${data.expiryDate}).`,
    metadata: {
      storageBookingId: data.storageBookingId,
      chefName: data.chefName,
      storageName: data.storageName,
      expiryDate: data.expiryDate,
      daysUntilExpiry: data.daysUntilExpiry
    },
    actionUrl: `/manager/booking-dashboard?view=storage`,
    actionLabel: "View Storage"
  });
}
async function notifyLicenseApproved(data) {
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "license_approved",
    priority: "normal",
    title: "Kitchen License Approved",
    message: `Your kitchen license for ${data.locationName} has been approved by the admin.${data.expiryDate ? ` Valid until ${data.expiryDate}.` : ""}`,
    metadata: {
      locationName: data.locationName,
      expiryDate: data.expiryDate
    },
    actionUrl: `/manager/booking-dashboard?view=settings`,
    actionLabel: "View Settings"
  });
}
async function notifyLicenseRejected(data) {
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "license_rejected",
    priority: "urgent",
    title: "Kitchen License Rejected",
    message: `Your kitchen license for ${data.locationName} was rejected.${data.feedback ? ` Feedback: ${data.feedback}` : " Please upload a new license."}`,
    metadata: {
      locationName: data.locationName,
      feedback: data.feedback
    },
    actionUrl: `/manager/booking-dashboard?view=settings`,
    actionLabel: "Upload New License"
  });
}
async function notifyLicenseExpiring(data) {
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "license_expiring",
    priority: "high",
    title: "Kitchen License Expiring Soon",
    message: `Your kitchen license for ${data.locationName} expires in ${data.daysUntilExpiry} day${data.daysUntilExpiry !== 1 ? "s" : ""} (${data.expiryDate}). Please renew to avoid service interruption.`,
    metadata: {
      locationName: data.locationName,
      expiryDate: data.expiryDate,
      daysUntilExpiry: data.daysUntilExpiry
    },
    actionUrl: `/manager/booking-dashboard?view=settings`,
    actionLabel: "Renew License"
  });
}
async function notifyNewMessage(data) {
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "message_received",
    priority: "normal",
    title: `Message from ${data.senderName}`,
    message: data.messagePreview.length > 100 ? `${data.messagePreview.substring(0, 100)}...` : data.messagePreview,
    metadata: {
      senderName: data.senderName,
      conversationId: data.conversationId
    },
    actionUrl: `/manager/booking-dashboard?view=messages`,
    actionLabel: "View Message"
  });
}
async function notifySystemAnnouncement(managerId, data) {
  return createManagerNotification({
    managerId,
    type: "system_announcement",
    priority: data.priority || "normal",
    title: data.title,
    message: data.message,
    metadata: { isSystemAnnouncement: true },
    actionUrl: data.actionUrl,
    actionLabel: data.actionLabel
  });
}
async function broadcastSystemAnnouncement(data) {
  try {
    const result = await db.execute(sql2`
      SELECT id FROM users WHERE is_manager = true
    `);
    const managerIds = result.rows.map((row) => row.id);
    const notifications = await Promise.all(
      managerIds.map((managerId) => notifySystemAnnouncement(managerId, data))
    );
    logger.info(`[NotificationService] Broadcasted system announcement to ${managerIds.length} managers`);
    return notifications;
  } catch (error) {
    logger.error(`[NotificationService] Failed to broadcast announcement:`, error);
    throw error;
  }
}
async function notifyChefBookingConfirmed(data) {
  return createChefNotification({
    chefId: data.chefId,
    type: "booking_confirmed",
    priority: "high",
    title: "Booking Confirmed!",
    message: `Your booking at ${data.kitchenName} on ${data.bookingDate} from ${data.startTime} to ${data.endTime} has been confirmed.`,
    metadata: {
      bookingId: data.bookingId,
      kitchenName: data.kitchenName,
      locationName: data.locationName,
      bookingDate: data.bookingDate
    },
    actionUrl: `/dashboard?view=bookings`,
    actionLabel: "View Booking"
  });
}
async function notifyChefBookingCancelled(data) {
  const isByManager = data.cancelledBy === "manager";
  return createChefNotification({
    chefId: data.chefId,
    type: "booking_cancelled",
    priority: "high",
    title: isByManager ? "Booking Cancelled by Manager" : "Booking Cancelled",
    message: isByManager ? `Your booking at ${data.kitchenName} on ${data.bookingDate} was cancelled by the manager.${data.reason ? ` Reason: ${data.reason}` : ""}` : `Your booking at ${data.kitchenName} on ${data.bookingDate} has been cancelled.`,
    metadata: {
      bookingId: data.bookingId,
      kitchenName: data.kitchenName,
      cancelledBy: data.cancelledBy,
      reason: data.reason
    },
    actionUrl: `/dashboard?view=bookings`,
    actionLabel: "View Details"
  });
}
async function notifyChefApplicationApproved(data) {
  return createChefNotification({
    chefId: data.chefId,
    type: "application_approved",
    priority: "high",
    title: "Application Approved!",
    message: `Congratulations! Your application to ${data.kitchenName} at ${data.locationName} has been approved. You can now book this kitchen.`,
    metadata: {
      kitchenName: data.kitchenName,
      locationName: data.locationName
    },
    actionUrl: `/dashboard?view=discover`,
    actionLabel: "Book Now"
  });
}
async function notifyChefApplicationRejected(data) {
  return createChefNotification({
    chefId: data.chefId,
    type: "application_rejected",
    priority: "normal",
    title: "Application Update",
    message: `Your application to ${data.kitchenName} at ${data.locationName} was not approved.${data.reason ? ` Reason: ${data.reason}` : ""}`,
    metadata: {
      kitchenName: data.kitchenName,
      locationName: data.locationName,
      reason: data.reason
    },
    actionUrl: `/dashboard?view=applications`,
    actionLabel: "View Details"
  });
}
async function notifyChefWelcome(chefId, chefName) {
  return createChefNotification({
    chefId,
    type: "welcome",
    priority: "normal",
    title: `Welcome to LocalCooks, ${chefName}!`,
    message: "Your account is set up. Start by exploring available kitchens and submitting your first application.",
    metadata: { isWelcome: true },
    actionUrl: `/dashboard?view=discover`,
    actionLabel: "Explore Kitchens"
  });
}
async function notifyChefPaymentReceived(data) {
  const formattedAmount = (data.amount / 100).toFixed(2);
  return createChefNotification({
    chefId: data.chefId,
    type: "payment_received",
    priority: "normal",
    title: "Payment Confirmed",
    message: `Your payment of $${formattedAmount} ${data.currency} for ${data.kitchenName} has been processed.`,
    metadata: {
      amount: data.amount,
      currency: data.currency,
      bookingId: data.bookingId
    },
    actionUrl: `/dashboard?view=bookings`,
    actionLabel: "View Booking"
  });
}
async function notifyChefMessage(data) {
  return createChefNotification({
    chefId: data.chefId,
    type: "message_received",
    priority: "normal",
    title: `Message from ${data.senderName}`,
    message: data.messagePreview.length > 100 ? `${data.messagePreview.substring(0, 100)}...` : data.messagePreview,
    metadata: {
      senderName: data.senderName,
      conversationId: data.conversationId
    },
    actionUrl: `/dashboard?view=messages`,
    actionLabel: "View Message"
  });
}
async function broadcastChefAnnouncement(data) {
  try {
    const result = await db.execute(sql2`
      SELECT id FROM users WHERE is_chef = true OR role = 'chef'
    `);
    const chefIds = result.rows.map((row) => row.id);
    const notifications = await Promise.all(
      chefIds.map((chefId) => createChefNotification({
        chefId,
        type: "system_announcement",
        priority: data.priority || "normal",
        title: data.title,
        message: data.message,
        metadata: { isSystemAnnouncement: true },
        actionUrl: data.actionUrl,
        actionLabel: data.actionLabel
      }))
    );
    logger.info(`[NotificationService] Broadcasted system announcement to ${chefIds.length} chefs`);
    return notifications;
  } catch (error) {
    logger.error(`[NotificationService] Failed to broadcast chef announcement:`, error);
    throw error;
  }
}
async function notifyManagerStorageExtensionPending(data) {
  if (!data.managerId) return;
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "storage_extension_approved",
    // Using existing type
    priority: "high",
    title: "Storage Extension Request",
    message: `${data.chefName} has requested a ${data.extensionDays}-day extension for "${data.storageName}". Payment received - awaiting your approval.`,
    metadata: {
      storageBookingId: data.storageBookingId,
      storageName: data.storageName,
      extensionDays: data.extensionDays,
      newEndDate: data.newEndDate,
      chefName: data.chefName
    },
    actionUrl: `/manager/booking-dashboard?view=storage`,
    actionLabel: "Review Extension"
  });
}
async function notifyChefStorageExtensionApproved(data) {
  if (!data.chefId) return;
  return createChefNotification({
    chefId: data.chefId,
    type: "storage_extension_approved",
    priority: "high",
    title: "Storage Extension Approved!",
    message: `Your ${data.extensionDays}-day extension for "${data.storageName}" has been approved. New end date: ${data.newEndDate}.`,
    metadata: {
      storageBookingId: data.storageBookingId,
      storageName: data.storageName,
      extensionDays: data.extensionDays,
      newEndDate: data.newEndDate
    },
    actionUrl: `/dashboard?view=bookings`,
    actionLabel: "View Booking"
  });
}
async function notifyChefStorageExtensionRejected(data) {
  if (!data.chefId) return;
  return createChefNotification({
    chefId: data.chefId,
    type: "storage_extension_rejected",
    priority: "high",
    title: "Storage Extension Declined",
    message: `Your extension request for "${data.storageName}" was declined.${data.reason ? ` Reason: ${data.reason}` : ""} A refund will be processed.`,
    metadata: {
      storageBookingId: data.storageBookingId,
      storageName: data.storageName,
      extensionDays: data.extensionDays,
      reason: data.reason
    },
    actionUrl: `/dashboard?view=bookings`,
    actionLabel: "View Details"
  });
}
async function notifyChefOverstayDetected(data) {
  const formattedAmount = (data.penaltyAmountCents / 100).toFixed(2);
  return createChefNotification({
    chefId: data.chefId,
    type: "overstay_detected",
    priority: "urgent",
    title: "\u26A0\uFE0F Storage Overstay Detected",
    message: `Your storage "${data.storageName}" at ${data.kitchenName} is ${data.daysOverdue} day(s) overdue. Potential penalty: $${formattedAmount}. Please remove your items or resolve this overstay to avoid further charges.`,
    metadata: {
      overstayId: data.overstayId,
      storageName: data.storageName,
      daysOverdue: data.daysOverdue,
      penaltyAmountCents: data.penaltyAmountCents
    },
    actionUrl: `/dashboard?view=storage`,
    actionLabel: "Resolve Now"
  });
}
async function notifyManagerOverstayPendingReview(data) {
  const formattedAmount = (data.penaltyAmountCents / 100).toFixed(2);
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "overstay_pending_review",
    priority: "high",
    title: "Overstay Requires Review",
    message: `${data.chefName}'s storage "${data.storageName}" is ${data.daysOverdue} day(s) overdue. Calculated penalty: $${formattedAmount}. Review and approve or waive the penalty.`,
    metadata: {
      overstayId: data.overstayId,
      storageName: data.storageName,
      chefName: data.chefName,
      daysOverdue: data.daysOverdue,
      penaltyAmountCents: data.penaltyAmountCents
    },
    actionUrl: `/manager/booking-dashboard?view=overstays`,
    actionLabel: "Review Penalty"
  });
}
async function notifyChefPenaltyApproved(data) {
  const formattedAmount = (data.penaltyAmountCents / 100).toFixed(2);
  return createChefNotification({
    chefId: data.chefId,
    type: "overstay_penalty_approved",
    priority: "urgent",
    title: "Overstay Penalty Approved",
    message: `A $${formattedAmount} penalty for your storage "${data.storageName}" (${data.daysOverdue} days overdue) has been approved. Payment will be charged to your saved card.`,
    metadata: {
      overstayId: data.overstayId,
      storageName: data.storageName,
      daysOverdue: data.daysOverdue,
      penaltyAmountCents: data.penaltyAmountCents
    },
    actionUrl: `/dashboard?view=payments`,
    actionLabel: "View Details"
  });
}
async function notifyChefPenaltyWaived(data) {
  return createChefNotification({
    chefId: data.chefId,
    type: "overstay_penalty_waived",
    priority: "normal",
    title: "Overstay Penalty Waived",
    message: `Good news! The penalty for your storage "${data.storageName}" has been waived by the manager.${data.waiveReason ? ` Reason: ${data.waiveReason}` : ""}`,
    metadata: {
      overstayId: data.overstayId,
      storageName: data.storageName,
      waiveReason: data.waiveReason
    },
    actionUrl: `/dashboard?view=storage`,
    actionLabel: "View Storage"
  });
}
async function notifyChefPenaltyCharged(data) {
  const formattedAmount = (data.penaltyAmountCents / 100).toFixed(2);
  return createChefNotification({
    chefId: data.chefId,
    type: "overstay_penalty_charged",
    priority: "high",
    title: "Overstay Penalty Charged",
    message: `$${formattedAmount} has been charged to your card for the storage overstay at "${data.storageName}" (${data.daysOverdue} days overdue).`,
    metadata: {
      overstayId: data.overstayId,
      storageName: data.storageName,
      daysOverdue: data.daysOverdue,
      penaltyAmountCents: data.penaltyAmountCents
    },
    actionUrl: `/dashboard?view=payments`,
    actionLabel: "View Receipt"
  });
}
async function notifyManagerPenaltyReceived(data) {
  const formattedAmount = (data.penaltyAmountCents / 100).toFixed(2);
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "payment_received",
    priority: "normal",
    title: "Overstay Penalty Collected",
    message: `$${formattedAmount} overstay penalty collected from ${data.chefName} for "${data.storageName}".`,
    metadata: {
      overstayId: data.overstayId,
      storageName: data.storageName,
      chefName: data.chefName,
      penaltyAmountCents: data.penaltyAmountCents
    },
    actionUrl: `/manager/booking-dashboard?view=revenue`,
    actionLabel: "View Revenue"
  });
}
async function notifyChefPaymentRequired(data) {
  const formattedAmount = (data.penaltyAmountCents / 100).toFixed(2);
  return createChefNotification({
    chefId: data.chefId,
    type: "overstay_payment_required",
    priority: "urgent",
    title: "\u26A0\uFE0F Payment Action Required",
    message: `Your card requires additional verification to process the $${formattedAmount} overstay penalty. Please complete payment to avoid account restrictions.`,
    metadata: {
      overstayId: data.overstayId,
      storageName: data.storageName,
      penaltyAmountCents: data.penaltyAmountCents,
      paymentUrl: data.paymentUrl
    },
    actionUrl: data.paymentUrl || `/dashboard?view=payments`,
    actionLabel: "Complete Payment"
  });
}
async function notifyChefOverstayRefunded(data) {
  const formattedAmount = (data.refundAmountCents / 100).toFixed(2);
  return createChefNotification({
    chefId: data.chefId,
    type: "overstay_refunded",
    priority: "normal",
    title: "Overstay Penalty Refunded",
    message: `$${formattedAmount} has been refunded for the overstay penalty on "${data.storageName}".${data.refundReason ? ` Reason: ${data.refundReason}` : ""}`,
    metadata: {
      overstayId: data.overstayId,
      storageName: data.storageName,
      refundAmountCents: data.refundAmountCents,
      refundReason: data.refundReason
    },
    actionUrl: `/dashboard?view=payments`,
    actionLabel: "View Details"
  });
}
async function notifyChefDamageClaimFiled(data) {
  const formattedAmount = (data.amountCents / 100).toFixed(2);
  return createChefNotification({
    chefId: data.chefId,
    type: "damage_claim_filed",
    priority: "urgent",
    title: "\u26A0\uFE0F Damage Claim Filed",
    message: `${data.managerName} has filed a $${formattedAmount} damage claim: "${data.claimTitle}" at ${data.locationName}. Please respond by ${format(data.responseDeadline, "MMM d, yyyy h:mm a")}.`,
    metadata: {
      claimId: data.claimId,
      claimTitle: data.claimTitle,
      amountCents: data.amountCents,
      locationName: data.locationName,
      responseDeadline: data.responseDeadline.toISOString()
    },
    actionUrl: `/dashboard?view=damage-claims`,
    actionLabel: "Respond Now"
  });
}
async function notifyManagerClaimResponseReceived(data) {
  const formattedAmount = (data.amountCents / 100).toFixed(2);
  const isAccepted = data.responseType === "accepted";
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "damage_claim_response_received",
    priority: "high",
    title: isAccepted ? "Damage Claim Accepted" : "Damage Claim Disputed",
    message: isAccepted ? `${data.chefName} accepted your $${formattedAmount} damage claim "${data.claimTitle}". Payment will be charged automatically.` : `${data.chefName} disputed your damage claim "${data.claimTitle}". Admin review required.`,
    metadata: {
      claimId: data.claimId,
      claimTitle: data.claimTitle,
      chefName: data.chefName,
      responseType: data.responseType,
      chefResponse: data.chefResponse
    },
    actionUrl: `/manager/booking-dashboard?view=damage-claims`,
    actionLabel: "View Claim"
  });
}
async function notifyChefClaimDecision(data) {
  const isApproved = data.decision === "approved" || data.decision === "partially_approved";
  const finalAmount = data.approvedAmountCents || data.amountCents;
  const formattedAmount = (finalAmount / 100).toFixed(2);
  return createChefNotification({
    chefId: data.chefId,
    type: isApproved ? "damage_claim_approved" : "damage_claim_rejected",
    priority: "high",
    title: isApproved ? `Damage Claim ${data.decision === "partially_approved" ? "Partially " : ""}Approved` : "Damage Claim Rejected",
    message: isApproved ? `The damage claim "${data.claimTitle}" has been ${data.decision === "partially_approved" ? "partially " : ""}approved for $${formattedAmount}. Payment will be charged to your card.` : `The damage claim "${data.claimTitle}" has been rejected.${data.decisionReason ? ` Reason: ${data.decisionReason}` : ""}`,
    metadata: {
      claimId: data.claimId,
      claimTitle: data.claimTitle,
      decision: data.decision,
      approvedAmountCents: data.approvedAmountCents,
      decisionReason: data.decisionReason
    },
    actionUrl: `/dashboard?view=damage-claims`,
    actionLabel: "View Details"
  });
}
async function notifyManagerClaimDecision(data) {
  const isApproved = data.decision === "approved" || data.decision === "partially_approved";
  const finalAmount = data.approvedAmountCents || data.amountCents;
  const formattedAmount = (finalAmount / 100).toFixed(2);
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: isApproved ? "damage_claim_approved" : "damage_claim_rejected",
    priority: "normal",
    title: isApproved ? `Damage Claim ${data.decision === "partially_approved" ? "Partially " : ""}Approved` : "Damage Claim Rejected",
    message: isApproved ? `Admin approved your damage claim "${data.claimTitle}" for $${formattedAmount}.` : `Admin rejected your damage claim "${data.claimTitle}".${data.decisionReason ? ` Reason: ${data.decisionReason}` : ""}`,
    metadata: {
      claimId: data.claimId,
      claimTitle: data.claimTitle,
      decision: data.decision,
      approvedAmountCents: data.approvedAmountCents,
      decisionReason: data.decisionReason
    },
    actionUrl: `/manager/booking-dashboard?view=damage-claims`,
    actionLabel: "View Claim"
  });
}
async function notifyChefDamageClaimCharged(data) {
  const formattedAmount = (data.amountCents / 100).toFixed(2);
  return createChefNotification({
    chefId: data.chefId,
    type: "damage_claim_charged",
    priority: "high",
    title: "Damage Claim Charged",
    message: `$${formattedAmount} has been charged to your card for the damage claim "${data.claimTitle}" at ${data.locationName}.`,
    metadata: {
      claimId: data.claimId,
      claimTitle: data.claimTitle,
      amountCents: data.amountCents,
      locationName: data.locationName
    },
    actionUrl: `/dashboard?view=payments`,
    actionLabel: "View Receipt"
  });
}
async function notifyManagerDamageClaimReceived(data) {
  const formattedAmount = (data.amountCents / 100).toFixed(2);
  return createManagerNotification({
    managerId: data.managerId,
    locationId: data.locationId,
    type: "payment_received",
    priority: "normal",
    title: "Damage Claim Payment Received",
    message: `$${formattedAmount} collected from ${data.chefName} for damage claim "${data.claimTitle}".`,
    metadata: {
      claimId: data.claimId,
      claimTitle: data.claimTitle,
      chefName: data.chefName,
      amountCents: data.amountCents
    },
    actionUrl: `/manager/booking-dashboard?view=revenue`,
    actionLabel: "View Revenue"
  });
}
async function notifyChefDamageClaimRefunded(data) {
  const formattedAmount = (data.refundAmountCents / 100).toFixed(2);
  return createChefNotification({
    chefId: data.chefId,
    type: "damage_claim_refunded",
    priority: "normal",
    title: "Damage Claim Refunded",
    message: `$${formattedAmount} has been refunded for the damage claim "${data.claimTitle}".${data.refundReason ? ` Reason: ${data.refundReason}` : ""}`,
    metadata: {
      claimId: data.claimId,
      claimTitle: data.claimTitle,
      refundAmountCents: data.refundAmountCents,
      refundReason: data.refundReason
    },
    actionUrl: `/dashboard?view=payments`,
    actionLabel: "View Details"
  });
}
var notificationService;
var init_notification_service = __esm({
  "server/services/notification.service.ts"() {
    "use strict";
    init_db();
    init_logger();
    notificationService = {
      // Core - Unified
      create: createNotification,
      createForManager: createManagerNotification,
      createForChef: createChefNotification,
      // Manager: Booking
      notifyNewBooking,
      notifyBookingConfirmed,
      notifyBookingCancelled,
      // Manager: Payment
      notifyPaymentReceived,
      notifyPaymentFailed,
      // Manager: Application
      notifyNewApplication,
      notifyApplicationApproved,
      // Manager: Storage & License
      notifyStorageExpiring,
      notifyLicenseApproved,
      notifyLicenseRejected,
      notifyLicenseExpiring,
      // Manager: Message & System
      notifyNewMessage,
      notifySystemAnnouncement,
      broadcastSystemAnnouncement,
      // Chef: Booking
      notifyChefBookingConfirmed,
      notifyChefBookingCancelled,
      // Chef: Application
      notifyChefApplicationApproved,
      notifyChefApplicationRejected,
      // Chef: Other
      notifyChefWelcome,
      notifyChefPaymentReceived,
      notifyChefMessage,
      broadcastChefAnnouncement,
      // Storage Extension
      notifyManagerStorageExtensionPending,
      notifyChefStorageExtensionApproved,
      notifyChefStorageExtensionRejected,
      // Overstay Penalty
      notifyChefOverstayDetected,
      notifyManagerOverstayPendingReview,
      notifyChefPenaltyApproved,
      notifyChefPenaltyWaived,
      notifyChefPenaltyCharged,
      notifyManagerPenaltyReceived,
      notifyChefPaymentRequired,
      notifyChefOverstayRefunded,
      // Damage Claim
      notifyChefDamageClaimFiled,
      notifyManagerClaimResponseReceived,
      notifyChefClaimDecision,
      notifyManagerClaimDecision,
      notifyChefDamageClaimCharged,
      notifyManagerDamageClaimReceived,
      notifyChefDamageClaimRefunded
    };
  }
});

// server/services/stripe-checkout-fee-service.ts
var stripe_checkout_fee_service_exports = {};
__export(stripe_checkout_fee_service_exports, {
  DEFAULT_FEE_CONFIG: () => DEFAULT_FEE_CONFIG,
  FEE_CONFIG: () => FEE_CONFIG,
  calculateCheckoutFees: () => calculateCheckoutFees,
  calculateCheckoutFeesAsync: () => calculateCheckoutFeesAsync,
  calculateCheckoutFeesWithRates: () => calculateCheckoutFeesWithRates,
  clearFeeConfigCache: () => clearFeeConfigCache,
  getFeeConfig: () => getFeeConfig
});
async function getFeeConfig() {
  if (feeConfigCache && Date.now() - feeConfigCache.timestamp < CACHE_TTL_MS) {
    return feeConfigCache.config;
  }
  try {
    const allSettings = await db.select({ key: platformSettings.key, value: platformSettings.value }).from(platformSettings);
    const settingsMap = new Map(allSettings.map((s) => [s.key, s.value]));
    const parseFloatOrDefault = (value, defaultValue) => {
      if (value === void 0 || value === "") return defaultValue;
      const parsed = parseFloat(value);
      return isNaN(parsed) ? defaultValue : parsed;
    };
    const parseIntOrDefault = (value, defaultValue) => {
      if (value === void 0 || value === "") return defaultValue;
      const parsed = parseInt(value, 10);
      return isNaN(parsed) ? defaultValue : parsed;
    };
    const config = {
      stripePercentageFee: parseFloatOrDefault(settingsMap.get("stripe_percentage_fee"), DEFAULT_FEE_CONFIG.stripePercentageFee),
      stripeFlatFeeCents: parseIntOrDefault(settingsMap.get("stripe_flat_fee_cents"), DEFAULT_FEE_CONFIG.stripeFlatFeeCents),
      platformCommissionRate: parseFloatOrDefault(settingsMap.get("platform_commission_rate"), DEFAULT_FEE_CONFIG.platformCommissionRate),
      minimumApplicationFeeCents: parseIntOrDefault(settingsMap.get("minimum_application_fee_cents"), DEFAULT_FEE_CONFIG.minimumApplicationFeeCents),
      useStripePlatformPricing: settingsMap.get("use_stripe_platform_pricing") === "true"
    };
    if (config.stripePercentageFee < 0 || config.stripePercentageFee > 1) {
      logger.warn("Invalid stripe_percentage_fee, using default");
      config.stripePercentageFee = DEFAULT_FEE_CONFIG.stripePercentageFee;
    }
    if (config.platformCommissionRate < 0 || config.platformCommissionRate > 1) {
      logger.warn("Invalid platform_commission_rate, using default");
      config.platformCommissionRate = DEFAULT_FEE_CONFIG.platformCommissionRate;
    }
    feeConfigCache = { config, timestamp: Date.now() };
    return config;
  } catch (error) {
    logger.error("Error fetching fee config from database, using defaults:", error);
    return DEFAULT_FEE_CONFIG;
  }
}
function clearFeeConfigCache() {
  feeConfigCache = null;
}
function calculateCheckoutFees(bookingPrice, options) {
  if (bookingPrice <= 0) {
    throw new Error("Booking price must be greater than 0");
  }
  const platformCommissionRate = options?.platformCommissionRate ?? FEE_CONFIG.PLATFORM_COMMISSION_RATE;
  const chargeFeesToCustomer = options?.chargeFeesToCustomer ?? false;
  const bookingPriceInCents = Math.round(bookingPrice * 100);
  const stripeProcessingFeeInCents = Math.round(
    bookingPriceInCents * FEE_CONFIG.STRIPE_PERCENTAGE_FEE + FEE_CONFIG.STRIPE_FLAT_FEE_CENTS
  );
  const platformCommissionInCents = Math.round(bookingPriceInCents * platformCommissionRate);
  let totalPlatformFeeInCents = stripeProcessingFeeInCents + platformCommissionInCents;
  totalPlatformFeeInCents = Math.max(totalPlatformFeeInCents, FEE_CONFIG.MINIMUM_APPLICATION_FEE_CENTS);
  const managerReceivesInCents = bookingPriceInCents - totalPlatformFeeInCents;
  if (managerReceivesInCents <= 0) {
    throw new Error(
      `Application fee (${totalPlatformFeeInCents} cents) cannot exceed booking price (${bookingPriceInCents} cents)`
    );
  }
  const totalChargeInCents = chargeFeesToCustomer ? bookingPriceInCents + totalPlatformFeeInCents : bookingPriceInCents;
  return {
    bookingPriceInCents,
    stripeProcessingFeeInCents,
    platformCommissionInCents,
    totalPlatformFeeInCents,
    totalChargeInCents,
    managerReceivesInCents,
    // Legacy fields for backward compatibility
    percentageFeeInCents: stripeProcessingFeeInCents,
    flatFeeInCents: FEE_CONFIG.STRIPE_FLAT_FEE_CENTS
  };
}
function calculateCheckoutFeesWithRates(bookingPrice, stripePercentage, stripeFlatCents, platformCommissionRate, minimumFeeCents = 50) {
  if (bookingPrice <= 0) {
    throw new Error("Booking price must be greater than 0");
  }
  const bookingPriceInCents = Math.round(bookingPrice * 100);
  const stripeProcessingFeeInCents = Math.round(
    bookingPriceInCents * stripePercentage + stripeFlatCents
  );
  const platformCommissionInCents = Math.round(bookingPriceInCents * platformCommissionRate);
  let totalPlatformFeeInCents = stripeProcessingFeeInCents + platformCommissionInCents;
  totalPlatformFeeInCents = Math.max(totalPlatformFeeInCents, minimumFeeCents);
  const managerReceivesInCents = bookingPriceInCents - totalPlatformFeeInCents;
  if (managerReceivesInCents <= 0) {
    throw new Error("Total fees exceed booking price");
  }
  return {
    bookingPriceInCents,
    stripeProcessingFeeInCents,
    platformCommissionInCents,
    totalPlatformFeeInCents,
    totalChargeInCents: bookingPriceInCents,
    managerReceivesInCents,
    percentageFeeInCents: stripeProcessingFeeInCents,
    flatFeeInCents: stripeFlatCents
  };
}
async function calculateCheckoutFeesAsync(bookingPriceInCents) {
  if (bookingPriceInCents <= 0) {
    throw new Error("Booking price must be greater than 0");
  }
  const config = await getFeeConfig();
  if (config.useStripePlatformPricing) {
    return {
      bookingPriceInCents,
      stripeProcessingFeeInCents: 0,
      platformCommissionInCents: 0,
      totalPlatformFeeInCents: 0,
      totalChargeInCents: bookingPriceInCents,
      managerReceivesInCents: bookingPriceInCents,
      percentageFeeInCents: 0,
      flatFeeInCents: 0,
      useStripePlatformPricing: true
    };
  }
  const stripeProcessingFeeInCents = Math.round(
    bookingPriceInCents * config.stripePercentageFee + config.stripeFlatFeeCents
  );
  const platformCommissionInCents = Math.round(
    bookingPriceInCents * config.platformCommissionRate
  );
  let totalPlatformFeeInCents = stripeProcessingFeeInCents + platformCommissionInCents;
  totalPlatformFeeInCents = Math.max(totalPlatformFeeInCents, config.minimumApplicationFeeCents);
  const managerReceivesInCents = bookingPriceInCents - totalPlatformFeeInCents;
  if (managerReceivesInCents <= 0) {
    throw new Error(
      `Application fee (${totalPlatformFeeInCents} cents) cannot exceed booking price (${bookingPriceInCents} cents)`
    );
  }
  return {
    bookingPriceInCents,
    stripeProcessingFeeInCents,
    platformCommissionInCents,
    totalPlatformFeeInCents,
    totalChargeInCents: bookingPriceInCents,
    managerReceivesInCents,
    percentageFeeInCents: stripeProcessingFeeInCents,
    flatFeeInCents: config.stripeFlatFeeCents,
    useStripePlatformPricing: false
  };
}
var DEFAULT_FEE_CONFIG, feeConfigCache, CACHE_TTL_MS, FEE_CONFIG;
var init_stripe_checkout_fee_service = __esm({
  "server/services/stripe-checkout-fee-service.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_schema();
    DEFAULT_FEE_CONFIG = {
      stripePercentageFee: 0.029,
      // 2.9% - Stripe Canada card processing fee
      stripeFlatFeeCents: 30,
      // $0.30 CAD - Stripe Canada flat fee per transaction
      platformCommissionRate: 0,
      // 0% platform commission for break-even
      minimumApplicationFeeCents: 0,
      // No minimum for break-even mode
      useStripePlatformPricing: false
    };
    feeConfigCache = null;
    CACHE_TTL_MS = 5 * 60 * 1e3;
    FEE_CONFIG = {
      // Stripe processing fees (Canada)
      STRIPE_PERCENTAGE_FEE: DEFAULT_FEE_CONFIG.stripePercentageFee,
      // 2.9%
      STRIPE_FLAT_FEE_CENTS: DEFAULT_FEE_CONFIG.stripeFlatFeeCents,
      // $0.30 CAD
      // Platform commission (0% for break-even)
      PLATFORM_COMMISSION_RATE: DEFAULT_FEE_CONFIG.platformCommissionRate,
      // 0%
      MINIMUM_APPLICATION_FEE_CENTS: DEFAULT_FEE_CONFIG.minimumApplicationFeeCents
      // 0
    };
  }
});

// server/services/payment-transactions-service.ts
var payment_transactions_service_exports = {};
__export(payment_transactions_service_exports, {
  addPaymentHistory: () => addPaymentHistory,
  createPaymentTransaction: () => createPaymentTransaction,
  findPaymentTransactionByBooking: () => findPaymentTransactionByBooking,
  findPaymentTransactionById: () => findPaymentTransactionById,
  findPaymentTransactionByIntentId: () => findPaymentTransactionByIntentId,
  findPaymentTransactionByMetadata: () => findPaymentTransactionByMetadata,
  getAdminPaymentTransactions: () => getAdminPaymentTransactions,
  getChefPaymentTransactions: () => getChefPaymentTransactions,
  getManagerPaymentTransactions: () => getManagerPaymentTransactions,
  getPaymentHistory: () => getPaymentHistory,
  syncExistingPaymentTransactionsFromStripe: () => syncExistingPaymentTransactionsFromStripe,
  syncStripeAmountsToBookings: () => syncStripeAmountsToBookings,
  syncStripeFees: () => syncStripeFees,
  updatePaymentTransaction: () => updatePaymentTransaction
});
import { sql as sql3 } from "drizzle-orm";
async function createPaymentTransaction(params, db2) {
  const {
    bookingId,
    bookingType,
    chefId,
    managerId,
    amount,
    baseAmount,
    serviceFee,
    managerRevenue,
    currency = "CAD",
    paymentIntentId,
    chargeId,
    paymentMethodId,
    status = "pending",
    stripeStatus,
    metadata = {}
  } = params;
  const netAmount = amount;
  const result = await db2.execute(sql3`
    INSERT INTO payment_transactions (
      booking_id,
      booking_type,
      chef_id,
      manager_id,
      amount,
      base_amount,
      service_fee,
      manager_revenue,
      refund_amount,
      net_amount,
      currency,
      payment_intent_id,
      charge_id,
      payment_method_id,
      status,
      stripe_status,
      metadata
    ) VALUES (
      ${bookingId},
      ${bookingType},
      ${chefId},
      ${managerId},
      ${amount.toString()},
      ${baseAmount.toString()},
      ${serviceFee.toString()},
      ${managerRevenue.toString()},
      '0',
      ${netAmount.toString()},
      ${currency},
      ${paymentIntentId || null},
      ${chargeId || null},
      ${paymentMethodId || null},
      ${status},
      ${stripeStatus || null},
      ${JSON.stringify(metadata)}
    )
    RETURNING *
  `);
  const record = result.rows[0];
  await addPaymentHistory(
    record.id,
    {
      previousStatus: null,
      newStatus: status,
      eventType: "created",
      eventSource: "system",
      description: `Payment transaction created for ${bookingType} booking ${bookingId}`,
      metadata: { initialAmount: amount, baseAmount, serviceFee, managerRevenue }
    },
    db2
  );
  return record;
}
async function updatePaymentTransaction(transactionId, params, db2) {
  const currentResult = await db2.execute(sql3`
    SELECT status, refund_amount, amount
    FROM payment_transactions
    WHERE id = ${transactionId}
  `);
  if (currentResult.rows.length === 0) {
    return null;
  }
  const current = currentResult.rows[0];
  const previousStatus = current.status;
  const currentRefundAmount = parseFloat(current.refund_amount || "0");
  const currentAmount = parseFloat(current.amount || "0");
  const updates = [];
  if (params.status !== void 0) {
    updates.push(sql3`status = ${params.status}`);
  }
  if (params.stripeStatus !== void 0) {
    updates.push(sql3`stripe_status = ${params.stripeStatus}`);
  }
  if (params.paymentIntentId !== void 0) {
    updates.push(sql3`payment_intent_id = ${params.paymentIntentId}`);
  }
  if (params.paymentMethodId !== void 0) {
    updates.push(sql3`payment_method_id = ${params.paymentMethodId}`);
  }
  if (params.chargeId !== void 0) {
    updates.push(sql3`charge_id = ${params.chargeId}`);
  }
  if (params.refundId !== void 0) {
    updates.push(sql3`refund_id = ${params.refundId}`);
  }
  if (params.amount !== void 0) {
    updates.push(sql3`amount = ${params.amount.toString()}`);
  }
  if (params.refundAmount !== void 0) {
    updates.push(sql3`refund_amount = ${params.refundAmount.toString()}`);
    const effectiveAmount = params.amount !== void 0 ? params.amount : currentAmount;
    const newRefundAmount = params.refundAmount;
    const netAmount = effectiveAmount - newRefundAmount;
    updates.push(sql3`net_amount = ${netAmount.toString()}`);
  }
  if (params.refundReason !== void 0) {
    updates.push(sql3`refund_reason = ${params.refundReason}`);
  }
  if (params.failureReason !== void 0) {
    updates.push(sql3`failure_reason = ${params.failureReason}`);
  }
  if (params.paidAt !== void 0) {
    updates.push(sql3`paid_at = ${params.paidAt}`);
  }
  if (params.refundedAt !== void 0) {
    updates.push(sql3`refunded_at = ${params.refundedAt}`);
  }
  if (params.lastSyncedAt !== void 0) {
    updates.push(sql3`last_synced_at = ${params.lastSyncedAt}`);
  }
  if (params.webhookEventId !== void 0) {
    updates.push(sql3`webhook_event_id = ${params.webhookEventId}`);
  }
  if (params.stripeAmount !== void 0 || params.stripeNetAmount !== void 0) {
    if (params.stripeAmount !== void 0) {
      updates.push(sql3`amount = ${params.stripeAmount.toString()}`);
    }
    if (params.stripeNetAmount !== void 0) {
      updates.push(sql3`net_amount = ${params.stripeNetAmount.toString()}`);
      updates.push(sql3`manager_revenue = ${params.stripeNetAmount.toString()}`);
    }
    if (params.stripeProcessingFee !== void 0) {
      updates.push(sql3`stripe_processing_fee = ${params.stripeProcessingFee.toString()}`);
    }
    if (params.stripePlatformFee !== void 0 && params.stripePlatformFee > 0) {
      updates.push(sql3`service_fee = ${params.stripePlatformFee.toString()}`);
    } else if (params.stripeAmount !== void 0 && params.stripeNetAmount !== void 0) {
      const totalFees = params.stripeAmount - params.stripeNetAmount;
      const processingFee = params.stripeProcessingFee || 0;
      const actualPlatformFee = Math.max(0, totalFees - processingFee);
      updates.push(sql3`service_fee = ${actualPlatformFee.toString()}`);
    }
    if (params.stripeAmount !== void 0) {
      const platformFee = params.stripePlatformFee || (params.stripeAmount !== void 0 && params.stripeNetAmount !== void 0 ? Math.max(0, params.stripeAmount - params.stripeNetAmount - (params.stripeProcessingFee || 0)) : 0);
      const baseAmount = params.stripeAmount - platformFee;
      updates.push(sql3`base_amount = ${baseAmount.toString()}`);
    }
    const currentMetadataResult = await db2.execute(sql3`
      SELECT metadata FROM payment_transactions WHERE id = ${transactionId}
    `);
    const currentMetadata = currentMetadataResult.rows[0]?.metadata ? typeof currentMetadataResult.rows[0].metadata === "string" ? JSON.parse(currentMetadataResult.rows[0].metadata) : currentMetadataResult.rows[0].metadata : {};
    const stripeFees = {
      processingFee: params.stripeProcessingFee || 0,
      platformFee: params.stripePlatformFee || 0,
      syncedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    const updatedMetadata = {
      ...currentMetadata,
      stripeFees
    };
    updates.push(sql3`metadata = ${JSON.stringify(updatedMetadata)}`);
  } else if (params.metadata !== void 0) {
    updates.push(sql3`metadata = ${JSON.stringify(params.metadata)}`);
  }
  if (updates.length === 0) {
    const result2 = await db2.execute(sql3`
      SELECT * FROM payment_transactions WHERE id = ${transactionId}
    `);
    return result2.rows[0];
  }
  const result = await db2.execute(sql3`
    UPDATE payment_transactions
    SET ${sql3.join(updates, sql3`, `)}, updated_at = NOW()
    WHERE id = ${transactionId}
    RETURNING *
  `);
  const updated = result.rows[0];
  if (params.status !== void 0 && params.status !== previousStatus) {
    const historyMetadata = { ...params.metadata || {} };
    if (params.stripeAmount !== void 0 || params.stripeNetAmount !== void 0) {
      historyMetadata.stripeAmounts = {
        amount: params.stripeAmount,
        netAmount: params.stripeNetAmount,
        processingFee: params.stripeProcessingFee,
        platformFee: params.stripePlatformFee,
        syncedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    await addPaymentHistory(
      transactionId,
      {
        previousStatus,
        newStatus: params.status,
        eventType: "status_change",
        eventSource: params.webhookEventId ? "stripe_webhook" : "system",
        description: `Status changed from ${previousStatus} to ${params.status}${params.stripeAmount !== void 0 ? " (Stripe amounts synced)" : ""}`,
        stripeEventId: params.webhookEventId,
        metadata: historyMetadata
      },
      db2
    );
  }
  if ((params.stripeAmount !== void 0 || params.stripeNetAmount !== void 0) && params.status === void 0) {
    await addPaymentHistory(
      transactionId,
      {
        previousStatus: updated.status,
        newStatus: updated.status,
        eventType: "stripe_sync",
        eventSource: params.webhookEventId ? "stripe_webhook" : "system",
        description: `Stripe amounts synced: Amount $${((params.stripeAmount || parseFloat(updated.amount || "0")) / 100).toFixed(2)}, Net $${((params.stripeNetAmount || parseFloat(updated.net_amount || "0")) / 100).toFixed(2)}`,
        stripeEventId: params.webhookEventId,
        metadata: {
          stripeAmounts: {
            amount: params.stripeAmount,
            netAmount: params.stripeNetAmount,
            processingFee: params.stripeProcessingFee,
            platformFee: params.stripePlatformFee,
            syncedAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      },
      db2
    );
  }
  if (params.refundAmount !== void 0 && params.refundAmount > currentRefundAmount) {
    await addPaymentHistory(
      transactionId,
      {
        previousStatus,
        newStatus: updated.status,
        eventType: params.refundAmount === parseFloat(updated.amount || "0") ? "refund" : "partial_refund",
        eventSource: params.webhookEventId ? "stripe_webhook" : "system",
        description: `Refund of ${params.refundAmount / 100} ${updated.currency}${params.refundReason ? `: ${params.refundReason}` : ""}`,
        stripeEventId: params.webhookEventId,
        metadata: {
          refundAmount: params.refundAmount,
          refundReason: params.refundReason,
          refundId: params.refundId
        }
      },
      db2
    );
  }
  return updated;
}
async function syncStripeAmountsToBookings(paymentIntentId, stripeAmounts, db2) {
  try {
    const transactionResult = await db2.execute(sql3`
      SELECT 
        pt.id,
        pt.booking_id,
        pt.booking_type,
        pt.base_amount,
        pt.service_fee,
        pt.amount as current_amount,
        pt.manager_revenue as current_manager_revenue,
        pt.metadata
      FROM payment_transactions pt
      WHERE pt.payment_intent_id = ${paymentIntentId}
    `);
    if (transactionResult.rows.length === 0) {
      logger.warn(`[Stripe Sync] No payment transaction found for PaymentIntent ${paymentIntentId}`);
      return;
    }
    const transaction = transactionResult.rows[0];
    const bookingId = transaction.booking_id;
    const bookingType = transaction.booking_type;
    const ptMetadata = transaction.metadata ? typeof transaction.metadata === "string" ? JSON.parse(transaction.metadata) : transaction.metadata : {};
    if (ptMetadata.partialCapture) {
      logger.info(`[Stripe Sync] Skipping booking table sync for partially captured PaymentIntent ${paymentIntentId} \u2014 capture engine already set correct values`);
      return;
    }
    if (bookingType === "bundle") {
      const kitchenBooking = await db2.execute(sql3`
        SELECT id, total_price, service_fee
        FROM kitchen_bookings
        WHERE id = ${bookingId}
      `);
      const storageBookings2 = await db2.execute(sql3`
        SELECT id, total_price, service_fee
        FROM storage_bookings
        WHERE kitchen_booking_id = ${bookingId}
      `);
      const equipmentBookings2 = await db2.execute(sql3`
        SELECT id, total_price, service_fee
        FROM equipment_bookings
        WHERE kitchen_booking_id = ${bookingId}
      `);
      let totalBaseAmount = parseFloat(transaction.base_amount || "0");
      if (totalBaseAmount === 0) {
        const kbAmount = parseFloat(kitchenBooking.rows[0]?.total_price || "0");
        const sbAmount = storageBookings2.rows.reduce((sum, sb) => sum + parseFloat(sb.total_price || "0"), 0);
        const ebAmount = equipmentBookings2.rows.reduce((sum, eb) => sum + parseFloat(eb.total_price || "0"), 0);
        totalBaseAmount = kbAmount + sbAmount + ebAmount;
      }
      if (kitchenBooking.rows.length > 0 && totalBaseAmount > 0) {
        const kbBase = parseFloat(kitchenBooking.rows[0].total_price || "0");
        const kbProportion = kbBase / totalBaseAmount;
        const kbStripeAmount = Math.round(stripeAmounts.stripeAmount * kbProportion);
        const kbStripeNet = Math.round(stripeAmounts.stripeNetAmount * kbProportion);
        const kbServiceFee = stripeAmounts.stripePlatformFee > 0 ? Math.round(stripeAmounts.stripePlatformFee * kbProportion) : Math.round((kbStripeAmount - kbStripeNet) * 0.5);
        await db2.execute(sql3`
          UPDATE kitchen_bookings
          SET 
            total_price = ${kbStripeAmount.toString()},
            service_fee = ${kbServiceFee.toString()},
            updated_at = NOW()
          WHERE id = ${bookingId}
        `);
      }
      for (const sb of storageBookings2.rows) {
        const sbBase = parseFloat(sb.total_price || "0");
        if (totalBaseAmount > 0 && sbBase > 0) {
          const sbProportion = sbBase / totalBaseAmount;
          const sbStripeAmount = Math.round(stripeAmounts.stripeAmount * sbProportion);
          const sbStripeNet = Math.round(stripeAmounts.stripeNetAmount * sbProportion);
          const sbServiceFee = stripeAmounts.stripePlatformFee > 0 ? Math.round(stripeAmounts.stripePlatformFee * sbProportion) : Math.round((sbStripeAmount - sbStripeNet) * 0.5);
          await db2.execute(sql3`
            UPDATE storage_bookings
            SET 
              total_price = ${sbStripeAmount.toString()},
              service_fee = ${sbServiceFee.toString()},
              updated_at = NOW()
            WHERE id = ${sb.id}
          `);
        }
      }
      for (const eb of equipmentBookings2.rows) {
        const ebBase = parseFloat(eb.total_price || "0");
        if (totalBaseAmount > 0 && ebBase > 0) {
          const ebProportion = ebBase / totalBaseAmount;
          const ebStripeAmount = Math.round(stripeAmounts.stripeAmount * ebProportion);
          const ebStripeNet = Math.round(stripeAmounts.stripeNetAmount * ebProportion);
          const ebServiceFee = stripeAmounts.stripePlatformFee > 0 ? Math.round(stripeAmounts.stripePlatformFee * ebProportion) : Math.round((ebStripeAmount - ebStripeNet) * 0.5);
          await db2.execute(sql3`
            UPDATE equipment_bookings
            SET 
              total_price = ${ebStripeAmount.toString()},
              service_fee = ${ebServiceFee.toString()},
              updated_at = NOW()
            WHERE id = ${eb.id}
          `);
        }
      }
    } else {
      const serviceFee = stripeAmounts.stripePlatformFee > 0 ? stripeAmounts.stripePlatformFee : Math.max(0, stripeAmounts.stripeAmount - stripeAmounts.stripeNetAmount - stripeAmounts.stripeProcessingFee);
      if (bookingType === "kitchen") {
        await db2.execute(sql3`
          UPDATE kitchen_bookings
          SET 
            total_price = ${stripeAmounts.stripeAmount.toString()},
            service_fee = ${serviceFee.toString()},
            updated_at = NOW()
          WHERE id = ${bookingId}
        `);
      } else if (bookingType === "storage") {
        await db2.execute(sql3`
          UPDATE storage_bookings
          SET 
            total_price = ${stripeAmounts.stripeAmount.toString()},
            service_fee = ${serviceFee.toString()},
            updated_at = NOW()
          WHERE id = ${bookingId}
        `);
      } else if (bookingType === "equipment") {
        await db2.execute(sql3`
          UPDATE equipment_bookings
          SET 
            total_price = ${stripeAmounts.stripeAmount.toString()},
            service_fee = ${serviceFee.toString()},
            updated_at = NOW()
          WHERE id = ${bookingId}
        `);
      }
    }
    logger.info(`[Stripe Sync] Synced Stripe amounts to ${bookingType} booking(s) for PaymentIntent ${paymentIntentId}`);
  } catch (error) {
    logger.error(`[Stripe Sync] Error syncing Stripe amounts to bookings for ${paymentIntentId}:`, error);
  }
}
async function syncExistingPaymentTransactionsFromStripe(managerId, db2, options) {
  let getStripePaymentAmounts2;
  const importPaths = [
    "./stripe-service",
    // Path 1: Relative without extension (works in some builds)
    "./stripe-service.js",
    // Path 2: Relative with .js extension (standard)
    "../server/services/stripe-service.js"
    // Path 3: From api/ perspective
  ];
  let lastError = null;
  for (const importPath of importPaths) {
    try {
      const mod = await import(importPath);
      if (mod.getStripePaymentAmounts) {
        getStripePaymentAmounts2 = mod.getStripePaymentAmounts;
        break;
      }
    } catch (e) {
      lastError = e;
      continue;
    }
  }
  if (!getStripePaymentAmounts2) {
    logger.error("[Stripe Sync] Failed to import stripe-service from all paths:", importPaths);
    throw new Error(`Cannot import stripe-service from any path. Last error: ${lastError?.message || "Unknown"}`);
  }
  const limit = options?.limit || 1e3;
  const onlyUnsynced = options?.onlyUnsynced !== false;
  try {
    const params = [managerId];
    const unsyncedFilter = onlyUnsynced ? sql3` AND (pt.last_synced_at IS NULL OR pt.metadata->>'stripeFees' IS NULL)` : sql3``;
    const result = await db2.execute(sql3`
      SELECT 
        pt.id,
        pt.payment_intent_id,
        pt.manager_id,
        pt.booking_id,
        pt.booking_type,
        pt.amount as current_amount,
        pt.manager_revenue as current_manager_revenue,
        pt.last_synced_at
      FROM payment_transactions pt
      WHERE pt.payment_intent_id IS NOT NULL
        AND pt.status IN ('succeeded', 'processing')
        AND (
          pt.manager_id = ${managerId} 
          OR EXISTS (
            SELECT 1 FROM kitchen_bookings kb
            JOIN kitchens k ON kb.kitchen_id = k.id
            JOIN locations l ON k.location_id = l.id
            WHERE kb.id = pt.booking_id 
              AND l.manager_id = ${managerId}
          )
        )
      ${unsyncedFilter}
      ORDER BY pt.created_at DESC
      LIMIT ${limit}
    `);
    const transactions = result.rows;
    logger.info(`[Stripe Sync] Found ${transactions.length} payment transactions to sync for manager ${managerId}`);
    let synced = 0;
    let failed = 0;
    const errors = [];
    for (const transaction of transactions) {
      const paymentIntentId = transaction.payment_intent_id;
      if (!paymentIntentId) continue;
      try {
        let managerConnectAccountId;
        try {
          const managerResult = await db2.execute(sql3`
            SELECT stripe_connect_account_id 
            FROM users 
            WHERE id = ${transaction.manager_id || managerId} AND stripe_connect_account_id IS NOT NULL
          `);
          if (managerResult.rows.length > 0) {
            managerConnectAccountId = managerResult.rows[0].stripe_connect_account_id;
          }
        } catch (error) {
          logger.warn(`[Stripe Sync] Could not fetch manager Connect account:`, error);
        }
        const stripeAmounts = await getStripePaymentAmounts2(paymentIntentId, managerConnectAccountId);
        if (!stripeAmounts) {
          logger.warn(`[Stripe Sync] Could not fetch Stripe amounts for ${paymentIntentId}`);
          failed++;
          errors.push({ paymentIntentId, error: "Could not fetch Stripe amounts" });
          continue;
        }
        await updatePaymentTransaction(transaction.id, {
          stripeAmount: stripeAmounts.stripeAmount,
          stripeNetAmount: stripeAmounts.stripeNetAmount,
          stripeProcessingFee: stripeAmounts.stripeProcessingFee,
          stripePlatformFee: stripeAmounts.stripePlatformFee,
          lastSyncedAt: /* @__PURE__ */ new Date()
        }, db2);
        await syncStripeAmountsToBookings(paymentIntentId, stripeAmounts, db2);
        synced++;
        logger.info(`[Stripe Sync] Synced transaction ${transaction.id} (PaymentIntent: ${paymentIntentId})`);
      } catch (error) {
        logger.error(`[Stripe Sync] Error syncing transaction ${transaction.id} (${paymentIntentId}):`, error);
        failed++;
        errors.push({ paymentIntentId, error: error.message || "Unknown error" });
      }
    }
    logger.info(`[Stripe Sync] Completed: ${synced} synced, ${failed} failed`);
    return { synced, failed, errors };
  } catch (error) {
    logger.error(`[Stripe Sync] Error syncing existing transactions:`, error);
    throw error;
  }
}
async function findPaymentTransactionByIntentId(paymentIntentId, db2) {
  const result = await db2.execute(sql3`
    SELECT * FROM payment_transactions
    WHERE payment_intent_id = ${paymentIntentId}
    LIMIT 1
  `);
  return result.rows[0];
}
async function findPaymentTransactionById(transactionId, db2) {
  const result = await db2.execute(sql3`
    SELECT * FROM payment_transactions
    WHERE id = ${transactionId}
    LIMIT 1
  `);
  return result.rows[0];
}
async function findPaymentTransactionByBooking(bookingId, bookingType, db2) {
  const result = await db2.execute(sql3`
    SELECT * FROM payment_transactions
    WHERE booking_id = ${bookingId} AND booking_type = ${bookingType}
    ORDER BY created_at DESC
    LIMIT 1
  `);
  return result.rows[0];
}
async function findPaymentTransactionByMetadata(metadataKey, metadataValue, db2) {
  const result = await db2.execute(sql3`
    SELECT * FROM payment_transactions
    WHERE metadata->>${metadataKey} = ${metadataValue}
    ORDER BY created_at DESC
    LIMIT 1
  `);
  return result.rows[0];
}
async function addPaymentHistory(transactionId, history, db2) {
  await db2.execute(sql3`
    INSERT INTO payment_history (
      transaction_id,
      previous_status,
      new_status,
      event_type,
      event_source,
      stripe_event_id,
      description,
      metadata,
      created_by
    ) VALUES (
      ${transactionId},
      ${history.previousStatus},
      ${history.newStatus},
      ${history.eventType},
      ${history.eventSource || "system"},
      ${history.stripeEventId || null},
      ${history.description || null},
      ${JSON.stringify(history.metadata || {})},
      ${history.createdBy || null}
    )
  `);
}
async function getPaymentHistory(transactionId, db2) {
  const result = await db2.execute(sql3`
    SELECT * FROM payment_history
    WHERE transaction_id = ${transactionId}
    ORDER BY created_at ASC
  `);
  return result.rows;
}
async function getManagerPaymentTransactions(managerId, db2, filters) {
  const whereConditions = [sql3`manager_id = ${managerId}`];
  if (filters?.status) {
    whereConditions.push(sql3`status = ${filters.status}`);
  }
  if (filters?.startDate) {
    whereConditions.push(sql3`
      (
        (status = 'succeeded' AND paid_at IS NOT NULL AND paid_at >= ${filters.startDate})
        OR (status != 'succeeded' AND created_at >= ${filters.startDate})
      )
    `);
  }
  if (filters?.endDate) {
    whereConditions.push(sql3`
      (
        (status = 'succeeded' AND paid_at IS NOT NULL AND paid_at <= ${filters.endDate})
        OR (status != 'succeeded' AND created_at <= ${filters.endDate})
      )
    `);
  }
  const whereClause = sql3`WHERE ${sql3.join(whereConditions, sql3` AND `)}`;
  const countResult = await db2.execute(sql3`
    SELECT COUNT(*) as total FROM payment_transactions ${whereClause}
  `);
  const total = parseInt(countResult.rows[0].total);
  const limit = filters?.limit || 50;
  const offset = filters?.offset || 0;
  const result = await db2.execute(sql3`
    SELECT * FROM payment_transactions
    ${whereClause}
    ORDER BY 
      CASE 
        WHEN status = 'succeeded' AND paid_at IS NOT NULL 
        THEN paid_at 
        ELSE created_at 
      END DESC
    LIMIT ${limit} OFFSET ${offset}
  `);
  return {
    transactions: result.rows,
    total
  };
}
async function getChefPaymentTransactions(chefId, db2, filters) {
  const whereConditions = [sql3`pt.chef_id = ${chefId}`];
  if (filters?.status) {
    whereConditions.push(sql3`pt.status = ${filters.status}`);
  }
  if (filters?.bookingType) {
    whereConditions.push(sql3`pt.booking_type = ${filters.bookingType}`);
  }
  if (filters?.startDate) {
    whereConditions.push(sql3`
      (
        (pt.status = 'succeeded' AND pt.paid_at IS NOT NULL AND pt.paid_at >= ${filters.startDate})
        OR (pt.status != 'succeeded' AND pt.created_at >= ${filters.startDate})
      )
    `);
  }
  if (filters?.endDate) {
    whereConditions.push(sql3`
      (
        (pt.status = 'succeeded' AND pt.paid_at IS NOT NULL AND pt.paid_at <= ${filters.endDate})
        OR (pt.status != 'succeeded' AND pt.created_at <= ${filters.endDate})
      )
    `);
  }
  const whereClause = sql3`WHERE ${sql3.join(whereConditions, sql3` AND `)}`;
  const countResult = await db2.execute(sql3`
    SELECT COUNT(*) as total FROM payment_transactions pt ${whereClause}
  `);
  const total = parseInt(countResult.rows[0].total);
  const limit = filters?.limit || 50;
  const offset = filters?.offset || 0;
  const result = await db2.execute(sql3`
    SELECT 
      pt.*,
      CASE 
        WHEN pt.booking_type = 'kitchen' THEN kb.start_time::text
        WHEN pt.booking_type = 'storage' THEN sb.start_date::text
        ELSE NULL
      END as booking_start,
      CASE 
        WHEN pt.booking_type = 'kitchen' THEN kb.end_time::text
        WHEN pt.booking_type = 'storage' THEN sb.end_date::text
        ELSE NULL
      END as booking_end,
      CASE 
        WHEN pt.booking_type = 'kitchen' THEN k.name
        WHEN pt.booking_type = 'storage' THEN sl.name
        ELSE NULL
      END as item_name,
      l.name as location_name,
      CASE 
        WHEN pt.booking_type = 'kitchen' THEN kb.reference_code
        WHEN pt.booking_type = 'storage' THEN sb.reference_code
        ELSE NULL
      END as reference_code
    FROM payment_transactions pt
    LEFT JOIN kitchen_bookings kb ON pt.booking_type = 'kitchen' AND pt.booking_id = kb.id
    LEFT JOIN kitchens k ON kb.kitchen_id = k.id
    LEFT JOIN storage_bookings sb ON pt.booking_type = 'storage' AND pt.booking_id = sb.id
    LEFT JOIN storage_listings sl ON sb.storage_listing_id = sl.id
    LEFT JOIN kitchens sk ON sl.kitchen_id = sk.id
    LEFT JOIN locations l ON (
      (pt.booking_type = 'kitchen' AND k.location_id = l.id) OR
      (pt.booking_type = 'storage' AND sk.location_id = l.id)
    )
    ${whereClause}
    ORDER BY 
      CASE 
        WHEN pt.status = 'succeeded' AND pt.paid_at IS NOT NULL 
        THEN pt.paid_at 
        ELSE pt.created_at 
      END DESC
    LIMIT ${limit} OFFSET ${offset}
  `);
  return {
    transactions: result.rows,
    total
  };
}
async function syncStripeFees(db2, managerId, limit = 100) {
  const Stripe7 = (await import("stripe")).default;
  const stripeSecretKey6 = process.env.STRIPE_SECRET_KEY;
  if (!stripeSecretKey6) {
    throw new Error("STRIPE_SECRET_KEY not configured");
  }
  const stripe6 = new Stripe7(stripeSecretKey6, {
    apiVersion: "2025-12-15.clover"
  });
  const whereConditions = [
    sql3`payment_intent_id IS NOT NULL`,
    sql3`(stripe_processing_fee IS NULL OR stripe_processing_fee = '0')`,
    sql3`status IN ('succeeded', 'partially_refunded')`
  ];
  if (managerId) {
    whereConditions.push(sql3`manager_id = ${managerId}`);
  }
  const whereClause = sql3`WHERE ${sql3.join(whereConditions, sql3` AND `)}`;
  const result = await db2.execute(sql3`
    SELECT id, payment_intent_id, amount, manager_id
    FROM payment_transactions
    ${whereClause}
    ORDER BY created_at DESC
    LIMIT ${limit}
  `);
  let synced = 0;
  let failed = 0;
  const errors = [];
  for (const row of result.rows) {
    const transactionId = row.id;
    const paymentIntentId = row.payment_intent_id;
    try {
      const paymentIntent = await stripe6.paymentIntents.retrieve(paymentIntentId, {
        expand: ["latest_charge"]
      });
      if (!paymentIntent.latest_charge) {
        errors.push(`Transaction ${transactionId}: No charge found for PaymentIntent ${paymentIntentId}`);
        failed++;
        continue;
      }
      const charge = typeof paymentIntent.latest_charge === "string" ? await stripe6.charges.retrieve(paymentIntent.latest_charge) : paymentIntent.latest_charge;
      if (!charge.balance_transaction) {
        errors.push(`Transaction ${transactionId}: No balance_transaction for charge ${charge.id}`);
        failed++;
        continue;
      }
      const balanceTransactionId = typeof charge.balance_transaction === "string" ? charge.balance_transaction : charge.balance_transaction.id;
      const balanceTransaction = await stripe6.balanceTransactions.retrieve(balanceTransactionId);
      const stripeProcessingFee = balanceTransaction.fee;
      const stripeAmount = paymentIntent.amount;
      const stripePlatformFee = paymentIntent.application_fee_amount || 0;
      const stripeNetAmount = stripePlatformFee > 0 ? stripeAmount - stripePlatformFee : stripeAmount - stripeProcessingFee;
      await updatePaymentTransaction(
        transactionId,
        {
          stripeAmount,
          stripeNetAmount,
          stripeProcessingFee,
          stripePlatformFee,
          lastSyncedAt: /* @__PURE__ */ new Date()
        },
        db2
      );
      logger.info(`[Stripe Sync] \u2705 Synced transaction ${transactionId}: fee=${stripeProcessingFee} cents`);
      synced++;
      await new Promise((resolve) => setTimeout(resolve, 100));
    } catch (error) {
      errors.push(`Transaction ${transactionId}: ${error.message}`);
      failed++;
    }
  }
  return { synced, failed, errors };
}
async function getAdminPaymentTransactions(db2, filters) {
  const whereConditions = [];
  if (filters?.status) {
    whereConditions.push(sql3`pt.status = ${filters.status}`);
  }
  if (filters?.bookingType) {
    whereConditions.push(sql3`pt.booking_type = ${filters.bookingType}`);
  }
  if (filters?.locationId) {
    whereConditions.push(sql3`(
      (pt.booking_type = 'kitchen' AND k.location_id = ${filters.locationId}) OR
      (pt.booking_type = 'storage' AND sk.location_id = ${filters.locationId}) OR
      (pt.booking_type = 'equipment' AND ek.location_id = ${filters.locationId})
    )`);
  }
  if (filters?.kitchenId) {
    whereConditions.push(sql3`(
      (pt.booking_type = 'kitchen' AND kb.kitchen_id = ${filters.kitchenId}) OR
      (pt.booking_type = 'storage' AND sl.kitchen_id = ${filters.kitchenId}) OR
      (pt.booking_type = 'equipment' AND el.kitchen_id = ${filters.kitchenId})
    )`);
  }
  if (filters?.chefId) {
    whereConditions.push(sql3`pt.chef_id = ${filters.chefId}`);
  }
  if (filters?.managerId) {
    whereConditions.push(sql3`pt.manager_id = ${filters.managerId}`);
  }
  if (filters?.startDate) {
    whereConditions.push(sql3`pt.created_at >= ${filters.startDate}`);
  }
  if (filters?.endDate) {
    whereConditions.push(sql3`pt.created_at <= ${filters.endDate}`);
  }
  if (filters?.search) {
    const searchTerm = filters.search.trim();
    const numericSearch = parseInt(searchTerm);
    const isNumeric = !isNaN(numericSearch);
    whereConditions.push(sql3`(
      pt.payment_intent_id ILIKE ${"%" + searchTerm + "%"}
      OR pt.charge_id ILIKE ${"%" + searchTerm + "%"}
      OR pt.refund_id ILIKE ${"%" + searchTerm + "%"}
      OR pt.payment_method_id ILIKE ${"%" + searchTerm + "%"}
      OR pt.webhook_event_id ILIKE ${"%" + searchTerm + "%"}
      OR pt.stripe_status ILIKE ${"%" + searchTerm + "%"}
      OR pt.refund_reason ILIKE ${"%" + searchTerm + "%"}
      OR pt.failure_reason ILIKE ${"%" + searchTerm + "%"}
      OR chef_user.username ILIKE ${"%" + searchTerm + "%"}
      OR COALESCE(cka.full_name, '') ILIKE ${"%" + searchTerm + "%"}
      OR l.name ILIKE ${"%" + searchTerm + "%"}
      OR k.name ILIKE ${"%" + searchTerm + "%"}
      OR CAST(pt.id AS TEXT) = ${searchTerm}
      OR CAST(pt.booking_id AS TEXT) = ${searchTerm}
      ${isNumeric ? sql3`OR pt.chef_id = ${numericSearch} OR pt.manager_id = ${numericSearch}` : sql3``}
    )`);
  }
  const whereClause = whereConditions.length > 0 ? sql3`WHERE ${sql3.join(whereConditions, sql3` AND `)}` : sql3``;
  const countResult = await db2.execute(sql3`
    SELECT COUNT(*) as total 
    FROM payment_transactions pt
    LEFT JOIN kitchen_bookings kb ON pt.booking_type = 'kitchen' AND pt.booking_id = kb.id
    LEFT JOIN kitchens k ON kb.kitchen_id = k.id
    LEFT JOIN storage_bookings sb ON pt.booking_type = 'storage' AND pt.booking_id = sb.id
    LEFT JOIN storage_listings sl ON sb.storage_listing_id = sl.id
    LEFT JOIN kitchens sk ON sl.kitchen_id = sk.id
    LEFT JOIN equipment_bookings eb ON pt.booking_type = 'equipment' AND pt.booking_id = eb.id
    LEFT JOIN equipment_listings el ON eb.equipment_listing_id = el.id
    LEFT JOIN kitchens ek ON el.kitchen_id = ek.id
    LEFT JOIN locations l ON (
      (pt.booking_type = 'kitchen' AND k.location_id = l.id) OR
      (pt.booking_type = 'storage' AND sk.location_id = l.id) OR
      (pt.booking_type = 'equipment' AND ek.location_id = l.id)
    )
    LEFT JOIN users chef_user ON pt.chef_id = chef_user.id
    LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = pt.chef_id AND cka.location_id = l.id
    ${whereClause}
  `);
  const total = parseInt(countResult.rows[0].total);
  const limit = filters?.limit || 50;
  const offset = filters?.offset || 0;
  const result = await db2.execute(sql3`
    SELECT 
      pt.id,
      pt.booking_id,
      pt.booking_type,
      pt.chef_id,
      pt.manager_id,
      pt.amount,
      pt.base_amount,
      pt.service_fee,
      pt.stripe_processing_fee,
      pt.manager_revenue,
      pt.refund_amount,
      pt.net_amount,
      pt.currency,
      pt.payment_intent_id,
      pt.charge_id,
      pt.refund_id,
      pt.payment_method_id,
      pt.status,
      pt.stripe_status,
      pt.metadata,
      pt.refund_reason,
      pt.failure_reason,
      pt.webhook_event_id,
      pt.last_synced_at,
      pt.created_at,
      pt.updated_at,
      pt.paid_at,
      pt.refunded_at,
      chef_user.username as chef_email,
      COALESCE(cka.full_name, split_part(chef_user.username, ${"@"}, 1)) as chef_name,
      chef_user.stripe_customer_id as stripe_customer_id,
      manager_user.username as manager_email,
      l.id as location_id,
      l.name as location_name,
      COALESCE(k.id, sk.id, ek.id) as kitchen_id,
      COALESCE(k.name, sk.name, ek.name) as kitchen_name,
      CASE 
        WHEN pt.booking_type = 'kitchen' THEN kb.start_time::text
        WHEN pt.booking_type = 'storage' THEN sb.start_date::text
        ELSE NULL
      END as booking_start,
      CASE 
        WHEN pt.booking_type = 'kitchen' THEN kb.end_time::text
        WHEN pt.booking_type = 'storage' THEN sb.end_date::text
        ELSE NULL
      END as booking_end,
      CASE 
        WHEN pt.booking_type = 'kitchen' THEN kb.status::text
        WHEN pt.booking_type = 'storage' THEN sb.status::text
        WHEN pt.booking_type = 'equipment' THEN eb.status::text
        ELSE NULL
      END as booking_status,
      CASE 
        WHEN pt.booking_type = 'kitchen' THEN kb.payment_status::text
        WHEN pt.booking_type = 'storage' THEN sb.payment_status::text
        WHEN pt.booking_type = 'equipment' THEN eb.payment_status::text
        ELSE NULL
      END as booking_payment_status,
      CASE 
        WHEN pt.booking_type = 'kitchen' THEN k.name
        WHEN pt.booking_type = 'storage' THEN sl.name
        ELSE NULL
      END as item_name
    FROM payment_transactions pt
    LEFT JOIN kitchen_bookings kb ON pt.booking_type = 'kitchen' AND pt.booking_id = kb.id
    LEFT JOIN kitchens k ON kb.kitchen_id = k.id
    LEFT JOIN storage_bookings sb ON pt.booking_type = 'storage' AND pt.booking_id = sb.id
    LEFT JOIN storage_listings sl ON sb.storage_listing_id = sl.id
    LEFT JOIN kitchens sk ON sl.kitchen_id = sk.id
    LEFT JOIN equipment_bookings eb ON pt.booking_type = 'equipment' AND pt.booking_id = eb.id
    LEFT JOIN equipment_listings el2 ON eb.equipment_listing_id = el2.id
    LEFT JOIN kitchens ek ON el2.kitchen_id = ek.id
    LEFT JOIN locations l ON (
      (pt.booking_type = 'kitchen' AND k.location_id = l.id) OR
      (pt.booking_type = 'storage' AND sk.location_id = l.id) OR
      (pt.booking_type = 'equipment' AND ek.location_id = l.id)
    )
    LEFT JOIN users chef_user ON pt.chef_id = chef_user.id
    LEFT JOIN users manager_user ON pt.manager_id = manager_user.id
    LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = pt.chef_id AND cka.location_id = l.id
    ${whereClause}
    ORDER BY pt.created_at DESC
    LIMIT ${limit} OFFSET ${offset}
  `);
  return {
    transactions: result.rows,
    total
  };
}
var init_payment_transactions_service = __esm({
  "server/services/payment-transactions-service.ts"() {
    "use strict";
    init_logger();
  }
});

// server/services/stripe-service.ts
var stripe_service_exports = {};
__export(stripe_service_exports, {
  calculateRefundBreakdown: () => calculateRefundBreakdown,
  cancelPaymentIntent: () => cancelPaymentIntent,
  capturePaymentIntent: () => capturePaymentIntent,
  confirmPaymentIntent: () => confirmPaymentIntent,
  createPaymentIntent: () => createPaymentIntent,
  createRefund: () => createRefund,
  getPaymentIntent: () => getPaymentIntent,
  getStripePaymentAmounts: () => getStripePaymentAmounts,
  reverseTransferAndRefund: () => reverseTransferAndRefund,
  verifyPaymentIntentForBooking: () => verifyPaymentIntentForBooking
});
import Stripe from "stripe";
async function createPaymentIntent(params) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  const {
    amount,
    currency = "cad",
    chefId,
    kitchenId,
    metadata = {},
    statementDescriptor = "LOCALCOOKS",
    managerConnectAccountId,
    applicationFeeAmount,
    enableACSS = true,
    // Default to true for ACSS debit support
    enableCards = true,
    // Default to true for standard card payments
    useAuthorizationHold = true,
    // DEPRECATED: No longer used - always uses automatic capture
    saveCardForFuture = true,
    // Default to true to save cards for future use
    customerId
  } = params;
  if (amount <= 0) {
    throw new Error("Payment amount must be greater than 0");
  }
  const hasApplicationFee = applicationFeeAmount !== void 0 && applicationFeeAmount !== null;
  if (hasApplicationFee && !managerConnectAccountId) {
    throw new Error("managerConnectAccountId is required when applicationFeeAmount is provided");
  }
  if (managerConnectAccountId && !hasApplicationFee) {
  }
  if (hasApplicationFee && applicationFeeAmount < 0) {
    throw new Error("Application fee must be 0 or a positive amount");
  }
  if (hasApplicationFee && applicationFeeAmount >= amount) {
    throw new Error("Application fee must be less than total amount");
  }
  if (!enableACSS && !enableCards) {
    throw new Error("At least one payment method must be enabled");
  }
  const cleanDescriptor = statementDescriptor.replace(/[<>'"]/g, "").substring(0, 15).toUpperCase();
  try {
    const paymentMethodTypes = [];
    if (enableCards) {
      paymentMethodTypes.push("card");
    }
    if (enableACSS) {
      paymentMethodTypes.push("acss_debit");
    }
    const paymentIntentParams = {
      amount,
      currency,
      payment_method_types: paymentMethodTypes,
      // Don't auto-confirm - we'll confirm after collecting payment method
      confirm: false,
      // Use automatic capture: payments are immediately processed when confirmed
      capture_method: "automatic",
      metadata: {
        booking_type: "kitchen",
        kitchen_id: kitchenId.toString(),
        chef_id: chefId.toString(),
        expected_amount: amount.toString(),
        // Store expected amount for verification
        ...metadata
      }
    };
    if (enableCards) {
      paymentIntentParams.statement_descriptor_suffix = cleanDescriptor.substring(0, 22);
    } else if (enableACSS) {
      paymentIntentParams.statement_descriptor = cleanDescriptor;
    }
    paymentIntentParams.payment_method_options = {};
    if (enableACSS) {
      paymentIntentParams.payment_method_options.acss_debit = {
        mandate_options: {
          payment_schedule: "combined",
          // Creates a mandate for future debits
          transaction_type: "personal",
          // Default to personal, can be made configurable
          interval_description: "Payment for kitchen booking and future bookings as authorized"
          // Required for 'combined' or 'interval' payment schedules
        }
      };
    }
    if (saveCardForFuture && enableCards) {
      paymentIntentParams.setup_future_usage = "off_session";
    }
    if (customerId) {
      paymentIntentParams.customer = customerId;
    }
    if (managerConnectAccountId) {
      paymentIntentParams.transfer_data = {
        destination: managerConnectAccountId
      };
      paymentIntentParams.metadata.manager_connect_account_id = managerConnectAccountId;
      if (hasApplicationFee) {
        paymentIntentParams.application_fee_amount = applicationFeeAmount;
        paymentIntentParams.metadata.platform_fee = applicationFeeAmount.toString();
      }
    }
    const paymentIntent = await stripe.paymentIntents.create(paymentIntentParams);
    return {
      id: paymentIntent.id,
      clientSecret: paymentIntent.client_secret,
      status: paymentIntent.status,
      amount: paymentIntent.amount
    };
  } catch (error) {
    logger.error("Error creating PaymentIntent:", error);
    throw new Error(`Failed to create payment intent: ${error.message}`);
  }
}
async function confirmPaymentIntent(paymentIntentId, paymentMethodId) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const paymentIntent = await stripe.paymentIntents.confirm(paymentIntentId, {
      payment_method: paymentMethodId
    });
    return {
      id: paymentIntent.id,
      clientSecret: paymentIntent.client_secret || "",
      status: paymentIntent.status,
      amount: paymentIntent.amount
    };
  } catch (error) {
    logger.error("Error confirming PaymentIntent:", error);
    throw new Error(`Failed to confirm payment intent: ${error.message}`);
  }
}
async function getPaymentIntent(paymentIntentId) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    return {
      id: paymentIntent.id,
      clientSecret: paymentIntent.client_secret || "",
      status: paymentIntent.status,
      amount: paymentIntent.amount
    };
  } catch (error) {
    if (error.code === "resource_missing") {
      return null;
    }
    logger.error("Error retrieving PaymentIntent:", error);
    throw new Error(`Failed to retrieve payment intent: ${error.message}`);
  }
}
async function getStripePaymentAmounts(paymentIntentId, managerConnectAccountId) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId, {
      expand: ["latest_charge"]
    });
    if (!paymentIntent.latest_charge) {
      logger.warn(`[Stripe] No charge found for PaymentIntent ${paymentIntentId}`);
      return null;
    }
    const chargeId = typeof paymentIntent.latest_charge === "string" ? paymentIntent.latest_charge : paymentIntent.latest_charge.id;
    const charge = typeof paymentIntent.latest_charge === "string" ? await stripe.charges.retrieve(paymentIntent.latest_charge) : paymentIntent.latest_charge;
    let balanceTransaction = null;
    if (charge.balance_transaction) {
      const balanceTransactionId = typeof charge.balance_transaction === "string" ? charge.balance_transaction : charge.balance_transaction.id;
      balanceTransaction = await stripe.balanceTransactions.retrieve(balanceTransactionId);
    }
    const stripeAmount = charge.amount_captured && charge.amount_captured > 0 ? charge.amount_captured : charge.amount;
    let stripeNetAmount = stripeAmount;
    let stripeProcessingFee = 0;
    let stripePlatformFee = 0;
    if (balanceTransaction) {
      stripeProcessingFee = balanceTransaction.fee;
      if (managerConnectAccountId && paymentIntent.application_fee_amount) {
        stripePlatformFee = paymentIntent.application_fee_amount;
        stripeNetAmount = stripeAmount - stripePlatformFee;
      } else {
        stripeNetAmount = stripeAmount - stripeProcessingFee;
      }
    } else {
      logger.info(`[Stripe] balance_transaction not immediately available for ${paymentIntentId}, retrying in 2s...`);
      await new Promise((resolve) => setTimeout(resolve, 2e3));
      const retryCharge = await stripe.charges.retrieve(chargeId);
      if (retryCharge.balance_transaction) {
        const retryBalanceTransactionId = typeof retryCharge.balance_transaction === "string" ? retryCharge.balance_transaction : retryCharge.balance_transaction.id;
        const retryBalanceTransaction = await stripe.balanceTransactions.retrieve(retryBalanceTransactionId);
        stripeProcessingFee = retryBalanceTransaction.fee;
        if (managerConnectAccountId && paymentIntent.application_fee_amount) {
          stripePlatformFee = paymentIntent.application_fee_amount;
          stripeNetAmount = stripeAmount - stripePlatformFee;
        } else {
          stripeNetAmount = stripeAmount - stripeProcessingFee;
        }
        logger.info(`[Stripe] \u2705 Retry successful - got actual fee: ${stripeProcessingFee} cents`);
      } else {
        logger.info(`[Stripe] balance_transaction still not available for ${paymentIntentId} - charge.updated webhook will sync fees`);
        stripeProcessingFee = 0;
        if (managerConnectAccountId && paymentIntent.application_fee_amount) {
          stripePlatformFee = paymentIntent.application_fee_amount;
          stripeNetAmount = stripeAmount - stripePlatformFee;
        }
      }
    }
    return {
      stripeAmount,
      stripeNetAmount,
      stripeProcessingFee,
      stripePlatformFee,
      chargeId
    };
  } catch (error) {
    logger.error(`[Stripe] Error fetching payment amounts for ${paymentIntentId}:`, error);
    return null;
  }
}
async function capturePaymentIntent(paymentIntentId, amountToCapture, applicationFeeAmount) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const captureParams = {};
    if (amountToCapture !== void 0) {
      captureParams.amount_to_capture = amountToCapture;
    }
    if (applicationFeeAmount !== void 0) {
      captureParams.application_fee_amount = applicationFeeAmount;
    }
    const paymentIntent = await stripe.paymentIntents.capture(paymentIntentId, captureParams);
    return {
      id: paymentIntent.id,
      clientSecret: paymentIntent.client_secret || "",
      status: paymentIntent.status,
      amount: paymentIntent.amount
    };
  } catch (error) {
    logger.error("Error capturing PaymentIntent:", error);
    throw new Error(`Failed to capture payment intent: ${error.message}`);
  }
}
async function cancelPaymentIntent(paymentIntentId) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const paymentIntent = await stripe.paymentIntents.cancel(paymentIntentId);
    return {
      id: paymentIntent.id,
      clientSecret: paymentIntent.client_secret || "",
      status: paymentIntent.status,
      amount: paymentIntent.amount
    };
  } catch (error) {
    logger.error("Error canceling PaymentIntent:", error);
    throw new Error(`Failed to cancel payment intent: ${error.message}`);
  }
}
async function createRefund(paymentIntentId, amount, reason = "requested_by_customer", options) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    if (!paymentIntent.latest_charge) {
      throw new Error("Payment intent has no charge to refund");
    }
    const chargeId = typeof paymentIntent.latest_charge === "string" ? paymentIntent.latest_charge : paymentIntent.latest_charge.id;
    const refundParams = {
      charge: chargeId,
      reason
    };
    if (amount !== void 0 && amount > 0) {
      refundParams.amount = amount;
    }
    if (options?.reverseTransfer !== void 0) {
      refundParams.reverse_transfer = options.reverseTransfer;
    }
    if (options?.refundApplicationFee !== void 0) {
      refundParams.refund_application_fee = options.refundApplicationFee;
    }
    if (options?.metadata) {
      refundParams.metadata = options.metadata;
    }
    const refund = await stripe.refunds.create(refundParams);
    if (!refund.charge || typeof refund.charge !== "string") {
      throw new Error("Refund created but charge ID is missing");
    }
    if (!refund.status || typeof refund.status !== "string") {
      throw new Error("Refund created but status is missing");
    }
    const refundChargeId = refund.charge;
    const refundStatus = refund.status;
    return {
      id: refund.id,
      amount: refund.amount,
      status: refundStatus,
      charge: refundChargeId
    };
  } catch (error) {
    logger.error("Error creating refund:", error);
    throw new Error(`Failed to create refund: ${error.message}`);
  }
}
function calculateRefundBreakdown(totalChargedCents, managerReceivedCents, alreadyRefundedCents, stripeProcessingFeeCents) {
  const managerRemainingBalance = Math.max(0, managerReceivedCents - alreadyRefundedCents);
  const maxRefundable = managerRemainingBalance;
  return {
    maxRefundableToCustomer: maxRefundable,
    maxDeductibleFromManager: maxRefundable,
    // Same value - no discrepancy!
    remainingManagerBalance: managerRemainingBalance,
    originalStripeFee: stripeProcessingFeeCents,
    explanation: managerRemainingBalance > 0 ? `Available to refund from this transaction: $${(maxRefundable / 100).toFixed(2)}` : "No remaining balance to refund"
  };
}
async function reverseTransferAndRefund(paymentIntentId, amount, reason = "requested_by_customer", options) {
  if (!stripe) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  if (!amount || amount <= 0) {
    throw new Error("Refund amount must be greater than 0");
  }
  try {
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId, {
      expand: ["latest_charge"]
    });
    if (!paymentIntent.latest_charge) {
      throw new Error("Payment intent has no charge to refund");
    }
    const charge = typeof paymentIntent.latest_charge === "string" ? await stripe.charges.retrieve(paymentIntent.latest_charge) : paymentIntent.latest_charge;
    const chargeId = charge.id;
    const transferId = typeof charge.transfer === "string" ? charge.transfer : charge.transfer?.id;
    if (!transferId) {
      throw new Error("No transfer found for this charge to reverse");
    }
    const reversalAmount = options?.reverseTransferAmount ?? amount;
    if (reversalAmount <= 0) {
      throw new Error("Transfer reversal amount must be greater than 0");
    }
    const reversal = await stripe.transfers.createReversal(transferId, {
      amount: reversalAmount,
      metadata: options?.transferMetadata || options?.metadata
    });
    const refundParams = {
      charge: chargeId,
      reason,
      amount
    };
    if (options?.refundApplicationFee !== void 0) {
      refundParams.refund_application_fee = options.refundApplicationFee;
    }
    if (options?.metadata) {
      refundParams.metadata = options.metadata;
    }
    const refund = await stripe.refunds.create(refundParams);
    if (!refund.charge || typeof refund.charge !== "string") {
      throw new Error("Refund created but charge ID is missing");
    }
    if (!refund.status || typeof refund.status !== "string") {
      throw new Error("Refund created but status is missing");
    }
    return {
      refundId: refund.id,
      refundAmount: refund.amount,
      refundStatus: refund.status,
      chargeId,
      transferReversalId: reversal.id
    };
  } catch (error) {
    logger.error("Error reversing transfer and refunding:", error);
    throw new Error(`Failed to reverse transfer and refund: ${error.message}`);
  }
}
async function verifyPaymentIntentForBooking(paymentIntentId, chefId, expectedAmount) {
  try {
    if (!stripe) {
      return { valid: false, status: "error", error: "Stripe is not configured" };
    }
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    if (!paymentIntent) {
      return { valid: false, status: "not_found", error: "Payment intent not found" };
    }
    if (paymentIntent.metadata?.chef_id !== chefId.toString()) {
      return { valid: false, status: paymentIntent.status, error: "Payment intent does not belong to this chef" };
    }
    const storedExpectedAmount = paymentIntent.metadata?.expected_amount ? parseInt(paymentIntent.metadata.expected_amount) : null;
    const amountToCompare = storedExpectedAmount !== null ? storedExpectedAmount : expectedAmount;
    const amountDifference = Math.abs(paymentIntent.amount - amountToCompare);
    if (amountDifference > 5) {
      logger.error("Payment amount mismatch:", {
        paymentIntentAmount: paymentIntent.amount,
        expectedAmount: amountToCompare,
        storedExpectedAmount,
        calculatedExpectedAmount: expectedAmount,
        difference: amountDifference,
        differenceDollars: (amountDifference / 100).toFixed(2)
      });
      return { valid: false, status: paymentIntent.status, error: "Payment amount does not match booking amount" };
    }
    const validStatuses = ["succeeded", "processing"];
    if (!validStatuses.includes(paymentIntent.status)) {
      return {
        valid: false,
        status: paymentIntent.status,
        error: `Payment is not in a valid state: ${paymentIntent.status}`
      };
    }
    return { valid: true, status: paymentIntent.status };
  } catch (error) {
    logger.error("Error verifying PaymentIntent:", error);
    if (error.code === "resource_missing") {
      return { valid: false, status: "not_found", error: "Payment intent not found" };
    }
    return { valid: false, status: "error", error: error.message };
  }
}
var stripeSecretKey, stripe;
var init_stripe_service = __esm({
  "server/services/stripe-service.ts"() {
    "use strict";
    init_logger();
    stripeSecretKey = process.env.STRIPE_SECRET_KEY;
    if (!stripeSecretKey) {
      logger.warn("\u26A0\uFE0F STRIPE_SECRET_KEY not found in environment variables");
    }
    stripe = stripeSecretKey ? new Stripe(stripeSecretKey, {
      apiVersion: "2025-12-15.clover"
    }) : null;
  }
});

// server/email.ts
var email_exports = {};
__export(email_exports, {
  generateApplicationWithDocumentsEmail: () => generateApplicationWithDocumentsEmail,
  generateApplicationWithoutDocumentsEmail: () => generateApplicationWithoutDocumentsEmail,
  generateBookingCancellationEmail: () => generateBookingCancellationEmail,
  generateBookingCancellationNotificationEmail: () => generateBookingCancellationNotificationEmail,
  generateBookingConfirmationEmail: () => generateBookingConfirmationEmail,
  generateBookingNotificationEmail: () => generateBookingNotificationEmail,
  generateBookingPaymentReceivedEmail: () => generateBookingPaymentReceivedEmail,
  generateBookingRequestEmail: () => generateBookingRequestEmail,
  generateBookingStatusChangeNotificationEmail: () => generateBookingStatusChangeNotificationEmail,
  generateChefAllDocumentsApprovedEmail: () => generateChefAllDocumentsApprovedEmail,
  generateChefKitchenAccessApprovedEmail: () => generateChefKitchenAccessApprovedEmail,
  generateChefLocationAccessApprovedEmail: () => generateChefLocationAccessApprovedEmail,
  generateChefProfileRequestEmail: () => generateChefProfileRequestEmail,
  generateDamageClaimChargedEmail: () => generateDamageClaimChargedEmail,
  generateDamageClaimDecisionEmail: () => generateDamageClaimDecisionEmail,
  generateDamageClaimDisputedAdminEmail: () => generateDamageClaimDisputedAdminEmail,
  generateDamageClaimFiledEmail: () => generateDamageClaimFiledEmail,
  generateDamageClaimResponseEmail: () => generateDamageClaimResponseEmail,
  generateDocumentStatusChangeEmail: () => generateDocumentStatusChangeEmail,
  generateDocumentUpdateEmail: () => generateDocumentUpdateEmail,
  generateEmailVerificationEmail: () => generateEmailVerificationEmail,
  generateFullVerificationEmail: () => generateFullVerificationEmail,
  generateKitchenApplicationApprovedEmail: () => generateKitchenApplicationApprovedEmail,
  generateKitchenApplicationRejectedEmail: () => generateKitchenApplicationRejectedEmail,
  generateKitchenApplicationSubmittedChefEmail: () => generateKitchenApplicationSubmittedChefEmail,
  generateKitchenAvailabilityChangeEmail: () => generateKitchenAvailabilityChangeEmail,
  generateKitchenLicenseApprovedEmail: () => generateKitchenLicenseApprovedEmail,
  generateKitchenLicenseRejectedEmail: () => generateKitchenLicenseRejectedEmail,
  generateKitchenLicenseSubmittedAdminEmail: () => generateKitchenLicenseSubmittedAdminEmail,
  generateKitchenSettingsChangeEmail: () => generateKitchenSettingsChangeEmail,
  generateLocationEmailChangedEmail: () => generateLocationEmailChangedEmail,
  generateManagerCredentialsEmail: () => generateManagerCredentialsEmail,
  generateManagerMagicLinkEmail: () => generateManagerMagicLinkEmail,
  generateNewKitchenApplicationManagerEmail: () => generateNewKitchenApplicationManagerEmail,
  generateNewUserRegistrationAdminEmail: () => generateNewUserRegistrationAdminEmail,
  generateOverstayDetectedEmail: () => generateOverstayDetectedEmail,
  generateOverstayManagerNotificationEmail: () => generateOverstayManagerNotificationEmail,
  generatePasswordResetEmail: () => generatePasswordResetEmail,
  generatePenaltyChargedEmail: () => generatePenaltyChargedEmail,
  generatePromoCodeEmail: () => generatePromoCodeEmail,
  generateStatusChangeEmail: () => generateStatusChangeEmail,
  generateStorageExpiringWarningEmail: () => generateStorageExpiringWarningEmail,
  generateStorageExtensionApprovedEmail: () => generateStorageExtensionApprovedEmail,
  generateStorageExtensionPaymentReceivedEmail: () => generateStorageExtensionPaymentReceivedEmail,
  generateStorageExtensionPendingApprovalEmail: () => generateStorageExtensionPendingApprovalEmail,
  generateStorageExtensionRejectedEmail: () => generateStorageExtensionRejectedEmail,
  generateWelcomeEmail: () => generateWelcomeEmail,
  getDashboardUrl: () => getDashboardUrl,
  getSubdomainUrl: () => getSubdomainUrl,
  getWebsiteUrl: () => getWebsiteUrl,
  sendApplicationReceivedEmail: () => sendApplicationReceivedEmail,
  sendApplicationRejectedEmail: () => sendApplicationRejectedEmail,
  sendEmail: () => sendEmail
});
import nodemailer from "nodemailer";
import { fileURLToPath, pathToFileURL } from "url";
import { dirname, join } from "path";
function createBookingDateTimeFallback(dateStr, timeStr, timezone = "America/St_Johns") {
  const [year, month, day] = dateStr.split("-").map(Number);
  const [hours, minutes] = timeStr.split(":").map(Number);
  return new Date(year, month - 1, day, hours, minutes);
}
function createBookingDateTime(dateStr, timeStr, timezone = "America/St_Johns") {
  return createBookingDateTimeImpl(dateStr, timeStr, timezone);
}
async function sendApplicationReceivedEmail(applicationData) {
  const firstName = applicationData.fullName ? applicationData.fullName.split(" ")[0] : "there";
  const subject = `Application Received - Local Cooks`;
  const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Thank you for submitting your application to Local Cooks. We&#8217;ve received it and our team will review it shortly.</p>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">What happens next:</p>
      <p class="message" style="margin-bottom: 20px;">Our team typically reviews applications within 2&#8211;3 business days. You&#8217;ll receive an email notification once we&#8217;ve made a decision.</p>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fffbeb; color: #d97706; border: 1px solid #fef3c7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#9679; Under Review</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${getDashboardUrl()}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Track Application Status</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
  const textContent = `
Hi ${firstName},

Thank you for submitting your application to Local Cooks. We've received it and our team will review it shortly.

What happens next:
Our team typically reviews applications within 2\u20133 business days. You'll receive an email notification once we've made a decision.

Track your application status: ${getDashboardUrl()}

If you have any questions, contact us at support@localcook.shop

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
`;
  return sendEmail({
    to: applicationData.email,
    subject,
    html: htmlContent,
    text: textContent
  });
}
async function sendApplicationRejectedEmail(applicationData, reason) {
  const firstName = applicationData.fullName ? applicationData.fullName.split(" ")[0] : "there";
  const subject = `Application Update - Local Cooks`;
  const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Thank you for your interest in joining Local Cooks. After careful review, we&#8217;re unable to approve your application at this time.</p>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fef2f2; color: #dc2626; border: 1px solid #fecaca; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">Not Approved</span>
      </div>
      ${reason ? `
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 24px 0 0 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Feedback:</span> <strong style="color: #1e293b;">${reason}</strong></p>
      </div>` : ""}
      <p class="message" style="margin-top: 24px; margin-bottom: 20px;">We encourage you to gain more experience and reapply in the future. We&#8217;d be happy to reconsider your application when you&#8217;re ready.</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${getWebsiteUrl()}/apply" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Learn About Requirements</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
  const textContent = `
Hi ${firstName},

Thank you for your interest in joining Local Cooks. After careful review, we're unable to approve your application at this time.

Status: Not Approved

${reason ? `Feedback: ${reason}

` : ""}We encourage you to gain more experience and reapply in the future. We'd be happy to reconsider your application when you're ready.

Learn more: ${getWebsiteUrl()}/apply

If you have any questions, contact us at support@localcook.shop

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
`;
  return sendEmail({
    to: applicationData.email,
    subject,
    html: htmlContent,
    text: textContent
  });
}
var createBookingDateTimeImpl, loadAttempted, recentEmails, DUPLICATE_PREVENTION_WINDOW, createTransporter, getEmailConfig, sendEmail, getDomainFromEmail, getOrganizationName, getUnsubscribeEmail, getSupportEmail, detectEmailProvider, formatDateForCalendar, escapeIcalText, generateEventUid, generateIcsFile, generateCalendarUrl, getUniformEmailStyles, generateStatusChangeEmail, generateVendorCredentials, generateFullVerificationEmail, generateApplicationWithDocumentsEmail, generateApplicationWithoutDocumentsEmail, generateDocumentStatusChangeEmail, generatePasswordResetEmail, generateEmailVerificationEmail, generateWelcomeEmail, getSubdomainUrl, getWebsiteUrl, getDashboardUrl, getVendorDashboardUrl, getPromoUrl, generateDocumentUpdateEmail, generatePromoCodeEmail, generateChefAllDocumentsApprovedEmail, generateManagerMagicLinkEmail, generateManagerCredentialsEmail, generateBookingNotificationEmail, generateBookingPaymentReceivedEmail, generateBookingCancellationNotificationEmail, generateBookingStatusChangeNotificationEmail, generateBookingRequestEmail, generateBookingConfirmationEmail, generateBookingCancellationEmail, generateKitchenAvailabilityChangeEmail, generateKitchenSettingsChangeEmail, generateChefProfileRequestEmail, generateChefLocationAccessApprovedEmail, generateChefKitchenAccessApprovedEmail, generateLocationEmailChangedEmail, generateStorageExtensionPendingApprovalEmail, generateStorageExtensionPaymentReceivedEmail, generateStorageExtensionApprovedEmail, generateStorageExtensionRejectedEmail, generateStorageExpiringWarningEmail, generateOverstayDetectedEmail, generatePenaltyChargedEmail, generateOverstayManagerNotificationEmail, generateNewKitchenApplicationManagerEmail, generateKitchenApplicationSubmittedChefEmail, generateKitchenApplicationApprovedEmail, generateKitchenApplicationRejectedEmail, generateKitchenLicenseApprovedEmail, generateKitchenLicenseRejectedEmail, generateKitchenLicenseSubmittedAdminEmail, generateDamageClaimFiledEmail, generateDamageClaimResponseEmail, generateDamageClaimDisputedAdminEmail, generateDamageClaimDecisionEmail, generateDamageClaimChargedEmail, generateNewUserRegistrationAdminEmail;
var init_email = __esm({
  "server/email.ts"() {
    "use strict";
    init_logger();
    createBookingDateTimeImpl = createBookingDateTimeFallback;
    loadAttempted = false;
    (async () => {
      if (loadAttempted) return;
      loadAttempted = true;
      try {
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = dirname(__filename);
        const possiblePaths = [
          join(__dirname, "../shared/timezone-utils.js"),
          // From server/email.js to shared/timezone-utils.js (CORRECT PATH for dist)
          join(__dirname, "../shared/timezone-utils"),
          // Without .js extension
          join(__dirname, "../../shared/timezone-utils.js"),
          // Alternative path
          "/var/task/shared/timezone-utils.js",
          // Absolute path for Vercel dist structure
          "/var/task/api/shared/timezone-utils.js"
          // Absolute path for Vercel api structure
        ];
        for (const filePath of possiblePaths) {
          try {
            const timezoneUtilsUrl = pathToFileURL(filePath).href;
            const timezoneUtils = await import(timezoneUtilsUrl);
            if (timezoneUtils && timezoneUtils.createBookingDateTime) {
              createBookingDateTimeImpl = timezoneUtils.createBookingDateTime;
              logger.info(`Successfully loaded timezone-utils from: ${timezoneUtilsUrl}`);
              return;
            }
          } catch {
            continue;
          }
        }
        logger.warn("Failed to load timezone-utils from any path, using fallback implementation");
      } catch (error) {
        logger.error("Error during timezone-utils initialization:", error);
      }
    })();
    recentEmails = /* @__PURE__ */ new Map();
    DUPLICATE_PREVENTION_WINDOW = 3e4;
    createTransporter = (config) => {
      const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
      return nodemailer.createTransport({
        host: config.host,
        port: config.port,
        secure: config.secure,
        auth: {
          user: config.auth.user,
          pass: config.auth.pass
        },
        // Enhanced configuration for Vercel serverless functions
        tls: {
          rejectUnauthorized: false,
          // Allow self-signed certificates
          minVersion: "TLSv1.2"
          // Use modern TLS (SSLv3 is deprecated and rejected by most servers)
        },
        // Reduced timeouts for serverless functions (max 10s execution time)
        connectionTimeout: isProduction2 ? 15e3 : 6e4,
        // 15s production, 60s development
        greetingTimeout: isProduction2 ? 1e4 : 3e4,
        // 10s production, 30s development
        socketTimeout: isProduction2 ? 15e3 : 6e4,
        // 15s production, 60s development
        // Let nodemailer auto-negotiate the best auth method
        // authMethod: 'PLAIN', // Removed - let server choose (Hostinger prefers LOGIN)
        // Enable debug for troubleshooting in development only
        debug: process.env.NODE_ENV === "development",
        logger: process.env.NODE_ENV === "development",
        // Disable pooling for serverless - each request should create fresh connection
        pool: false
      });
    };
    getEmailConfig = () => {
      const forceDirectSMTP = process.env.FORCE_DIRECT_SMTP === "true";
      const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
      if (forceDirectSMTP && isProduction2) {
        logger.info("\u{1F504} Forcing direct SMTP connection (bypassing MailChannels)");
      }
      return {
        host: process.env.EMAIL_HOST || "smtp.hostinger.com",
        port: parseInt(process.env.EMAIL_PORT || "587"),
        secure: process.env.EMAIL_SECURE === "true",
        auth: {
          user: process.env.EMAIL_USER || "",
          pass: process.env.EMAIL_PASS || ""
        }
      };
    };
    sendEmail = async (content, options) => {
      const startTime = Date.now();
      let transporter = null;
      try {
        if (options?.trackingId) {
          const lastSent = recentEmails.get(options.trackingId);
          const now = Date.now();
          if (lastSent && now - lastSent < DUPLICATE_PREVENTION_WINDOW) {
            logger.info(`Preventing duplicate email for tracking ID: ${options.trackingId} (sent ${now - lastSent}ms ago)`);
            return true;
          }
          recentEmails.set(options.trackingId, now);
          if (recentEmails.size > 100) {
            const cutoffTime = now - DUPLICATE_PREVENTION_WINDOW;
            recentEmails.forEach((timestamp2, id) => {
              if (timestamp2 < cutoffTime) recentEmails.delete(id);
            });
          }
        }
        if (!process.env.EMAIL_USER || !process.env.EMAIL_PASS) {
          logger.error("Email configuration is missing. Please set EMAIL_USER and EMAIL_PASS environment variables.");
          return false;
        }
        const config = getEmailConfig();
        const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
        logger.info("\u{1F4E7} COMPREHENSIVE EMAIL SEND INITIATED:", {
          to: content.to,
          subject: content.subject,
          emailType: content.subject.includes("Application") ? "\u{1F3AF} APPLICATION_EMAIL" : "\u{1F4DD} SYSTEM_EMAIL",
          trackingId: options?.trackingId || `auto_${Date.now()}`,
          hasText: !!content.text,
          hasHtml: !!content.html,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          config: {
            host: config.host,
            port: config.port,
            secure: config.secure,
            user: config.auth.user ? config.auth.user.replace(/(.{3}).*@/, "$1***@") : "not set",
            domain: getDomainFromEmail(config.auth.user),
            organization: getOrganizationName(),
            hasEmailFrom: !!process.env.EMAIL_FROM,
            isProduction: isProduction2,
            environment: process.env.VERCEL_ENV || process.env.NODE_ENV,
            vercelRegion: process.env.VERCEL_REGION || "unknown"
          }
        });
        transporter = createTransporter(config);
        const fromName = getOrganizationName();
        const fromEmail = process.env.EMAIL_FROM || `${fromName} <${config.auth.user}>`;
        if (!isProduction2) {
          try {
            await new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject(new Error("SMTP verification timeout"));
              }, 1e4);
              transporter.verify((error, success) => {
                clearTimeout(timeout);
                if (error) {
                  logger.error("SMTP connection verification failed:", error);
                  reject(error);
                } else {
                  logger.info("SMTP connection verified successfully");
                  resolve(success);
                }
              });
            });
          } catch (verifyError) {
            logger.error("Failed to verify SMTP connection:", verifyError);
          }
        }
        const domain = getDomainFromEmail(config.auth.user);
        const unsubscribeEmail = getUnsubscribeEmail();
        const organizationName = getOrganizationName();
        const mailOptions = {
          from: fromEmail,
          to: content.to,
          subject: content.subject,
          text: content.text,
          html: content.html,
          // Add attachments if provided (e.g., .ics calendar files)
          attachments: content.attachments || [],
          // Optimized headers for better deliverability with Hostinger SMTP
          headers: {
            "Organization": organizationName,
            "X-Mailer": "Local Cooks Community",
            // Proper sender identification for DKIM/SPF alignment
            "Sender": config.auth.user,
            "Return-Path": config.auth.user,
            "Reply-To": config.auth.user,
            // Standard priority headers (avoid high priority to reduce spam score)
            "Importance": "Normal",
            // Merge any additional headers from content
            ...content.headers || {}
          },
          // Proper encoding settings for DKIM
          encoding: "utf8",
          // Enhanced delivery options for Hostinger SMTP
          envelope: {
            from: config.auth.user,
            to: content.to
          },
          // DKIM-compatible message ID with proper domain
          messageId: `<${Date.now()}.${Math.random().toString(36).substr(2, 9)}@${domain}>`,
          date: /* @__PURE__ */ new Date()
          // DKIM signing is handled by Hostinger SMTP server
        };
        let info;
        let attempts = 0;
        const maxAttempts = 2;
        while (attempts < maxAttempts) {
          attempts++;
          logger.info(`\u{1F4E7} Attempt ${attempts}/${maxAttempts} sending email to ${content.to}`);
          try {
            const emailPromise = transporter.sendMail(mailOptions);
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(() => reject(new Error("Email sending timeout - exceeded 25 seconds")), 25e3);
            });
            info = await Promise.race([emailPromise, timeoutPromise]);
            logger.info(`\u2705 Email sent successfully on attempt ${attempts}`);
            break;
          } catch (attemptError) {
            logger.warn(`\u26A0\uFE0F Attempt ${attempts} failed for ${content.to}:`, attemptError instanceof Error ? attemptError.message : String(attemptError));
            if (attempts >= maxAttempts) {
              throw attemptError;
            }
            await new Promise((resolve) => setTimeout(resolve, 1e3 * attempts));
          }
        }
        const executionTime = Date.now() - startTime;
        logger.info("Email sent successfully:", {
          messageId: info.messageId,
          accepted: info.accepted,
          rejected: info.rejected,
          response: info.response,
          domain,
          organization: organizationName,
          fromEmail,
          executionTime: `${executionTime}ms`,
          isProduction: isProduction2
        });
        if (transporter && typeof transporter.close === "function") {
          transporter.close();
        }
        return true;
      } catch (error) {
        const executionTime = Date.now() - startTime;
        logger.error("Error sending email:", {
          error: error instanceof Error ? error.message : error,
          executionTime: `${executionTime}ms`,
          to: content.to,
          subject: content.subject,
          trackingId: options?.trackingId,
          isProduction: process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production"
        });
        if (error instanceof Error) {
          logger.error("Error details:", error.message);
          if ("code" in error) {
            logger.error("Error code:", error.code);
          }
          if ("responseCode" in error) {
            logger.error("SMTP Response code:", error.responseCode);
          }
        }
        if (transporter && typeof transporter.close === "function") {
          try {
            transporter.close();
          } catch (closeError) {
            logger.error("Error closing transporter:", closeError);
          }
        }
        return false;
      }
    };
    getDomainFromEmail = (email) => {
      if (process.env.EMAIL_DOMAIN) {
        return process.env.EMAIL_DOMAIN;
      }
      if (process.env.EMAIL_FROM) {
        const match2 = process.env.EMAIL_FROM.match(/<([^>]+)>/);
        if (match2) {
          const emailPart = match2[1];
          const domainMatch = emailPart.match(/@(.+)$/);
          if (domainMatch) {
            return domainMatch[1];
          }
        }
      }
      const match = email.match(/@(.+)$/);
      if (match) {
        return match[1];
      }
      return "localcooks.community";
    };
    getOrganizationName = () => {
      return process.env.EMAIL_ORGANIZATION || "Local Cooks Community";
    };
    getUnsubscribeEmail = () => {
      const domain = getDomainFromEmail(process.env.EMAIL_USER || "");
      return `unsubscribe@${domain}`;
    };
    getSupportEmail = () => {
      const domain = getDomainFromEmail(process.env.EMAIL_USER || "");
      return `support@${domain}`;
    };
    detectEmailProvider = (email) => {
      const emailLower = email.toLowerCase();
      const domain = emailLower.split("@")[1] || "";
      if (domain === "gmail.com" || domain === "googlemail.com" || domain.endsWith(".google.com")) {
        return "google";
      }
      if (domain === "outlook.com" || domain === "hotmail.com" || domain === "live.com" || domain === "msn.com" || domain.endsWith(".outlook.com")) {
        return "outlook";
      }
      if (domain === "yahoo.com" || domain === "yahoo.co.uk" || domain === "yahoo.ca" || domain.endsWith(".yahoo.com")) {
        return "yahoo";
      }
      if (domain === "icloud.com" || domain === "me.com" || domain === "mac.com" || domain.endsWith(".icloud.com")) {
        return "apple";
      }
      return "generic";
    };
    formatDateForCalendar = (date2) => {
      const year = date2.getUTCFullYear();
      const month = String(date2.getUTCMonth() + 1).padStart(2, "0");
      const day = String(date2.getUTCDate()).padStart(2, "0");
      const hours = String(date2.getUTCHours()).padStart(2, "0");
      const minutes = String(date2.getUTCMinutes()).padStart(2, "0");
      const seconds = String(date2.getUTCSeconds()).padStart(2, "0");
      return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
    };
    escapeIcalText = (text2) => {
      return text2.replace(/\\/g, "\\\\").replace(/;/g, "\\;").replace(/,/g, "\\,").replace(/\n/g, "\\n").replace(/\r/g, "");
    };
    generateEventUid = (bookingDate, startTime, location) => {
      const dateStr = bookingDate instanceof Date ? bookingDate.toISOString().split("T")[0] : bookingDate.split("T")[0];
      const hashInput = `${dateStr}-${startTime}-${location}`;
      let hash = 0;
      for (let i = 0; i < hashInput.length; i++) {
        const char = hashInput.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      const positiveHash = Math.abs(hash).toString(36);
      return `${dateStr.replace(/-/g, "")}T${startTime.replace(/:/g, "")}-${positiveHash}@localcooks.com`;
    };
    generateIcsFile = (title, startDateTime, endDateTime, location, description, organizerEmail, attendeeEmails, eventUid) => {
      const startDateStr = formatDateForCalendar(startDateTime);
      const endDateStr = formatDateForCalendar(endDateTime);
      const now = formatDateForCalendar(/* @__PURE__ */ new Date());
      const uid = eventUid || `${Date.now()}-${Math.random().toString(36).substr(2, 9)}@localcooks.com`;
      const lines = [
        "BEGIN:VCALENDAR",
        "VERSION:2.0",
        "PRODID:-//Local Cooks Community//Kitchen Booking System//EN",
        "CALSCALE:GREGORIAN",
        "METHOD:REQUEST",
        // Indicates this is a calendar invitation
        "BEGIN:VEVENT",
        `UID:${uid}`,
        `DTSTAMP:${now}`,
        // When the event was created
        `DTSTART:${startDateStr}`,
        // Start time in UTC
        `DTEND:${endDateStr}`,
        // End time in UTC
        `SUMMARY:${escapeIcalText(title)}`,
        `DESCRIPTION:${escapeIcalText(description)}`,
        `LOCATION:${escapeIcalText(location)}`,
        "STATUS:CONFIRMED",
        "SEQUENCE:0",
        // Increment on updates for synchronization
        "TRANSP:OPAQUE"
        // Indicates busy time
      ];
      if (organizerEmail) {
        lines.push(`ORGANIZER;CN=Local Cooks Community:mailto:${organizerEmail}`);
      } else {
        const supportEmail = getSupportEmail();
        lines.push(`ORGANIZER;CN=Local Cooks Community:mailto:${supportEmail}`);
      }
      if (attendeeEmails && attendeeEmails.length > 0) {
        attendeeEmails.forEach((email) => {
          if (email && email.includes("@")) {
            lines.push(`ATTENDEE;CN=${email.split("@")[0]};RSVP=TRUE;CUTYPE=INDIVIDUAL:mailto:${email}`);
          }
        });
      }
      lines.push(
        "BEGIN:VALARM",
        "ACTION:DISPLAY",
        "TRIGGER:-PT15M",
        // 15 minutes before
        "DESCRIPTION:Reminder: Kitchen booking in 15 minutes",
        "END:VALARM",
        "BEGIN:VALARM",
        "ACTION:EMAIL",
        "TRIGGER:-P1D",
        // 1 day before
        "DESCRIPTION:Reminder: Kitchen booking tomorrow",
        "END:VALARM",
        "END:VEVENT",
        "END:VCALENDAR"
      );
      return lines.join("\r\n");
    };
    generateCalendarUrl = (email, title, bookingDate, startTime, endTime, location, description, timezone = "America/St_Johns") => {
      try {
        let bookingDateStr;
        if (bookingDate instanceof Date) {
          bookingDateStr = bookingDate.toISOString().split("T")[0];
        } else if (typeof bookingDate === "string") {
          bookingDateStr = bookingDate.split("T")[0];
        } else {
          bookingDateStr = String(bookingDate);
        }
        const startDateTime = createBookingDateTime(bookingDateStr, startTime, timezone);
        const endDateTime = createBookingDateTime(bookingDateStr, endTime, timezone);
        const startDateStr = formatDateForCalendar(startDateTime);
        const endDateStr = formatDateForCalendar(endDateTime);
        const provider = detectEmailProvider(email);
        switch (provider) {
          case "google":
            const googleParams = new URLSearchParams({
              action: "TEMPLATE",
              text: encodeURIComponent(title),
              dates: `${startDateStr}/${endDateStr}`,
              // ISO 8601 format in UTC
              details: encodeURIComponent(description),
              location: encodeURIComponent(location),
              sf: "true",
              // Show form
              output: "xml"
              // Output format
            });
            return `https://calendar.google.com/calendar/render?${googleParams.toString()}`;
          case "outlook":
            const outlookParams = new URLSearchParams({
              subject: title,
              startdt: startDateTime.toISOString(),
              enddt: endDateTime.toISOString(),
              body: description,
              location
            });
            return `https://outlook.live.com/calendar/0/deeplink/compose?${outlookParams.toString()}`;
          case "yahoo":
            const yahooParams = new URLSearchParams({
              v: "60",
              // version
              view: "d",
              type: "20",
              title,
              st: startDateStr.replace(/[-:]/g, "").replace("T", "").replace("Z", ""),
              dur: String(Math.round((endDateTime.getTime() - startDateTime.getTime()) / 6e4)),
              // duration in minutes
              desc: description,
              in_loc: location
            });
            return `https://calendar.yahoo.com/?${yahooParams.toString()}`;
          case "apple":
            const appleParams = new URLSearchParams({
              action: "TEMPLATE",
              text: title,
              dates: `${startDateStr}/${endDateStr}`,
              details: description,
              location
            });
            return `https://calendar.google.com/calendar/render?${appleParams.toString()}`;
          case "generic":
          default:
            const genericParams = new URLSearchParams({
              action: "TEMPLATE",
              text: title,
              dates: `${startDateStr}/${endDateStr}`,
              details: description,
              location
            });
            return `https://calendar.google.com/calendar/render?${genericParams.toString()}`;
        }
      } catch (error) {
        logger.error("Error generating calendar URL:", error);
        return `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(title)}&location=${encodeURIComponent(location)}`;
      }
    };
    getUniformEmailStyles = () => `
<style>
  @import url('https://fonts.googleapis.com/css2?family=Lobster&display=swap');
  
  body { 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
    line-height: 1.6; 
    color: #475569; 
    margin: 0; 
    padding: 0; 
    background: #f1f5f9;
  }
  .email-container { 
    max-width: 600px; 
    margin: 0 auto; 
    background: white; 
    border-radius: 12px; 
    overflow: hidden; 
    box-shadow: 0 4px 20px rgba(0,0,0,0.08);
  }
  .header { 
    background: linear-gradient(135deg, hsl(347, 91%, 51%) 0%, hsl(347, 91%, 45%) 100%); 
    color: white; 
    padding: 24px 32px; 
    text-align: center; 
  }
  .header-image {
    max-width: 280px;
    height: auto;
    display: block;
    margin: 0 auto;
  }
  .content { 
    padding: 40px 32px; 
  }
  .greeting {
    font-size: 24px;
    font-weight: 600;
    color: #1e293b;
    margin: 0 0 16px 0;
  }
  .message {
    font-size: 16px;
    line-height: 1.6;
    color: #475569;
    margin: 0 0 24px 0;
  }
  .status-badge { 
    display: inline-block; 
    padding: 12px 20px; 
    background: linear-gradient(135deg, #fef7f7 0%, #fecaca 100%); 
    color: hsl(347, 91%, 51%); 
    border: 1px solid hsl(347, 91%, 70%);
    border-radius: 8px; 
    font-weight: 600; 
    margin: 16px 0; 
  }
  .status-badge.approved {
    background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
    color: #16a34a;
    border-color: #bbf7d0;
  }
  .status-badge.rejected {
    background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
    color: #dc2626;
    border-color: #fecaca;
  }
  .status-badge.cancelled {
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    color: #64748b;
    border-color: #cbd5e1;
  }
  .cta-button { 
    display: inline-block; 
    padding: 14px 28px; 
    background: linear-gradient(135deg, hsl(347, 91%, 51%) 0%, hsl(347, 91%, 45%) 100%); 
    color: white !important; 
    text-decoration: none; 
    border-radius: 8px; 
    font-weight: 600;
    margin: 24px 0;
    box-shadow: 0 2px 8px hsla(347, 91%, 51%, 0.3);
    mso-hide: none;
    mso-text-raise: 0;
  }
  .info-box {
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    padding: 20px;
    margin: 24px 0;
  }
  .credentials-table {
    width: 100%;
    border-collapse: collapse;
    margin: 16px 0;
  }
  .credentials-table td {
    padding: 12px 16px;
    background: #fff;
    border: 1px solid #e2e8f0;
  }
  .credentials-table td:first-child {
    font-weight: 600;
    color: hsl(347, 91%, 51%);
    background: #f8fafc;
  }
  .credentials-table code {
    font-family: 'Courier New', monospace;
    font-size: 14px;
    color: #1e293b;
    font-weight: 600;
  }
  .footer { 
    background: #f8fafc; 
    padding: 24px 32px; 
    text-align: center; 
    border-top: 1px solid #e2e8f0;
  }
  .footer-text {
    font-size: 14px;
    color: #64748b;
    margin: 0 0 8px 0;
  }
  .footer-links {
    font-size: 13px;
    color: #94a3b8;
  }
  .footer-links a { 
    color: hsl(347, 91%, 51%); 
    text-decoration: none;
  }
  .divider {
    height: 1px;
    background: linear-gradient(90deg, transparent 0%, #e2e8f0 50%, transparent 100%);
    margin: 24px 0;
  }
  .warning-box {
    background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
    border: 1px solid #f59e0b;
    border-radius: 8px;
    padding: 16px;
    margin: 16px 0;
  }
  .warning-text {
    font-size: 14px;
    color: #92400e;
    margin: 0;
  }
  a { color: hsl(347, 91%, 51%); text-decoration: underline; }
</style>`;
    generateStatusChangeEmail = (applicationData) => {
      const firstName = applicationData.fullName.split(" ")[0];
      const getSubjectLine = (status) => {
        switch (status) {
          case "approved":
            return "Application Approved - Local Cooks";
          case "rejected":
            return "Application Update - Local Cooks";
          case "cancelled":
            return "Application Status Update - Local Cooks";
          case "under_review":
            return "Application Under Review - Local Cooks";
          default:
            return "Application Status Update - Local Cooks";
        }
      };
      const subject = getSubjectLine(applicationData.status);
      const getMessage = (status) => {
        switch (status) {
          case "approved":
            return "Your application has been approved. You now have full access to the Local Cooks platform, including our food safety training program.";
          case "rejected":
            return "Thank you for your application. After careful review, we are unable to move forward at this time. We appreciate your interest in Local Cooks.";
          case "cancelled":
            return "Your application has been cancelled. You can submit a new application anytime when you&#8217;re ready.";
          case "under_review":
            return "Your application is currently under review by our team. We&#8217;ll notify you once the review is complete.";
          case "pending":
            return "Your application has been received and is pending review. We&#8217;ll be in touch with updates soon.";
          default:
            return "Your application status has been updated. Please check your dashboard for more details.";
        }
      };
      const getStatusBadge = (status) => {
        switch (status) {
          case "approved":
            return `<span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; Approved</span>`;
          case "rejected":
            return `<span style="display: inline-block; padding: 4px 12px; background: #fef2f2; color: #dc2626; border: 1px solid #fecaca; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">Not Approved</span>`;
          case "cancelled":
            return `<span style="display: inline-block; padding: 4px 12px; background: #f8fafc; color: #64748b; border: 1px solid #e2e8f0; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">Cancelled</span>`;
          case "under_review":
            return `<span style="display: inline-block; padding: 4px 12px; background: #fffbeb; color: #d97706; border: 1px solid #fef3c7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#9679; Under Review</span>`;
          default:
            return `<span style="display: inline-block; padding: 4px 12px; background: #fffbeb; color: #d97706; border: 1px solid #fef3c7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#9679; Pending</span>`;
        }
      };
      const message = getMessage(applicationData.status);
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">${message}</p>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        ${getStatusBadge(applicationData.status)}
      </div>
      ${applicationData.status === "approved" ? `
      <p class="message" style="margin-top: 24px; margin-bottom: 8px; font-weight: 600; color: #1e293b;">Your next step:</p>
      <p class="message" style="margin-bottom: 10px;">Complete your food safety training to unlock all features. From your dashboard you can:</p>
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="margin: 0 0 24px 4px;">
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Access all 22 food safety training videos</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Earn your Local Cooks certification and HACCP fundamentals</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Build customer trust with a verified status on your profile</td>
        </tr>
      </table>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${getDashboardUrl()}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Start Food Safety Training</a>
      </div>` : ""}${applicationData.status === "cancelled" ? `
      <p class="message" style="margin-top: 24px; margin-bottom: 20px;">You can submit a new application anytime when you&#8217;re ready to join Local Cooks.</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${getWebsiteUrl()}/apply" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Submit New Application</a>
      </div>` : ""}
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const statusLabel = applicationData.status.charAt(0).toUpperCase() + applicationData.status.slice(1).replace("_", " ");
      const text2 = `
Hi ${firstName},

${getMessage(applicationData.status).replace(/&#8217;/g, "'")}

Status: ${statusLabel}

${applicationData.status === "approved" ? `Your next step: Complete your food safety training to unlock all features.

\u2022 Access all 22 food safety training videos
\u2022 Earn your Local Cooks certification and HACCP fundamentals
\u2022 Build customer trust with a verified status

Start training: ${getDashboardUrl()}` : ""}${applicationData.status === "cancelled" ? `You can submit a new application anytime: ${getWebsiteUrl()}/apply` : ""}

If you have any questions, contact us at support@localcook.shop

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: applicationData.email,
        subject,
        text: text2,
        html
      };
    };
    generateVendorCredentials = (fullName, phone) => {
      let cleanPhone = phone.replace(/[^0-9]/g, "");
      if (cleanPhone.length === 11 && cleanPhone.startsWith("1")) {
        cleanPhone = cleanPhone.substring(1);
      }
      const username = cleanPhone;
      const namePrefix = fullName.replace(/[^a-zA-Z]/g, "").toLowerCase().substring(0, 3) || "usr";
      const phoneSuffix = cleanPhone.slice(-4) || "0000";
      const password = namePrefix + phoneSuffix;
      return { username, password };
    };
    generateFullVerificationEmail = (userData) => {
      const { username, password } = generateVendorCredentials(userData.fullName, userData.phone);
      const firstName = userData.fullName.split(" ")[0];
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chef Account Approved</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Your documents have been approved and you are now fully verified. You can start accepting orders and serving customers through Local Cooks.</p>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; Fully Verified</span>
      </div>
      <p class="message" style="margin-top: 24px; margin-bottom: 8px; font-weight: 600; color: #1e293b;">Your login credentials:</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 16px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Username:</span> <strong style="color: #1e293b; font-family: 'Courier New', monospace;">${username}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Password:</span> <strong style="color: #1e293b; font-family: 'Courier New', monospace;">${password}</strong></p>
      </div>
      <div style="background: #fffbeb; border: 1px solid #fef3c7; border-radius: 8px; padding: 12px 16px; margin: 0 0 24px 0;">
        <p style="font-size: 14px; line-height: 1.6; color: #92400e; margin: 0;"><strong>Important:</strong> Please change your password after your first login for security.</p>
      </div>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Next steps:</p>
      <p class="message" style="margin-bottom: 10px;">You have two accounts to set up:</p>
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="margin: 0 0 24px 4px;">
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;"><strong style="color: #1e293b;">Chef Dashboard</strong> &#8212; use your credentials above to manage your profile, products, and orders</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;"><strong style="color: #1e293b;">Stripe Payments</strong> &#8212; set up payment processing to start receiving payments from customers</td>
        </tr>
      </table>
      <div style="text-align: center; margin: 0 0 8px 0;">
        <a href="https://localcook.shop/app/shop/index.php" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0 8px 8px 0;">Access Chef Dashboard</a>
        <a href="${getVendorDashboardUrl()}" style="display: inline-block; padding: 10px 24px; background: #f1f5f9; color: #475569 !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; border: 1px solid #e2e8f0; margin: 0 0 8px 0;">Set Up Stripe Payments</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Warmly,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

Your documents have been approved and you are now fully verified. You can start accepting orders and serving customers through Local Cooks.

Your login credentials:
Username: ${username}
Password: ${password}

Important: Please change your password after your first login for security.

Next steps:
\u2022 Chef Dashboard \u2014 use your credentials above to manage your profile, products, and orders
  Access: https://localcook.shop/app/shop/index.php
\u2022 Stripe Payments \u2014 set up payment processing to start receiving payments
  Access: ${getVendorDashboardUrl()}

If you have any questions, contact us at support@localcook.shop

Warmly,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: userData.email,
        subject: "Chef Account Approved",
        text: text2,
        html,
        headers: {
          "X-Priority": "3",
          "X-MSMail-Priority": "Normal",
          "Importance": "Normal",
          "List-Unsubscribe": `<mailto:${getUnsubscribeEmail()}>`
        }
      };
    };
    generateApplicationWithDocumentsEmail = (applicationData) => {
      const firstName = applicationData.fullName.split(" ")[0];
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Application and Documents Received</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Thank you for submitting your application to Local Cooks. We&#8217;ve received both your application and supporting documents.</p>
      <p class="message" style="margin-bottom: 20px;">Our team will review everything together. You&#8217;ll receive another email once the review is complete, typically within 2&#8211;3 business days.</p>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fffbeb; color: #d97706; border: 1px solid #fef3c7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#9679; Under Review</span>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

Thank you for submitting your application to Local Cooks. We've received both your application and supporting documents.

Our team will review everything together. You'll receive another email once the review is complete, typically within 2\u20133 business days.

Status: Under Review

If you have any questions, contact us at support@localcook.shop

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: applicationData.email,
        subject: "Application and Documents Received",
        text: text2,
        html
      };
    };
    generateApplicationWithoutDocumentsEmail = (applicationData) => {
      const firstName = applicationData.fullName.split(" ")[0];
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Application Received - Next Steps</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Thank you for submitting your application to Local Cooks. We&#8217;ve received it and it will be reviewed soon.</p>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Next step:</p>
      <p class="message" style="margin-bottom: 20px;">Please visit your dashboard to upload the required documents to complete your application.</p>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fffbeb; color: #d97706; border: 1px solid #fef3c7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#9679; Documents Required</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${getDashboardUrl()}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Upload Documents</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

Thank you for submitting your application to Local Cooks. We've received it and it will be reviewed soon.

Next step: Please visit your dashboard to upload the required documents to complete your application.

Upload documents: ${getDashboardUrl()}

If you have any questions, contact us at support@localcook.shop

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: applicationData.email,
        subject: "Application Received - Next Steps",
        text: text2,
        html
      };
    };
    generateDocumentStatusChangeEmail = (userData) => {
      const firstName = userData.fullName.split(" ")[0];
      const docName = userData.documentType === "foodSafetyLicenseStatus" ? "Food Safety License" : "Food Establishment Certificate";
      const getSubjectLine = (documentType, status) => {
        const dn = documentType === "foodSafetyLicenseStatus" ? "Food Safety License" : "Food Establishment Certificate";
        switch (status) {
          case "approved":
            return `${dn} Approved - Local Cooks`;
          case "rejected":
            return `${dn} Update Required - Local Cooks`;
          default:
            return `${dn} Status Update - Local Cooks`;
        }
      };
      const subject = getSubjectLine(userData.documentType, userData.status);
      const getMessage = (status) => {
        switch (status) {
          case "approved":
            return `Your ${docName} has been approved by our verification team. This brings you one step closer to being fully verified on Local Cooks.`;
          case "rejected":
            return `Your ${docName} could not be approved at this time. Please review the feedback below and upload an updated document.`;
          case "pending":
            return `Your ${docName} is currently being reviewed by our verification team. We&#8217;ll notify you once the review is complete.`;
          default:
            return `Your ${docName} status has been updated. Please check your dashboard for more details.`;
        }
      };
      const getStatusBadge = (status) => {
        switch (status) {
          case "approved":
            return `<span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; Approved</span>`;
          case "rejected":
            return `<span style="display: inline-block; padding: 4px 12px; background: #fef2f2; color: #dc2626; border: 1px solid #fecaca; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">Update Required</span>`;
          default:
            return `<span style="display: inline-block; padding: 4px 12px; background: #fffbeb; color: #d97706; border: 1px solid #fef3c7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#9679; Under Review</span>`;
        }
      };
      const message = getMessage(userData.status);
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">${message}</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Document:</span> <strong style="color: #1e293b;">${docName}</strong></p>
      </div>
      <div style="margin: 0 0 4px 0; text-align: center;">
        ${getStatusBadge(userData.status)}
      </div>
      ${userData.adminFeedback ? `
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 24px 0 0 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Feedback:</span> <strong style="color: #1e293b;">${userData.adminFeedback}</strong></p>
      </div>` : ""}
      ${userData.status === "approved" || userData.status === "rejected" ? `
      <div style="margin: 24px 0 0 0; text-align: center;">
        <a href="${getDashboardUrl()}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">${userData.status === "approved" ? "Access Your Dashboard" : "Update Document"}</a>
      </div>` : ""}
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const statusLabel = userData.status.charAt(0).toUpperCase() + userData.status.slice(1);
      const text2 = `
Hi ${firstName},

${getMessage(userData.status).replace(/&#8217;/g, "'")}

Document: ${docName}
Status: ${statusLabel}

${userData.adminFeedback ? `Feedback: ${userData.adminFeedback}

` : ""}${userData.status === "approved" ? `Access your dashboard: ${getDashboardUrl()}` : userData.status === "rejected" ? `Update your document: ${getDashboardUrl()}` : ""}

If you have any questions, contact us at support@localcook.shop

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: userData.email,
        subject,
        text: text2,
        html
      };
    };
    generatePasswordResetEmail = (userData) => {
      const firstName = userData.fullName.split(" ")[0];
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Password Reset Request - Local Cooks</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">We received a request to reset your password for your Local Cooks account. Click the button below to create a new password.</p>
      <p class="message" style="margin-bottom: 20px;">This link will expire in 1 hour for security.</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${userData.resetUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Reset My Password</a>
      </div>
      <div style="background: #fffbeb; border: 1px solid #fef3c7; border-radius: 8px; padding: 12px 16px; margin: 24px 0 0 0;">
        <p style="font-size: 14px; line-height: 1.6; color: #92400e; margin: 0;"><strong>Didn&#8217;t request this?</strong> If you didn&#8217;t ask to reset your password, you can safely ignore this email. Your account remains secure.</p>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you need help, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

We received a request to reset your password for your Local Cooks account.

Reset your password: ${userData.resetUrl}

This link will expire in 1 hour for security.

If you didn't request this, you can safely ignore this email. Your account remains secure.

If you need help, contact us at support@localcook.shop

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: userData.email,
        subject: "Password Reset Request - Local Cooks",
        text: text2,
        html,
        headers: {
          "X-Priority": "3",
          "X-MSMail-Priority": "Normal",
          "Importance": "Normal",
          "List-Unsubscribe": `<mailto:${getUnsubscribeEmail()}>`
        }
      };
    };
    generateEmailVerificationEmail = (userData) => {
      const firstName = userData.fullName.split(" ")[0];
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Verify Your Email - Local Cooks</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Thank you for joining Local Cooks. To complete your registration and activate your account, please verify your email address.</p>
      <p class="message" style="margin-bottom: 20px;">Click the button below to confirm your email. This link will expire in 24 hours for security.</p>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fffbeb; color: #d97706; border: 1px solid #fef3c7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#9679; Verification Required</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${userData.verificationUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Verify My Email</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you didn&#8217;t create an account with Local Cooks, you can safely ignore this email.</p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

Thank you for joining Local Cooks. To complete your registration and activate your account, please verify your email address.

Verify your email: ${userData.verificationUrl}

This link will expire in 24 hours for security.

If you didn't create an account with Local Cooks, you can safely ignore this email.

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: userData.email,
        subject: "Verify Your Email - Local Cooks",
        text: text2,
        html,
        headers: {
          "X-Priority": "3",
          "X-MSMail-Priority": "Normal",
          "Importance": "Normal",
          "List-Unsubscribe": `<mailto:${getUnsubscribeEmail()}>`
        }
      };
    };
    generateWelcomeEmail = (userData) => {
      const userType = userData.role === "manager" ? "kitchen" : userData.role === "admin" ? "admin" : "chef";
      const dashboardUrl = getDashboardUrl(userType);
      const firstName = userData.fullName.split(" ")[0];
      const isManager = userData.role === "manager";
      const bullet1 = isManager ? "List your kitchen, storage, and equipment availability so qualified chefs and food businesses can book your space." : "Apply to sell your creations through Local Cooks; we handle payments and delivery logistics so you can focus on cooking.";
      const bullet2 = isManager ? "Turn underutilized hours and assets into a new revenue stream, while keeping full control over your schedule, pricing, and approvals." : "Request access to partnered commercial kitchens and book licensed, professional spaces when you need them.";
      const additionalParagraph = isManager ? "Managing everything is simple: view and approve booking requests, adjust availability, and track usage directly from your dashboard." : `You&#8217;ll also find training resources, including Unilever modules and other materials aligned with HACCP principles and common food safety standards. These are learning tools only that can help you prepare for food handler certification requirements in your region.`;
      const closingParagraph = isManager ? `We&#8217;re here to make this as smooth and valuable as possible for you and your team. If you&#8217;d like help setting up your listings or figuring out the best way to use Local Cooks for your kitchen, please reach out.` : `We&#8217;re here to support you at every step. If you&#8217;re unsure what to do next or how best to use the platform, please reach out.`;
      const signOff = isManager ? "Best regards," : "Warmly,";
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Welcome to Local Cooks</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Welcome to Local Cooks, and thank you for joining us.</p>
      <p class="message" style="margin-bottom: 10px;">Your account is now created and verified. From your dashboard, you can:</p>
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="margin: 0 0 24px 4px;">
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">${bullet1}</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">${bullet2}</td>
        </tr>
      </table>
      <p class="message">${additionalParagraph}</p>
      <p class="message" style="margin-bottom: 20px;">${closingParagraph}</p>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; Verified</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Access Your Dashboard</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">${signOff}</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const bulletText1 = isManager ? "List your kitchen, storage, and equipment availability so qualified chefs and food businesses can book your space." : "Apply to sell your creations through Local Cooks; we handle payments and delivery logistics so you can focus on cooking.";
      const bulletText2 = isManager ? "Turn underutilized hours and assets into a new revenue stream, while keeping full control over your schedule, pricing, and approvals." : "Request access to partnered commercial kitchens and book licensed, professional spaces when you need them.";
      const additionalText = isManager ? "Managing everything is simple: view and approve booking requests, adjust availability, and track usage directly from your dashboard." : "You'll also find training resources, including Unilever modules and other materials aligned with HACCP principles and common food safety standards. These are learning tools only that can help you prepare for food handler certification requirements in your region.";
      const closingText = isManager ? "We're here to make this as smooth and valuable as possible for you and your team. If you'd like help setting up your listings or figuring out the best way to use Local Cooks for your kitchen, please reach out." : "We're here to support you at every step. If you're unsure what to do next or how best to use the platform, please reach out.";
      const text2 = `
Hi ${firstName},

Welcome to Local Cooks, and thank you for joining us.

Your account is now created and verified. From your dashboard, you can:

\u2022 ${bulletText1}
\u2022 ${bulletText2}

${additionalText}

${closingText}

Access your dashboard at: ${dashboardUrl}

If you have any questions, contact us at support@localcook.shop

${signOff}
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: userData.email,
        subject: "Welcome to Local Cooks",
        text: text2,
        html
      };
    };
    getSubdomainUrl = (userType = "main") => {
      const baseDomain = process.env.BASE_DOMAIN || "localcooks.ca";
      const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
      if (!isProduction2) {
        const devBase = process.env.BASE_URL || "http://localhost:5001";
        if (devBase.includes("localhost") || devBase.includes("127.0.0.1")) {
          return devBase;
        }
      }
      if (userType === "main") {
        return `https://${baseDomain}`;
      }
      return `https://${userType}.${baseDomain}`;
    };
    getWebsiteUrl = () => {
      return getSubdomainUrl("main");
    };
    getDashboardUrl = (userType = "chef") => {
      const baseUrl = getSubdomainUrl(userType);
      if (userType === "admin") return `${baseUrl}/admin`;
      if (userType === "kitchen") return `${baseUrl}/manager/dashboard`;
      return `${baseUrl}/dashboard`;
    };
    getVendorDashboardUrl = () => {
      return process.env.VENDOR_DASHBOARD_URL || "https://localcook.shop/app/shop/index.php?redirect=https%3A%2F%2Flocalcook.shop%2Fapp%2Fshop%2Fvendor_onboarding.php";
    };
    getPromoUrl = () => {
      return "https://localcook.shop/app/index.php";
    };
    generateDocumentUpdateEmail = (userData) => {
      const firstName = userData.fullName.split(" ")[0];
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document Update Received - Local Cooks</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Thank you for updating your documents. Our team will review them and update your verification status as soon as possible.</p>
      <p class="message" style="margin-bottom: 20px;">You&#8217;ll receive another email once your documents have been reviewed.</p>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fffbeb; color: #d97706; border: 1px solid #fef3c7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#9679; Under Review</span>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: userData.email,
        subject: "Document Update Received - Local Cooks",
        text: `Hi ${firstName},

Thank you for updating your documents. Our team will review them and update your verification status as soon as possible.

You'll receive another email once your documents have been reviewed.

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html,
        headers: {
          "X-Priority": "3",
          "X-MSMail-Priority": "Normal",
          "Importance": "Normal",
          "List-Unsubscribe": `<mailto:${getUnsubscribeEmail()}>`
        }
      };
    };
    generatePromoCodeEmail = (userData) => {
      const organizationName = getOrganizationName();
      const supportEmail = getSupportEmail();
      const defaultPromoStyle = userData.promoStyle || { colorTheme: "green", borderStyle: "dashed" };
      const messageContent = userData.customMessage || userData.message || "";
      const getSectionData = (sectionId) => {
        if (!userData.sections) return null;
        if (Array.isArray(userData.sections)) {
          return userData.sections.find((s) => s.id === sectionId || s.id === `${sectionId}-section`) || null;
        }
        if (typeof userData.sections === "object") {
          return userData.sections[sectionId] || userData.sections[`${sectionId}-section`] || userData.sections[sectionId.replace("-section", "")] || null;
        }
        return null;
      };
      const getPromoStyling = (colorTheme, borderStyle) => {
        const themes = {
          green: {
            background: "linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%)",
            textColor: "#16a34a",
            accentColor: "#15803d",
            borderColor: "#16a34a",
            border: "2px dashed #16a34a",
            boxShadow: "0 4px 16px rgba(22, 163, 74, 0.15)"
          },
          blue: {
            background: "linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)",
            textColor: "#2563eb",
            accentColor: "#1d4ed8",
            borderColor: "#2563eb",
            border: "2px dashed #2563eb",
            boxShadow: "0 4px 16px rgba(37, 99, 235, 0.15)"
          },
          purple: {
            background: "linear-gradient(135deg, #faf5ff 0%, #e9d5ff 100%)",
            textColor: "#7c3aed",
            accentColor: "#6d28d9",
            borderColor: "#7c3aed",
            border: "2px dashed #7c3aed",
            boxShadow: "0 4px 16px rgba(124, 58, 237, 0.15)"
          },
          red: {
            background: "linear-gradient(135deg, #fef2f2 0%, #fecaca 100%)",
            textColor: "#dc2626",
            accentColor: "#b91c1c",
            borderColor: "#dc2626",
            border: "2px dashed #dc2626",
            boxShadow: "0 4px 16px rgba(220, 38, 38, 0.15)"
          },
          orange: {
            background: "linear-gradient(135deg, #fff7ed 0%, #fed7aa 100%)",
            textColor: "#ea580c",
            accentColor: "#c2410c",
            borderColor: "#ea580c",
            border: "2px dashed #ea580c",
            boxShadow: "0 4px 16px rgba(234, 88, 12, 0.15)"
          },
          pink: {
            background: "linear-gradient(135deg, #fdf2f8 0%, #fce7f3 100%)",
            textColor: "#e11d48",
            accentColor: "#be185d",
            borderColor: "#e11d48",
            border: "2px dashed #e11d48",
            boxShadow: "0 4px 16px rgba(225, 29, 72, 0.15)"
          },
          yellow: {
            background: "linear-gradient(135deg, #fefce8 0%, #fef3c7 100%)",
            textColor: "#ca8a04",
            accentColor: "#a16207",
            borderColor: "#ca8a04",
            border: "2px dashed #ca8a04",
            boxShadow: "0 4px 16px rgba(202, 138, 4, 0.15)"
          },
          gray: {
            background: "linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%)",
            textColor: "#475569",
            accentColor: "#334155",
            borderColor: "#475569",
            border: "2px dashed #475569",
            boxShadow: "0 4px 16px rgba(71, 85, 105, 0.15)"
          }
        };
        const theme = themes[colorTheme] || themes.green;
        if (borderStyle === "solid") {
          theme.border = `2px solid ${theme.borderColor}`;
        } else if (borderStyle === "dotted") {
          theme.border = `2px dotted ${theme.borderColor}`;
        }
        return theme;
      };
      const generateAdvancedSections = (sections = []) => {
        return sections.map((section) => {
          switch (section.type) {
            case "text":
              const hasBackground = section.styling?.backgroundColor && section.styling.backgroundColor !== "transparent";
              const paddingValue = hasBackground ? "12px" : section.styling?.padding || "8px 0";
              return `
            <div style="
              font-size: ${section.styling?.fontSize || "16px"};
              color: ${section.styling?.color || "#374151"};
              font-weight: ${section.styling?.fontWeight || "400"};
              font-style: ${section.styling?.fontStyle || "normal"};
              text-align: ${section.styling?.textAlign || "left"};
              padding: ${paddingValue};
              margin: ${section.styling?.margin || "0"};
              line-height: 1.6;
              ${hasBackground ? `background: ${section.styling.backgroundColor};` : ""}
              ${hasBackground ? `border-radius: 8px;` : ""}
            ">
              ${section.content || section.text || ""}
            </div>
          `;
            case "button":
              return `
            <div style="text-align: ${section.styling?.textAlign || "center"}; margin: 20px 0;">
              <a href="${section.styling?.url || getPromoUrl()}" style="
                display: inline-block;
                background: ${section.styling?.backgroundColor || styling.accentColor};
                color: ${section.styling?.color || "#ffffff"} !important;
                text-decoration: none !important;
                padding: ${section.styling?.padding || "12px 24px"};
                border-radius: 6px;
                font-weight: ${section.styling?.fontWeight || "600"};
                font-size: ${section.styling?.fontSize || "16px"};
                border: none;
                cursor: pointer;
              ">
                ${section.content || section.text || "Click Here"}
              </a>
            </div>
          `;
            case "image":
              if (section.content) {
                const hasOverlay = section.overlay?.enabled && section.overlay?.text;
                if (hasOverlay) {
                  return `
                <div style="text-align: ${section.styling?.textAlign || "center"}; margin: 20px 0;">
                  <div style="position: relative; display: inline-block; width: ${section.styling?.width || "200px"}; height: ${section.styling?.height || "120px"};">
                    <img 
                      src="${section.content}" 
                      alt="Email image"
                      style="
                        width: 100%;
                        height: 100%;
                        object-fit: ${section.styling?.objectFit || "cover"};
                        border-radius: ${section.styling?.borderRadius || "8px"};
                        border: 1px solid #e2e8f0;
                        display: block;
                        max-width: 100%;
                      "
                    />
                    <!--[if mso]>
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10;">
                    <![endif]-->
                    <div style="
                      position: absolute;
                      top: 50%;
                      left: 50%;
                      transform: translate(-50%, -50%);
                      color: ${section.overlay.styling?.color || "#ffffff"};
                      font-size: ${section.overlay.styling?.fontSize || "18px"};
                      font-weight: ${section.overlay.styling?.fontWeight || "600"};
                      text-align: center;
                      background-color: ${section.overlay.styling?.backgroundColor || "rgba(0, 0, 0, 0.5)"};
                      padding: ${section.overlay.styling?.padding || "12px 20px"};
                      border-radius: ${section.overlay.styling?.borderRadius || "6px"};
                      text-shadow: ${section.overlay.styling?.textShadow || "1px 1px 2px rgba(0, 0, 0, 0.7)"};
                      max-width: 90%;
                      word-wrap: break-word;
                      z-index: 10;
                      line-height: 1.4;
                    ">
                      ${section.overlay.text}
                    </div>
                    <!--[if mso]>
                    </div>
                    <![endif]-->
                  </div>
                </div>
              `;
                } else {
                  return `
                <div style="text-align: ${section.styling?.textAlign || "center"}; margin: 20px 0;">
                  <img 
                    src="${section.content}" 
                    alt="Email image"
                    style="
                      width: ${section.styling?.width || "200px"};
                      height: ${section.styling?.height || "120px"};
                      object-fit: ${section.styling?.objectFit || "cover"};
                      border-radius: ${section.styling?.borderRadius || "8px"};
                      border: 1px solid #e2e8f0;
                      display: block;
                      max-width: 100%;
                    "
                  />
                </div>
              `;
                }
              }
              return "";
            default:
              return "";
          }
        }).join("");
      };
      const generateDivider = () => {
        if (!userData.dividers?.enabled) return "";
        return `
      <div style="margin: ${userData.dividers.margin || "24px 0"};">
        <hr style="
          border: none;
          border-top: ${userData.dividers.thickness || "1px"} ${userData.dividers.style || "solid"} ${userData.dividers.color || "#e2e8f0"};
          opacity: ${userData.dividers.opacity || "1"};
          margin: 0;
        " />
      </div>
    `;
      };
      const getGreeting = () => {
        const greetingSection = getSectionData("greeting") || getSectionData("greeting-section");
        if (greetingSection?.content || greetingSection?.text) {
          return greetingSection.content || greetingSection.text;
        }
        return userData.greeting || "Hello! \u{1F44B}";
      };
      const getCustomMessage = () => {
        const messageSection = getSectionData("custom-message") || getSectionData("custom-message-section");
        if (messageSection?.content || messageSection?.text) {
          return messageSection.content || messageSection.text;
        }
        return messageContent || "Thank you for being a valued customer!";
      };
      const generatePlainText = (email, promoCode, customMessage) => {
        if (promoCode) {
          return `Special Promo Code from ${organizationName}

${customMessage}

Your Promo Code: ${promoCode}

To use your promo code:
1. Visit our website: ${getPromoUrl()}
2. Apply during checkout or registration
3. Enjoy your special offer!

Questions? Contact us at ${supportEmail}

Best regards,
${organizationName} Team

Visit: ${getPromoUrl()}
`;
        } else {
          return `Message from ${organizationName}

${customMessage}

Questions? Contact us at ${supportEmail}

Best regards,
${organizationName} Team

Visit: ${getPromoUrl()}
`;
        }
      };
      const subject = userData.subject || (userData.promoCode ? `\u{1F381} Exclusive Promo Code: ${userData.promoCode}` : "Important Update from Local Cooks Community");
      const styling = getPromoStyling(defaultPromoStyle.colorTheme, defaultPromoStyle.borderStyle);
      const finalGreeting = getGreeting();
      const finalMessage = getCustomMessage();
      const generateUsageStepsSection = () => {
        const defaultSteps = [
          `Visit our website: <a href="${userData.orderButton?.url || getPromoUrl()}" style="color: ${userData.usageSteps?.styling?.linkColor || "#1d4ed8"};">${userData.orderButton?.url || getPromoUrl()}</a>`,
          "Browse our amazing local cooks and their delicious offerings",
          "Apply your promo code during checkout",
          "Enjoy your special offer!"
        ];
        const steps = userData.usageSteps?.steps && userData.usageSteps.steps.length > 0 ? userData.usageSteps.steps : defaultSteps;
        const stepsHtml = steps.map((step) => `<li>${step}</li>`).join("");
        return `
      <div class="usage-steps">
        <h4>${userData.usageSteps?.title || "\u{1F680} How to use your promo code:"}</h4>
        <ol>
          ${stepsHtml}
        </ol>
      </div>
      ${generateDivider()}
    `;
      };
      const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
  <style>
    /* Override email container styles for customization */
    body { 
      background: ${userData.emailContainer?.backgroundColor || "#f1f5f9"} !important;
      ${userData.emailContainer?.backgroundImage ? `background-image: url(${userData.emailContainer.backgroundImage}) !important;` : ""}
      ${userData.emailContainer?.backgroundSize ? `background-size: ${userData.emailContainer.backgroundSize} !important;` : ""}
      ${userData.emailContainer?.backgroundPosition ? `background-position: ${userData.emailContainer.backgroundPosition} !important;` : ""}
      ${userData.emailContainer?.backgroundRepeat ? `background-repeat: ${userData.emailContainer.backgroundRepeat} !important;` : ""}
      ${userData.emailContainer?.backgroundAttachment ? `background-attachment: ${userData.emailContainer.backgroundAttachment} !important;` : ""}
    }
    .email-container { 
      max-width: ${userData.emailContainer?.maxWidth || "600px"} !important; 
      border-radius: ${userData.emailContainer?.borderRadius || "12px"} !important; 
      box-shadow: ${userData.emailContainer?.boxShadow || "0 4px 20px rgba(0,0,0,0.08)"} !important;
    }
    
    .promo-code-box {
      background: ${userData.promoCodeStyling?.backgroundColor || "#f3f4f6"};
      border: ${userData.promoCodeStyling?.borderWidth || userData.promoCodeStyling?.borderStyle || userData.promoCodeStyling?.borderColor ? `${userData.promoCodeStyling?.borderWidth || "2px"} ${userData.promoCodeStyling?.borderStyle || "dashed"} ${userData.promoCodeStyling?.borderColor || "#9ca3af"}` : "2px dashed #9ca3af"};
      border-radius: ${userData.promoCodeStyling?.borderRadius || "12px"};
      padding: ${userData.promoCodeStyling?.padding || "20px"};
      box-shadow: ${userData.promoCodeStyling?.boxShadow || "0 2px 4px rgba(0,0,0,0.1)"};
      display: inline-block;
      min-width: 200px;
    }
    .promo-code {
      font-family: 'Courier New', monospace;
      font-size: ${userData.promoCodeStyling?.fontSize || "24px"};
      font-weight: ${userData.promoCodeStyling?.fontWeight || "bold"};
      color: ${userData.promoCodeStyling?.textColor || "#1f2937"};
      letter-spacing: 2px;
      margin: 0;
    }
    .promo-label {
      font-size: ${userData.promoCodeStyling?.labelFontSize || "16px"};
      font-weight: ${userData.promoCodeStyling?.labelFontWeight || "600"};
      color: ${userData.promoCodeStyling?.labelColor || "#374151"};
      margin: 0;
      text-align: center;
    }
    .greeting {
      font-size: ${getSectionData("greeting")?.styling?.fontSize || getSectionData("greeting-section")?.styling?.fontSize || "18px"};
      font-weight: ${getSectionData("greeting")?.styling?.fontWeight || getSectionData("greeting-section")?.styling?.fontWeight || "normal"};
      font-style: ${getSectionData("greeting")?.styling?.fontStyle || getSectionData("greeting-section")?.styling?.fontStyle || "normal"};
      color: ${getSectionData("greeting")?.styling?.color || getSectionData("greeting-section")?.styling?.color || "#1f2937"};
      text-align: ${getSectionData("greeting")?.styling?.textAlign || getSectionData("greeting-section")?.styling?.textAlign || "left"};
      line-height: ${getSectionData("greeting")?.styling?.lineHeight || getSectionData("greeting-section")?.styling?.lineHeight || "1.6"};
      letter-spacing: ${getSectionData("greeting")?.styling?.letterSpacing || getSectionData("greeting-section")?.styling?.letterSpacing || "normal"};
      text-transform: ${getSectionData("greeting")?.styling?.textTransform || getSectionData("greeting-section")?.styling?.textTransform || "none"};
      margin: ${getSectionData("greeting")?.styling?.margin || getSectionData("greeting-section")?.styling?.margin || "0"};
      ${getSectionData("greeting")?.styling?.marginTop ? `margin-top: ${getSectionData("greeting")?.styling?.marginTop};` : ""}
      ${getSectionData("greeting")?.styling?.marginRight ? `margin-right: ${getSectionData("greeting")?.styling?.marginRight};` : ""}
      ${getSectionData("greeting")?.styling?.marginBottom ? `margin-bottom: ${getSectionData("greeting")?.styling?.marginBottom || "16px"};` : "margin-bottom: 16px;"}
      ${getSectionData("greeting")?.styling?.marginLeft ? `margin-left: ${getSectionData("greeting")?.styling?.marginLeft};` : ""}
      padding: ${getSectionData("greeting")?.styling?.padding || getSectionData("greeting-section")?.styling?.padding || "0"};
      ${getSectionData("greeting")?.styling?.paddingTop ? `padding-top: ${getSectionData("greeting")?.styling?.paddingTop};` : ""}
      ${getSectionData("greeting")?.styling?.paddingRight ? `padding-right: ${getSectionData("greeting")?.styling?.paddingRight};` : ""}
      ${getSectionData("greeting")?.styling?.paddingBottom ? `padding-bottom: ${getSectionData("greeting")?.styling?.paddingBottom};` : ""}
      ${getSectionData("greeting")?.styling?.paddingLeft ? `padding-left: ${getSectionData("greeting")?.styling?.paddingLeft};` : ""}
    }
    .custom-message {
      font-size: ${getSectionData("custom-message")?.styling?.fontSize || getSectionData("custom-message-section")?.styling?.fontSize || "16px"};
      font-weight: ${getSectionData("custom-message")?.styling?.fontWeight || getSectionData("custom-message-section")?.styling?.fontWeight || "normal"};
      font-style: ${getSectionData("custom-message")?.styling?.fontStyle || getSectionData("custom-message-section")?.styling?.fontStyle || "normal"};
      color: ${getSectionData("custom-message")?.styling?.color || getSectionData("custom-message-section")?.styling?.color || "#374151"};
      text-align: ${getSectionData("custom-message")?.styling?.textAlign || getSectionData("custom-message-section")?.styling?.textAlign || "left"};
      line-height: ${getSectionData("custom-message")?.styling?.lineHeight || getSectionData("custom-message-section")?.styling?.lineHeight || "1.7"};
      letter-spacing: ${getSectionData("custom-message")?.styling?.letterSpacing || getSectionData("custom-message-section")?.styling?.letterSpacing || "normal"};
      text-transform: ${getSectionData("custom-message")?.styling?.textTransform || getSectionData("custom-message-section")?.styling?.textTransform || "none"};
      white-space: pre-line; /* Preserves line breaks from admin input */
      margin: ${getSectionData("custom-message")?.styling?.margin || getSectionData("custom-message-section")?.styling?.margin || "24px 0"};
      ${getSectionData("custom-message")?.styling?.marginTop ? `margin-top: ${getSectionData("custom-message")?.styling?.marginTop};` : ""}
      ${getSectionData("custom-message")?.styling?.marginRight ? `margin-right: ${getSectionData("custom-message")?.styling?.marginRight};` : ""}
      ${getSectionData("custom-message")?.styling?.marginBottom ? `margin-bottom: ${getSectionData("custom-message")?.styling?.marginBottom};` : ""}
      ${getSectionData("custom-message")?.styling?.marginLeft ? `margin-left: ${getSectionData("custom-message")?.styling?.marginLeft};` : ""}
      padding: ${getSectionData("custom-message")?.styling?.padding || getSectionData("custom-message-section")?.styling?.padding || "0"};
      ${getSectionData("custom-message")?.styling?.paddingTop ? `padding-top: ${getSectionData("custom-message")?.styling?.paddingTop};` : ""}
      ${getSectionData("custom-message")?.styling?.paddingRight ? `padding-right: ${getSectionData("custom-message")?.styling?.paddingRight};` : ""}
      ${getSectionData("custom-message")?.styling?.paddingBottom ? `padding-bottom: ${getSectionData("custom-message")?.styling?.paddingBottom};` : ""}
      ${getSectionData("custom-message")?.styling?.paddingLeft ? `padding-left: ${getSectionData("custom-message")?.styling?.paddingLeft};` : ""}
    }
    .custom-header {
      background: ${userData.header?.styling?.backgroundColor || "linear-gradient(135deg, #F51042 0%, #FF5470 100%)"};
      ${userData.header?.styling?.backgroundImage ? `background-image: url(${userData.header.styling.backgroundImage});` : ""}
      ${userData.header?.styling?.backgroundSize ? `background-size: ${userData.header.styling.backgroundSize};` : ""}
      ${userData.header?.styling?.backgroundPosition ? `background-position: ${userData.header.styling.backgroundPosition};` : ""}
      ${userData.header?.styling?.backgroundRepeat ? `background-repeat: ${userData.header.styling.backgroundRepeat};` : ""}
      ${userData.header?.styling?.backgroundAttachment ? `background-attachment: ${userData.header.styling.backgroundAttachment};` : ""}
      border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")};
      -webkit-border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")};
      -moz-border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")};
      border-top-left-radius: ${userData.emailContainer?.borderRadius || "12px"};
      border-top-right-radius: ${userData.emailContainer?.borderRadius || "12px"};
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      padding: ${userData.header?.styling?.padding || "24px 32px"};
      text-align: ${userData.header?.styling?.textAlign || "center"};
      margin: 0 0 24px 0;
      overflow: hidden;
    }
    .custom-header h1 {
      color: ${userData.header?.styling?.titleColor || "#ffffff"};
      font-size: ${userData.header?.styling?.titleFontSize || "32px"};
      font-weight: 700;
      margin: 0 0 8px 0;
      line-height: 1.2;
    }
    .custom-header p {
      color: ${userData.header?.styling?.subtitleColor || "#ffffff"};
      font-size: ${userData.header?.styling?.subtitleFontSize || "18px"};
      margin: 0;
      opacity: 0.9;
    }
    .custom-order-button {
      display: inline-block;
      background: ${userData.orderButton?.styling?.backgroundColor || "linear-gradient(135deg, hsl(347, 91%, 51%) 0%, hsl(347, 91%, 45%) 100%)"};
      color: ${userData.orderButton?.styling?.color || "#ffffff"} !important;
      text-decoration: none !important;
      padding: ${userData.orderButton?.styling?.padding || "14px 28px"};
      border-radius: ${userData.orderButton?.styling?.borderRadius || "8px"};
      font-weight: ${userData.orderButton?.styling?.fontWeight || "600"};
      font-size: ${userData.orderButton?.styling?.fontSize || "16px"};
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px hsla(347, 91%, 51%, 0.3);
      line-height: 1.4;
      text-align: center;
      word-wrap: break-word;
      word-break: break-word;
      hyphens: auto;
      max-width: 100%;
      box-sizing: border-box;
      min-height: 48px;
      vertical-align: middle;
    }
    .usage-steps {
      background: ${userData.usageSteps?.styling?.backgroundColor || "linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)"};
      border: 1px solid ${userData.usageSteps?.styling?.borderColor || "#93c5fd"};
      border-radius: ${userData.usageSteps?.styling?.borderRadius || "8px"};
      padding: ${userData.usageSteps?.styling?.padding || "20px"};
      margin: 24px 0;
    }
    .usage-steps h4 {
      color: ${userData.usageSteps?.styling?.titleColor || "#1d4ed8"};
      font-size: 16px;
      font-weight: 600;
      margin: 0 0 12px 0;
    }
    .usage-steps ol {
      margin: 0;
      padding-left: 20px;
      color: ${userData.usageSteps?.styling?.textColor || "#1e40af"};
    }
    .usage-steps li {
      margin: 6px 0;
      font-size: 14px;
    }
    .custom-footer {
      background: ${userData.footer?.styling?.backgroundColor || "#f8fafc"};
      padding: ${userData.footer?.styling?.padding || "24px 32px"};
      text-align: ${userData.footer?.styling?.textAlign || "center"};
      border-top: 1px solid ${userData.footer?.styling?.borderColor || "#e2e8f0"};
    }
    .custom-footer .footer-text {
      font-size: ${userData.footer?.styling?.fontSize || "14px"};
      color: ${userData.footer?.styling?.textColor || "#64748b"};
      margin: 0 0 8px 0;
      line-height: 1.5;
    }
    .custom-footer .footer-link {
      color: ${userData.footer?.styling?.linkColor || "#F51042"};
      text-decoration: none;
    }
    .cta-container {
      text-align: ${userData.orderButton?.styling?.textAlign || "center"};
      margin: 32px 0;
      padding: 0 20px;
      overflow: hidden;
    }
    
    /* Mobile-specific styles */
    @media only screen and (max-width: 600px) {
      .email-container {
        max-width: ${userData.emailContainer?.mobileMaxWidth || "100%"} !important;
        padding: ${userData.emailContainer?.mobilePadding || "16px"} !important;
      }
      
      .greeting {
        font-size: calc(${getSectionData("greeting")?.styling?.fontSize || "18px"} * ${userData.emailContainer?.mobileFontScale ? parseFloat(userData.emailContainer.mobileFontScale) / 100 : 1}) !important;
      }
      
      .custom-message {
        font-size: calc(${getSectionData("custom-message")?.styling?.fontSize || "16px"} * ${userData.emailContainer?.mobileFontScale ? parseFloat(userData.emailContainer.mobileFontScale) / 100 : 1}) !important;
      }
      
      .custom-order-button {
        ${userData.emailContainer?.mobileButtonSize === "full-width" ? "width: calc(100% - 40px) !important; display: block !important; text-align: center !important; margin: 0 auto !important;" : ""}
        ${userData.emailContainer?.mobileButtonSize === "large" ? "padding: 16px 32px !important; font-size: 18px !important; min-height: 56px !important;" : ""}
        ${userData.emailContainer?.mobileButtonSize === "small" ? "padding: 10px 20px !important; font-size: 14px !important; min-height: 40px !important;" : ""}
        line-height: 1.3 !important;
        word-wrap: break-word !important;
        overflow-wrap: break-word !important;
        max-width: calc(100% - 40px) !important;
      }
      
      .promo-code-box {
        padding: 16px !important;
        margin: 16px 0 !important;
      }
      
      .promo-code {
        font-size: calc(${userData.promoCodeStyling?.fontSize || "24px"} * ${userData.emailContainer?.mobileFontScale ? parseFloat(userData.emailContainer.mobileFontScale) / 100 : 1}) !important;
      }
      
      .custom-header {
        padding: 20px 16px !important;
        border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")} !important;
        -webkit-border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")} !important;
        -moz-border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")} !important;
        border-top-left-radius: ${userData.emailContainer?.borderRadius || "12px"} !important;
        border-top-right-radius: ${userData.emailContainer?.borderRadius || "12px"} !important;
        overflow: hidden !important;
      }
      
      .custom-header h1 {
        font-size: calc(${userData.header?.styling?.titleFontSize || "32px"} * ${userData.emailContainer?.mobileFontScale ? parseFloat(userData.emailContainer.mobileFontScale) / 100 : 1}) !important;
      }
      
      .custom-header p {
        font-size: calc(${userData.header?.styling?.subtitleFontSize || "18px"} * ${userData.emailContainer?.mobileFontScale ? parseFloat(userData.emailContainer.mobileFontScale) / 100 : 1}) !important;
      }
      
      .usage-steps {
        padding: 16px !important;
        margin: 16px 0 !important;
      }
      
      .custom-footer {
        padding: 20px 16px !important;
      }
    }
    
    /* Additional mobile email client compatibility */
    @media screen and (max-width: 480px) {
      .custom-header {
        border-radius: ${userData.emailContainer?.borderRadius || "12px"} ${userData.emailContainer?.borderRadius || "12px"} 0 0 !important;
        -webkit-border-top-left-radius: ${userData.emailContainer?.borderRadius || "12px"} !important;
        -webkit-border-top-right-radius: ${userData.emailContainer?.borderRadius || "12px"} !important;
        -webkit-border-bottom-left-radius: 0 !important;
        -webkit-border-bottom-right-radius: 0 !important;
      }
    }
    
    /* Gmail mobile app specific fixes */
    u + .body .custom-header {
      border-radius: ${userData.emailContainer?.borderRadius || "12px"} ${userData.emailContainer?.borderRadius || "12px"} 0 0 !important;
    }
    
    /* Outlook mobile app specific fixes */
    .ExternalClass .custom-header {
      border-radius: ${userData.emailContainer?.borderRadius || "12px"} ${userData.emailContainer?.borderRadius || "12px"} 0 0 !important;
    }
  </style>
</head>
<body>
  <div class="email-container">
    <div class="custom-header" style="
      background: ${userData.header?.styling?.backgroundColor || "linear-gradient(135deg, #F51042 0%, #FF5470 100%)"};
      border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")};
      -webkit-border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")};
      -moz-border-radius: ${userData.header?.styling?.borderRadius || (userData.emailContainer?.borderRadius ? `${userData.emailContainer.borderRadius} ${userData.emailContainer.borderRadius} 0 0` : "12px 12px 0 0")};
      border-top-left-radius: ${userData.emailContainer?.borderRadius || "12px"};
      border-top-right-radius: ${userData.emailContainer?.borderRadius || "12px"};
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      padding: ${userData.header?.styling?.padding || "24px 32px"};
      text-align: ${userData.header?.styling?.textAlign || "center"};
      margin: 0 0 24px 0;
      overflow: hidden;
    ">
      <img 
        src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" 
        alt="Local Cooks" 
        style="max-width: 280px; height: auto; display: block; margin: 0 auto${userData.header?.title ? "; margin-bottom: 16px" : ""}"
      />
      ${userData.header?.title ? `<h1 style="color: ${userData.header?.styling?.titleColor || "#ffffff"}; font-size: ${userData.header?.styling?.titleFontSize || "32px"}; font-weight: 700; margin: 0 0 8px 0; line-height: 1.2;">${userData.header.title}</h1>` : ""}
      ${userData.header?.subtitle ? `<p style="color: ${userData.header?.styling?.subtitleColor || "#ffffff"}; font-size: ${userData.header?.styling?.subtitleFontSize || "18px"}; margin: 0; opacity: 0.9;">${userData.header.subtitle}</p>` : ""}
    </div>
    <div class="content">
      <!-- Enhanced Email Design -->
      <h2 class="greeting">${finalGreeting}</h2>
      
      ${generateDivider()}
      
      <div class="custom-message">
        ${finalMessage}
      </div>
      
      ${generateDivider()}
      
      ${userData.promoCode ? `
        <div style="text-align: center; margin: 32px 0;">
          <div class="promo-label" style="margin-bottom: 12px;">${userData.promoCodeLabel || "Use promo code:"}</div>
          <div class="promo-code-box">
            <div class="promo-code">${userData.promoCode}</div>
          </div>
        </div>
        ${generateDivider()}
      ` : ""}

      <!-- Usage Steps Section (Always Show Unless Explicitly Disabled) -->
      ${userData.usageSteps?.enabled !== false ? generateUsageStepsSection() : ""}

      <!-- Custom Sections (if any) -->
      ${userData.sections && (Array.isArray(userData.sections) ? userData.sections.length > 0 : Object.keys(userData.sections).length > 0) ? generateAdvancedSections(Array.isArray(userData.sections) ? userData.sections : Object.values(userData.sections)) + generateDivider() : ""}
      
      <!-- Call to Action Button -->
      <div class="cta-container">
        <a href="${userData.orderButton?.url || getPromoUrl()}" class="custom-order-button">
          ${userData.orderButton?.text || "\u{1F31F} Start Shopping Now"}
        </a>
      </div>
      
      <div class="divider"></div>
    </div>
    <div class="custom-footer">
      ${userData.footer?.mainText ? `<p class="footer-text"><strong>${userData.footer.mainText}</strong></p>` : `<p class="footer-text">Thank you for being part of the <strong>${organizationName}</strong> community!</p>`}
      
      ${userData.footer?.showContact !== false && userData.footer?.contactText ? `
        <p class="footer-text">
          ${userData.footer.contactText.includes("@") ? userData.footer.contactText.replace(/(\S+@\S+)/g, '<a href="mailto:$1" class="footer-link">$1</a>') : userData.footer.contactText}
        </p>
      ` : userData.footer?.showContact !== false ? `
        <p class="footer-text">Questions? Contact us at <a href="mailto:${supportEmail}" class="footer-link">${supportEmail}</a>.</p>
      ` : ""}
      
      ${userData.footer?.showCopyright !== false ? `
        <div style="height: 1px; background: linear-gradient(90deg, transparent 0%, ${userData.footer?.styling?.borderColor || "#e2e8f0"} 50%, transparent 100%); margin: 16px 0;"></div>
        <p class="footer-text" style="opacity: 0.8; font-size: ${userData.footer?.styling?.fontSize ? parseInt(userData.footer.styling.fontSize) - 2 + "px" : "12px"};">
          ${userData.footer?.copyrightText || `&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} ${organizationName}. All rights reserved.`}
        </p>
      ` : ""}
      
      <!-- Unsubscribe Link -->
      <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid ${userData.footer?.styling?.borderColor || "#e2e8f0"};">
        <p style="text-align: center; font-size: 11px; color: #6b7280; margin: 0;">
          Don't want to receive these emails? 
          <a href="${getWebsiteUrl()}/unsubscribe?email=${encodeURIComponent(userData.email)}" 
             style="color: #F51042; text-decoration: underline;">
            Unsubscribe here
          </a>
        </p>
      </div>
    </div>
  </div>
</body>
</html>`;
      return {
        to: userData.email,
        subject,
        text: generatePlainText(userData.email, userData.promoCode, finalMessage),
        html,
        headers: {
          "X-Priority": "3",
          "X-MSMail-Priority": "Normal",
          "Importance": "Normal",
          "List-Unsubscribe": `<mailto:${getUnsubscribeEmail()}>`
        }
      };
    };
    generateChefAllDocumentsApprovedEmail = (userData) => {
      const firstName = userData.fullName.split(" ")[0];
      const subject = "All Documents Approved - Local Cooks";
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">All your submitted documents have been approved by our verification team. You are now fully verified and can start using Local Cooks as a chef.</p>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; All Documents Approved</span>
      </div>
      <p class="message" style="margin-top: 24px; margin-bottom: 8px; font-weight: 600; color: #1e293b;">Approved documents:</p>
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="margin: 0 0 24px 4px;">
        ${userData.approvedDocuments.map((doc) => `<tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">${doc}</td>
        </tr>`).join("")}
      </table>
      ${userData.adminFeedback ? `
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Feedback:</span> <strong style="color: #1e293b;">${userData.adminFeedback}</strong></p>
      </div>` : ""}
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${getDashboardUrl()}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Access Your Dashboard</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Warmly,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

All your submitted documents have been approved by our verification team. You are now fully verified and can start using Local Cooks as a chef.

Approved documents:
${userData.approvedDocuments.map((doc) => `\u2022 ${doc}`).join("\n")}

${userData.adminFeedback ? `Feedback: ${userData.adminFeedback}

` : ""}Access your dashboard: ${getDashboardUrl()}

If you have any questions, contact us at support@localcook.shop

Warmly,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: userData.email,
        subject,
        text: text2,
        html
      };
    };
    generateManagerMagicLinkEmail = (userData) => {
      const subject = "Set Up Your Manager Account - Local Cooks";
      const firstName = userData.name.split(" ")[0];
      const baseUrl = getSubdomainUrl("kitchen");
      const resetUrl = `${baseUrl}/password-reset?token=${userData.resetToken}&role=manager`;
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Your manager account has been created for the Local Cooks commercial kitchen booking system.</p>
      <p class="message" style="margin-bottom: 10px;">Click the button below to set up your password and access your manager dashboard. Once set up, you&#8217;ll be able to:</p>
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="margin: 0 0 24px 4px;">
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Manage kitchen schedules and availability</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">View and approve booking requests from chefs</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Set up your location&#8217;s pricing and policies</td>
        </tr>
      </table>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${resetUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Set Up Password</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

Your manager account has been created for the Local Cooks commercial kitchen booking system.

Set up your password: ${resetUrl}

Once set up, you'll be able to:
\u2022 Manage kitchen schedules and availability
\u2022 View and approve booking requests from chefs
\u2022 Set up your location's pricing and policies

If you have any questions, contact us at support@localcook.shop

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return { to: userData.email, subject, text: text2, html };
    };
    generateManagerCredentialsEmail = (userData) => {
      const subject = "Your Manager Account - Local Cooks";
      const firstName = (userData.name || "Manager").split(" ")[0];
      const loginUrl = `${getSubdomainUrl("kitchen")}/manager/login`;
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Your manager account has been created for the Local Cooks kitchen booking system.</p>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Your login credentials:</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 16px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Username:</span> <strong style="color: #1e293b; font-family: 'Courier New', monospace;">${userData.username}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Password:</span> <strong style="color: #1e293b; font-family: 'Courier New', monospace;">${userData.password}</strong></p>
      </div>
      <div style="background: #fffbeb; border: 1px solid #fef3c7; border-radius: 8px; padding: 12px 16px; margin: 0 0 24px 0;">
        <p style="font-size: 14px; line-height: 1.6; color: #92400e; margin: 0;"><strong>Important:</strong> Please change your password after your first login for security.</p>
      </div>
      <p class="message" style="margin-bottom: 20px;">You&#8217;ll be able to manage kitchen schedules, view bookings, and set up availability for your locations.</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${loginUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Login Now</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

Your manager account has been created for the Local Cooks kitchen booking system.

Your login credentials:
Username: ${userData.username}
Password: ${userData.password}

Important: Please change your password after your first login for security.

Login at: ${loginUrl}

If you have any questions, contact us at support@localcook.shop

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return { to: userData.email, subject, text: text2, html };
    };
    generateBookingNotificationEmail = (bookingData) => {
      const chefFirstName = bookingData.chefName.split(" ")[0];
      const chefLastName = bookingData.chefName.includes(" ") ? bookingData.chefName.split(" ").slice(1).join(" ") : "";
      const subject = `New Booking Request from ${chefFirstName}${chefLastName ? " " + chefLastName : ""}`;
      const timezone = bookingData.timezone || "America/St_Johns";
      const locationName = bookingData.locationName || bookingData.kitchenName;
      const bookingDetailsUrl = `${getSubdomainUrl("kitchen")}/manager/booking/${bookingData.bookingId}`;
      const dashboardUrl = getDashboardUrl("kitchen");
      const managerFirstName = bookingData.managerName ? bookingData.managerName.split(" ")[0] : bookingData.managerEmail.split("@")[0];
      const bookingDateObj = bookingData.bookingDate instanceof Date ? bookingData.bookingDate : new Date(bookingData.bookingDate);
      const formattedDate = bookingDateObj.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const calendarTitle = `Kitchen Booking - ${bookingData.kitchenName}`;
      const calendarDescription = `Kitchen booking with ${bookingData.chefName} for ${bookingData.kitchenName}.

Chef: ${bookingData.chefName}
Date: ${bookingDateObj.toLocaleDateString()}
Time: ${bookingData.startTime} - ${bookingData.endTime}
Status: Pending Approval${bookingData.specialNotes ? `

Notes: ${bookingData.specialNotes}` : ""}`;
      const calendarUrl = generateCalendarUrl(
        bookingData.managerEmail,
        calendarTitle,
        bookingData.bookingDate,
        bookingData.startTime,
        bookingData.endTime,
        locationName,
        calendarDescription,
        timezone
      );
      const bookingDateStr = bookingData.bookingDate instanceof Date ? bookingData.bookingDate.toISOString().split("T")[0] : bookingData.bookingDate.split("T")[0];
      const startDateTime = createBookingDateTime(bookingDateStr, bookingData.startTime, timezone);
      const endDateTime = createBookingDateTime(bookingDateStr, bookingData.endTime, timezone);
      const eventUid = generateEventUid(bookingData.bookingDate, bookingData.startTime, locationName);
      const icsContent = generateIcsFile(
        calendarTitle,
        startDateTime,
        endDateTime,
        locationName,
        calendarDescription,
        getSupportEmail(),
        [bookingData.managerEmail],
        // Manager is the primary attendee for this email
        eventUid
        // Use consistent UID for synchronization
      );
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${managerFirstName},</h2>
      <p class="message" style="margin-bottom: 24px;">You've received a new booking request for ${bookingData.kitchenName} that needs your review.</p>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Chef Information:</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 16px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Name:</span> <strong style="color: #1e293b;">${bookingData.chefName}</strong></p>
      </div>
      <div style="margin: 0 0 24px 0; text-align: center;">
        <a href="${dashboardUrl}" style="display: inline-block; padding: 10px 24px; background: #f1f5f9; color: #475569 !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; border: 1px solid #e2e8f0;">View Chef's Profile</a>
      </div>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Booking Request Details:</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        ${bookingData.referenceCode ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Reference:</span> <strong style="color: #1e293b; font-family: monospace;">${bookingData.referenceCode}</strong></p>` : ""}
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Kitchen:</span> <strong style="color: #1e293b;">${bookingData.kitchenName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Date:</span> <strong style="color: #1e293b;">${formattedDate}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Time:</span> <strong style="color: #1e293b;">${bookingData.startTime} &#8211; ${bookingData.endTime}</strong></p>
      </div>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Next Steps:</p>
      <p class="message" style="margin-bottom: 20px;">Please review this request and respond within 24&#8211;48 hours so ${chefFirstName} can confirm their production schedule.</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${bookingDetailsUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Review &amp; Respond to Request</a>
      </div>
      <p class="message" style="margin-top: 20px;">You can approve or decline this booking directly from your dashboard. If you need to discuss any details with the chef, you can use the built-in chat feature.</p>
      <p style="font-size: 13px; line-height: 1.6; color: #94a3b8; margin: 20px 0 0 0;">A calendar invite has been attached to this email. You can also <a href="${calendarUrl}" target="_blank" style="color: hsl(347, 91%, 51%); text-decoration: none;">add it to your calendar</a>.</p>
      <p style="font-size: 13px; line-height: 1.6; color: #94a3b8; margin: 16px 0 0 0;">If you have any questions about this request, simply reply to this email or contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${managerFirstName},

You've received a new booking request for ${bookingData.kitchenName} that needs your review.

Chef Information:
Name: ${bookingData.chefName}

Booking Request Details:
Kitchen: ${bookingData.kitchenName}
Date: ${formattedDate}
Time: ${bookingData.startTime} - ${bookingData.endTime}

Next Steps:
Please review this request and respond within 24-48 hours so ${chefFirstName} can confirm their production schedule.

Review & Respond: ${bookingDetailsUrl}

You can approve or decline this booking directly from your dashboard. If you need to discuss any details with the chef, you can use the built-in chat feature.

Add to calendar: ${calendarUrl}

If you have any questions about this request, simply reply to this email or contact us at support@localcook.shop

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: bookingData.managerEmail,
        subject,
        text: text2,
        html,
        attachments: [{
          filename: "kitchen-booking.ics",
          content: icsContent,
          contentType: "text/calendar; charset=utf-8; method=REQUEST"
        }]
      };
    };
    generateBookingPaymentReceivedEmail = (data) => {
      const subject = `Payment Received - ${data.kitchenName} Booking`;
      const formattedAmount = `$${(data.amountCents / 100).toFixed(2)} ${data.currency}`;
      const bookingDateObj = data.bookingDate instanceof Date ? data.bookingDate : new Date(data.bookingDate);
      const formattedDate = bookingDateObj.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const bookingDetailsUrl = `${getSubdomainUrl("kitchen")}/manager/booking/${data.bookingId}`;
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Payment Received</h2>
      <p class="message" style="margin-bottom: 20px;">Payment has been received for a kitchen booking. The booking is now confirmed and ready.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Chef:</span> <strong style="color: #1e293b;">${data.chefName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Kitchen:</span> <strong style="color: #1e293b;">${data.kitchenName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Date:</span> <strong style="color: #1e293b;">${formattedDate}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Time:</span> <strong style="color: #1e293b;">${data.startTime} &#8211; ${data.endTime}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Amount:</span> <strong style="color: #16a34a;">${formattedAmount}</strong></p>
      </div>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; Paid</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${bookingDetailsUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View Booking Details</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Payment Received

Chef: ${data.chefName}
Kitchen: ${data.kitchenName}
Date: ${formattedDate}
Time: ${data.startTime} \u2013 ${data.endTime}
Amount: ${formattedAmount}

The booking is now confirmed and ready.

View booking: ${bookingDetailsUrl}

If you have any questions, contact us at support@localcook.shop

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: data.managerEmail,
        subject,
        text: text2,
        html
      };
    };
    generateBookingCancellationNotificationEmail = (bookingData) => {
      const subject = `Booking Cancelled - ${bookingData.kitchenName}`;
      const formattedDate = new Date(bookingData.bookingDate).toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Booking Cancelled</h2>
      <p class="message" style="margin-bottom: 20px;">A chef has cancelled their booking at ${bookingData.kitchenName}.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Chef:</span> <strong style="color: #1e293b;">${bookingData.chefName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Kitchen:</span> <strong style="color: #1e293b;">${bookingData.kitchenName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Date:</span> <strong style="color: #1e293b;">${formattedDate}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Time:</span> <strong style="color: #1e293b;">${bookingData.startTime} &#8211; ${bookingData.endTime}</strong></p>
        ${bookingData.cancellationReason ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 8px 0 0 0;"><span style="color: #64748b;">Reason:</span> <strong style="color: #1e293b;">${bookingData.cancellationReason}</strong></p>` : ""}
      </div>
      <div style="margin: 0 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f8fafc; color: #64748b; border: 1px solid #e2e8f0; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">Cancelled</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${getSubdomainUrl("kitchen")}/manager/bookings" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View Bookings</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Booking Cancelled

Chef: ${bookingData.chefName}
Kitchen: ${bookingData.kitchenName}
Date: ${formattedDate}
Time: ${bookingData.startTime} \u2013 ${bookingData.endTime}
${bookingData.cancellationReason ? `Reason: ${bookingData.cancellationReason}
` : ""}
View bookings: ${getSubdomainUrl("kitchen")}/manager/bookings

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return { to: bookingData.managerEmail, subject, text: text2, html };
    };
    generateBookingStatusChangeNotificationEmail = (bookingData) => {
      const chefFirstName = bookingData.chefName.split(" ")[0];
      const timezone = bookingData.timezone || "America/St_Johns";
      const locationName = bookingData.locationName || bookingData.kitchenName;
      const dashboardUrl = getDashboardUrl("kitchen");
      const managerFirstName = bookingData.managerName ? bookingData.managerName.split(" ")[0] : bookingData.managerEmail.split("@")[0];
      const bookingDateObj = bookingData.bookingDate instanceof Date ? bookingData.bookingDate : new Date(bookingData.bookingDate);
      const formattedDate = bookingDateObj.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const [startH, startM] = bookingData.startTime.split(":").map(Number);
      const [endH, endM] = bookingData.endTime.split(":").map(Number);
      const durationMins = endH * 60 + endM - (startH * 60 + startM);
      const durationHrs = Math.floor(durationMins / 60);
      const durationRemMins = durationMins % 60;
      const durationStr = durationRemMins > 0 ? `${durationHrs}h ${durationRemMins}m` : `${durationHrs}h`;
      const subject = `You Confirmed a Booking for ${formattedDate}`;
      const calendarTitle = `Kitchen Booking - ${bookingData.kitchenName}`;
      const calendarDescription = `Confirmed kitchen booking with ${bookingData.chefName} for ${bookingData.kitchenName}.

Chef: ${bookingData.chefName}
Date: ${bookingDateObj.toLocaleDateString()}
Time: ${bookingData.startTime} - ${bookingData.endTime}
Status: Confirmed`;
      const calendarUrl = generateCalendarUrl(
        bookingData.managerEmail,
        calendarTitle,
        bookingData.bookingDate,
        bookingData.startTime,
        bookingData.endTime,
        locationName,
        calendarDescription,
        timezone
      );
      const bookingDateStr = bookingData.bookingDate instanceof Date ? bookingData.bookingDate.toISOString().split("T")[0] : bookingData.bookingDate.split("T")[0];
      const startDateTime = createBookingDateTime(bookingDateStr, bookingData.startTime, timezone);
      const endDateTime = createBookingDateTime(bookingDateStr, bookingData.endTime, timezone);
      const eventUid = generateEventUid(bookingData.bookingDate, bookingData.startTime, locationName);
      const icsContent = generateIcsFile(
        calendarTitle,
        startDateTime,
        endDateTime,
        locationName,
        calendarDescription,
        getSupportEmail(),
        [bookingData.managerEmail],
        // Manager is the primary attendee for this email
        eventUid
        // Use consistent UID for synchronization
      );
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${managerFirstName},</h2>
      <p class="message" style="margin-bottom: 24px;">Thank you for confirming this booking. The chef has been notified, and your kitchen is now reserved for their session.</p>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Booking Details:</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Chef:</span> <strong style="color: #1e293b;">${bookingData.chefName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Date:</span> <strong style="color: #1e293b;">${formattedDate}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Time:</span> <strong style="color: #1e293b;">${bookingData.startTime} &#8211; ${bookingData.endTime} (${durationStr})</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Kitchen:</span> <strong style="color: #1e293b;">${bookingData.kitchenName}</strong></p>
        ${bookingData.addons ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Equipment/Storage:</span> <strong style="color: #1e293b;">${bookingData.addons}</strong></p>` : ""}
      </div>
      <div style="margin: 0 0 24px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; Confirmed</span>
      </div>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Add to Your Calendar:</p>
      <div style="margin: 0 0 8px 0; text-align: center;">
        <a href="${calendarUrl}" target="_blank" style="display: inline-block; padding: 10px 24px; background: #f1f5f9; color: #475569 !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; border: 1px solid #e2e8f0; margin: 0 8px 8px 0;">&#128197; Add to Google Calendar</a>
        <a href="cid:kitchen-booking.ics" style="display: inline-block; padding: 10px 24px; background: #f1f5f9; color: #475569 !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; border: 1px solid #e2e8f0; margin: 0 0 8px 0;">&#128197; Download ICS File</a>
      </div>
      <p class="message" style="margin-top: 24px; margin-bottom: 8px; font-weight: 600; color: #1e293b;">Before the Session:</p>
      <p class="message" style="margin-bottom: 20px;">The chef will arrive at ${bookingData.startTime}. Please ensure the kitchen and requested equipment are accessible and ready. You can reach ${chefFirstName} directly through the chat in your dashboard if you need to coordinate any details.</p>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Need to Cancel or Reschedule?</p>
      <p class="message" style="margin-bottom: 20px;">If something comes up, please use the dashboard tools and notify the chef as soon as possible. Cancellations within 24 hours may affect your booking acceptance rate.</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Go to Your Dashboard</a>
      </div>
      <p style="font-size: 13px; line-height: 1.6; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions or need assistance, simply reply to this email or contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <p class="message" style="margin-top: 20px; color: #64748b;">Thank you for being part of Local Cooks.</p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${managerFirstName},

Thank you for confirming this booking. The chef has been notified, and your kitchen is now reserved for their session.

Booking Details:
Chef: ${bookingData.chefName}
Date: ${formattedDate}
Time: ${bookingData.startTime} \u2013 ${bookingData.endTime} (${durationStr})
Kitchen: ${bookingData.kitchenName}
${bookingData.addons ? `Equipment/Storage: ${bookingData.addons}
` : ""}
Add to your calendar: ${calendarUrl}

Before the Session:
The chef will arrive at ${bookingData.startTime}. Please ensure the kitchen and requested equipment are accessible and ready. You can reach ${chefFirstName} directly through the chat in your dashboard if you need to coordinate any details.

Need to Cancel or Reschedule?
If something comes up, please use the dashboard tools and notify the chef as soon as possible. Cancellations within 24 hours may affect your booking acceptance rate.

Dashboard: ${dashboardUrl}

If you have any questions or need assistance, simply reply to this email or contact us at support@localcook.shop

Thank you for being part of Local Cooks.

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: bookingData.managerEmail,
        subject,
        text: text2,
        html,
        attachments: [{
          filename: "kitchen-booking.ics",
          content: icsContent,
          contentType: "text/calendar; charset=utf-8; method=REQUEST"
        }]
      };
    };
    generateBookingRequestEmail = (bookingData) => {
      const subject = `Your Booking Request Has Been Submitted`;
      const timezone = bookingData.timezone || "America/St_Johns";
      const locationName = bookingData.locationName || bookingData.kitchenName;
      const dashboardUrl = getDashboardUrl();
      const firstName = bookingData.chefName.split(" ")[0];
      const bookingDateObj = bookingData.bookingDate instanceof Date ? bookingData.bookingDate : new Date(bookingData.bookingDate);
      const formattedDate = bookingDateObj.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const calendarTitle = `Kitchen Booking - ${bookingData.kitchenName}`;
      const calendarDescription = `Kitchen booking request for ${bookingData.kitchenName}.

Date: ${bookingDateObj.toLocaleDateString()}
Time: ${bookingData.startTime} - ${bookingData.endTime}
Status: Pending Approval${bookingData.specialNotes ? `

Notes: ${bookingData.specialNotes}` : ""}`;
      const calendarUrl = generateCalendarUrl(
        bookingData.chefEmail,
        calendarTitle,
        bookingData.bookingDate,
        bookingData.startTime,
        bookingData.endTime,
        locationName,
        calendarDescription,
        timezone
      );
      const bookingDateStr = bookingData.bookingDate instanceof Date ? bookingData.bookingDate.toISOString().split("T")[0] : bookingData.bookingDate.split("T")[0];
      const startDateTime = createBookingDateTime(bookingDateStr, bookingData.startTime, timezone);
      const endDateTime = createBookingDateTime(bookingDateStr, bookingData.endTime, timezone);
      const eventUid = generateEventUid(bookingData.bookingDate, bookingData.startTime, locationName);
      const icsContent = generateIcsFile(
        calendarTitle,
        startDateTime,
        endDateTime,
        locationName,
        calendarDescription,
        getSupportEmail(),
        [bookingData.chefEmail],
        // Chef is the primary attendee
        eventUid
        // Use consistent UID for synchronization
      );
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Thank you for submitting your booking request for ${bookingData.kitchenName}. We&#8217;ve sent it to the kitchen manager and are awaiting their confirmation.</p>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Request Details:</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Kitchen:</span> <strong style="color: #1e293b;">${bookingData.kitchenName}</strong></p>
        ${bookingData.locationAddress ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Location:</span> <strong style="color: #1e293b;">${bookingData.locationAddress}</strong></p>` : locationName !== bookingData.kitchenName ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Location:</span> <strong style="color: #1e293b;">${locationName}</strong></p>` : ""}
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Date:</span> <strong style="color: #1e293b;">${formattedDate}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Time:</span> <strong style="color: #1e293b;">${bookingData.startTime} &#8211; ${bookingData.endTime}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Status:</span> <strong style="color: #f59e0b;">Pending Manager Confirmation</strong></p>
      </div>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">What happens next:</p>
      <p class="message" style="margin-bottom: 20px;">The kitchen manager will review your request and respond within 24&#8211;48 hours. You&#8217;ll receive an email notification as soon as they confirm or decline your booking.</p>
      <p class="message" style="margin-bottom: 20px;">In the meantime, you can use the built-in chat with the kitchen manager if you need to clarify any details about your request.</p>
      <p class="message" style="margin-bottom: 20px;">You can also check your request status anytime from your dashboard.</p>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fffbeb; color: #d97706; border: 1px solid #fef3c7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#9679; Pending Confirmation</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${calendarUrl}" target="_blank" style="display: inline-block; padding: 10px 24px; background: #f1f5f9; color: #475569 !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; border: 1px solid #e2e8f0; margin: 0 8px 0 0;">Add to Calendar</a>
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View My Bookings</a>
      </div>
      <p style="font-size: 13px; line-height: 1.6; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, simply reply to this email or contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

Thank you for submitting your booking request for ${bookingData.kitchenName}. We've sent it to the kitchen manager and are awaiting their confirmation.

Request Details:
Kitchen: ${bookingData.kitchenName}
${bookingData.locationAddress ? `Location: ${bookingData.locationAddress}
` : ""}Date: ${formattedDate}
Time: ${bookingData.startTime} \u2013 ${bookingData.endTime}
Status: Pending Manager Confirmation

What happens next:
The kitchen manager will review your request and respond within 24\u201348 hours. You'll receive an email notification as soon as they confirm or decline your booking.

In the meantime, you can use the built-in chat with the kitchen manager if you need to clarify any details about your request.

You can also check your request status anytime from your dashboard: ${dashboardUrl}

Add to calendar: ${calendarUrl}

If you have any questions, simply reply to this email or contact us at support@localcook.shop

Best,
The Local Cooks Team

${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: bookingData.chefEmail,
        subject,
        text: text2,
        html,
        attachments: [{
          filename: "kitchen-booking.ics",
          content: icsContent,
          contentType: "text/calendar; charset=utf-8; method=REQUEST"
        }]
      };
    };
    generateBookingConfirmationEmail = (bookingData) => {
      const timezone = bookingData.timezone || "America/St_Johns";
      const locationName = bookingData.locationName || bookingData.kitchenName;
      const dashboardUrl = getDashboardUrl();
      const firstName = bookingData.chefName.split(" ")[0];
      const bookingDateObj = bookingData.bookingDate instanceof Date ? bookingData.bookingDate : new Date(bookingData.bookingDate);
      const formattedDate = bookingDateObj.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const [startH, startM] = bookingData.startTime.split(":").map(Number);
      const [endH, endM] = bookingData.endTime.split(":").map(Number);
      const durationMins = endH * 60 + endM - (startH * 60 + startM);
      const durationHrs = Math.floor(durationMins / 60);
      const durationRemMins = durationMins % 60;
      const durationStr = durationRemMins > 0 ? `${durationHrs}h ${durationRemMins}m` : `${durationHrs}h`;
      const subject = `Your Kitchen Booking Is Confirmed for ${formattedDate}`;
      const calendarTitle = `Kitchen Booking - ${bookingData.kitchenName}`;
      const calendarDescription = `Confirmed kitchen booking for ${bookingData.kitchenName}.

Date: ${bookingDateObj.toLocaleDateString()}
Time: ${bookingData.startTime} - ${bookingData.endTime}
Status: Confirmed${bookingData.specialNotes ? `

Notes: ${bookingData.specialNotes}` : ""}`;
      const calendarUrl = generateCalendarUrl(
        bookingData.chefEmail,
        calendarTitle,
        bookingData.bookingDate,
        bookingData.startTime,
        bookingData.endTime,
        locationName,
        calendarDescription,
        timezone
      );
      const bookingDateStr = bookingData.bookingDate instanceof Date ? bookingData.bookingDate.toISOString().split("T")[0] : bookingData.bookingDate.split("T")[0];
      const startDateTime = createBookingDateTime(bookingDateStr, bookingData.startTime, timezone);
      const endDateTime = createBookingDateTime(bookingDateStr, bookingData.endTime, timezone);
      const eventUid = generateEventUid(bookingData.bookingDate, bookingData.startTime, locationName);
      const icsContent = generateIcsFile(
        calendarTitle,
        startDateTime,
        endDateTime,
        locationName,
        calendarDescription,
        getSupportEmail(),
        [bookingData.chefEmail],
        // Chef is the primary attendee
        eventUid
        // Use consistent UID for synchronization
      );
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 24px;">Great news &#8212; your booking at ${bookingData.kitchenName} has been confirmed!</p>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Booking Details:</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Kitchen:</span> <strong style="color: #1e293b;">${bookingData.kitchenName}</strong></p>
        ${bookingData.locationAddress ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Location:</span> <strong style="color: #1e293b;">${bookingData.locationAddress}</strong></p>` : locationName !== bookingData.kitchenName ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Location:</span> <strong style="color: #1e293b;">${locationName}</strong></p>` : ""}
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Date:</span> <strong style="color: #1e293b;">${formattedDate}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Time:</span> <strong style="color: #1e293b;">${bookingData.startTime} &#8211; ${bookingData.endTime} (${durationStr})</strong></p>
        ${bookingData.addons ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Equipment/Storage Booked:</span> <strong style="color: #1e293b;">${bookingData.addons}</strong></p>` : ""}
      </div>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; Confirmed</span>
      </div>
      <p class="message" style="margin-top: 24px; margin-bottom: 8px; font-weight: 600; color: #1e293b;">Add to Your Calendar:</p>
      <div style="margin: 0 0 8px 0; text-align: center;">
        <a href="${calendarUrl}" target="_blank" style="display: inline-block; padding: 10px 24px; background: #f1f5f9; color: #475569 !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; border: 1px solid #e2e8f0; margin: 0 8px 8px 0;">&#128197; Add to Google Calendar</a>
        <a href="cid:kitchen-booking.ics" style="display: inline-block; padding: 10px 24px; background: #f1f5f9; color: #475569 !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; border: 1px solid #e2e8f0; margin: 0 0 8px 0;">&#128197; Download ICS File</a>
      </div>
      <p style="font-size: 13px; line-height: 1.6; color: #94a3b8; margin: 0 0 24px 0; text-align: center;">(Or open the attached calendar invite to add this booking to your preferred calendar app)</p>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Before Your Session:</p>
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="margin: 0 0 24px 4px;">
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Arrive 10&#8211;15 minutes early for check-in</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Review the kitchen&#8217;s specific terms and policies in your dashboard</td>
        </tr>
      </table>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Need to Make Changes?</p>
      <p class="message" style="margin-bottom: 20px;">If you need to reschedule or cancel, please use your dashboard.</p>
      <p class="message" style="margin-bottom: 20px;">You can also reach the kitchen manager directly through the chat in your dashboard.</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Go to Your Dashboard</a>
      </div>
      <p style="font-size: 13px; line-height: 1.6; color: #94a3b8; margin: 24px 0 0 0;">Contact us anytime at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a> or reply to this email.</p>
      <p class="message" style="margin-top: 20px; font-style: italic; color: #64748b;">We&#8217;re excited for your upcoming session and look forward to supporting your culinary work!</p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

Great news \u2014 your booking at ${bookingData.kitchenName} has been confirmed!

Booking Details:
Kitchen: ${bookingData.kitchenName}
${bookingData.locationAddress ? `Location: ${bookingData.locationAddress}
` : ""}Date: ${formattedDate}
Time: ${bookingData.startTime} \u2013 ${bookingData.endTime} (${durationStr})
${bookingData.addons ? `Equipment/Storage Booked: ${bookingData.addons}
` : ""}
Add to your calendar: ${calendarUrl}
(Or open the attached calendar invite to add this booking to your preferred calendar app)

Before Your Session:
\u2022 Arrive 10\u201315 minutes early for check-in
\u2022 Review the kitchen's specific terms and policies in your dashboard

Need to Make Changes?
If you need to reschedule or cancel, please use your dashboard: ${dashboardUrl}
You can also reach the kitchen manager directly through the chat in your dashboard.

Contact us anytime at support@localcook.shop or reply to this email.

We're excited for your upcoming session and look forward to supporting your culinary work!

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: bookingData.chefEmail,
        subject,
        text: text2,
        html,
        attachments: [{
          filename: "kitchen-booking.ics",
          content: icsContent,
          contentType: "text/calendar; charset=utf-8; method=REQUEST"
        }]
      };
    };
    generateBookingCancellationEmail = (bookingData) => {
      const firstName = bookingData.chefName.split(" ")[0];
      const subject = `Booking Cancelled - ${bookingData.kitchenName}`;
      const formattedDate = new Date(bookingData.bookingDate).toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Your kitchen booking has been cancelled.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Kitchen:</span> <strong style="color: #1e293b;">${bookingData.kitchenName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Date:</span> <strong style="color: #1e293b;">${formattedDate}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Time:</span> <strong style="color: #1e293b;">${bookingData.startTime} &#8211; ${bookingData.endTime}</strong></p>
        ${bookingData.cancellationReason ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 8px 0 0 0;"><span style="color: #64748b;">Reason:</span> <strong style="color: #1e293b;">${bookingData.cancellationReason}</strong></p>` : ""}
      </div>
      <div style="margin: 0 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f8fafc; color: #64748b; border: 1px solid #e2e8f0; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">Cancelled</span>
      </div>
      <p class="message" style="margin-top: 24px; margin-bottom: 20px;">You can make a new booking anytime from your dashboard.</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${getSubdomainUrl("chef")}/book-kitchen" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Browse Available Kitchens</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

Your kitchen booking has been cancelled.

Kitchen: ${bookingData.kitchenName}
Date: ${formattedDate}
Time: ${bookingData.startTime} \u2013 ${bookingData.endTime}
${bookingData.cancellationReason ? `Reason: ${bookingData.cancellationReason}
` : ""}
You can make a new booking anytime from your dashboard: ${getSubdomainUrl("chef")}/book-kitchen

If you have any questions, contact us at support@localcook.shop

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return { to: bookingData.chefEmail, subject, text: text2, html };
    };
    generateKitchenAvailabilityChangeEmail = (data) => {
      const firstName = data.chefName.split(" ")[0];
      const subject = `Kitchen Availability Update - ${data.kitchenName}`;
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">The availability for <strong>${data.kitchenName}</strong> has been updated. Please check the updated availability before making your next booking.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Kitchen:</span> <strong style="color: #1e293b;">${data.kitchenName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Change:</span> <strong style="color: #1e293b;">${data.changeType}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Details:</span> <strong style="color: #1e293b;">${data.details}</strong></p>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${getSubdomainUrl("chef")}/book-kitchen" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View Kitchen Availability</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

The availability for ${data.kitchenName} has been updated.

Change: ${data.changeType}
Details: ${data.details}

View availability: ${getSubdomainUrl("chef")}/book-kitchen

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return { to: data.chefEmail, subject, text: text2, html };
    };
    generateKitchenSettingsChangeEmail = (data) => {
      const firstName = data.name.split(" ")[0];
      const subject = `Kitchen Settings Updated - ${data.kitchenName}`;
      const ctaUrl = data.isChef ? `${getSubdomainUrl("chef")}/book-kitchen` : getDashboardUrl("kitchen");
      const ctaLabel = data.isChef ? "View Kitchen Details" : "View Kitchen Settings";
      const extraNote = data.isChef ? " This may affect your existing or future bookings." : "";
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">The settings for <strong>${data.kitchenName}</strong> have been updated.${extraNote}</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Kitchen:</span> <strong style="color: #1e293b;">${data.kitchenName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Changes:</span> <strong style="color: #1e293b;">${data.changes}</strong></p>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${ctaUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">${ctaLabel}</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

The settings for ${data.kitchenName} have been updated.${extraNote}

Changes: ${data.changes}

${ctaLabel}: ${ctaUrl}

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return { to: data.email, subject, text: text2, html };
    };
    generateChefProfileRequestEmail = (data) => {
      const subject = `Chef Access Request - ${data.locationName}`;
      const reviewUrl = `${getSubdomainUrl("kitchen")}/manager/applications`;
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">New Chef Access Request</h2>
      <p class="message" style="margin-bottom: 20px;">A chef has requested access to your location and kitchen facilities. Please review and approve or reject from your manager dashboard.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Chef:</span> <strong style="color: #1e293b;">${data.chefName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Email:</span> <strong style="color: #1e293b;">${data.chefEmail}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Location:</span> <strong style="color: #1e293b;">${data.locationName}</strong></p>
      </div>
      <div style="margin: 0 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fffbeb; color: #d97706; border: 1px solid #fef3c7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#9679; Pending Review</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${reviewUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Review Chef Request</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
New Chef Access Request

Chef: ${data.chefName} (${data.chefEmail})
Location: ${data.locationName}
Status: Pending Review

Review: ${reviewUrl}

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return { to: data.managerEmail, subject, text: text2, html };
    };
    generateChefLocationAccessApprovedEmail = (data) => {
      const firstName = data.chefName.split(" ")[0];
      const subject = `Kitchen Access Approved - ${data.locationName}`;
      const bookingsUrl = `${getSubdomainUrl("chef")}/book-kitchen`;
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Your chef profile has been approved for kitchen access at <strong>${data.locationName}</strong>. You can now book kitchen facilities at this location.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Location:</span> <strong style="color: #1e293b;">${data.locationName}</strong></p>
      </div>
      <div style="margin: 0 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; Approved</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${bookingsUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View Available Kitchens</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `Hi ${firstName},

Your chef profile has been approved for kitchen access at ${data.locationName}. You can now book kitchen facilities at this location.

View available kitchens: ${bookingsUrl}

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`;
      return { to: data.chefEmail, subject, text: text2, html };
    };
    generateChefKitchenAccessApprovedEmail = (data) => {
      const firstName = data.chefName.split(" ")[0];
      const subject = `Kitchen Access Approved - ${data.kitchenName}`;
      const bookingsUrl = `${getSubdomainUrl("chef")}/book-kitchen`;
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Your chef profile has been approved for kitchen access at <strong>${data.kitchenName}</strong>. You can now book this kitchen from your dashboard.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Kitchen:</span> <strong style="color: #1e293b;">${data.kitchenName}</strong></p>
      </div>
      <div style="margin: 0 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; Approved</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${bookingsUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View Available Kitchens</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `Hi ${firstName},

Your chef profile has been approved for kitchen access at ${data.kitchenName}. You can now book this kitchen from your dashboard.

View available kitchens: ${bookingsUrl}

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`;
      return { to: data.chefEmail, subject, text: text2, html };
    };
    generateLocationEmailChangedEmail = (data) => {
      const subject = `Location Notification Email Updated - ${data.locationName}`;
      const dashboardUrl = getDashboardUrl("kitchen");
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Notification Email Updated</h2>
      <p class="message" style="margin-bottom: 20px;">This email address has been set as the notification email for <strong>${data.locationName}</strong>. You&#8217;ll now receive notifications for bookings, cancellations, and other important updates for this location.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Location:</span> <strong style="color: #1e293b;">${data.locationName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Email:</span> <strong style="color: #1e293b;">${data.email}</strong></p>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View Dashboard</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you didn&#8217;t make this change, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `Notification Email Updated

This email address has been set as the notification email for ${data.locationName}. You'll now receive notifications for bookings, cancellations, and other important updates.

Location: ${data.locationName}
Email: ${data.email}

View dashboard: ${dashboardUrl}

If you didn't make this change, contact us at support@localcook.shop

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`;
      return { to: data.email, subject, text: text2, html };
    };
    generateStorageExtensionPendingApprovalEmail = (data) => {
      const subject = `Storage Extension Request - ${data.storageName}`;
      const dashboardUrl = `${getDashboardUrl("kitchen")}?view=bookings`;
      const formattedPrice = `$${(data.totalPrice / 100).toFixed(2)}`;
      const formattedDate = data.newEndDate.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Storage Extension Request</h2>
      <p class="message" style="margin-bottom: 20px;">A chef has requested to extend their storage booking. Payment has been received and is awaiting your approval.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Chef:</span> <strong style="color: #1e293b;">${data.chefName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Storage:</span> <strong style="color: #1e293b;">${data.storageName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Extension:</span> <strong style="color: #1e293b;">${data.extensionDays} days</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">New End Date:</span> <strong style="color: #1e293b;">${formattedDate}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Amount Paid:</span> <strong style="color: #16a34a;">${formattedPrice}</strong></p>
      </div>
      <div style="margin: 0 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fffbeb; color: #d97706; border: 1px solid #fef3c7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#9679; Awaiting Approval</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Review Extension Request</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.managerEmail,
        subject,
        text: `Storage Extension Request

Chef: ${data.chefName}
Storage: ${data.storageName}
Extension: ${data.extensionDays} days
New End Date: ${formattedDate}
Amount: ${formattedPrice}
Status: Awaiting Approval

Review: ${dashboardUrl}

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateStorageExtensionPaymentReceivedEmail = (data) => {
      const firstName = data.chefName.split(" ")[0];
      const subject = `Storage Extension Payment Received - ${data.storageName}`;
      const dashboardUrl = getDashboardUrl();
      const formattedPrice = `$${(data.totalPrice / 100).toFixed(2)}`;
      const formattedDate = data.newEndDate.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Your payment for the storage extension has been received. The manager has been notified and will review your request shortly.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Storage:</span> <strong style="color: #1e293b;">${data.storageName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Extension:</span> <strong style="color: #1e293b;">${data.extensionDays} days</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">New End Date:</span> <strong style="color: #1e293b;">${formattedDate}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Amount Paid:</span> <strong style="color: #16a34a;">${formattedPrice}</strong></p>
      </div>
      <div style="margin: 0 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fffbeb; color: #d97706; border: 1px solid #fef3c7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#9679; Awaiting Approval</span>
      </div>
      <p class="message" style="margin-top: 20px; margin-bottom: 20px;">You&#8217;ll receive a confirmation email once the manager approves your extension.</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View My Bookings</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.chefEmail,
        subject,
        text: `Hi ${firstName},

Your payment for the storage extension has been received.

Storage: ${data.storageName}
Extension: ${data.extensionDays} days
New End Date: ${formattedDate}
Amount: ${formattedPrice}
Status: Awaiting Approval

View bookings: ${dashboardUrl}

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateStorageExtensionApprovedEmail = (data) => {
      const firstName = data.chefName.split(" ")[0];
      const subject = `Storage Extension Approved - ${data.storageName}`;
      const dashboardUrl = getDashboardUrl();
      const formattedDate = data.newEndDate.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Your storage extension has been approved. You can continue using the storage until the new end date.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Storage:</span> <strong style="color: #1e293b;">${data.storageName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Extension:</span> <strong style="color: #1e293b;">${data.extensionDays} days</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">New End Date:</span> <strong style="color: #1e293b;">${formattedDate}</strong></p>
      </div>
      <div style="margin: 0 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; Approved</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View My Bookings</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.chefEmail,
        subject,
        text: `Hi ${firstName},

Your storage extension has been approved.

Storage: ${data.storageName}
Extension: ${data.extensionDays} days
New End Date: ${formattedDate}

View bookings: ${dashboardUrl}

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateStorageExtensionRejectedEmail = (data) => {
      const firstName = data.chefName.split(" ")[0];
      const subject = `Storage Extension Declined - ${data.storageName}`;
      const dashboardUrl = getDashboardUrl();
      const refundText = data.refundAmount ? `A refund of $${(data.refundAmount / 100).toFixed(2)} has been processed and will be credited to your original payment method within 5&#8211;10 business days.` : "A refund will be processed shortly.";
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Unfortunately, your storage extension request has been declined.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Storage:</span> <strong style="color: #1e293b;">${data.storageName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Requested Extension:</span> <strong style="color: #1e293b;">${data.extensionDays} days</strong></p>
        ${data.rejectionReason ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 8px 0 0 0;"><span style="color: #64748b;">Reason:</span> <strong style="color: #1e293b;">${data.rejectionReason}</strong></p>` : ""}
      </div>
      <div style="margin: 0 0 16px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fef2f2; color: #dc2626; border: 1px solid #fecaca; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10007; Declined</span>
      </div>
      <p class="message" style="margin-bottom: 20px;">${refundText}</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View My Bookings</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const refundPlainText = data.refundAmount ? `A refund of $${(data.refundAmount / 100).toFixed(2)} has been processed and will be credited within 5-10 business days.` : "A refund will be processed shortly.";
      return {
        to: data.chefEmail,
        subject,
        text: `Hi ${firstName},

Your storage extension request has been declined.

Storage: ${data.storageName}
Requested Extension: ${data.extensionDays} days
${data.rejectionReason ? `Reason: ${data.rejectionReason}
` : ""}
${refundPlainText}

View bookings: ${dashboardUrl}

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateStorageExpiringWarningEmail = (data) => {
      const firstName = data.chefName.split(" ")[0];
      const subject = `Storage Booking Expiring ${data.daysUntilExpiry === 0 ? "Today" : `in ${data.daysUntilExpiry} Day${data.daysUntilExpiry > 1 ? "s" : ""}`}`;
      const dashboardUrl = getDashboardUrl();
      const formattedEndDate = data.endDate.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const dailyRate = (data.dailyRateCents / 100).toFixed(2);
      const penaltyPerDay = (data.dailyRateCents * data.penaltyRate / 100).toFixed(2);
      const expiryText = data.daysUntilExpiry === 0 ? '<strong style="color: #dc2626;">expiring today</strong>' : `expiring in <strong>${data.daysUntilExpiry} day${data.daysUntilExpiry > 1 ? "s" : ""}</strong>`;
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Your storage booking is ${expiryText}. Please take action to avoid overstay penalties.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 16px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Storage:</span> <strong style="color: #1e293b;">${data.storageName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">End Date:</span> <strong style="color: #1e293b;">${formattedEndDate}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Daily Rate:</span> <strong style="color: #1e293b;">$${dailyRate} CAD</strong></p>
      </div>
      <div style="background: #fffbeb; border: 1px solid #fef3c7; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 14px; font-weight: 600; color: #92400e; margin: 0 0 8px 0;">Overstay Policy</p>
        <table cellpadding="0" cellspacing="0" border="0" width="100%" style="margin: 0;">
          <tr>
            <td style="padding: 4px 10px 4px 0; vertical-align: top; width: 16px; color: #d97706; font-size: 14px; line-height: 22px;">&#8226;</td>
            <td style="padding: 4px 0; font-size: 14px; line-height: 1.5; color: #92400e;">Grace Period: ${data.gracePeriodDays} days after end date</td>
          </tr>
          <tr>
            <td style="padding: 4px 10px 4px 0; vertical-align: top; width: 16px; color: #d97706; font-size: 14px; line-height: 22px;">&#8226;</td>
            <td style="padding: 4px 0; font-size: 14px; line-height: 1.5; color: #92400e;">Penalty Rate: ${(data.penaltyRate * 100).toFixed(0)}% of daily rate ($${penaltyPerDay}/day)</td>
          </tr>
          <tr>
            <td style="padding: 4px 10px 4px 0; vertical-align: top; width: 16px; color: #d97706; font-size: 14px; line-height: 22px;">&#8226;</td>
            <td style="padding: 4px 0; font-size: 14px; line-height: 1.5; color: #92400e;">Penalties require manager approval before charging</td>
          </tr>
        </table>
      </div>
      <p class="message" style="margin-bottom: 8px;">To avoid penalties, please either:</p>
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="margin: 0 0 24px 4px;">
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Extend your storage booking</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Remove your items before the end date</td>
        </tr>
      </table>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Manage My Bookings</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.chefEmail,
        subject,
        text: `Hi ${firstName},

Your storage booking for ${data.storageName} is expiring on ${formattedEndDate}. Please extend or remove your items to avoid overstay penalties.

Grace period: ${data.gracePeriodDays} days
Penalty rate: ${(data.penaltyRate * 100).toFixed(0)}% of daily rate ($${penaltyPerDay}/day)

Manage bookings: ${dashboardUrl}

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateOverstayDetectedEmail = (data) => {
      const firstName = data.chefName.split(" ")[0];
      const subject = data.isInGracePeriod ? `Storage Overstay - Grace Period Active` : `Storage Overstay - Penalty Pending Review`;
      const dashboardUrl = getDashboardUrl();
      const formattedEndDate = data.endDate.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const formattedGraceEnd = data.gracePeriodEndsAt.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const penaltyAmount = (data.calculatedPenaltyCents / 100).toFixed(2);
      const alertBg = data.isInGracePeriod ? "#fffbeb" : "#fef2f2";
      const alertBorder = data.isInGracePeriod ? "#fef3c7" : "#fecaca";
      const alertColor = data.isInGracePeriod ? "#92400e" : "#991b1b";
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Your storage booking has exceeded its end date.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 16px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Storage:</span> <strong style="color: #1e293b;">${data.storageName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">End Date:</span> <strong style="color: #1e293b;">${formattedEndDate}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Days Overdue:</span> <strong style="color: #1e293b;">${data.daysOverdue}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Grace Period Ends:</span> <strong style="color: #1e293b;">${formattedGraceEnd}</strong></p>
        ${!data.isInGracePeriod ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Calculated Penalty:</span> <strong style="color: #dc2626;">$${penaltyAmount} CAD</strong></p>` : ""}
      </div>
      <div style="background: ${alertBg}; border: 1px solid ${alertBorder}; border-radius: 8px; padding: 12px 16px; margin: 0 0 24px 0;">
        <p style="font-size: 14px; line-height: 1.6; color: ${alertColor}; margin: 0;">${data.isInGracePeriod ? `You are currently in the <strong>grace period</strong>. No penalties will be charged if you resolve this before <strong>${formattedGraceEnd}</strong>.` : `The grace period has ended. A penalty of <strong>$${penaltyAmount} CAD</strong> has been calculated and is pending manager review.`}</p>
      </div>
      <p class="message" style="margin-bottom: 8px;">To resolve this overstay, please:</p>
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="margin: 0 0 24px 4px;">
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Remove your items or resolve the overstay</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Contact the kitchen manager to arrange item removal</td>
        </tr>
      </table>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Manage My Bookings</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.chefEmail,
        subject,
        text: `Hi ${firstName},

Your storage booking for ${data.storageName} has exceeded its end date (${formattedEndDate}). Days overdue: ${data.daysOverdue}. ${data.isInGracePeriod ? `Grace period ends: ${formattedGraceEnd}. No penalties yet.` : `Calculated penalty: $${penaltyAmount} CAD (pending manager review).`}

Manage bookings: ${dashboardUrl}

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generatePenaltyChargedEmail = (data) => {
      const firstName = data.chefName.split(" ")[0];
      const penaltyAmount = (data.penaltyAmountCents / 100).toFixed(2);
      const subject = `Overstay Penalty Charged - $${penaltyAmount} CAD`;
      const dashboardUrl = getDashboardUrl();
      const formattedDate = data.chargeDate.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">An overstay penalty has been charged to your payment method.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Storage:</span> <strong style="color: #1e293b;">${data.storageName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Days Overdue:</span> <strong style="color: #1e293b;">${data.daysOverdue}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Penalty Amount:</span> <strong style="color: #dc2626;">$${penaltyAmount} CAD</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Charge Date:</span> <strong style="color: #1e293b;">${formattedDate}</strong></p>
      </div>
      <div style="margin: 0 0 16px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fef2f2; color: #dc2626; border: 1px solid #fecaca; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">Penalty Charged</span>
      </div>
      <p class="message" style="margin-bottom: 20px;">This charge was approved by the kitchen manager after the grace period ended. If you believe this charge is in error, please contact the kitchen manager directly.</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View My Bookings</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.chefEmail,
        subject,
        text: `Hi ${firstName},

An overstay penalty of $${penaltyAmount} CAD has been charged for ${data.storageName}.

Days overdue: ${data.daysOverdue}
Charge date: ${formattedDate}

View bookings: ${dashboardUrl}

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateOverstayManagerNotificationEmail = (data) => {
      const subject = data.isInGracePeriod ? `Storage Overstay Detected - ${data.storageName}` : `Overstay Pending Review - ${data.storageName}`;
      const dashboardUrl = `${getDashboardUrl("kitchen")}?view=overstays`;
      const formattedEndDate = data.endDate.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const formattedGraceEnd = data.gracePeriodEndsAt.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const penaltyAmount = (data.calculatedPenaltyCents / 100).toFixed(2);
      const alertBg = data.isInGracePeriod ? "#fffbeb" : "#fef2f2";
      const alertBorder = data.isInGracePeriod ? "#fef3c7" : "#fecaca";
      const alertColor = data.isInGracePeriod ? "#92400e" : "#991b1b";
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Overstay Alert</h2>
      <p class="message" style="margin-bottom: 20px;">A storage booking at <strong>${data.kitchenName}</strong> has exceeded its end date.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 16px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Storage:</span> <strong style="color: #1e293b;">${data.storageName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Chef:</span> <strong style="color: #1e293b;">${data.chefName} (${data.chefEmail})</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">End Date:</span> <strong style="color: #1e293b;">${formattedEndDate}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Days Overdue:</span> <strong style="color: #1e293b;">${data.daysOverdue}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Grace Period Ends:</span> <strong style="color: #1e293b;">${formattedGraceEnd}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Calculated Penalty:</span> <strong style="color: #dc2626;">$${penaltyAmount} CAD</strong></p>
      </div>
      <div style="background: ${alertBg}; border: 1px solid ${alertBorder}; border-radius: 8px; padding: 12px 16px; margin: 0 0 24px 0;">
        <p style="font-size: 14px; line-height: 1.6; color: ${alertColor}; margin: 0;">${data.isInGracePeriod ? `The chef is currently in the grace period (ends ${formattedGraceEnd}). No action required yet, but you may want to reach out.` : `<strong>Action Required:</strong> The grace period has ended. Please review and decide whether to approve, adjust, or waive the penalty.`}</p>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Review Overstays</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.managerEmail,
        subject,
        text: `Overstay Alert: ${data.storageName} at ${data.kitchenName}

Chef: ${data.chefName} (${data.chefEmail})
Days overdue: ${data.daysOverdue}
Calculated penalty: $${penaltyAmount} CAD
${data.isInGracePeriod ? "Grace period active." : "Action required - please review."}

Review: ${dashboardUrl}

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateNewKitchenApplicationManagerEmail = (data) => {
      const subject = `New Kitchen Access Application from ${data.chefName}`;
      const dashboardUrl = `${getDashboardUrl("kitchen")}?view=applications`;
      const managerFirstName = data.managerName ? data.managerName.split(" ")[0] : data.managerEmail.split("@")[0];
      const chefFirstName = data.chefName.split(" ")[0];
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${managerFirstName},</h2>
      <p class="message" style="margin-bottom: 20px;">You&#8217;ve received a new application from a chef requesting access to ${data.locationName}.</p>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Chef Information:</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.6; color: #475569; margin: 0;"><span style="color: #64748b;">Name:</span> <strong style="color: #1e293b;">${data.chefName}</strong></p>
      </div>
      <div style="margin: 0 0 24px 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: #f8fafc; color: #1e293b !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0; border: 1px solid #e2e8f0;">View Dashboard</a>
      </div>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">Next steps:</p>
      <p class="message" style="margin-bottom: 20px;">Please review ${chefFirstName}&#8217;s profile and application in your dashboard and decide whether to approve or decline their request.</p>
      <div style="margin: 0 0 8px 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Review Application</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 16px 0 0 0; text-align: center;">We recommend responding within 3&#8211;5 business days.</p>
      <p style="font-size: 13px; line-height: 1.6; color: #94a3b8; margin: 16px 0 0 0;">If you have any questions about this application, you can reply to this email or contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${managerFirstName},

You've received a new application from a chef requesting access to ${data.locationName}.

Chef Information:
Name: ${data.chefName}

Next steps:
Please review ${chefFirstName}'s profile and application in your dashboard and decide whether to approve or decline their request.

Review application at: ${dashboardUrl}

We recommend responding within 3\u20135 business days.

If you have any questions about this application, you can reply to this email or contact us at support@localcook.shop

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: data.managerEmail,
        subject,
        text: text2,
        html
      };
    };
    generateKitchenApplicationSubmittedChefEmail = (data) => {
      const subject = `Step 1 Approved for ${data.locationName} \u2013 Next Steps`;
      const dashboardUrl = getDashboardUrl();
      const firstName = data.chefName.split(" ")[0];
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Good news &#8212; your Step 1 application for ${data.locationName} has been approved.</p>
      <p class="message" style="margin-bottom: 24px;">You now have access to the chat feature with this kitchen inside your Local Cooks dashboard. This allows you and the kitchen manager to coordinate directly and share any information needed to complete Step 2.</p>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">What to do next:</p>
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="margin: 0 0 24px 4px;">
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Use the chat in your dashboard to connect with the kitchen manager</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Confirm any requirements or details they need from you</td>
        </tr>
      </table>
      <p class="message" style="margin-bottom: 10px;">When you&#8217;re ready, complete Step 2 of your application by submitting your:</p>
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="margin: 0 0 24px 4px;">
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Food establishment certificate</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Insurance documents (if required)</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Any additional information requested in the Step 2 form</td>
        </tr>
      </table>
      <p class="message" style="margin-bottom: 20px;">Once Step 2 is submitted and approved, you&#8217;ll be able to start booking this kitchen through Local Cooks.</p>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; Step 1 Approved</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Go to Your Dashboard</a>
      </div>
      <p style="font-size: 13px; line-height: 1.6; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions about the process, simply reply to this email or contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

Good news \u2014 your Step 1 application for ${data.locationName} has been approved.

You now have access to the chat feature with this kitchen inside your Local Cooks dashboard. This allows you and the kitchen manager to coordinate directly and share any information needed to complete Step 2.

What to do next:

\u2022 Use the chat in your dashboard to connect with the kitchen manager
\u2022 Confirm any requirements or details they need from you

When you're ready, complete Step 2 of your application by submitting your:

\u2022 Food establishment certificate
\u2022 Insurance documents (if required)
\u2022 Any additional information requested in the Step 2 form

Once Step 2 is submitted and approved, you'll be able to start booking this kitchen through Local Cooks.

Go to your dashboard at: ${dashboardUrl}

If you have any questions about the process, simply reply to this email or contact us at support@localcook.shop

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: data.chefEmail,
        subject,
        text: text2,
        html
      };
    };
    generateKitchenApplicationApprovedEmail = (data) => {
      const subject = `You're Fully Approved for ${data.locationName} \u2013 You Can Now Book`;
      const dashboardUrl = getDashboardUrl();
      const firstName = data.chefName.split(" ")[0];
      const kitchenDisplay = data.kitchenName || data.locationName;
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Great news &#8212; your Step 2 application for ${data.locationName} has been approved.</p>
      <p class="message" style="margin-bottom: 24px;">You now have full access to this kitchen through Local Cooks and can start submitting booking requests based on the kitchen&#8217;s availability.</p>
      <p class="message" style="margin-bottom: 8px; font-weight: 600; color: #1e293b;">What you can do now:</p>
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="margin: 0 0 24px 4px;">
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">View ${kitchenDisplay}&#8217;s schedule and available time slots</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Submit booking requests directly from your dashboard</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Coordinate final details with the kitchen via the built-in chat</td>
        </tr>
      </table>
      <p class="message" style="margin-bottom: 20px;">Please make sure you continue to follow the kitchen&#8217;s specific guidelines and any local food safety requirements when using the space.</p>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; Fully Approved</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Go to Your Dashboard</a>
      </div>
      <p style="font-size: 13px; line-height: 1.6; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions about bookings or how to use the platform, simply reply to this email or contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

Great news \u2014 your Step 2 application for ${data.locationName} has been approved.

You now have full access to this kitchen through Local Cooks and can start submitting booking requests based on the kitchen's availability.

What you can do now:

\u2022 View ${kitchenDisplay}'s schedule and available time slots
\u2022 Submit booking requests directly from your dashboard
\u2022 Coordinate final details with the kitchen via the built-in chat

Please make sure you continue to follow the kitchen's specific guidelines and any local food safety requirements when using the space.

Go to your dashboard at: ${dashboardUrl}

If you have any questions about bookings or how to use the platform, simply reply to this email or contact us at support@localcook.shop

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: data.chefEmail,
        subject,
        text: text2,
        html
      };
    };
    generateKitchenApplicationRejectedEmail = (data) => {
      const firstName = data.chefName.split(" ")[0];
      const subject = `Kitchen Application Update - ${data.locationName}`;
      const dashboardUrl = getDashboardUrl();
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Thank you for your interest in using our kitchen facilities. Unfortunately, your application could not be approved at this time.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Location:</span> <strong style="color: #1e293b;">${data.locationName}</strong></p>
        ${data.feedback ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 8px 0 0 0;"><span style="color: #64748b;">Feedback:</span> <strong style="color: #1e293b;">${data.feedback}</strong></p>` : ""}
      </div>
      <div style="margin: 0 0 16px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fef2f2; color: #dc2626; border: 1px solid #fecaca; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">Not Approved</span>
      </div>
      <p class="message" style="margin-bottom: 20px;">You may reapply in the future or explore other kitchen locations on our platform.</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View My Applications</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.chefEmail,
        subject,
        text: `Hi ${firstName},

Thank you for your interest. Unfortunately, your kitchen application to ${data.locationName} could not be approved at this time.${data.feedback ? `

Feedback: ${data.feedback}` : ""}

You may reapply or explore other locations: ${dashboardUrl}

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateKitchenLicenseApprovedEmail = (data) => {
      const subject = `Your Kitchen Is Approved and Ready to List on Local Cooks`;
      const dashboardUrl = getDashboardUrl("kitchen");
      const firstName = data.managerName.split(" ")[0];
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Great news &#8212; your kitchen license has been reviewed and approved. Your account is now fully set up to host chefs and food businesses on Local Cooks.</p>
      <p class="message" style="margin-bottom: 10px;">From your dashboard, you can now:</p>
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="margin: 0 0 24px 4px;">
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Create and publish listings for your kitchen, storage, and equipment</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Set your availability and pricing to match your schedule and capacity</td>
        </tr>
        <tr>
          <td style="padding: 6px 10px 6px 0; vertical-align: top; width: 16px; color: hsl(347, 91%, 55%); font-size: 16px; line-height: 24px;">&#8226;</td>
          <td style="padding: 6px 0; font-size: 15px; line-height: 1.65; color: #475569;">Review and manage booking requests from verified chefs and food entrepreneurs</td>
        </tr>
      </table>
      <p class="message" style="margin-bottom: 20px;">This is a great moment to add clear details and good photos to your listings so chefs can quickly understand what your space offers and when it&#8217;s available.</p>
      <div style="margin: 16px 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; Approved</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Go to Your Dashboard</a>
      </div>
      <p style="font-size: 13px; line-height: 1.6; color: #94a3b8; margin: 24px 0 0 0; text-align: center;">We&#8217;re here to help you get the most out of the platform. If you&#8217;d like guidance on setting up your first listing or optimizing your availability and pricing, simply reply to this email or contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      const text2 = `
Hi ${firstName},

Great news \u2014 your kitchen license has been reviewed and approved. Your account is now fully set up to host chefs and food businesses on Local Cooks.

From your dashboard, you can now:

\u2022 Create and publish listings for your kitchen, storage, and equipment
\u2022 Set your availability and pricing to match your schedule and capacity
\u2022 Review and manage booking requests from verified chefs and food entrepreneurs

This is a great moment to add clear details and good photos to your listings so chefs can quickly understand what your space offers and when it's available.

Go to your dashboard at: ${dashboardUrl}

We're here to help you get the most out of the platform. If you'd like guidance on setting up your first listing or optimizing your availability and pricing, simply reply to this email or contact us at support@localcook.shop

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks
  `.trim();
      return {
        to: data.managerEmail,
        subject,
        text: text2,
        html
      };
    };
    generateKitchenLicenseRejectedEmail = (data) => {
      const firstName = data.managerName.split(" ")[0];
      const subject = `Kitchen License Update Required - ${data.locationName}`;
      const dashboardUrl = `${getDashboardUrl("kitchen")}?view=settings-license`;
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">Your kitchen license submission requires attention. The admin team was unable to approve it at this time.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Location:</span> <strong style="color: #1e293b;">${data.locationName}</strong></p>
        ${data.feedback ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 8px 0 0 0;"><span style="color: #64748b;">Feedback:</span> <strong style="color: #1e293b;">${data.feedback}</strong></p>` : ""}
      </div>
      <div style="margin: 0 0 16px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fef2f2; color: #dc2626; border: 1px solid #fecaca; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">Action Required</span>
      </div>
      <p class="message" style="margin-bottom: 20px;">Please review the feedback and upload a new license document from your dashboard.</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Upload New License</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.managerEmail,
        subject,
        text: `Hi ${firstName},

Your kitchen license for ${data.locationName} requires attention.${data.feedback ? `

Feedback: ${data.feedback}` : ""}

Please upload a new license: ${dashboardUrl}

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateKitchenLicenseSubmittedAdminEmail = (data) => {
      const subject = `Kitchen License Pending Review - ${data.locationName}`;
      const dashboardUrl = `${getDashboardUrl("admin")}?section=kitchen-licenses`;
      const formattedDate = data.submittedAt.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric" });
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Kitchen License Pending Review</h2>
      <p class="message" style="margin-bottom: 20px;">A manager has submitted a kitchen license for your review.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Manager:</span> <strong style="color: #1e293b;">${data.managerName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Email:</span> <strong style="color: #1e293b;">${data.managerEmail}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Location:</span> <strong style="color: #1e293b;">${data.locationName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Submitted:</span> <strong style="color: #1e293b;">${formattedDate}</strong></p>
      </div>
      <div style="margin: 0 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #fffbeb; color: #d97706; border: 1px solid #fef3c7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#9679; Pending Review</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Review License</a>
      </div>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.adminEmail,
        subject,
        text: `Kitchen License Pending Review

Manager: ${data.managerName} (${data.managerEmail})
Location: ${data.locationName}
Submitted: ${formattedDate}

Review: ${dashboardUrl}

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateDamageClaimFiledEmail = (data) => {
      const firstName = data.chefName.split(" ")[0];
      const subject = `Damage Claim Filed - Action Required`;
      const dashboardUrl = getDashboardUrl();
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">A damage claim has been filed against your booking. Please review and respond before the deadline.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Claim:</span> <strong style="color: #1e293b;">${data.claimTitle}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Amount:</span> <strong style="color: #1e293b;">${data.claimedAmount}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Location:</span> <strong style="color: #1e293b;">${data.locationName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Filed by:</span> <strong style="color: #1e293b;">${data.managerName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Damage Date:</span> <strong style="color: #1e293b;">${data.damageDate}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Response Deadline:</span> <strong style="color: #dc2626;">${data.responseDeadline}</strong></p>
      </div>
      <div style="background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px; padding: 12px 16px; margin: 0 0 24px 0;">
        <p style="font-size: 14px; line-height: 1.6; color: #991b1b; margin: 0;">You can accept the claim or dispute it for admin review. If you don&#8217;t respond by the deadline, the claim may be automatically approved.</p>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Review &amp; Respond</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.chefEmail,
        subject,
        text: `Hi ${firstName},

A damage claim has been filed against your booking at ${data.locationName}.

Claim: ${data.claimTitle}
Amount: ${data.claimedAmount}
Deadline: ${data.responseDeadline}

Respond: ${dashboardUrl}

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateDamageClaimResponseEmail = (data) => {
      const managerFirstName = data.managerName.split(" ")[0];
      const isAccepted = data.response === "accepted";
      const subject = `Damage Claim ${isAccepted ? "Accepted" : "Disputed"} - ${data.claimTitle}`;
      const dashboardUrl = `${getDashboardUrl("kitchen")}?view=damage-claims`;
      const statusColor = isAccepted ? "#16a34a" : "#dc2626";
      const statusText = isAccepted ? "Accepted" : "Disputed";
      const badgeBg = isAccepted ? "#f0fdf4" : "#fef2f2";
      const badgeBorder = isAccepted ? "#dcfce7" : "#fecaca";
      const nextSteps = isAccepted ? "You can now charge the chef&#8217;s saved payment method from your dashboard." : "The claim has been escalated to admin for review. You will be notified of the decision.";
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${managerFirstName},</h2>
      <p class="message" style="margin-bottom: 20px;">${data.chefName} has responded to your damage claim.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Claim:</span> <strong style="color: #1e293b;">${data.claimTitle}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Amount:</span> <strong style="color: #1e293b;">${data.claimedAmount}</strong></p>
        ${data.chefResponse ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 8px 0 0 0;"><span style="color: #64748b;">Chef&#8217;s Response:</span> <strong style="color: #1e293b;">${data.chefResponse}</strong></p>` : ""}
      </div>
      <div style="margin: 0 0 16px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: ${badgeBg}; color: ${statusColor}; border: 1px solid ${badgeBorder}; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">${statusText}</span>
      </div>
      <p class="message" style="margin-bottom: 20px;">${nextSteps}</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View Claim</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.managerEmail,
        subject,
        text: `Hi ${managerFirstName},

${data.chefName} has ${data.response} your damage claim "${data.claimTitle}" for ${data.claimedAmount}.${data.chefResponse ? `

Response: ${data.chefResponse}` : ""}

${isAccepted ? "You can now charge from your dashboard." : "Escalated to admin for review."}

View claim: ${dashboardUrl}

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateDamageClaimDisputedAdminEmail = (data) => {
      const subject = `Damage Claim Disputed - Admin Review Required`;
      const dashboardUrl = `${getDashboardUrl("admin")}?section=damage-claims`;
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Damage Claim Dispute &#8212; Review Required</h2>
      <p class="message" style="margin-bottom: 20px;">A chef has disputed a damage claim and requires your review.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 16px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Claim:</span> <strong style="color: #1e293b;">${data.claimTitle}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Amount:</span> <strong style="color: #1e293b;">${data.claimedAmount}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Location:</span> <strong style="color: #1e293b;">${data.locationName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Manager:</span> <strong style="color: #1e293b;">${data.managerName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Chef:</span> <strong style="color: #1e293b;">${data.chefName} (${data.chefEmail})</strong></p>
      </div>
      <div style="background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px; padding: 12px 16px; margin: 0 0 24px 0;">
        <p style="font-size: 14px; font-weight: 600; color: #991b1b; margin: 0 0 4px 0;">Chef&#8217;s Dispute Reason:</p>
        <p style="font-size: 14px; line-height: 1.6; color: #991b1b; margin: 0;">${data.chefResponse}</p>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">Review Dispute</a>
      </div>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.adminEmail,
        subject,
        text: `Damage Claim Dispute - Review Required

Claim: ${data.claimTitle}
Amount: ${data.claimedAmount}
Location: ${data.locationName}
Manager: ${data.managerName}
Chef: ${data.chefName} (${data.chefEmail})

Dispute Reason: ${data.chefResponse}

Review: ${dashboardUrl}

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateDamageClaimDecisionEmail = (data) => {
      const firstName = data.recipientName.split(" ")[0];
      const isChef = data.recipientRole === "chef";
      const decisionLabels = {
        approved: "Approved",
        partially_approved: "Partially Approved",
        rejected: "Rejected"
      };
      const decisionColors = {
        approved: "#16a34a",
        partially_approved: "#d97706",
        rejected: "#dc2626"
      };
      const badgeBgs = {
        approved: "#f0fdf4",
        partially_approved: "#fffbeb",
        rejected: "#fef2f2"
      };
      const badgeBorders = {
        approved: "#dcfce7",
        partially_approved: "#fef3c7",
        rejected: "#fecaca"
      };
      const subject = `Damage Claim ${decisionLabels[data.decision]} - ${data.claimTitle}`;
      const dashboardUrl = isChef ? getDashboardUrl() : getDashboardUrl("kitchen");
      const nextStepsChef = data.decision === "rejected" ? "No payment will be charged to your account." : "The approved amount will be charged to your saved payment method.";
      const nextStepsManager = data.decision === "rejected" ? "The claim has been rejected and no payment will be collected." : "You can now charge the chef from your dashboard.";
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">The admin has made a decision on the disputed damage claim.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Claim:</span> <strong style="color: #1e293b;">${data.claimTitle}</strong></p>
        ${data.decision === "partially_approved" && data.finalAmount ? `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Final Amount:</span> <strong style="color: #1e293b;">${data.finalAmount}</strong> <span style="color: #94a3b8;">(originally ${data.claimedAmount})</span></p>` : `<p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Amount:</span> <strong style="color: #1e293b;">${data.claimedAmount}</strong></p>`}
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 8px 0 0 0;"><span style="color: #64748b;">Reason:</span> <strong style="color: #1e293b;">${data.decisionReason}</strong></p>
      </div>
      <div style="margin: 0 0 16px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: ${badgeBgs[data.decision]}; color: ${decisionColors[data.decision]}; border: 1px solid ${badgeBorders[data.decision]}; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">${decisionLabels[data.decision]}</span>
      </div>
      <p class="message" style="margin-bottom: 20px;">${isChef ? nextStepsChef : nextStepsManager}</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View Details</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.recipientEmail,
        subject,
        text: `Hi ${firstName},

The admin has ${decisionLabels[data.decision].toLowerCase()} the damage claim "${data.claimTitle}".

${data.decisionReason}

View details: ${dashboardUrl}

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateDamageClaimChargedEmail = (data) => {
      const firstName = data.chefName.split(" ")[0];
      const subject = `Payment Processed - Damage Claim`;
      const dashboardUrl = getDashboardUrl();
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">Hi ${firstName},</h2>
      <p class="message" style="margin-bottom: 20px;">A payment has been processed for a damage claim.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Claim:</span> <strong style="color: #1e293b;">${data.claimTitle}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Amount Charged:</span> <strong style="color: #1e293b;">${data.chargedAmount}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Location:</span> <strong style="color: #1e293b;">${data.locationName}</strong></p>
      </div>
      <div style="margin: 0 0 16px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">&#10003; Payment Complete</span>
      </div>
      <p class="message" style="margin-bottom: 20px;">This charge was made to your saved payment method. A receipt has been sent to your email by Stripe.</p>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View Details</a>
      </div>
      <p style="font-size: 13px; line-height: 1.5; color: #94a3b8; margin: 24px 0 0 0;">If you have any questions, contact us at <a href="mailto:support@localcook.shop" style="color: hsl(347, 91%, 51%); text-decoration: none;">support@localcook.shop</a></p>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.chefEmail,
        subject,
        text: `Hi ${firstName},

A payment of ${data.chargedAmount} has been processed for the damage claim "${data.claimTitle}" at ${data.locationName}.

View details: ${dashboardUrl}

Best,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
    generateNewUserRegistrationAdminEmail = (data) => {
      const roleLabel = data.userRole.charAt(0).toUpperCase() + data.userRole.slice(1);
      const subject = `New ${roleLabel} Registration - ${data.newUserName}`;
      const dashboardUrl = `${getDashboardUrl("admin")}?section=overview`;
      const formattedDate = data.registrationDate.toLocaleDateString("en-US", { weekday: "long", year: "numeric", month: "long", day: "numeric", hour: "2-digit", minute: "2-digit" });
      const roleColor = data.userRole === "admin" ? "#dc2626" : data.userRole === "manager" ? "#2563eb" : "#16a34a";
      const roleBg = data.userRole === "admin" ? "#fef2f2" : data.userRole === "manager" ? "#eff6ff" : "#f0fdf4";
      const roleBorder = data.userRole === "admin" ? "#fecaca" : data.userRole === "manager" ? "#dbeafe" : "#dcfce7";
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${subject}</title>
  ${getUniformEmailStyles()}
</head>
<body>
  <div class="email-container">
    <div class="header">
      <img src="https://raw.githubusercontent.com/Raunak-Sarmacharya/LocalCooksCommunity/refs/heads/main/attached_assets/emailHeader.png" alt="Local Cooks" class="header-image" />
    </div>
    <div class="content">
      <h2 class="greeting" style="font-size: 22px; margin-bottom: 12px;">New User Registration</h2>
      <p class="message" style="margin-bottom: 20px;">A new user has registered on the platform.</p>
      <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px 20px; margin: 0 0 24px 0;">
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Name:</span> <strong style="color: #1e293b;">${data.newUserName}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Email:</span> <strong style="color: #1e293b;">${data.newUserEmail}</strong></p>
        <p style="font-size: 15px; line-height: 1.8; color: #475569; margin: 0;"><span style="color: #64748b;">Registered:</span> <strong style="color: #1e293b;">${formattedDate}</strong></p>
      </div>
      <div style="margin: 0 0 4px 0; text-align: center;">
        <span style="display: inline-block; padding: 4px 12px; background: ${roleBg}; color: ${roleColor}; border: 1px solid ${roleBorder}; border-radius: 100px; font-weight: 500; font-size: 12px; text-transform: uppercase; letter-spacing: 0.04em;">${roleLabel}</span>
      </div>
      <div style="margin: 16px 0 0 0; text-align: center;">
        <a href="${dashboardUrl}" class="cta-button" style="display: inline-block; padding: 10px 24px; background: hsl(347, 91%, 51%); color: #ffffff !important; text-decoration: none !important; border-radius: 6px; font-weight: 500; font-size: 14px; letter-spacing: 0.01em; box-shadow: none; margin: 0;">View Users</a>
      </div>
      <div style="margin-top: 28px; padding-top: 20px; border-top: 1px solid #f1f5f9;">
        <p style="font-size: 15px; color: #64748b; margin: 0;">Best regards,</p>
        <p style="font-size: 15px; color: #1e293b; font-weight: 600; margin: 4px 0 0 0;">The Local Cooks Team</p>
      </div>
    </div>
    <div class="footer">
      <div class="divider"></div>
      <p class="footer-text">&copy; ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks</p>
    </div>
  </div>
</body>
</html>`;
      return {
        to: data.adminEmail,
        subject,
        text: `New ${roleLabel} Registration

Name: ${data.newUserName}
Email: ${data.newUserEmail}
Registered: ${formattedDate}

View users: ${dashboardUrl}

Best regards,
The Local Cooks Team

\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} Local Cooks`,
        html
      };
    };
  }
});

// server/services/overstay-penalty-service.ts
var overstay_penalty_service_exports = {};
__export(overstay_penalty_service_exports, {
  chargeApprovedPenalty: () => chargeApprovedPenalty,
  createPenaltyPaymentCheckout: () => createPenaltyPaymentCheckout,
  detectOverstays: () => detectOverstays,
  getAllOverstayRecords: () => getAllOverstayRecords,
  getChefAllPenalties: () => getChefAllPenalties,
  getChefPendingPenalties: () => getChefPendingPenalties,
  getChefUnpaidPenalties: () => getChefUnpaidPenalties,
  getOverstayHistory: () => getOverstayHistory,
  getOverstayRecord: () => getOverstayRecord,
  getOverstayStats: () => getOverstayStats,
  getPendingOverstayReviews: () => getPendingOverstayReviews,
  hasChefUnpaidPenalties: () => hasChefUnpaidPenalties,
  markChefWarningSent: () => markChefWarningSent,
  markManagerNotified: () => markManagerNotified,
  overstayPenaltyService: () => overstayPenaltyService,
  processManagerDecision: () => processManagerDecision,
  refundOverstayPenalty: () => refundOverstayPenalty,
  resolveOverstay: () => resolveOverstay
});
import { eq as eq3, and, lt, not, inArray, desc, asc, sql as sql4 } from "drizzle-orm";
import Stripe2 from "stripe";
async function detectOverstays() {
  const today = /* @__PURE__ */ new Date();
  today.setHours(0, 0, 0, 0);
  const expiredBookings = await db.select({
    id: storageBookings.id,
    storageListingId: storageBookings.storageListingId,
    chefId: storageBookings.chefId,
    endDate: storageBookings.endDate,
    totalPrice: storageBookings.totalPrice,
    status: storageBookings.status,
    paymentStatus: storageBookings.paymentStatus,
    stripeCustomerId: storageBookings.stripeCustomerId,
    stripePaymentMethodId: storageBookings.stripePaymentMethodId,
    checkoutStatus: storageBookings.checkoutStatus,
    // Storage listing config
    basePrice: storageListings.basePrice,
    gracePeriodDays: storageListings.overstayGracePeriodDays,
    penaltyRate: storageListings.overstayPenaltyRate,
    maxPenaltyDays: storageListings.overstayMaxPenaltyDays
  }).from(storageBookings).innerJoin(storageListings, eq3(storageBookings.storageListingId, storageListings.id)).where(and(
    lt(storageBookings.endDate, today),
    not(eq3(storageBookings.status, "cancelled")),
    eq3(storageBookings.status, "confirmed")
    // Only confirmed bookings can have overstay
  )).orderBy(asc(storageBookings.endDate));
  const results = [];
  for (const booking of expiredBookings) {
    try {
      const checkoutStatus = booking.checkoutStatus;
      if (checkoutStatus === "checkout_requested" || checkoutStatus === "checkout_approved" || checkoutStatus === "completed" || checkoutStatus === "checkout_claim_filed") {
        logger.info(`[OverstayService] Skipping booking ${booking.id} - checkout in progress (status: ${checkoutStatus})`);
        continue;
      }
      const endDate = new Date(booking.endDate);
      endDate.setHours(0, 0, 0, 0);
      const daysOverdue = Math.floor((today.getTime() - endDate.getTime()) / (1e3 * 60 * 60 * 24));
      if (daysOverdue <= 0) continue;
      const effectiveConfig = await getEffectivePenaltyConfig(
        booking.gracePeriodDays,
        booking.penaltyRate?.toString() || null,
        booking.maxPenaltyDays
      );
      const gracePeriodDays = effectiveConfig.gracePeriodDays;
      const gracePeriodEndsAt = new Date(endDate);
      gracePeriodEndsAt.setDate(gracePeriodEndsAt.getDate() + gracePeriodDays);
      const isInGracePeriod = today < gracePeriodEndsAt;
      const penaltyRate = effectiveConfig.penaltyRate;
      const maxPenaltyDays = effectiveConfig.maxPenaltyDays;
      const dailyRateCents = booking.basePrice ? Math.round(parseFloat(booking.basePrice.toString())) : 0;
      let penaltyDays = 0;
      if (!isInGracePeriod) {
        penaltyDays = Math.min(daysOverdue - gracePeriodDays, maxPenaltyDays);
      }
      const dailyPenaltyChargeCents = Math.round(dailyRateCents * (1 + penaltyRate));
      const calculatedPenaltyCents = dailyPenaltyChargeCents * penaltyDays;
      let status = "detected";
      if (isInGracePeriod) {
        status = "grace_period";
      } else {
        status = "pending_review";
      }
      const idempotencyKey = `booking_${booking.id}_overstay_${endDate.toISOString().split("T")[0]}`;
      const [existingRecord] = await db.select().from(storageOverstayRecords).where(
        and(
          eq3(storageOverstayRecords.storageBookingId, booking.id),
          inArray(storageOverstayRecords.status, ["detected", "grace_period", "pending_review", "charge_failed"])
        )
      ).orderBy(desc(storageOverstayRecords.detectedAt)).limit(1);
      if (existingRecord) {
        const shouldUpdate = existingRecord.status === "detected" || existingRecord.status === "grace_period" && status === "pending_review" || existingRecord.daysOverdue !== daysOverdue;
        if (shouldUpdate && !["penalty_approved", "penalty_waived", "charge_pending", "charge_succeeded", "resolved", "escalated"].includes(existingRecord.status)) {
          await db.update(storageOverstayRecords).set({
            daysOverdue,
            calculatedPenaltyCents,
            status: existingRecord.status === "grace_period" && !isInGracePeriod ? "pending_review" : existingRecord.status,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq3(storageOverstayRecords.id, existingRecord.id));
          if (existingRecord.status !== status) {
            await createOverstayHistoryEntry(existingRecord.id, existingRecord.status, status, "status_change", "cron", `Days overdue: ${daysOverdue}`);
          }
        }
        results.push({
          bookingId: booking.id,
          chefId: booking.chefId,
          daysOverdue,
          gracePeriodEndsAt,
          isInGracePeriod,
          calculatedPenaltyCents,
          dailyRateCents,
          penaltyRate,
          status: existingRecord.status
        });
      } else {
        const opRefCode = await generateReferenceCode("overstay_penalty");
        const [newRecord] = await db.insert(storageOverstayRecords).values({
          referenceCode: opRefCode,
          storageBookingId: booking.id,
          endDate: booking.endDate,
          daysOverdue,
          gracePeriodEndsAt,
          status,
          calculatedPenaltyCents,
          dailyRateCents,
          penaltyRate: penaltyRate.toString(),
          idempotencyKey
        }).returning();
        await createOverstayHistoryEntry(newRecord.id, null, status, "status_change", "cron", `Overstay detected. Days overdue: ${daysOverdue}`);
        results.push({
          bookingId: booking.id,
          chefId: booking.chefId,
          daysOverdue,
          gracePeriodEndsAt,
          isInGracePeriod,
          calculatedPenaltyCents,
          dailyRateCents,
          penaltyRate,
          status
        });
        logger.info(`[OverstayService] Created overstay record for booking ${booking.id}`, {
          daysOverdue,
          isInGracePeriod,
          calculatedPenaltyCents
        });
        try {
          await sendOverstayNotificationEmails({
            storageBookingId: booking.id,
            chefId: booking.chefId,
            daysOverdue,
            gracePeriodEndsAt,
            isInGracePeriod,
            calculatedPenaltyCents,
            endDate: new Date(booking.endDate)
          });
        } catch (emailError) {
          logger.error(`[OverstayService] Error sending overstay notification emails for booking ${booking.id}:`, emailError);
        }
        try {
          const { notificationService: notificationService2 } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
          const [listingData] = await db.select({ name: storageListings.name, kitchenId: storageListings.kitchenId }).from(storageListings).where(eq3(storageListings.id, booking.storageListingId)).limit(1);
          let kitchenName = "Kitchen";
          let locationData;
          if (listingData?.kitchenId) {
            const [kitchenData] = await db.select({ name: kitchens.name, locationId: kitchens.locationId }).from(kitchens).where(eq3(kitchens.id, listingData.kitchenId)).limit(1);
            kitchenName = kitchenData?.name || "Kitchen";
            if (kitchenData?.locationId) {
              const [locData] = await db.select({ id: locations.id, managerId: locations.managerId }).from(locations).where(eq3(locations.id, kitchenData.locationId)).limit(1);
              locationData = locData;
            }
          }
          let chefName = "Chef";
          if (booking.chefId) {
            const [chefData] = await db.select({ email: users.username }).from(users).where(eq3(users.id, booking.chefId)).limit(1);
            chefName = chefData?.email || "Chef";
          }
          if (booking.chefId) {
            await notificationService2.notifyChefOverstayDetected({
              chefId: booking.chefId,
              overstayId: newRecord.id,
              storageName: listingData?.name || "Storage",
              kitchenName,
              daysOverdue,
              penaltyAmountCents: calculatedPenaltyCents,
              gracePeriodEndsAt
            });
          }
          if (!isInGracePeriod && locationData?.managerId && locationData.id) {
            await notificationService2.notifyManagerOverstayPendingReview({
              managerId: locationData.managerId,
              locationId: locationData.id,
              chefName,
              overstayId: newRecord.id,
              storageName: listingData?.name || "Storage",
              kitchenName,
              daysOverdue,
              penaltyAmountCents: calculatedPenaltyCents
            });
          }
        } catch (notifError) {
          logger.error(`[OverstayService] Error sending in-app notifications for booking ${booking.id}:`, notifError);
        }
      }
    } catch (error) {
      logger.error(`[OverstayService] Error processing booking ${booking.id}:`, error);
    }
  }
  return results;
}
async function getPendingOverstayReviews(locationId) {
  const platformDefaults = await getOverstayPlatformDefaults();
  const query = db.select({
    overstayId: storageOverstayRecords.id,
    storageBookingId: storageOverstayRecords.storageBookingId,
    status: storageOverstayRecords.status,
    daysOverdue: storageOverstayRecords.daysOverdue,
    gracePeriodEndsAt: storageOverstayRecords.gracePeriodEndsAt,
    calculatedPenaltyCents: storageOverstayRecords.calculatedPenaltyCents,
    finalPenaltyCents: storageOverstayRecords.finalPenaltyCents,
    detectedAt: storageOverstayRecords.detectedAt,
    bookingStartDate: storageBookings.startDate,
    bookingEndDate: storageBookings.endDate,
    bookingTotalPrice: storageBookings.totalPrice,
    storageListingId: storageListings.id,
    storageName: storageListings.name,
    storageType: storageListings.storageType,
    dailyRateCents: storageOverstayRecords.dailyRateCents,
    gracePeriodDays: storageListings.overstayGracePeriodDays,
    penaltyRate: storageListings.overstayPenaltyRate,
    maxPenaltyDays: storageListings.overstayMaxPenaltyDays,
    kitchenId: kitchens.id,
    kitchenName: kitchens.name,
    kitchenTaxRatePercent: kitchens.taxRatePercent,
    locationId: kitchens.locationId,
    chefId: storageBookings.chefId,
    chefEmail: users.username,
    stripeCustomerId: storageBookings.stripeCustomerId,
    stripePaymentMethodId: storageBookings.stripePaymentMethodId
  }).from(storageOverstayRecords).innerJoin(storageBookings, eq3(storageOverstayRecords.storageBookingId, storageBookings.id)).innerJoin(storageListings, eq3(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq3(storageListings.kitchenId, kitchens.id)).leftJoin(users, eq3(storageBookings.chefId, users.id)).where(
    inArray(storageOverstayRecords.status, ["detected", "grace_period", "pending_review", "penalty_approved", "charge_pending", "charge_failed", "escalated"])
  ).orderBy(desc(storageOverstayRecords.daysOverdue));
  const results = await query;
  const filtered = locationId ? results.filter((r) => r.locationId === locationId) : results;
  return filtered.map((r) => ({
    ...r,
    storageName: r.storageName || "Storage",
    storageType: r.storageType || "dry",
    kitchenName: r.kitchenName || "Kitchen",
    kitchenTaxRatePercent: r.kitchenTaxRatePercent ? parseFloat(String(r.kitchenTaxRatePercent)) : 0,
    gracePeriodDays: r.gracePeriodDays ?? platformDefaults.gracePeriodDays,
    penaltyRate: r.penaltyRate?.toString() ?? platformDefaults.penaltyRate.toString(),
    maxPenaltyDays: r.maxPenaltyDays ?? platformDefaults.maxPenaltyDays,
    chefInfo: null
  }));
}
async function getAllOverstayRecords(locationId) {
  const platformDefaults = await getOverstayPlatformDefaults();
  const query = db.select({
    overstayId: storageOverstayRecords.id,
    storageBookingId: storageOverstayRecords.storageBookingId,
    status: storageOverstayRecords.status,
    daysOverdue: storageOverstayRecords.daysOverdue,
    gracePeriodEndsAt: storageOverstayRecords.gracePeriodEndsAt,
    calculatedPenaltyCents: storageOverstayRecords.calculatedPenaltyCents,
    finalPenaltyCents: storageOverstayRecords.finalPenaltyCents,
    detectedAt: storageOverstayRecords.detectedAt,
    bookingStartDate: storageBookings.startDate,
    bookingEndDate: storageBookings.endDate,
    bookingTotalPrice: storageBookings.totalPrice,
    storageListingId: storageListings.id,
    storageName: storageListings.name,
    storageType: storageListings.storageType,
    dailyRateCents: storageOverstayRecords.dailyRateCents,
    gracePeriodDays: storageListings.overstayGracePeriodDays,
    penaltyRate: storageListings.overstayPenaltyRate,
    maxPenaltyDays: storageListings.overstayMaxPenaltyDays,
    kitchenId: kitchens.id,
    kitchenName: kitchens.name,
    kitchenTaxRatePercent: kitchens.taxRatePercent,
    locationId: kitchens.locationId,
    chefId: storageBookings.chefId,
    chefEmail: users.username,
    stripeCustomerId: storageBookings.stripeCustomerId,
    stripePaymentMethodId: storageBookings.stripePaymentMethodId
  }).from(storageOverstayRecords).innerJoin(storageBookings, eq3(storageOverstayRecords.storageBookingId, storageBookings.id)).innerJoin(storageListings, eq3(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq3(storageListings.kitchenId, kitchens.id)).leftJoin(users, eq3(storageBookings.chefId, users.id)).orderBy(desc(storageOverstayRecords.detectedAt));
  const results = await query;
  const filtered = locationId ? results.filter((r) => r.locationId === locationId) : results;
  return filtered.map((r) => ({
    ...r,
    storageName: r.storageName || "Storage",
    storageType: r.storageType || "dry",
    kitchenName: r.kitchenName || "Kitchen",
    kitchenTaxRatePercent: r.kitchenTaxRatePercent ? parseFloat(String(r.kitchenTaxRatePercent)) : 0,
    gracePeriodDays: r.gracePeriodDays ?? platformDefaults.gracePeriodDays,
    penaltyRate: r.penaltyRate?.toString() ?? platformDefaults.penaltyRate.toString(),
    maxPenaltyDays: r.maxPenaltyDays ?? platformDefaults.maxPenaltyDays,
    chefInfo: null
  }));
}
async function getOverstayRecord(overstayId) {
  const [record] = await db.select().from(storageOverstayRecords).where(eq3(storageOverstayRecords.id, overstayId)).limit(1);
  return record || null;
}
async function processManagerDecision(decision) {
  const { overstayRecordId, managerId, action, finalPenaltyCents, waiveReason, managerNotes } = decision;
  if (!overstayRecordId || overstayRecordId <= 0) {
    return { success: false, error: "Invalid overstay record ID" };
  }
  if (!managerId || managerId <= 0) {
    return { success: false, error: "Invalid manager ID" };
  }
  const record = await getOverstayRecord(overstayRecordId);
  if (!record) {
    return { success: false, error: "Overstay record not found" };
  }
  const allowedStatuses = ["pending_review", "charge_failed"];
  if (!allowedStatuses.includes(record.status)) {
    return { success: false, error: `Cannot process decision for record in status: ${record.status}` };
  }
  const previousStatus = record.status;
  let newStatus;
  const updateData = {
    penaltyApprovedBy: managerId,
    penaltyApprovedAt: /* @__PURE__ */ new Date(),
    managerNotes: managerNotes || record.managerNotes,
    updatedAt: /* @__PURE__ */ new Date()
  };
  const validatePenaltyAmount = (amount) => {
    if (amount < 0) {
      return { valid: false, error: "Penalty amount cannot be negative" };
    }
    if (amount > record.calculatedPenaltyCents) {
      return {
        valid: false,
        error: `Penalty amount cannot exceed the calculated maximum of $${(record.calculatedPenaltyCents / 100).toFixed(2)}`
      };
    }
    return { valid: true };
  };
  switch (action) {
    case "approve": {
      if (finalPenaltyCents !== void 0) {
        const validation = validatePenaltyAmount(finalPenaltyCents);
        if (!validation.valid) {
          return { success: false, error: validation.error };
        }
      }
      newStatus = "penalty_approved";
      updateData.finalPenaltyCents = finalPenaltyCents ?? record.calculatedPenaltyCents;
      updateData.status = newStatus;
      break;
    }
    case "waive":
      newStatus = "penalty_waived";
      updateData.penaltyWaived = true;
      updateData.waiveReason = waiveReason || "Manager waived penalty";
      updateData.finalPenaltyCents = 0;
      updateData.status = newStatus;
      updateData.resolvedAt = /* @__PURE__ */ new Date();
      updateData.resolutionType = "waived";
      break;
    case "adjust": {
      if (finalPenaltyCents === void 0) {
        return { success: false, error: "finalPenaltyCents required for adjust action" };
      }
      const adjustValidation = validatePenaltyAmount(finalPenaltyCents);
      if (!adjustValidation.valid) {
        return { success: false, error: adjustValidation.error };
      }
      newStatus = "penalty_approved";
      updateData.finalPenaltyCents = finalPenaltyCents;
      updateData.status = newStatus;
      break;
    }
    default:
      return { success: false, error: `Invalid action: ${action}` };
  }
  await db.update(storageOverstayRecords).set(updateData).where(eq3(storageOverstayRecords.id, overstayRecordId));
  await createOverstayHistoryEntry(
    overstayRecordId,
    previousStatus,
    newStatus,
    action === "waive" ? "penalty_waived" : "penalty_approved",
    "manager",
    `Manager ${action}: ${action === "waive" ? waiveReason : `$${((finalPenaltyCents ?? record.calculatedPenaltyCents) / 100).toFixed(2)}`}`,
    { managerId, action, finalPenaltyCents, waiveReason },
    managerId
  );
  logger.info(`[OverstayService] Manager decision processed`, {
    overstayRecordId,
    managerId,
    action,
    finalPenaltyCents: updateData.finalPenaltyCents
  });
  if (action === "waive") {
    try {
      await db.update(storageBookings).set({ status: "completed", updatedAt: /* @__PURE__ */ new Date() }).where(eq3(storageBookings.id, record.storageBookingId));
      logger.info(`[OverstayService] Auto-completed storage booking ${record.storageBookingId} after penalty waived`);
    } catch (completeError) {
      logger.error(`[OverstayService] Failed to auto-complete booking ${record.storageBookingId}:`, completeError);
    }
  }
  return { success: true };
}
async function chargeApprovedPenalty(overstayRecordId) {
  if (!stripe2) {
    return { success: false, error: "Stripe not configured" };
  }
  const record = await getOverstayRecord(overstayRecordId);
  if (!record) {
    return { success: false, error: "Overstay record not found" };
  }
  const chargeableStatuses = ["penalty_approved", "charge_failed", "charge_pending", "escalated"];
  if (!chargeableStatuses.includes(record.status)) {
    return { success: false, error: `Cannot charge record in status: ${record.status}` };
  }
  if (!record.finalPenaltyCents || record.finalPenaltyCents <= 0) {
    return { success: false, error: "No penalty amount to charge" };
  }
  const [booking] = await db.select({
    stripeCustomerId: storageBookings.stripeCustomerId,
    stripePaymentMethodId: storageBookings.stripePaymentMethodId,
    chefId: storageBookings.chefId
  }).from(storageBookings).where(eq3(storageBookings.id, record.storageBookingId)).limit(1);
  if (!booking) {
    return { success: false, error: "Booking not found" };
  }
  let customerId = booking.stripeCustomerId;
  const paymentMethodId = booking.stripePaymentMethodId;
  if (!customerId && booking.chefId) {
    const [user] = await db.select({ stripeCustomerId: users.stripeCustomerId }).from(users).where(eq3(users.id, booking.chefId)).limit(1);
    customerId = user?.stripeCustomerId || null;
  }
  if (!customerId || !paymentMethodId) {
    await db.update(storageOverstayRecords).set({
      status: "charge_failed",
      chargeFailedAt: /* @__PURE__ */ new Date(),
      chargeFailureReason: "No saved payment method available",
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq3(storageOverstayRecords.id, overstayRecordId));
    await createOverstayHistoryEntry(
      overstayRecordId,
      "penalty_approved",
      "charge_failed",
      "charge_attempt",
      "system",
      "No saved payment method available"
    );
    return { success: false, error: "No saved payment method available for off-session charging" };
  }
  let managerStripeAccountId = null;
  let managerId = null;
  const [storageBooking] = await db.select({ storageListingId: storageBookings.storageListingId }).from(storageBookings).where(eq3(storageBookings.id, record.storageBookingId)).limit(1);
  if (storageBooking) {
    const [listing] = await db.select({ kitchenId: storageListings.kitchenId }).from(storageListings).where(eq3(storageListings.id, storageBooking.storageListingId)).limit(1);
    if (listing?.kitchenId) {
      const [kitchen] = await db.select({ locationId: kitchens.locationId }).from(kitchens).where(eq3(kitchens.id, listing.kitchenId)).limit(1);
      if (kitchen?.locationId) {
        const [location] = await db.select({ managerId: locations.managerId }).from(locations).where(eq3(locations.id, kitchen.locationId)).limit(1);
        if (location?.managerId) {
          managerId = location.managerId;
          const [manager] = await db.select({ stripeConnectAccountId: users.stripeConnectAccountId }).from(users).where(eq3(users.id, location.managerId)).limit(1);
          managerStripeAccountId = manager?.stripeConnectAccountId || null;
        }
      }
    }
  }
  await db.update(storageOverstayRecords).set({
    status: "charge_pending",
    chargeAttemptedAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq3(storageOverstayRecords.id, overstayRecordId));
  try {
    let taxRatePercent = 0;
    try {
      const [storageBooking2] = await db.select({ storageListingId: storageBookings.storageListingId }).from(storageBookings).where(eq3(storageBookings.id, record.storageBookingId)).limit(1);
      if (storageBooking2) {
        const [listing] = await db.select({ kitchenId: storageListings.kitchenId }).from(storageListings).where(eq3(storageListings.id, storageBooking2.storageListingId)).limit(1);
        if (listing?.kitchenId) {
          const [kitchen] = await db.select({ taxRatePercent: kitchens.taxRatePercent }).from(kitchens).where(eq3(kitchens.id, listing.kitchenId)).limit(1);
          if (kitchen?.taxRatePercent) {
            taxRatePercent = parseFloat(String(kitchen.taxRatePercent));
          }
        }
      }
    } catch (taxError) {
      logger.warn(`[OverstayService] Could not fetch tax rate for penalty:`, taxError);
    }
    const penaltyBaseCents = record.finalPenaltyCents;
    const penaltyTaxCents = Math.round(penaltyBaseCents * taxRatePercent / 100);
    const penaltyTotalCents = penaltyBaseCents + penaltyTaxCents;
    logger.info(`[OverstayService] Calculated tax for overstay penalty:`, {
      overstayRecordId,
      penaltyBaseCents,
      penaltyTaxCents,
      penaltyTotalCents,
      taxRatePercent
    });
    let applicationFeeAmount;
    if (managerStripeAccountId) {
      const { calculateCheckoutFees: calculateCheckoutFees2 } = await Promise.resolve().then(() => (init_stripe_checkout_fee_service(), stripe_checkout_fee_service_exports));
      const feeResult = calculateCheckoutFees2(penaltyTotalCents / 100);
      applicationFeeAmount = feeResult.stripeProcessingFeeInCents;
      logger.info(`[OverstayService] Calculated application fee for break-even: ${applicationFeeAmount} cents`);
    }
    const paymentIntentParams = {
      amount: penaltyTotalCents,
      currency: "cad",
      customer: customerId,
      payment_method: paymentMethodId,
      off_session: true,
      confirm: true,
      metadata: {
        type: "overstay_penalty",
        overstay_record_id: overstayRecordId.toString(),
        storage_booking_id: record.storageBookingId.toString(),
        days_overdue: record.daysOverdue.toString(),
        manager_id: managerId?.toString() || "",
        tax_rate_percent: taxRatePercent.toString(),
        penalty_base_cents: penaltyBaseCents.toString(),
        penalty_tax_cents: penaltyTaxCents.toString()
      },
      statement_descriptor_suffix: "OVERSTAY FEE"
    };
    if (managerStripeAccountId) {
      paymentIntentParams.transfer_data = {
        destination: managerStripeAccountId
      };
      if (applicationFeeAmount && applicationFeeAmount > 0) {
        paymentIntentParams.application_fee_amount = applicationFeeAmount;
        logger.info(`[OverstayService] Setting application_fee_amount: ${applicationFeeAmount} cents for break-even`);
      }
      logger.info(`[OverstayService] Using destination charge to manager account: ${managerStripeAccountId}`);
    }
    const idempotencyKey = `overstay_penalty_${overstayRecordId}_${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`;
    const paymentIntent = await stripe2.paymentIntents.create(paymentIntentParams, {
      idempotencyKey
    });
    if (paymentIntent.status === "succeeded") {
      const chargeId = typeof paymentIntent.latest_charge === "string" ? paymentIntent.latest_charge : paymentIntent.latest_charge?.id;
      await db.update(storageOverstayRecords).set({
        status: "charge_succeeded",
        stripePaymentIntentId: paymentIntent.id,
        stripeChargeId: chargeId || null,
        chargeSucceededAt: /* @__PURE__ */ new Date(),
        resolvedAt: /* @__PURE__ */ new Date(),
        resolutionType: "paid",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq3(storageOverstayRecords.id, overstayRecordId));
      await createOverstayHistoryEntry(
        overstayRecordId,
        "charge_pending",
        "charge_succeeded",
        "charge_attempt",
        "stripe_webhook",
        `Payment successful: ${paymentIntent.id}`,
        { paymentIntentId: paymentIntent.id, chargeId }
      );
      try {
        const { createPaymentTransaction: createPaymentTransaction2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
        const { getStripePaymentAmounts: getStripePaymentAmounts2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
        const serviceFeeForTransaction = applicationFeeAmount || 0;
        const managerRevenueForTransaction = penaltyTotalCents - serviceFeeForTransaction;
        const ptRecord = await createPaymentTransaction2({
          bookingId: record.storageBookingId,
          bookingType: "storage",
          chefId: booking.chefId || null,
          managerId,
          // Already fetched above for destination charge
          amount: penaltyTotalCents,
          // Total including tax
          baseAmount: penaltyBaseCents,
          // Base before tax
          serviceFee: serviceFeeForTransaction,
          // Platform fee (covers Stripe processing)
          managerRevenue: managerRevenueForTransaction,
          // What manager actually receives
          currency: "CAD",
          paymentIntentId: paymentIntent.id,
          // CRITICAL: Save payment intent for fee syncing
          chargeId: chargeId || void 0,
          status: "succeeded",
          stripeStatus: "succeeded",
          metadata: {
            type: "overstay_penalty",
            overstay_record_id: overstayRecordId.toString(),
            storage_booking_id: record.storageBookingId.toString(),
            charged_via: "off_session",
            // Indicates this was charged directly, not via checkout
            tax_rate_percent: taxRatePercent.toString(),
            penalty_base_cents: penaltyBaseCents.toString(),
            penalty_tax_cents: penaltyTaxCents.toString(),
            application_fee_cents: serviceFeeForTransaction.toString()
          }
        }, db);
        if (ptRecord) {
          const stripeAmounts = await getStripePaymentAmounts2(paymentIntent.id, managerStripeAccountId || void 0);
          if (stripeAmounts) {
            await updatePaymentTransaction2(ptRecord.id, {
              paidAt: /* @__PURE__ */ new Date(),
              lastSyncedAt: /* @__PURE__ */ new Date(),
              stripeAmount: stripeAmounts.stripeAmount,
              stripeNetAmount: stripeAmounts.stripeNetAmount,
              stripeProcessingFee: stripeAmounts.stripeProcessingFee,
              stripePlatformFee: stripeAmounts.stripePlatformFee
            }, db);
            logger.info(`[OverstayService] Synced Stripe fees for overstay penalty ${overstayRecordId}:`, {
              processingFee: `$${(stripeAmounts.stripeProcessingFee / 100).toFixed(2)}`
            });
          }
        }
        logger.info(`[OverstayService] Created payment_transactions for overstay penalty ${overstayRecordId}`);
      } catch (ptError) {
        logger.error(`[OverstayService] Failed to create payment_transactions for overstay penalty:`, ptError);
      }
      logger.info(`[OverstayService] Penalty charged successfully`, {
        overstayRecordId,
        paymentIntentId: paymentIntent.id,
        amount: record.finalPenaltyCents
      });
      try {
        await sendPenaltyChargedEmail(overstayRecordId, record.finalPenaltyCents, record.daysOverdue);
      } catch (emailError) {
        logger.error(`[OverstayService] Error sending penalty charged email:`, emailError);
      }
      try {
        const { notificationService: notificationService2 } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
        let storageName = "Storage";
        let kitchenNameForNotif = "Kitchen";
        let locationIdForNotif = null;
        if (storageBooking?.storageListingId) {
          const [listingInfo] = await db.select({ name: storageListings.name, kitchenId: storageListings.kitchenId }).from(storageListings).where(eq3(storageListings.id, storageBooking.storageListingId)).limit(1);
          storageName = listingInfo?.name || "Storage";
          if (listingInfo?.kitchenId) {
            const [kitchenInfo] = await db.select({ name: kitchens.name, locationId: kitchens.locationId }).from(kitchens).where(eq3(kitchens.id, listingInfo.kitchenId)).limit(1);
            kitchenNameForNotif = kitchenInfo?.name || "Kitchen";
            locationIdForNotif = kitchenInfo?.locationId || null;
          }
        }
        if (booking.chefId) {
          await notificationService2.notifyChefPenaltyCharged({
            chefId: booking.chefId,
            overstayId: overstayRecordId,
            storageName,
            kitchenName: kitchenNameForNotif,
            daysOverdue: record.daysOverdue,
            penaltyAmountCents: record.finalPenaltyCents || 0
          });
        }
        if (managerId && locationIdForNotif) {
          await notificationService2.notifyManagerPenaltyReceived({
            managerId,
            locationId: locationIdForNotif,
            chefName: booking.chefId ? `Chef #${booking.chefId}` : "Chef",
            overstayId: overstayRecordId,
            storageName,
            kitchenName: kitchenNameForNotif,
            daysOverdue: record.daysOverdue,
            penaltyAmountCents: record.finalPenaltyCents || 0
          });
        }
      } catch (notifError) {
        logger.error(`[OverstayService] Error sending in-app notifications for charge:`, notifError);
      }
      try {
        await db.update(storageBookings).set({ status: "completed", updatedAt: /* @__PURE__ */ new Date() }).where(eq3(storageBookings.id, record.storageBookingId));
        logger.info(`[OverstayService] Auto-completed storage booking ${record.storageBookingId} after penalty charge succeeded`);
      } catch (completeError) {
        logger.error(`[OverstayService] Failed to auto-complete booking ${record.storageBookingId}:`, completeError);
      }
      return {
        success: true,
        paymentIntentId: paymentIntent.id,
        chargeId: chargeId || void 0
      };
    } else {
      const failureReason = paymentIntent.status === "requires_action" || paymentIntent.status === "requires_confirmation" || paymentIntent.status === "requires_payment_method" ? `Payment requires authentication (3DS/SCA)` : `Payment status: ${paymentIntent.status}`;
      await db.update(storageOverstayRecords).set({
        status: "escalated",
        stripePaymentIntentId: paymentIntent.id,
        chargeFailedAt: /* @__PURE__ */ new Date(),
        chargeFailureReason: failureReason,
        resolutionType: "escalated_collection",
        resolutionNotes: `Auto-escalated: off-session charge failed (${failureReason}). Self-serve payment link sent to chef.`,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq3(storageOverstayRecords.id, overstayRecordId));
      await createOverstayHistoryEntry(
        overstayRecordId,
        "charge_pending",
        "escalated",
        "auto_escalation",
        "system",
        `Off-session charge failed: ${failureReason}. Escalated immediately.`,
        { paymentIntentId: paymentIntent.id, status: paymentIntent.status }
      );
      await sendEscalationPaymentLinkToChef(overstayRecordId, record, booking.chefId, failureReason);
      await sendEscalationAdminEmail(overstayRecordId, record, failureReason);
      return {
        success: false,
        error: `Auto-charge failed (${failureReason}). Escalated \u2014 payment link sent to chef.`
      };
    }
  } catch (error) {
    const errorMessage = error.message || "Unknown error";
    const stripeErrorCode = error.code || error.raw?.code || "";
    const failureReason = stripeErrorCode === "authentication_required" || errorMessage.includes("requires authentication") || errorMessage.includes("authentication_required") ? `Payment requires authentication (3DS/SCA)` : errorMessage;
    await db.update(storageOverstayRecords).set({
      status: "escalated",
      chargeFailedAt: /* @__PURE__ */ new Date(),
      chargeFailureReason: failureReason,
      resolutionType: "escalated_collection",
      resolutionNotes: `Auto-escalated: off-session charge threw error (${failureReason}). Self-serve payment link sent to chef.`,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq3(storageOverstayRecords.id, overstayRecordId));
    await createOverstayHistoryEntry(
      overstayRecordId,
      "charge_pending",
      "escalated",
      "auto_escalation",
      "system",
      `Off-session charge error: ${failureReason}. Escalated immediately.`,
      { error: errorMessage, stripeErrorCode }
    );
    logger.error(`[OverstayService] Penalty charge failed \u2014 escalated immediately`, {
      overstayRecordId,
      error: errorMessage,
      stripeErrorCode
    });
    await sendEscalationPaymentLinkToChef(overstayRecordId, record, booking.chefId, failureReason);
    await sendEscalationAdminEmail(overstayRecordId, record, failureReason);
    return { success: false, error: `Auto-charge failed (${failureReason}). Escalated \u2014 payment link sent to chef.` };
  }
}
async function sendEscalationPaymentLinkToChef(overstayRecordId, record, chefId, failureReason) {
  if (!chefId) return;
  try {
    const [chef] = await db.select({ email: users.username }).from(users).where(eq3(users.id, chefId)).limit(1);
    if (!chef?.email) {
      logger.warn(`[OverstayService] No email found for chef ${chefId} \u2014 cannot send escalation payment link`);
      return;
    }
    const [booking] = await db.select({ storageName: storageListings.name }).from(storageBookings).innerJoin(storageListings, eq3(storageBookings.storageListingId, storageListings.id)).where(eq3(storageBookings.id, record.storageBookingId)).limit(1);
    const storageName = booking?.storageName || "Storage";
    const penaltyAmount = ((record.finalPenaltyCents || record.calculatedPenaltyCents || 0) / 100).toFixed(2);
    const baseUrl = process.env.FRONTEND_URL || process.env.VITE_API_URL || "https://localcooks.com";
    const checkoutResult = await createPenaltyPaymentCheckout(
      overstayRecordId,
      chefId,
      `${baseUrl}/chef/payments/success?overstay=${overstayRecordId}`,
      `${baseUrl}/chef/payments/cancel?overstay=${overstayRecordId}`
    );
    if ("checkoutUrl" in checkoutResult) {
      const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
      await sendEmail2({
        to: chef.email,
        subject: `\u26A0\uFE0F Action Required: Overstay Penalty Payment - $${penaltyAmount} CAD`,
        html: `
          <h2>\u26A0\uFE0F Overstay Penalty \u2014 Payment Required</h2>
          <p>We were unable to automatically charge your saved payment method for your storage overstay penalty.</p>
          <p><strong>Reason:</strong> ${failureReason}</p>
          <p><strong>Amount:</strong> $${penaltyAmount} CAD</p>
          <p><strong>Storage:</strong> ${storageName}</p>
          <p><strong>Days Overdue:</strong> ${record.daysOverdue}</p>
          <p>Please pay immediately using the secure link below:</p>
          <p><a href="${checkoutResult.checkoutUrl}" style="display: inline-block; padding: 12px 24px; background-color: #DC2626; color: white; text-decoration: none; border-radius: 6px; font-weight: bold;">Pay Now \u2014 $${penaltyAmount} CAD</a></p>
          <p>This link will expire in 24 hours.</p>
          <p><em>You will not be able to make new bookings until this penalty is resolved. If payment is not received, this matter may be referred for manual collection.</em></p>
        `,
        text: `Overstay Penalty \u2014 Payment Required

Reason: ${failureReason}
Amount: $${penaltyAmount} CAD
Storage: ${storageName}
Days Overdue: ${record.daysOverdue}

Pay now: ${checkoutResult.checkoutUrl}

This link expires in 24 hours.`
      });
      logger.info(`[OverstayService] Sent escalation payment link to chef ${chef.email} for overstay ${overstayRecordId}`);
      await createOverstayHistoryEntry(
        overstayRecordId,
        "escalated",
        "escalated",
        "escalation_payment_link_sent",
        "system",
        `Escalation payment link sent to chef ${chef.email}`,
        { checkoutUrl: checkoutResult.checkoutUrl, chefEmail: chef.email, failureReason }
      );
    }
  } catch (error) {
    logger.error(`[OverstayService] Failed to send escalation payment link to chef:`, error);
  }
}
async function sendEscalationAdminEmail(overstayRecordId, record, failureReason) {
  try {
    const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
    const [booking] = await db.select({
      storageName: storageListings.name,
      chefId: storageBookings.chefId
    }).from(storageBookings).innerJoin(storageListings, eq3(storageBookings.storageListingId, storageListings.id)).where(eq3(storageBookings.id, record.storageBookingId)).limit(1);
    let chefEmail = "Unknown";
    if (booking?.chefId) {
      const [chef] = await db.select({ email: users.username }).from(users).where(eq3(users.id, booking.chefId)).limit(1);
      chefEmail = chef?.email || "Unknown";
    }
    const penaltyAmount = ((record.finalPenaltyCents || record.calculatedPenaltyCents || 0) / 100).toFixed(2);
    const admins = await db.select({ username: users.username }).from(users).where(eq3(users.role, "admin"));
    if (admins.length === 0) {
      logger.warn(`[OverstayService] No admin users found \u2014 escalation email NOT sent for overstay ${overstayRecordId}`);
      return;
    }
    for (const admin2 of admins) {
      if (admin2.username) {
        await sendEmail2({
          to: admin2.username,
          subject: `\u26A0\uFE0F Escalated Overstay Penalty \u2014 Auto-Charge Failed`,
          html: `
            <h2>Overstay Penalty Escalated</h2>
            <p>An overstay penalty auto-charge failed and has been escalated. A self-serve payment link has been sent to the chef.</p>
            <h3>Details:</h3>
            <ul>
              <li><strong>Overstay Record ID:</strong> ${overstayRecordId}</li>
              <li><strong>Storage:</strong> ${booking?.storageName || "Unknown"}</li>
              <li><strong>Chef Email:</strong> ${chefEmail}</li>
              <li><strong>Penalty Amount:</strong> $${penaltyAmount} CAD</li>
              <li><strong>Days Overdue:</strong> ${record.daysOverdue}</li>
              <li><strong>Failure Reason:</strong> ${failureReason}</li>
            </ul>
            <p>If the chef does not pay via the link, please take appropriate collection action.</p>
          `,
          text: `Overstay Penalty Escalated

Record ID: ${overstayRecordId}
Chef: ${chefEmail}
Amount: $${penaltyAmount} CAD
Reason: ${failureReason}`
        });
      }
    }
    logger.info(`[OverstayService] Sent escalation notification to ${admins.length} admin(s) for overstay ${overstayRecordId}`);
  } catch (emailError) {
    logger.error(`[OverstayService] Failed to send escalation admin email:`, emailError);
  }
}
async function resolveOverstay(overstayRecordId, resolutionType, resolutionNotes, resolvedBy) {
  const record = await getOverstayRecord(overstayRecordId);
  if (!record) {
    return { success: false, error: "Overstay record not found" };
  }
  const previousStatus = record.status;
  const newStatus = resolutionType === "escalated" ? "escalated" : "resolved";
  await db.update(storageOverstayRecords).set({
    status: newStatus,
    resolvedAt: /* @__PURE__ */ new Date(),
    resolutionType,
    resolutionNotes,
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq3(storageOverstayRecords.id, overstayRecordId));
  await createOverstayHistoryEntry(
    overstayRecordId,
    previousStatus,
    newStatus,
    "resolution",
    resolvedBy ? "manager" : "system",
    `Resolved: ${resolutionType}${resolutionNotes ? ` - ${resolutionNotes}` : ""}`,
    { resolutionType, resolutionNotes },
    resolvedBy
  );
  if (resolutionType === "removed") {
    try {
      await db.update(storageBookings).set({ status: "completed", updatedAt: /* @__PURE__ */ new Date() }).where(eq3(storageBookings.id, record.storageBookingId));
      logger.info(`[OverstayService] Auto-completed storage booking ${record.storageBookingId} after overstay resolved (items removed)`);
    } catch (completeError) {
      logger.error(`[OverstayService] Failed to auto-complete booking ${record.storageBookingId}:`, completeError);
    }
  }
  return { success: true };
}
async function createOverstayHistoryEntry(overstayRecordId, previousStatus, newStatus, eventType, eventSource, description, metadata, createdBy) {
  await db.insert(storageOverstayHistory).values({
    overstayRecordId,
    previousStatus,
    newStatus,
    eventType,
    eventSource,
    description,
    metadata: metadata || {},
    createdBy
  });
}
async function getOverstayHistory(overstayRecordId) {
  return db.select().from(storageOverstayHistory).where(eq3(storageOverstayHistory.overstayRecordId, overstayRecordId)).orderBy(desc(storageOverstayHistory.createdAt));
}
async function getOverstayStats(locationIds) {
  const query = db.select({
    status: storageOverstayRecords.status,
    calculatedPenaltyCents: storageOverstayRecords.calculatedPenaltyCents,
    finalPenaltyCents: storageOverstayRecords.finalPenaltyCents,
    locationId: kitchens.locationId
  }).from(storageOverstayRecords).innerJoin(storageBookings, eq3(storageOverstayRecords.storageBookingId, storageBookings.id)).innerJoin(storageListings, eq3(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq3(storageListings.kitchenId, kitchens.id));
  const allRecords = locationIds && locationIds.length > 0 ? await query.where(inArray(kitchens.locationId, locationIds)) : await query;
  const filtered = allRecords;
  const stats = {
    total: filtered.length,
    pendingReview: filtered.filter((r) => r.status === "pending_review").length,
    inGracePeriod: filtered.filter((r) => r.status === "grace_period").length,
    approved: filtered.filter((r) => r.status === "penalty_approved").length,
    waived: filtered.filter((r) => r.status === "penalty_waived").length,
    charged: filtered.filter((r) => r.status === "charge_succeeded").length,
    failed: filtered.filter((r) => r.status === "charge_failed").length,
    resolved: filtered.filter((r) => r.status === "resolved").length,
    escalated: filtered.filter((r) => r.status === "escalated").length,
    totalPenaltiesCollected: filtered.filter((r) => r.status === "charge_succeeded").reduce((sum, r) => sum + (r.finalPenaltyCents || 0), 0),
    totalPenaltiesWaived: filtered.filter((r) => r.status === "penalty_waived").reduce((sum, r) => sum + (r.calculatedPenaltyCents || 0), 0)
  };
  return stats;
}
async function markChefWarningSent(overstayRecordId) {
  const record = await getOverstayRecord(overstayRecordId);
  if (!record) return;
  const currentStatus = record.status;
  await db.update(storageOverstayRecords).set({
    chefWarningSentAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq3(storageOverstayRecords.id, overstayRecordId));
  await createOverstayHistoryEntry(
    overstayRecordId,
    currentStatus,
    currentStatus,
    "notification_sent",
    "system",
    "Chef warning email sent"
  );
}
async function markManagerNotified(overstayRecordId) {
  const record = await getOverstayRecord(overstayRecordId);
  if (!record) return;
  const currentStatus = record.status;
  await db.update(storageOverstayRecords).set({
    managerNotifiedAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq3(storageOverstayRecords.id, overstayRecordId));
  await createOverstayHistoryEntry(
    overstayRecordId,
    currentStatus,
    currentStatus,
    "notification_sent",
    "system",
    "Manager notification sent"
  );
}
async function getChefPendingPenalties(chefId) {
  const records = await db.select({
    overstayId: storageOverstayRecords.id,
    storageBookingId: storageOverstayRecords.storageBookingId,
    status: storageOverstayRecords.status,
    daysOverdue: storageOverstayRecords.daysOverdue,
    calculatedPenaltyCents: storageOverstayRecords.calculatedPenaltyCents,
    finalPenaltyCents: storageOverstayRecords.finalPenaltyCents,
    detectedAt: storageOverstayRecords.detectedAt,
    penaltyApprovedAt: storageOverstayRecords.penaltyApprovedAt,
    storageName: storageListings.name,
    storageType: storageListings.storageType,
    kitchenName: kitchens.name,
    bookingEndDate: storageBookings.endDate
  }).from(storageOverstayRecords).innerJoin(storageBookings, eq3(storageOverstayRecords.storageBookingId, storageBookings.id)).innerJoin(storageListings, eq3(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq3(storageListings.kitchenId, kitchens.id)).where(
    and(
      eq3(storageBookings.chefId, chefId),
      eq3(storageOverstayRecords.status, "penalty_approved")
    )
  ).orderBy(desc(storageOverstayRecords.penaltyApprovedAt));
  return records.map((r) => ({
    ...r,
    storageName: r.storageName || "Storage",
    storageType: r.storageType || "dry",
    kitchenName: r.kitchenName || "Kitchen",
    penaltyAmountCents: r.finalPenaltyCents || r.calculatedPenaltyCents || 0
  }));
}
async function getChefAllPenalties(chefId) {
  const relevantStatuses = ["penalty_approved", "charge_pending", "charge_succeeded", "charge_failed", "escalated", "penalty_waived", "resolved"];
  const records = await db.select({
    overstayId: storageOverstayRecords.id,
    storageBookingId: storageOverstayRecords.storageBookingId,
    status: storageOverstayRecords.status,
    daysOverdue: storageOverstayRecords.daysOverdue,
    calculatedPenaltyCents: storageOverstayRecords.calculatedPenaltyCents,
    finalPenaltyCents: storageOverstayRecords.finalPenaltyCents,
    detectedAt: storageOverstayRecords.detectedAt,
    penaltyApprovedAt: storageOverstayRecords.penaltyApprovedAt,
    chargeSucceededAt: storageOverstayRecords.chargeSucceededAt,
    // BACKWARDS COMPATIBILITY: Include fallback fields for older records
    stripePaymentIntentId: storageOverstayRecords.stripePaymentIntentId,
    stripeChargeId: storageOverstayRecords.stripeChargeId,
    resolutionType: storageOverstayRecords.resolutionType,
    resolvedAt: storageOverstayRecords.resolvedAt,
    storageName: storageListings.name,
    storageType: storageListings.storageType,
    kitchenName: kitchens.name,
    kitchenTaxRatePercent: kitchens.taxRatePercent,
    bookingEndDate: storageBookings.endDate
  }).from(storageOverstayRecords).innerJoin(storageBookings, eq3(storageOverstayRecords.storageBookingId, storageBookings.id)).innerJoin(storageListings, eq3(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq3(storageListings.kitchenId, kitchens.id)).where(
    and(
      eq3(storageBookings.chefId, chefId),
      inArray(storageOverstayRecords.status, relevantStatuses)
    )
  ).orderBy(desc(storageOverstayRecords.penaltyApprovedAt));
  return records.map((r) => {
    const failureStatuses = ["charge_failed", "escalated", "charge_pending"];
    const statusIndicatesPaid = r.status === "charge_succeeded";
    const hasStripeCharge = !!r.stripeChargeId && !failureStatuses.includes(r.status);
    const resolutionIndicatesPaid = r.resolutionType === "paid";
    const hasChargeSucceededTimestamp = !!r.chargeSucceededAt;
    const isPaid = statusIndicatesPaid || hasStripeCharge || resolutionIndicatesPaid || hasChargeSucceededTimestamp;
    const isResolved = isPaid || r.status === "penalty_waived" || r.status === "resolved" || !failureStatuses.includes(r.status) && !!r.resolvedAt;
    const baseCents = r.finalPenaltyCents || r.calculatedPenaltyCents || 0;
    const taxRate = parseFloat(String(r.kitchenTaxRatePercent || 0));
    const taxCents = Math.round(baseCents * taxRate / 100);
    return {
      ...r,
      storageName: r.storageName || "Storage",
      storageType: r.storageType || "dry",
      kitchenName: r.kitchenName || "Kitchen",
      kitchenTaxRatePercent: taxRate,
      penaltyAmountCents: baseCents,
      penaltyTaxCents: taxCents,
      penaltyTotalCents: baseCents + taxCents,
      isResolved,
      isPaid
    };
  });
}
async function createPenaltyPaymentCheckout(overstayRecordId, chefId, successUrl, cancelUrl) {
  if (!stripe2) {
    return { error: "Stripe not configured" };
  }
  try {
    const [overstayRecord] = await db.select().from(storageOverstayRecords).where(eq3(storageOverstayRecords.id, overstayRecordId)).limit(1);
    if (!overstayRecord) {
      return { error: "Overstay record not found" };
    }
    const [booking] = await db.select().from(storageBookings).where(eq3(storageBookings.id, overstayRecord.storageBookingId)).limit(1);
    if (!booking) {
      return { error: "Storage booking not found" };
    }
    if (booking.chefId !== chefId) {
      return { error: "Unauthorized: This penalty does not belong to you" };
    }
    const payableStatuses = ["penalty_approved", "charge_failed", "escalated"];
    if (!payableStatuses.includes(overstayRecord.status)) {
      return { error: `Cannot pay penalty in status: ${overstayRecord.status}` };
    }
    const [listing] = await db.select().from(storageListings).where(eq3(storageListings.id, booking.storageListingId)).limit(1);
    const [kitchen] = listing?.kitchenId ? await db.select().from(kitchens).where(eq3(kitchens.id, listing.kitchenId)).limit(1) : [null];
    const [location] = kitchen?.locationId ? await db.select().from(locations).where(eq3(locations.id, kitchen.locationId)).limit(1) : [null];
    let managerStripeAccountId = null;
    if (location?.managerId) {
      const [manager] = await db.select({ stripeConnectAccountId: users.stripeConnectAccountId }).from(users).where(eq3(users.id, location.managerId)).limit(1);
      managerStripeAccountId = manager?.stripeConnectAccountId || null;
    }
    const penaltyAmountCents = overstayRecord.finalPenaltyCents || overstayRecord.calculatedPenaltyCents || 0;
    const storageName = listing?.name || "Storage";
    const kitchenName = kitchen?.name || "Kitchen";
    const managerId = location?.managerId;
    if (penaltyAmountCents <= 0) {
      return { error: "Invalid penalty amount" };
    }
    const [chef] = await db.select({ email: users.username }).from(users).where(eq3(users.id, chefId)).limit(1);
    if (!chef) {
      return { error: "Chef not found" };
    }
    const sessionParams = {
      mode: "payment",
      payment_method_types: ["card"],
      customer_email: chef.email,
      line_items: [
        {
          price_data: {
            currency: "cad",
            product_data: {
              name: `Overstay Penalty - ${storageName}`,
              description: `Storage overstay penalty for ${kitchenName}`
            },
            unit_amount: penaltyAmountCents
          },
          quantity: 1
        }
      ],
      metadata: {
        type: "overstay_penalty",
        overstayRecordId: overstayRecordId.toString(),
        chefId: chefId.toString(),
        storageBookingId: overstayRecord.storageBookingId.toString(),
        managerId: managerId?.toString() || ""
      },
      success_url: successUrl,
      cancel_url: cancelUrl,
      // ENTERPRISE STANDARD: Enable automatic invoice generation
      // Stripe sends paid invoice email to customer when payment succeeds
      // Requires "Successful payments" enabled in Stripe Dashboard > Customer emails settings
      invoice_creation: {
        enabled: true,
        invoice_data: {
          description: `Overstay Penalty - ${storageName} at ${kitchenName}`,
          metadata: {
            booking_type: "overstay_penalty",
            overstay_record_id: overstayRecordId.toString(),
            chef_id: chefId.toString()
          }
        }
      }
    };
    if (managerStripeAccountId) {
      const { calculateCheckoutFees: calculateCheckoutFees2 } = await Promise.resolve().then(() => (init_stripe_checkout_fee_service(), stripe_checkout_fee_service_exports));
      const feeResult = calculateCheckoutFees2(penaltyAmountCents / 100);
      const applicationFeeAmount = feeResult.stripeProcessingFeeInCents;
      logger.info(`[OverstayService] Calculated application fee for checkout break-even: ${applicationFeeAmount} cents`);
      sessionParams.payment_intent_data = {
        transfer_data: {
          destination: managerStripeAccountId
        },
        // ENTERPRISE STANDARD: Add application_fee_amount for break-even on Stripe fees
        // Manager pays the Stripe fee, platform breaks even
        application_fee_amount: applicationFeeAmount,
        // ENTERPRISE STANDARD: Set receipt_email for Stripe to send payment receipt
        receipt_email: chef.email
      };
    } else {
      sessionParams.payment_intent_data = {
        receipt_email: chef.email
      };
    }
    const session = await stripe2.checkout.sessions.create(sessionParams);
    await db.update(storageOverstayRecords).set({
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq3(storageOverstayRecords.id, overstayRecordId));
    logger.info(`[OverstayService] Created penalty payment checkout (status unchanged)`, {
      overstayRecordId,
      chefId,
      penaltyAmountCents,
      sessionId: session.id,
      currentStatus: overstayRecord.status
    });
    return { checkoutUrl: session.url };
  } catch (error) {
    logger.error(`[OverstayService] Failed to create penalty checkout`, { error, overstayRecordId });
    return { error: "Failed to create payment session" };
  }
}
async function sendOverstayNotificationEmails(data) {
  try {
    const {
      sendEmail: sendEmail2,
      generateOverstayDetectedEmail: generateOverstayDetectedEmail2,
      generateOverstayManagerNotificationEmail: generateOverstayManagerNotificationEmail2
    } = await Promise.resolve().then(() => (init_email(), email_exports));
    const [booking] = await db.select({
      storageListingId: storageBookings.storageListingId,
      chefId: storageBookings.chefId,
      chefEmail: users.username
    }).from(storageBookings).leftJoin(users, eq3(storageBookings.chefId, users.id)).where(eq3(storageBookings.id, data.storageBookingId)).limit(1);
    if (!booking) {
      logger.warn(`[OverstayService] No booking found for overstay email: ${data.storageBookingId}`);
      return;
    }
    const [listing] = await db.select({
      name: storageListings.name,
      kitchenId: storageListings.kitchenId
    }).from(storageListings).where(eq3(storageListings.id, booking.storageListingId)).limit(1);
    if (!listing) {
      logger.warn(`[OverstayService] No listing found for overstay email: ${booking.storageListingId}`);
      return;
    }
    const [kitchen] = await db.select({
      name: kitchens.name,
      locationId: kitchens.locationId
    }).from(kitchens).where(eq3(kitchens.id, listing.kitchenId)).limit(1);
    if (!kitchen) {
      logger.warn(`[OverstayService] No kitchen found for overstay email`);
      return;
    }
    const [location] = await db.select({
      name: locations.name,
      managerId: locations.managerId,
      notificationEmail: locations.notificationEmail
    }).from(locations).where(eq3(locations.id, kitchen.locationId)).limit(1);
    if (booking.chefEmail) {
      const chefEmail = generateOverstayDetectedEmail2({
        chefEmail: booking.chefEmail,
        chefName: booking.chefEmail,
        storageName: listing.name || "Storage",
        endDate: data.endDate,
        daysOverdue: data.daysOverdue,
        gracePeriodEndsAt: data.gracePeriodEndsAt,
        isInGracePeriod: data.isInGracePeriod,
        calculatedPenaltyCents: data.calculatedPenaltyCents
      });
      await sendEmail2(chefEmail, {
        trackingId: `overstay_chef_${data.storageBookingId}_${Date.now()}`
      });
      logger.info(`[OverstayService] Sent overstay notification email to chef: ${booking.chefEmail}`);
    }
    if (location && location.notificationEmail) {
      const managerEmail = generateOverstayManagerNotificationEmail2({
        managerEmail: location.notificationEmail,
        chefName: booking.chefEmail || "Chef",
        chefEmail: booking.chefEmail || "",
        storageName: listing.name || "Storage",
        kitchenName: kitchen.name || "Kitchen",
        endDate: data.endDate,
        daysOverdue: data.daysOverdue,
        gracePeriodEndsAt: data.gracePeriodEndsAt,
        isInGracePeriod: data.isInGracePeriod,
        calculatedPenaltyCents: data.calculatedPenaltyCents
      });
      await sendEmail2(managerEmail, {
        trackingId: `overstay_manager_${data.storageBookingId}_${Date.now()}`
      });
      logger.info(`[OverstayService] Sent overstay notification email to manager: ${location.notificationEmail}`);
    }
  } catch (error) {
    logger.error(`[OverstayService] Error sending overstay notification emails:`, error);
  }
}
async function sendPenaltyChargedEmail(overstayRecordId, penaltyAmountCents, daysOverdue) {
  try {
    const { sendEmail: sendEmail2, generatePenaltyChargedEmail: generatePenaltyChargedEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
    const [record] = await db.select({
      storageBookingId: storageOverstayRecords.storageBookingId
    }).from(storageOverstayRecords).where(eq3(storageOverstayRecords.id, overstayRecordId)).limit(1);
    if (!record) return;
    const [booking] = await db.select({
      chefEmail: users.username,
      storageListingId: storageBookings.storageListingId
    }).from(storageBookings).leftJoin(users, eq3(storageBookings.chefId, users.id)).where(eq3(storageBookings.id, record.storageBookingId)).limit(1);
    if (!booking || !booking.chefEmail) return;
    const [listing] = await db.select({ name: storageListings.name }).from(storageListings).where(eq3(storageListings.id, booking.storageListingId)).limit(1);
    const email = generatePenaltyChargedEmail2({
      chefEmail: booking.chefEmail,
      chefName: booking.chefEmail,
      storageName: listing?.name || "Storage",
      penaltyAmountCents,
      daysOverdue,
      chargeDate: /* @__PURE__ */ new Date()
    });
    await sendEmail2(email, {
      trackingId: `penalty_charged_${overstayRecordId}_${Date.now()}`
    });
    logger.info(`[OverstayService] Sent penalty charged email to chef: ${booking.chefEmail}`);
  } catch (error) {
    logger.error(`[OverstayService] Error sending penalty charged email:`, error);
  }
}
async function hasChefUnpaidPenalties(chefId) {
  const blockingStatuses = [
    "detected",
    "grace_period",
    "pending_review",
    "penalty_approved",
    "charge_pending",
    "charge_failed",
    "escalated"
  ];
  const [result] = await db.select({ count: sql4`count(*)` }).from(storageOverstayRecords).innerJoin(storageBookings, eq3(storageOverstayRecords.storageBookingId, storageBookings.id)).where(
    and(
      eq3(storageBookings.chefId, chefId),
      inArray(storageOverstayRecords.status, blockingStatuses)
    )
  );
  return (result?.count || 0) > 0;
}
async function getChefUnpaidPenalties(chefId) {
  const blockingStatuses = [
    "detected",
    "grace_period",
    "pending_review",
    "penalty_approved",
    "charge_pending",
    "charge_failed",
    "escalated"
  ];
  const records = await db.select({
    overstayId: storageOverstayRecords.id,
    storageBookingId: storageOverstayRecords.storageBookingId,
    status: storageOverstayRecords.status,
    daysOverdue: storageOverstayRecords.daysOverdue,
    calculatedPenaltyCents: storageOverstayRecords.calculatedPenaltyCents,
    finalPenaltyCents: storageOverstayRecords.finalPenaltyCents,
    detectedAt: storageOverstayRecords.detectedAt,
    gracePeriodEndsAt: storageOverstayRecords.gracePeriodEndsAt,
    penaltyApprovedAt: storageOverstayRecords.penaltyApprovedAt,
    storageName: storageListings.name,
    storageType: storageListings.storageType,
    kitchenName: kitchens.name,
    kitchenTaxRatePercent: kitchens.taxRatePercent,
    bookingEndDate: storageBookings.endDate
  }).from(storageOverstayRecords).innerJoin(storageBookings, eq3(storageOverstayRecords.storageBookingId, storageBookings.id)).innerJoin(storageListings, eq3(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq3(storageListings.kitchenId, kitchens.id)).where(
    and(
      eq3(storageBookings.chefId, chefId),
      inArray(storageOverstayRecords.status, blockingStatuses)
    )
  ).orderBy(desc(storageOverstayRecords.detectedAt));
  return records.map((r) => {
    const baseCents = r.finalPenaltyCents || r.calculatedPenaltyCents || 0;
    const taxRate = parseFloat(String(r.kitchenTaxRatePercent || 0));
    const taxCents = Math.round(baseCents * taxRate / 100);
    return {
      ...r,
      storageName: r.storageName || "Storage",
      storageType: r.storageType || "dry",
      kitchenName: r.kitchenName || "Kitchen",
      kitchenTaxRatePercent: taxRate,
      penaltyAmountCents: baseCents,
      penaltyTaxCents: taxCents,
      penaltyTotalCents: baseCents + taxCents,
      requiresImmediatePayment: ["penalty_approved", "charge_failed", "escalated"].includes(r.status)
    };
  });
}
async function refundOverstayPenalty(overstayRecordId, refundReason, refundedBy, partialAmountCents) {
  try {
    const [record] = await db.select().from(storageOverstayRecords).where(eq3(storageOverstayRecords.id, overstayRecordId)).limit(1);
    if (!record) {
      return { success: false, error: "Overstay record not found" };
    }
    if (record.status !== "charge_succeeded") {
      return {
        success: false,
        error: `Cannot refund penalty in status '${record.status}'. Only 'charge_succeeded' penalties can be refunded.`
      };
    }
    if (!record.stripePaymentIntentId) {
      return { success: false, error: "No payment intent found for this penalty. Manual refund required in Stripe Dashboard." };
    }
    const chargedAmount = record.finalPenaltyCents || record.calculatedPenaltyCents || 0;
    const refundAmount = partialAmountCents || chargedAmount;
    if (refundAmount <= 0) {
      return { success: false, error: "Refund amount must be greater than 0" };
    }
    if (refundAmount > chargedAmount) {
      return { success: false, error: `Refund amount ($${(refundAmount / 100).toFixed(2)}) cannot exceed charged amount ($${(chargedAmount / 100).toFixed(2)})` };
    }
    const stripeSecretKey6 = process.env.STRIPE_SECRET_KEY;
    if (!stripeSecretKey6) {
      return { success: false, error: "Stripe not configured" };
    }
    const stripe6 = new Stripe2(stripeSecretKey6, {
      apiVersion: "2025-12-15.clover"
    });
    logger.info(`[OverstayPenalty] Issuing refund for overstay ${overstayRecordId}:`, {
      paymentIntentId: record.stripePaymentIntentId,
      chargedAmount: `$${(chargedAmount / 100).toFixed(2)}`,
      refundAmount: `$${(refundAmount / 100).toFixed(2)}`,
      reason: refundReason
    });
    const refund = await stripe6.refunds.create({
      payment_intent: record.stripePaymentIntentId,
      amount: refundAmount,
      reason: "requested_by_customer",
      metadata: {
        overstay_record_id: overstayRecordId.toString(),
        refund_reason: refundReason,
        refunded_by: refundedBy.toString()
      }
    });
    const isFullRefund = refundAmount >= chargedAmount;
    const newStatus = isFullRefund ? "resolved" : "charge_succeeded";
    await db.update(storageOverstayRecords).set({
      status: newStatus,
      resolvedAt: isFullRefund ? /* @__PURE__ */ new Date() : record.resolvedAt,
      resolutionType: isFullRefund ? "refunded" : record.resolutionType,
      resolutionNotes: isFullRefund ? `Full refund issued: ${refundReason}` : `Partial refund of $${(refundAmount / 100).toFixed(2)}: ${refundReason}`,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq3(storageOverstayRecords.id, overstayRecordId));
    await db.insert(storageOverstayHistory).values({
      overstayRecordId,
      previousStatus: "charge_succeeded",
      newStatus,
      eventType: "refund",
      eventSource: "manager",
      createdBy: refundedBy,
      description: `${isFullRefund ? "Full" : "Partial"} refund of $${(refundAmount / 100).toFixed(2)} issued. Reason: ${refundReason}`,
      metadata: {
        refundId: refund.id,
        refundAmount,
        chargedAmount,
        isFullRefund,
        reason: refundReason
      }
    });
    try {
      const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
      const ptRecord = await findPaymentTransactionByIntentId2(record.stripePaymentIntentId, db);
      if (ptRecord) {
        await updatePaymentTransaction2(ptRecord.id, {
          status: isFullRefund ? "refunded" : "partially_refunded",
          refundAmount,
          refundId: refund.id,
          refundedAt: /* @__PURE__ */ new Date()
        }, db);
      }
    } catch (ptError) {
      logger.warn(`[OverstayPenalty] Could not update payment_transactions for refund:`, ptError);
    }
    try {
      const [booking] = await db.select({
        chefId: storageBookings.chefId,
        storageName: storageListings.name
      }).from(storageBookings).innerJoin(storageListings, eq3(storageBookings.storageListingId, storageListings.id)).where(eq3(storageBookings.id, record.storageBookingId)).limit(1);
      if (booking?.chefId) {
        const [chef] = await db.select({ email: users.username }).from(users).where(eq3(users.id, booking.chefId)).limit(1);
        if (chef?.email) {
          const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
          await sendEmail2({
            to: chef.email,
            subject: `Overstay Penalty Refund - $${(refundAmount / 100).toFixed(2)}`,
            html: `
              <h2>Overstay Penalty Refund</h2>
              <p>A ${isFullRefund ? "full" : "partial"} refund has been issued for your overstay penalty.</p>
              <p><strong>Storage:</strong> ${booking.storageName || "Storage Unit"}</p>
              <p><strong>Refund Amount:</strong> $${(refundAmount / 100).toFixed(2)}</p>
              <p><strong>Reason:</strong> ${refundReason}</p>
              <p>The refund should appear on your statement within 5-10 business days.</p>
            `,
            text: `Overstay Penalty Refund

A ${isFullRefund ? "full" : "partial"} refund of $${(refundAmount / 100).toFixed(2)} has been issued for your overstay penalty.

Storage: ${booking.storageName || "Storage Unit"}
Reason: ${refundReason}`
          });
          logger.info(`[OverstayPenalty] Sent refund notification email to chef ${chef.email}`);
        }
      }
    } catch (emailError) {
      logger.error(`[OverstayPenalty] Error sending refund notification email:`, emailError);
    }
    logger.info(`[OverstayPenalty] \u2705 Refund successful for overstay ${overstayRecordId}:`, {
      refundId: refund.id,
      amount: `$${(refundAmount / 100).toFixed(2)}`,
      isFullRefund
    });
    return { success: true, refundId: refund.id };
  } catch (error) {
    logger.error(`[OverstayPenalty] Error refunding penalty ${overstayRecordId}:`, error);
    if (error.type === "StripeInvalidRequestError") {
      return { success: false, error: `Stripe error: ${error.message}` };
    }
    return { success: false, error: error.message || "Failed to process refund" };
  }
}
var stripeSecretKey2, stripe2, overstayPenaltyService;
var init_overstay_penalty_service = __esm({
  "server/services/overstay-penalty-service.ts"() {
    "use strict";
    init_db();
    init_reference_code();
    init_schema();
    init_logger();
    init_overstay_defaults_service();
    stripeSecretKey2 = process.env.STRIPE_SECRET_KEY;
    stripe2 = stripeSecretKey2 ? new Stripe2(stripeSecretKey2, {
      apiVersion: "2025-12-15.clover"
    }) : null;
    overstayPenaltyService = {
      detectOverstays,
      getPendingOverstayReviews,
      getAllOverstayRecords,
      getOverstayRecord,
      processManagerDecision,
      chargeApprovedPenalty,
      resolveOverstay,
      getOverstayHistory,
      getOverstayStats,
      markChefWarningSent,
      markManagerNotified,
      getChefPendingPenalties,
      getChefAllPenalties,
      createPenaltyPaymentCheckout,
      sendOverstayNotificationEmails,
      sendPenaltyChargedEmail,
      hasChefUnpaidPenalties,
      getChefUnpaidPenalties,
      refundOverstayPenalty
    };
  }
});

// server/services/damage-claim-limits-service.ts
var damage_claim_limits_service_exports = {};
__export(damage_claim_limits_service_exports, {
  canFileClaimForBooking: () => canFileClaimForBooking,
  damageClaimLimitsService: () => damageClaimLimitsService,
  getDamageClaimLimits: () => getDamageClaimLimits,
  getDefaultLimits: () => getDefaultLimits,
  getDefaultStorageCheckoutSettings: () => getDefaultStorageCheckoutSettings,
  getStorageCheckoutSettings: () => getStorageCheckoutSettings,
  validateClaimAmount: () => validateClaimAmount
});
import { eq as eq4 } from "drizzle-orm";
async function getDamageClaimLimits() {
  try {
    const [maxClaimSetting] = await db.select().from(platformSettings).where(eq4(platformSettings.key, "damage_claim_max_amount_cents")).limit(1);
    const [minClaimSetting] = await db.select().from(platformSettings).where(eq4(platformSettings.key, "damage_claim_min_amount_cents")).limit(1);
    const [maxClaimsPerBookingSetting] = await db.select().from(platformSettings).where(eq4(platformSettings.key, "damage_claim_max_per_booking")).limit(1);
    const [responseDeadlineSetting] = await db.select().from(platformSettings).where(eq4(platformSettings.key, "damage_claim_response_deadline_hours")).limit(1);
    const [submissionDeadlineSetting] = await db.select().from(platformSettings).where(eq4(platformSettings.key, "damage_claim_submission_deadline_days")).limit(1);
    return {
      maxClaimAmountCents: maxClaimSetting ? parseInt(maxClaimSetting.value) : DEFAULTS2.maxClaimAmountCents,
      minClaimAmountCents: minClaimSetting ? parseInt(minClaimSetting.value) : DEFAULTS2.minClaimAmountCents,
      maxClaimsPerBooking: maxClaimsPerBookingSetting ? parseInt(maxClaimsPerBookingSetting.value) : DEFAULTS2.maxClaimsPerBooking,
      chefResponseDeadlineHours: responseDeadlineSetting ? parseInt(responseDeadlineSetting.value) : DEFAULTS2.chefResponseDeadlineHours,
      claimSubmissionDeadlineDays: submissionDeadlineSetting ? parseInt(submissionDeadlineSetting.value) : DEFAULTS2.claimSubmissionDeadlineDays
    };
  } catch (error) {
    logger.error("[DamageClaimLimitsService] Error fetching limits:", error);
    return DEFAULTS2;
  }
}
async function validateClaimAmount(amountCents) {
  const limits = await getDamageClaimLimits();
  if (amountCents < limits.minClaimAmountCents) {
    return {
      valid: false,
      error: `Claim amount must be at least $${(limits.minClaimAmountCents / 100).toFixed(2)}`,
      limits
    };
  }
  if (amountCents > limits.maxClaimAmountCents) {
    return {
      valid: false,
      error: `Claim amount cannot exceed $${(limits.maxClaimAmountCents / 100).toFixed(2)}. For larger claims, contact platform support.`,
      limits
    };
  }
  return { valid: true, limits };
}
async function canFileClaimForBooking(bookingType, bookingId) {
  const limits = await getDamageClaimLimits();
  const { damageClaims: damageClaims2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
  const { and: and24, eq: eq38, count: count3 } = await import("drizzle-orm");
  const bookingColumn = bookingType === "kitchen" ? damageClaims2.kitchenBookingId : damageClaims2.storageBookingId;
  const [result] = await db.select({ count: count3() }).from(damageClaims2).where(and24(
    eq38(bookingColumn, bookingId),
    eq38(damageClaims2.bookingType, bookingType)
  ));
  const currentCount = result?.count || 0;
  if (currentCount >= limits.maxClaimsPerBooking) {
    return {
      allowed: false,
      error: `Maximum of ${limits.maxClaimsPerBooking} claims per booking reached`,
      currentCount,
      maxAllowed: limits.maxClaimsPerBooking
    };
  }
  return {
    allowed: true,
    currentCount,
    maxAllowed: limits.maxClaimsPerBooking
  };
}
function getDefaultLimits() {
  return { ...DEFAULTS2 };
}
async function getStorageCheckoutSettings() {
  try {
    const [reviewWindowSetting] = await db.select().from(platformSettings).where(eq4(platformSettings.key, "storage_checkout_review_window_hours")).limit(1);
    const [extendedWindowSetting] = await db.select().from(platformSettings).where(eq4(platformSettings.key, "storage_checkout_extended_claim_window_hours")).limit(1);
    return {
      reviewWindowHours: reviewWindowSetting ? parseInt(reviewWindowSetting.value) : STORAGE_CHECKOUT_DEFAULTS.reviewWindowHours,
      extendedClaimWindowHours: extendedWindowSetting ? parseInt(extendedWindowSetting.value) : STORAGE_CHECKOUT_DEFAULTS.extendedClaimWindowHours
    };
  } catch (error) {
    logger.error("[DamageClaimLimitsService] Error fetching storage checkout settings:", error);
    return STORAGE_CHECKOUT_DEFAULTS;
  }
}
function getDefaultStorageCheckoutSettings() {
  return { ...STORAGE_CHECKOUT_DEFAULTS };
}
var DEFAULTS2, STORAGE_CHECKOUT_DEFAULTS, damageClaimLimitsService;
var init_damage_claim_limits_service = __esm({
  "server/services/damage-claim-limits-service.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_schema();
    DEFAULTS2 = {
      maxClaimAmountCents: 5e5,
      // $5,000 CAD max per claim
      minClaimAmountCents: 1e3,
      // $10 CAD minimum
      maxClaimsPerBooking: 3,
      // Max 3 claims per booking
      chefResponseDeadlineHours: 72,
      // 72 hours to respond
      claimSubmissionDeadlineDays: 14
      // 14 days after booking ends
    };
    STORAGE_CHECKOUT_DEFAULTS = {
      reviewWindowHours: 2,
      // 2 hours for manager to inspect
      extendedClaimWindowHours: 48
      // 48 hours extended window for serious issues
    };
    damageClaimLimitsService = {
      getDamageClaimLimits,
      validateClaimAmount,
      canFileClaimForBooking,
      getDefaultLimits,
      getStorageCheckoutSettings,
      getDefaultStorageCheckoutSettings
    };
  }
});

// server/services/damage-claim-service.ts
var damage_claim_service_exports = {};
__export(damage_claim_service_exports, {
  addEvidence: () => addEvidence,
  adminDecision: () => adminDecision,
  chargeApprovedClaim: () => chargeApprovedClaim,
  chefRespondToClaim: () => chefRespondToClaim,
  createDamageClaim: () => createDamageClaim,
  createDamageClaimPaymentCheckout: () => createDamageClaimPaymentCheckout,
  damageClaimService: () => damageClaimService,
  deleteDraftClaim: () => deleteDraftClaim,
  getChefPendingClaims: () => getChefPendingClaims,
  getChefUnpaidDamageClaims: () => getChefUnpaidDamageClaims,
  getClaimById: () => getClaimById,
  getClaimHistory: () => getClaimHistory,
  getDisputedClaims: () => getDisputedClaims,
  getManagerClaims: () => getManagerClaims,
  hasChefUnpaidDamageClaims: () => hasChefUnpaidDamageClaims,
  processExpiredClaims: () => processExpiredClaims,
  refundDamageClaim: () => refundDamageClaim,
  removeEvidence: () => removeEvidence,
  submitClaim: () => submitClaim,
  updateDraftClaim: () => updateDraftClaim
});
import { eq as eq5, and as and2, inArray as inArray2, desc as desc2, sql as sql5 } from "drizzle-orm";
import Stripe3 from "stripe";
import { format as format2 } from "date-fns";
async function createHistoryEntry(damageClaimId, previousStatus, newStatus, action, actionBy, actionByUserId, notes, metadata) {
  await db.insert(damageClaimHistory).values({
    damageClaimId,
    previousStatus,
    newStatus,
    action,
    actionBy,
    actionByUserId,
    notes,
    metadata: metadata || {}
  });
}
async function getBookingPaymentDetails(bookingType, bookingId) {
  if (bookingType === "storage") {
    const [booking] = await db.select({
      stripeCustomerId: storageBookings.stripeCustomerId,
      stripePaymentMethodId: storageBookings.stripePaymentMethodId,
      chefId: storageBookings.chefId
    }).from(storageBookings).where(eq5(storageBookings.id, bookingId)).limit(1);
    return booking || { stripeCustomerId: null, stripePaymentMethodId: null, chefId: null };
  } else {
    const [booking] = await db.select({
      chefId: kitchenBookings.chefId
    }).from(kitchenBookings).where(eq5(kitchenBookings.id, bookingId)).limit(1);
    if (!booking || !booking.chefId) {
      return { stripeCustomerId: null, stripePaymentMethodId: null, chefId: null };
    }
    const [user] = await db.select({
      stripeCustomerId: users.stripeCustomerId
    }).from(users).where(eq5(users.id, booking.chefId)).limit(1);
    return {
      stripeCustomerId: user?.stripeCustomerId || null,
      stripePaymentMethodId: null,
      // Kitchen bookings don't store payment methods
      chefId: booking.chefId
    };
  }
}
async function createDamageClaim(input) {
  try {
    const { validateClaimAmount: validateClaimAmount2, canFileClaimForBooking: canFileClaimForBooking2, getDamageClaimLimits: getDamageClaimLimits2 } = await Promise.resolve().then(() => (init_damage_claim_limits_service(), damage_claim_limits_service_exports));
    const amountValidation = await validateClaimAmount2(input.claimedAmountCents);
    if (!amountValidation.valid) {
      return {
        success: false,
        error: amountValidation.error,
        limits: {
          maxClaimAmountCents: amountValidation.limits.maxClaimAmountCents,
          minClaimAmountCents: amountValidation.limits.minClaimAmountCents
        }
      };
    }
    const bookingId = input.bookingType === "storage" ? input.storageBookingId : input.kitchenBookingId;
    if (bookingId) {
      const claimCheck = await canFileClaimForBooking2(input.bookingType, bookingId);
      if (!claimCheck.allowed) {
        return { success: false, error: claimCheck.error };
      }
    }
    const limits = await getDamageClaimLimits2();
    let chefId = null;
    let locationId = null;
    const chefResponseDeadlineHours = limits.chefResponseDeadlineHours;
    const invalidBookingStatuses = ["cancelled", "rejected", "refunded"];
    if (input.bookingType === "storage" && input.storageBookingId) {
      const [booking] = await db.select({
        chefId: storageBookings.chefId,
        endDate: storageBookings.endDate,
        status: storageBookings.status,
        kitchenId: storageListings.kitchenId
      }).from(storageBookings).innerJoin(storageListings, eq5(storageBookings.storageListingId, storageListings.id)).where(eq5(storageBookings.id, input.storageBookingId)).limit(1);
      if (!booking) {
        return { success: false, error: "Storage booking not found" };
      }
      if (invalidBookingStatuses.includes(booking.status)) {
        return {
          success: false,
          error: `Cannot file damage claim for a ${booking.status} booking. Only active or completed bookings are eligible.`
        };
      }
      chefId = booking.chefId;
      if (booking.kitchenId) {
        const [kitchen] = await db.select({ locationId: kitchens.locationId }).from(kitchens).where(eq5(kitchens.id, booking.kitchenId)).limit(1);
        locationId = kitchen?.locationId || null;
      }
    } else if (input.bookingType === "kitchen" && input.kitchenBookingId) {
      const [booking] = await db.select({
        chefId: kitchenBookings.chefId,
        kitchenId: kitchenBookings.kitchenId,
        status: kitchenBookings.status
      }).from(kitchenBookings).where(eq5(kitchenBookings.id, input.kitchenBookingId)).limit(1);
      if (!booking) {
        return { success: false, error: "Kitchen booking not found" };
      }
      if (invalidBookingStatuses.includes(booking.status)) {
        return {
          success: false,
          error: `Cannot file damage claim for a ${booking.status} booking. Only active or completed bookings are eligible.`
        };
      }
      chefId = booking.chefId;
      if (booking.kitchenId) {
        const [kitchen] = await db.select({ locationId: kitchens.locationId }).from(kitchens).where(eq5(kitchens.id, booking.kitchenId)).limit(1);
        locationId = kitchen?.locationId || null;
      }
    } else {
      return { success: false, error: "Invalid booking type or missing booking ID" };
    }
    if (!chefId) {
      return { success: false, error: "Chef not found for this booking" };
    }
    if (!locationId) {
      return { success: false, error: "Location not found for this booking" };
    }
    const chefResponseDeadline = /* @__PURE__ */ new Date();
    chefResponseDeadline.setHours(chefResponseDeadline.getHours() + chefResponseDeadlineHours);
    const shouldSubmit = input.submitImmediately === true;
    const initialStatus = shouldSubmit ? "submitted" : "draft";
    let stripeCustomerId = null;
    let stripePaymentMethodId = null;
    if (shouldSubmit) {
      const bookingId2 = input.bookingType === "storage" ? input.storageBookingId : input.kitchenBookingId;
      if (bookingId2) {
        try {
          const paymentDetails = await getBookingPaymentDetails(input.bookingType, bookingId2);
          stripeCustomerId = paymentDetails.stripeCustomerId;
          stripePaymentMethodId = paymentDetails.stripePaymentMethodId;
        } catch (payErr) {
          logger.warn(`[DamageClaimService] Could not get payment details for immediate submit:`, payErr);
        }
      }
    }
    const dcRefCode = await generateReferenceCode("damage_claim");
    const [claim] = await db.insert(damageClaims).values({
      referenceCode: dcRefCode,
      bookingType: input.bookingType,
      kitchenBookingId: input.kitchenBookingId || null,
      storageBookingId: input.storageBookingId || null,
      chefId,
      managerId: input.managerId,
      locationId,
      claimTitle: input.claimTitle,
      claimDescription: input.claimDescription,
      damageDate: input.damageDate,
      claimedAmountCents: input.claimedAmountCents,
      chefResponseDeadline,
      status: initialStatus,
      damagedItems: input.damagedItems || [],
      ...shouldSubmit ? {
        submittedAt: /* @__PURE__ */ new Date(),
        stripeCustomerId,
        stripePaymentMethodId
      } : {}
    }).returning();
    await createHistoryEntry(
      claim.id,
      null,
      initialStatus,
      shouldSubmit ? "submitted" : "created",
      "manager",
      input.managerId,
      shouldSubmit ? "Damage claim created and submitted to chef" : "Damage claim created as draft"
    );
    logger.info(`[DamageClaimService] Created damage claim ${claim.id} (status: ${initialStatus})`, {
      bookingType: input.bookingType,
      chefId,
      managerId: input.managerId,
      claimedAmountCents: input.claimedAmountCents
    });
    if (shouldSubmit) {
      try {
        const claimWithDetails = await getClaimById(claim.id);
        if (claimWithDetails) {
          const [chefUser] = await db.select({ username: users.username }).from(users).where(eq5(users.id, chefId)).limit(1);
          const [managerUser] = await db.select({ username: users.username }).from(users).where(eq5(users.id, input.managerId)).limit(1);
          if (chefUser?.username) {
            const emailContent = generateDamageClaimFiledEmail({
              chefEmail: chefUser.username,
              chefName: claimWithDetails.chefName || chefUser.username || "Chef",
              managerName: claimWithDetails.managerName || managerUser?.username || "Manager",
              locationName: claimWithDetails.locationName || "Unknown Location",
              claimTitle: claim.claimTitle,
              claimedAmount: `$${(claim.claimedAmountCents / 100).toFixed(2)}`,
              damageDate: format2(new Date(claim.damageDate), "MMM d, yyyy"),
              responseDeadline: format2(new Date(claim.chefResponseDeadline), "MMM d, yyyy h:mm a"),
              claimId: claim.id
            });
            await sendEmail(emailContent);
            logger.info(`[DamageClaimService] Sent claim filed email to chef ${chefUser.username}`);
            try {
              const { notificationService: notificationService2 } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
              await notificationService2.notifyChefDamageClaimFiled({
                chefId,
                managerName: claimWithDetails.managerName || managerUser?.username || "Manager",
                responseDeadline: new Date(claim.chefResponseDeadline),
                claimId: claim.id,
                claimTitle: claim.claimTitle,
                amountCents: claim.claimedAmountCents,
                locationName: claimWithDetails.locationName || "Unknown Location",
                bookingType: claim.bookingType
              });
            } catch (notifError) {
              logger.error("[DamageClaimService] Failed to send in-app notification:", notifError);
            }
          }
        }
      } catch (emailError) {
        logger.error("[DamageClaimService] Failed to send claim filed email:", emailError);
      }
    }
    return { success: true, claim };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Failed to create damage claim";
    logger.error("[DamageClaimService] Error creating damage claim:", error);
    return { success: false, error: errorMessage };
  }
}
async function updateDraftClaim(claimId, managerId, updates) {
  try {
    const [claim] = await db.select().from(damageClaims).where(and2(eq5(damageClaims.id, claimId), eq5(damageClaims.managerId, managerId))).limit(1);
    if (!claim) {
      return { success: false, error: "Claim not found or unauthorized" };
    }
    if (claim.status !== "draft") {
      return { success: false, error: "Can only update draft claims" };
    }
    await db.update(damageClaims).set({
      ...updates,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq5(damageClaims.id, claimId));
    return { success: true };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Failed to update claim";
    logger.error("[DamageClaimService] Error updating draft claim:", error);
    return { success: false, error: errorMessage };
  }
}
async function deleteDraftClaim(claimId, managerId) {
  try {
    const [claim] = await db.select().from(damageClaims).where(and2(eq5(damageClaims.id, claimId), eq5(damageClaims.managerId, managerId))).limit(1);
    if (!claim) {
      return { success: false, error: "Claim not found or unauthorized" };
    }
    if (claim.status !== "draft") {
      return { success: false, error: "Can only delete draft claims" };
    }
    await db.delete(damageEvidence).where(eq5(damageEvidence.damageClaimId, claimId));
    await db.delete(damageClaims).where(eq5(damageClaims.id, claimId));
    logger.info(`[DamageClaimService] Deleted draft claim ${claimId}`, { managerId });
    return { success: true };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Failed to delete claim";
    logger.error("[DamageClaimService] Error deleting draft claim:", error);
    return { success: false, error: errorMessage };
  }
}
async function submitClaim(claimId, managerId) {
  try {
    const [claim] = await db.select().from(damageClaims).where(and2(eq5(damageClaims.id, claimId), eq5(damageClaims.managerId, managerId))).limit(1);
    if (!claim) {
      return { success: false, error: "Claim not found or unauthorized" };
    }
    if (claim.status !== "draft") {
      return { success: false, error: "Can only submit draft claims" };
    }
    const evidenceCount = await db.select({ count: sql5`count(*)` }).from(damageEvidence).where(eq5(damageEvidence.damageClaimId, claimId));
    if (!evidenceCount[0] || evidenceCount[0].count < 2) {
      return { success: false, error: "Minimum 2 pieces of evidence required" };
    }
    const bookingId = claim.bookingType === "storage" ? claim.storageBookingId : claim.kitchenBookingId;
    if (bookingId) {
      const paymentDetails = await getBookingPaymentDetails(claim.bookingType, bookingId);
      await db.update(damageClaims).set({
        status: "submitted",
        submittedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        stripeCustomerId: paymentDetails.stripeCustomerId,
        stripePaymentMethodId: paymentDetails.stripePaymentMethodId
      }).where(eq5(damageClaims.id, claimId));
    } else {
      await db.update(damageClaims).set({
        status: "submitted",
        submittedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq5(damageClaims.id, claimId));
    }
    await createHistoryEntry(
      claimId,
      "draft",
      "submitted",
      "submitted",
      "manager",
      managerId,
      "Claim submitted to chef for response"
    );
    logger.info(`[DamageClaimService] Claim ${claimId} submitted`, { managerId });
    try {
      const claimWithDetails = await getClaimById(claimId);
      if (claimWithDetails) {
        const [chefUser] = await db.select({ username: users.username }).from(users).where(eq5(users.id, claim.chefId)).limit(1);
        const [managerUser] = await db.select({ username: users.username }).from(users).where(eq5(users.id, claim.managerId)).limit(1);
        if (chefUser?.username) {
          const emailContent = generateDamageClaimFiledEmail({
            chefEmail: chefUser.username,
            chefName: claimWithDetails.chefName || chefUser.username || "Chef",
            managerName: claimWithDetails.managerName || managerUser?.username || "Manager",
            locationName: claimWithDetails.locationName || "Unknown Location",
            claimTitle: claim.claimTitle,
            claimedAmount: `$${(claim.claimedAmountCents / 100).toFixed(2)}`,
            damageDate: format2(new Date(claim.damageDate), "MMM d, yyyy"),
            responseDeadline: format2(new Date(claim.chefResponseDeadline), "MMM d, yyyy h:mm a"),
            claimId: claim.id
          });
          await sendEmail(emailContent);
          logger.info(`[DamageClaimService] Sent claim filed email to chef ${chefUser.username}`);
          try {
            const { notificationService: notificationService2 } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
            await notificationService2.notifyChefDamageClaimFiled({
              chefId: claim.chefId,
              managerName: claimWithDetails.managerName || managerUser?.username || "Manager",
              responseDeadline: new Date(claim.chefResponseDeadline),
              claimId: claim.id,
              claimTitle: claim.claimTitle,
              amountCents: claim.claimedAmountCents,
              locationName: claimWithDetails.locationName || "Unknown Location",
              bookingType: claim.bookingType
            });
            logger.info(`[DamageClaimService] Sent in-app notification to chef for claim ${claimId}`);
          } catch (notifError) {
            logger.error("[DamageClaimService] Failed to send in-app notification:", notifError);
          }
        }
      }
    } catch (emailError) {
      logger.error("[DamageClaimService] Failed to send claim filed email:", emailError);
    }
    return { success: true };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Failed to submit claim";
    logger.error("[DamageClaimService] Error submitting claim:", error);
    return { success: false, error: errorMessage };
  }
}
async function addEvidence(claimId, userId, evidence) {
  try {
    const [claim] = await db.select().from(damageClaims).where(eq5(damageClaims.id, claimId)).limit(1);
    if (!claim) {
      return { success: false, error: "Claim not found" };
    }
    if (!["draft", "submitted", "chef_disputed", "under_review"].includes(claim.status)) {
      return { success: false, error: "Cannot add evidence to claim in current status" };
    }
    const [newEvidence] = await db.insert(damageEvidence).values({
      damageClaimId: claimId,
      evidenceType: evidence.evidenceType,
      fileUrl: evidence.fileUrl,
      fileName: evidence.fileName,
      fileSize: evidence.fileSize,
      mimeType: evidence.mimeType,
      description: evidence.description,
      uploadedBy: userId,
      amountCents: evidence.amountCents,
      vendorName: evidence.vendorName
    }).returning();
    logger.info(`[DamageClaimService] Evidence added to claim ${claimId}`, {
      evidenceId: newEvidence.id,
      evidenceType: evidence.evidenceType
    });
    return { success: true, evidence: newEvidence };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Failed to add evidence";
    logger.error("[DamageClaimService] Error adding evidence:", error);
    return { success: false, error: errorMessage };
  }
}
async function removeEvidence(evidenceId, _userId) {
  try {
    const [evidence] = await db.select().from(damageEvidence).where(eq5(damageEvidence.id, evidenceId)).limit(1);
    if (!evidence) {
      return { success: false, error: "Evidence not found" };
    }
    const [claim] = await db.select().from(damageClaims).where(eq5(damageClaims.id, evidence.damageClaimId)).limit(1);
    if (!claim || claim.status !== "draft") {
      return { success: false, error: "Can only remove evidence from draft claims" };
    }
    await db.delete(damageEvidence).where(eq5(damageEvidence.id, evidenceId));
    logger.info(`[DamageClaimService] Evidence ${evidenceId} removed from claim ${evidence.damageClaimId}`);
    return { success: true };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Failed to remove evidence";
    logger.error("[DamageClaimService] Error removing evidence:", error);
    return { success: false, error: errorMessage };
  }
}
async function getChefPendingClaims(chefId) {
  const allChefStatuses = [
    "submitted",
    // Awaiting chef response
    "chef_accepted",
    // Chef accepted
    "chef_disputed",
    // Chef disputed
    "under_review",
    // Admin reviewing
    "approved",
    // Approved by admin
    "partially_approved",
    // Partially approved
    "charge_pending",
    // Payment processing
    "charge_succeeded",
    // Successfully charged (RESOLVED)
    "charge_failed",
    // Charge failed
    "escalated",
    // Auto-charge failed â€” chef needs to pay via link
    "resolved",
    // Resolved (RESOLVED)
    "rejected",
    // Rejected by admin (RESOLVED)
    "expired"
    // Expired (RESOLVED)
  ];
  const claims = await db.select({
    claim: damageClaims,
    chefEmail: users.username,
    chefName: users.username,
    // users table doesn't have fullName
    locationName: locations.name
  }).from(damageClaims).innerJoin(users, eq5(damageClaims.chefId, users.id)).innerJoin(locations, eq5(damageClaims.locationId, locations.id)).where(and2(
    eq5(damageClaims.chefId, chefId),
    inArray2(damageClaims.status, allChefStatuses)
  )).orderBy(desc2(damageClaims.createdAt));
  const result = [];
  for (const row of claims) {
    const evidence = await db.select().from(damageEvidence).where(eq5(damageEvidence.damageClaimId, row.claim.id));
    result.push({
      ...row.claim,
      chefEmail: row.chefEmail,
      chefName: row.chefName,
      managerName: null,
      locationName: row.locationName,
      kitchenName: null,
      bookingStartDate: null,
      bookingEndDate: null,
      evidence
    });
  }
  return result;
}
async function chefRespondToClaim(claimId, chefId, response) {
  try {
    const [claim] = await db.select().from(damageClaims).where(and2(eq5(damageClaims.id, claimId), eq5(damageClaims.chefId, chefId))).limit(1);
    if (!claim) {
      return { success: false, error: "Claim not found or unauthorized" };
    }
    if (claim.status !== "submitted") {
      return { success: false, error: "Can only respond to submitted claims" };
    }
    const previousStatus = claim.status;
    let newStatus;
    if (response.action === "accept") {
      newStatus = "chef_accepted";
      await db.update(damageClaims).set({
        status: newStatus,
        chefResponse: response.response,
        chefRespondedAt: /* @__PURE__ */ new Date(),
        approvedAmountCents: claim.claimedAmountCents,
        finalAmountCents: claim.claimedAmountCents,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq5(damageClaims.id, claimId));
      await db.update(damageClaims).set({
        status: "approved",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq5(damageClaims.id, claimId));
      await createHistoryEntry(
        claimId,
        previousStatus,
        "chef_accepted",
        "chef_response",
        "chef",
        chefId,
        `Chef accepted claim: ${response.response}`
      );
      await createHistoryEntry(
        claimId,
        "chef_accepted",
        "approved",
        "auto_approved",
        "system",
        void 0,
        "Claim auto-approved after chef acceptance"
      );
      logger.info(`[DamageClaimService] Chef ${chefId} accepted claim ${claimId}`);
      try {
        const chargeResult = await chargeApprovedClaim(claimId);
        if (chargeResult.success) {
          logger.info(`[DamageClaimService] Auto-charged claim ${claimId} after chef acceptance`);
        } else {
          logger.warn(`[DamageClaimService] Auto-charge failed for claim ${claimId}: ${chargeResult.error}`);
        }
      } catch (chargeError) {
        logger.error(`[DamageClaimService] Error auto-charging claim ${claimId}:`, chargeError);
      }
    } else {
      newStatus = "chef_disputed";
      await db.update(damageClaims).set({
        status: newStatus,
        chefResponse: response.response,
        chefRespondedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq5(damageClaims.id, claimId));
      await db.update(damageClaims).set({
        status: "under_review",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq5(damageClaims.id, claimId));
      await createHistoryEntry(
        claimId,
        previousStatus,
        "chef_disputed",
        "chef_response",
        "chef",
        chefId,
        `Chef disputed claim: ${response.response}`
      );
      await createHistoryEntry(
        claimId,
        "chef_disputed",
        "under_review",
        "escalated_to_admin",
        "system",
        void 0,
        "Disputed claim escalated to admin for review"
      );
      logger.info(`[DamageClaimService] Chef ${chefId} disputed claim ${claimId}`);
    }
    try {
      const claimWithDetails = await getClaimById(claimId);
      if (claimWithDetails) {
        const [managerUser] = await db.select({ username: users.username }).from(users).where(eq5(users.id, claim.managerId)).limit(1);
        const [chefUser] = await db.select({ username: users.username }).from(users).where(eq5(users.id, chefId)).limit(1);
        if (managerUser?.username) {
          const emailContent = generateDamageClaimResponseEmail({
            managerEmail: managerUser.username,
            managerName: claimWithDetails.managerName || managerUser.username || "Manager",
            chefName: claimWithDetails.chefName || chefUser?.username || "Chef",
            claimTitle: claim.claimTitle,
            claimedAmount: `$${(claim.claimedAmountCents / 100).toFixed(2)}`,
            response: response.action === "accept" ? "accepted" : "disputed",
            chefResponse: response.response,
            claimId: claim.id
          });
          await sendEmail(emailContent);
          logger.info(`[DamageClaimService] Sent response notification to manager ${managerUser.username}`);
          try {
            const { notificationService: notificationService2 } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
            await notificationService2.notifyManagerClaimResponseReceived({
              managerId: claim.managerId,
              locationId: claim.locationId,
              chefName: claimWithDetails.chefName || chefUser?.username || "Chef",
              responseType: response.action === "accept" ? "accepted" : "disputed",
              chefResponse: response.response,
              claimId: claim.id,
              claimTitle: claim.claimTitle,
              amountCents: claim.claimedAmountCents,
              locationName: claimWithDetails.locationName || "Unknown Location",
              bookingType: claim.bookingType
            });
            logger.info(`[DamageClaimService] Sent in-app notification to manager for claim ${claimId} response`);
          } catch (notifError) {
            logger.error("[DamageClaimService] Failed to send manager in-app notification:", notifError);
          }
        }
        if (response.action === "dispute") {
          const admins = await db.select({ username: users.username }).from(users).where(eq5(users.role, "admin"));
          for (const admin2 of admins) {
            if (admin2.username) {
              const adminEmailContent = generateDamageClaimDisputedAdminEmail({
                adminEmail: admin2.username,
                chefName: claimWithDetails.chefName || chefUser?.username || "Chef",
                chefEmail: claimWithDetails.chefEmail || chefUser?.username || "",
                managerName: claimWithDetails.managerName || managerUser?.username || "Manager",
                locationName: claimWithDetails.locationName || "Unknown Location",
                claimTitle: claim.claimTitle,
                claimedAmount: `$${(claim.claimedAmountCents / 100).toFixed(2)}`,
                chefResponse: response.response,
                claimId: claim.id
              });
              await sendEmail(adminEmailContent);
            }
          }
          if (admins.length > 0) {
            logger.info(`[DamageClaimService] Sent dispute notification to ${admins.length} admin(s)`);
          }
        }
      }
    } catch (emailError) {
      logger.error("[DamageClaimService] Failed to send response emails:", emailError);
    }
    return { success: true };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Failed to process response";
    logger.error("[DamageClaimService] Error processing chef response:", error);
    return { success: false, error: errorMessage };
  }
}
async function getDisputedClaims() {
  const claims = await db.select({
    claim: damageClaims,
    chefEmail: users.username,
    chefName: users.username,
    // users table doesn't have fullName
    locationName: locations.name
  }).from(damageClaims).innerJoin(users, eq5(damageClaims.chefId, users.id)).innerJoin(locations, eq5(damageClaims.locationId, locations.id)).where(eq5(damageClaims.status, "under_review")).orderBy(desc2(damageClaims.createdAt));
  const result = [];
  for (const row of claims) {
    const evidence = await db.select().from(damageEvidence).where(eq5(damageEvidence.damageClaimId, row.claim.id));
    result.push({
      ...row.claim,
      chefEmail: row.chefEmail,
      chefName: row.chefName,
      managerName: null,
      locationName: row.locationName,
      kitchenName: null,
      bookingStartDate: null,
      bookingEndDate: null,
      evidence
    });
  }
  return result;
}
async function adminDecision(claimId, adminId, decision) {
  try {
    const [claim] = await db.select().from(damageClaims).where(eq5(damageClaims.id, claimId)).limit(1);
    if (!claim) {
      return { success: false, error: "Claim not found" };
    }
    if (claim.status !== "under_review") {
      return { success: false, error: "Can only review claims under review" };
    }
    const previousStatus = claim.status;
    let newStatus;
    let approvedAmount = null;
    let finalAmount = null;
    switch (decision.decision) {
      case "approve":
        newStatus = "approved";
        approvedAmount = claim.claimedAmountCents;
        finalAmount = claim.claimedAmountCents;
        break;
      case "partially_approve":
        if (!decision.approvedAmountCents || decision.approvedAmountCents <= 0) {
          return { success: false, error: "Approved amount required for partial approval" };
        }
        newStatus = "partially_approved";
        approvedAmount = decision.approvedAmountCents;
        finalAmount = decision.approvedAmountCents;
        break;
      case "reject":
        newStatus = "rejected";
        approvedAmount = 0;
        finalAmount = 0;
        break;
      default:
        return { success: false, error: "Invalid decision" };
    }
    await db.update(damageClaims).set({
      status: newStatus,
      adminReviewerId: adminId,
      adminReviewedAt: /* @__PURE__ */ new Date(),
      adminDecisionReason: decision.decisionReason,
      adminNotes: decision.notes,
      approvedAmountCents: approvedAmount,
      finalAmountCents: finalAmount,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq5(damageClaims.id, claimId));
    await createHistoryEntry(
      claimId,
      previousStatus,
      newStatus,
      "admin_decision",
      "admin",
      adminId,
      `Admin ${decision.decision}: ${decision.decisionReason}`,
      { approvedAmountCents: approvedAmount }
    );
    logger.info(`[DamageClaimService] Admin ${adminId} decided on claim ${claimId}: ${decision.decision}`);
    try {
      const claimWithDetails = await getClaimById(claimId);
      if (claimWithDetails) {
        const [chefUser] = await db.select({ username: users.username }).from(users).where(eq5(users.id, claim.chefId)).limit(1);
        const [managerUser] = await db.select({ username: users.username }).from(users).where(eq5(users.id, claim.managerId)).limit(1);
        const decisionType = decision.decision === "approve" ? "approved" : decision.decision === "partially_approve" ? "partially_approved" : "rejected";
        if (chefUser?.username) {
          const chefEmail = generateDamageClaimDecisionEmail({
            recipientEmail: chefUser.username,
            recipientName: claimWithDetails.chefName || chefUser.username || "Chef",
            recipientRole: "chef",
            claimTitle: claim.claimTitle,
            claimedAmount: `$${(claim.claimedAmountCents / 100).toFixed(2)}`,
            decision: decisionType,
            finalAmount: finalAmount ? `$${(finalAmount / 100).toFixed(2)}` : void 0,
            decisionReason: decision.decisionReason,
            claimId: claim.id
          });
          await sendEmail(chefEmail);
        }
        if (managerUser?.username) {
          const managerEmail = generateDamageClaimDecisionEmail({
            recipientEmail: managerUser.username,
            recipientName: claimWithDetails.managerName || managerUser.username || "Manager",
            recipientRole: "manager",
            claimTitle: claim.claimTitle,
            claimedAmount: `$${(claim.claimedAmountCents / 100).toFixed(2)}`,
            decision: decisionType,
            finalAmount: finalAmount ? `$${(finalAmount / 100).toFixed(2)}` : void 0,
            decisionReason: decision.decisionReason,
            claimId: claim.id
          });
          await sendEmail(managerEmail);
        }
        try {
          const { notificationService: notificationService2 } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
          await notificationService2.notifyChefClaimDecision({
            chefId: claim.chefId,
            decision: decisionType,
            approvedAmountCents: finalAmount || void 0,
            decisionReason: decision.decisionReason,
            claimId: claim.id,
            claimTitle: claim.claimTitle,
            amountCents: claim.claimedAmountCents,
            locationName: claimWithDetails.locationName || "Unknown Location",
            bookingType: claim.bookingType
          });
          await notificationService2.notifyManagerClaimDecision({
            managerId: claim.managerId,
            locationId: claim.locationId,
            decision: decisionType,
            approvedAmountCents: finalAmount || void 0,
            decisionReason: decision.decisionReason,
            claimId: claim.id,
            claimTitle: claim.claimTitle,
            amountCents: claim.claimedAmountCents,
            locationName: claimWithDetails.locationName || "Unknown Location",
            bookingType: claim.bookingType
          });
          logger.info(`[DamageClaimService] Sent in-app decision notifications for claim ${claimId}`);
        } catch (notifError) {
          logger.error("[DamageClaimService] Failed to send in-app decision notifications:", notifError);
        }
        logger.info(`[DamageClaimService] Sent decision emails for claim ${claimId}`);
      }
    } catch (emailError) {
      logger.error("[DamageClaimService] Failed to send decision emails:", emailError);
    }
    if (newStatus === "approved" || newStatus === "partially_approved") {
      try {
        const chargeResult = await chargeApprovedClaim(claimId);
        if (chargeResult.success) {
          logger.info(`[DamageClaimService] Auto-charged claim ${claimId} after admin ${decision.decision}`);
        } else {
          logger.warn(`[DamageClaimService] Auto-charge failed for claim ${claimId}: ${chargeResult.error}`);
        }
      } catch (chargeError) {
        logger.error(`[DamageClaimService] Error auto-charging claim ${claimId}:`, chargeError);
      }
    }
    return { success: true };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Failed to process decision";
    logger.error("[DamageClaimService] Error processing admin decision:", error);
    return { success: false, error: errorMessage };
  }
}
async function chargeApprovedClaim(claimId) {
  if (!stripe3) {
    return { success: false, error: "Stripe not configured" };
  }
  const [claim] = await db.select().from(damageClaims).where(eq5(damageClaims.id, claimId)).limit(1);
  if (!claim) {
    return { success: false, error: "Claim not found" };
  }
  const chargeableStatuses = ["approved", "partially_approved", "chef_accepted", "charge_failed", "charge_pending", "escalated"];
  if (!chargeableStatuses.includes(claim.status)) {
    return { success: false, error: `Cannot charge claim in status: ${claim.status}` };
  }
  const chargeAmount = claim.finalAmountCents;
  if (!chargeAmount || chargeAmount <= 0) {
    return { success: false, error: "No amount to charge" };
  }
  let customerId = null;
  let paymentMethodId = null;
  let paymentMethodSource = "unknown";
  if (claim.bookingType === "kitchen" && claim.kitchenBookingId) {
    const [booking] = await db.select({
      stripeCustomerId: kitchenBookings.stripeCustomerId,
      stripePaymentMethodId: kitchenBookings.stripePaymentMethodId
    }).from(kitchenBookings).where(eq5(kitchenBookings.id, claim.kitchenBookingId)).limit(1);
    if (booking?.stripeCustomerId && booking?.stripePaymentMethodId) {
      customerId = booking.stripeCustomerId;
      paymentMethodId = booking.stripePaymentMethodId;
      paymentMethodSource = "kitchen_booking";
    } else {
      logger.info(`[DamageClaimService] Kitchen booking ${claim.kitchenBookingId} has null Stripe fields, checking storage bookings...`);
      const [storageBooking] = await db.select({
        stripeCustomerId: storageBookings.stripeCustomerId,
        stripePaymentMethodId: storageBookings.stripePaymentMethodId
      }).from(storageBookings).where(eq5(storageBookings.kitchenBookingId, claim.kitchenBookingId)).limit(1);
      if (storageBooking?.stripeCustomerId && storageBooking?.stripePaymentMethodId) {
        customerId = storageBooking.stripeCustomerId;
        paymentMethodId = storageBooking.stripePaymentMethodId;
        paymentMethodSource = "storage_booking_fallback";
        logger.info(`[DamageClaimService] Using storage booking payment method as fallback for kitchen claim ${claimId}`);
      }
    }
  } else if (claim.bookingType === "storage" && claim.storageBookingId) {
    const [booking] = await db.select({
      stripeCustomerId: storageBookings.stripeCustomerId,
      stripePaymentMethodId: storageBookings.stripePaymentMethodId
    }).from(storageBookings).where(eq5(storageBookings.id, claim.storageBookingId)).limit(1);
    if (booking) {
      customerId = booking.stripeCustomerId;
      paymentMethodId = booking.stripePaymentMethodId;
      paymentMethodSource = "storage_booking";
    }
  }
  logger.info(`[DamageClaimService] Payment method lookup for claim ${claimId}:`, {
    customerId: customerId ? `${customerId.substring(0, 10)}...` : null,
    paymentMethodId: paymentMethodId ? `${paymentMethodId.substring(0, 10)}...` : null,
    source: paymentMethodSource
  });
  if (!customerId || !paymentMethodId) {
    await db.update(damageClaims).set({
      status: "charge_failed",
      chargeFailedAt: /* @__PURE__ */ new Date(),
      chargeFailureReason: "No saved payment method available",
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq5(damageClaims.id, claimId));
    await createHistoryEntry(
      claimId,
      claim.status,
      "charge_failed",
      "charge_attempt",
      "system",
      void 0,
      "No saved payment method available"
    );
    return { success: false, error: "No saved payment method available" };
  }
  let managerStripeAccountId = null;
  const [manager] = await db.select({ stripeConnectAccountId: users.stripeConnectAccountId }).from(users).where(eq5(users.id, claim.managerId)).limit(1);
  managerStripeAccountId = manager?.stripeConnectAccountId || null;
  let applicationFeeAmount;
  if (managerStripeAccountId) {
    const { calculateCheckoutFees: calculateCheckoutFees2 } = await Promise.resolve().then(() => (init_stripe_checkout_fee_service(), stripe_checkout_fee_service_exports));
    const feeResult = calculateCheckoutFees2(chargeAmount / 100);
    applicationFeeAmount = feeResult.stripeProcessingFeeInCents;
    logger.info(`[DamageClaimService] Calculated application fee for break-even: ${applicationFeeAmount} cents`);
  }
  await db.update(damageClaims).set({
    status: "charge_pending",
    chargeAttemptedAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq5(damageClaims.id, claimId));
  try {
    const paymentIntentParams = {
      amount: chargeAmount,
      currency: "cad",
      customer: customerId,
      payment_method: paymentMethodId,
      off_session: true,
      confirm: true,
      metadata: {
        type: "damage_claim",
        damage_claim_id: claimId.toString(),
        booking_type: claim.bookingType,
        chef_id: claim.chefId.toString(),
        manager_id: claim.managerId.toString()
      },
      statement_descriptor_suffix: "DAMAGE CLAIM"
    };
    if (managerStripeAccountId) {
      paymentIntentParams.transfer_data = {
        destination: managerStripeAccountId
      };
      if (applicationFeeAmount && applicationFeeAmount > 0) {
        paymentIntentParams.application_fee_amount = applicationFeeAmount;
        logger.info(`[DamageClaimService] Setting application_fee_amount: ${applicationFeeAmount} cents for break-even`);
      }
      logger.info(`[DamageClaimService] Using destination charge to manager: ${managerStripeAccountId}`);
    }
    const idempotencyKey = `damage_claim_${claimId}_${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`;
    const paymentIntent = await stripe3.paymentIntents.create(paymentIntentParams, {
      idempotencyKey
    });
    if (paymentIntent.status === "succeeded") {
      const chargeId = typeof paymentIntent.latest_charge === "string" ? paymentIntent.latest_charge : paymentIntent.latest_charge?.id;
      await db.update(damageClaims).set({
        status: "charge_succeeded",
        stripePaymentIntentId: paymentIntent.id,
        stripeChargeId: chargeId || null,
        chargeSucceededAt: /* @__PURE__ */ new Date(),
        resolvedAt: /* @__PURE__ */ new Date(),
        resolutionType: "paid",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq5(damageClaims.id, claimId));
      await createHistoryEntry(
        claimId,
        "charge_pending",
        "charge_succeeded",
        "charge_attempt",
        "stripe_webhook",
        void 0,
        `Payment successful: ${paymentIntent.id}`,
        { paymentIntentId: paymentIntent.id, chargeId }
      );
      try {
        const { createPaymentTransaction: createPaymentTransaction2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
        const { getStripePaymentAmounts: getStripePaymentAmounts2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
        const serviceFeeForTransaction = applicationFeeAmount || 0;
        const managerRevenueForTransaction = chargeAmount - serviceFeeForTransaction;
        const ptRecord = await createPaymentTransaction2({
          bookingId: claim.bookingType === "storage" ? claim.storageBookingId : claim.kitchenBookingId,
          bookingType: claim.bookingType,
          chefId: claim.chefId,
          managerId: claim.managerId,
          amount: chargeAmount,
          baseAmount: chargeAmount,
          // No tax on damage claims, so base = amount
          serviceFee: serviceFeeForTransaction,
          // Platform fee (covers Stripe processing)
          managerRevenue: managerRevenueForTransaction,
          // What manager actually receives
          currency: "CAD",
          paymentIntentId: paymentIntent.id,
          chargeId: chargeId || void 0,
          status: "succeeded",
          stripeStatus: "succeeded",
          metadata: {
            type: "damage_claim",
            damage_claim_id: claimId.toString(),
            is_reimbursement: "true",
            // Flag to identify as reimbursement in UI
            no_tax: "true",
            // Flag to indicate no tax should be displayed
            application_fee_cents: serviceFeeForTransaction.toString()
          }
        }, db);
        if (ptRecord) {
          const stripeAmounts = await getStripePaymentAmounts2(paymentIntent.id, managerStripeAccountId || void 0);
          if (stripeAmounts) {
            await updatePaymentTransaction2(ptRecord.id, {
              paidAt: /* @__PURE__ */ new Date(),
              lastSyncedAt: /* @__PURE__ */ new Date(),
              stripeAmount: stripeAmounts.stripeAmount,
              stripeProcessingFee: stripeAmounts.stripeProcessingFee,
              stripePlatformFee: stripeAmounts.stripePlatformFee
            }, db);
            logger.info(`[DamageClaimService] Synced Stripe fees for damage claim ${claimId}:`, {
              processingFee: `$${(stripeAmounts.stripeProcessingFee / 100).toFixed(2)}`,
              platformFee: `$${(stripeAmounts.stripePlatformFee / 100).toFixed(2)}`
            });
          }
        }
        logger.info(`[DamageClaimService] Created payment transaction for damage claim ${claimId}`, {
          amount: chargeAmount,
          serviceFee: serviceFeeForTransaction,
          managerRevenue: managerRevenueForTransaction
        });
      } catch (ptError) {
        logger.error(`[DamageClaimService] Failed to create payment transaction:`, ptError);
      }
      logger.info(`[DamageClaimService] Claim ${claimId} charged successfully`, {
        paymentIntentId: paymentIntent.id,
        amount: chargeAmount
      });
      try {
        const claimWithDetails = await getClaimById(claimId);
        const [chefUser] = await db.select({ username: users.username }).from(users).where(eq5(users.id, claim.chefId)).limit(1);
        if (chefUser?.username && claimWithDetails) {
          const chargeEmail = generateDamageClaimChargedEmail({
            chefEmail: chefUser.username,
            chefName: claimWithDetails.chefName || chefUser.username || "Chef",
            claimTitle: claim.claimTitle,
            chargedAmount: `$${(chargeAmount / 100).toFixed(2)}`,
            locationName: claimWithDetails.locationName || "Unknown Location",
            claimId: claim.id
          });
          await sendEmail(chargeEmail);
          logger.info(`[DamageClaimService] Sent charge notification to chef ${chefUser.username}`);
          try {
            const { notificationService: notificationService2 } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
            await notificationService2.notifyChefDamageClaimCharged({
              chefId: claim.chefId,
              claimId: claim.id,
              claimTitle: claim.claimTitle,
              amountCents: chargeAmount,
              locationName: claimWithDetails.locationName || "Unknown Location",
              bookingType: claim.bookingType
            });
            await notificationService2.notifyManagerDamageClaimReceived({
              managerId: claim.managerId,
              locationId: claim.locationId,
              chefName: claimWithDetails.chefName || chefUser.username || "Chef",
              claimId: claim.id,
              claimTitle: claim.claimTitle,
              amountCents: chargeAmount,
              locationName: claimWithDetails.locationName || "Unknown Location",
              bookingType: claim.bookingType
            });
            logger.info(`[DamageClaimService] Sent in-app charge notifications for claim ${claimId}`);
          } catch (notifError) {
            logger.error("[DamageClaimService] Failed to send in-app charge notifications:", notifError);
          }
        }
      } catch (emailError) {
        logger.error("[DamageClaimService] Failed to send charge email:", emailError);
      }
      return {
        success: true,
        paymentIntentId: paymentIntent.id,
        chargeId: chargeId || void 0
      };
    } else {
      const failureReason = paymentIntent.status === "requires_action" || paymentIntent.status === "requires_confirmation" || paymentIntent.status === "requires_payment_method" ? `Payment requires authentication (3DS/SCA)` : `Payment status: ${paymentIntent.status}`;
      await db.update(damageClaims).set({
        status: "escalated",
        stripePaymentIntentId: paymentIntent.id,
        chargeFailedAt: /* @__PURE__ */ new Date(),
        chargeFailureReason: failureReason,
        resolutionType: "escalated_collection",
        resolutionNotes: `Auto-escalated: off-session charge failed (${failureReason}). Self-serve payment link sent to chef.`,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq5(damageClaims.id, claimId));
      await createHistoryEntry(
        claimId,
        "charge_pending",
        "escalated",
        "auto_escalation",
        "system",
        void 0,
        `Off-session charge failed: ${failureReason}. Escalated immediately.`,
        { paymentIntentId: paymentIntent.id, status: paymentIntent.status }
      );
      await sendDamageClaimPaymentLinkToChef(claimId, claim, failureReason);
      await sendDamageClaimEscalationAdminEmail(claimId, claim, failureReason);
      return {
        success: false,
        error: `Auto-charge failed (${failureReason}). Escalated \u2014 payment link sent to chef.`
      };
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    const stripeErrorCode = error?.code || error?.raw?.code || "";
    const failureReason = stripeErrorCode === "authentication_required" || errorMessage.includes("requires authentication") || errorMessage.includes("authentication_required") ? `Payment requires authentication (3DS/SCA)` : errorMessage;
    await db.update(damageClaims).set({
      status: "escalated",
      chargeFailedAt: /* @__PURE__ */ new Date(),
      chargeFailureReason: failureReason,
      resolutionType: "escalated_collection",
      resolutionNotes: `Auto-escalated: off-session charge threw error (${failureReason}). Self-serve payment link sent to chef.`,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq5(damageClaims.id, claimId));
    await createHistoryEntry(
      claimId,
      "charge_pending",
      "escalated",
      "auto_escalation",
      "system",
      void 0,
      `Off-session charge error: ${failureReason}. Escalated immediately.`,
      { error: errorMessage, stripeErrorCode }
    );
    logger.error(`[DamageClaimService] Charge failed \u2014 escalated immediately for claim ${claimId}:`, {
      error: errorMessage,
      stripeErrorCode
    });
    await sendDamageClaimPaymentLinkToChef(claimId, claim, failureReason);
    await sendDamageClaimEscalationAdminEmail(claimId, claim, failureReason);
    return { success: false, error: `Auto-charge failed (${failureReason}). Escalated \u2014 payment link sent to chef.` };
  }
}
async function sendDamageClaimPaymentLinkToChef(claimId, claim, failureReason) {
  try {
    const baseUrl = process.env.FRONTEND_URL || process.env.VITE_API_URL || "https://localcooks.com";
    const checkoutResult = await createDamageClaimPaymentCheckout(
      claimId,
      claim.chefId,
      `${baseUrl}/chef/payments/success?damage_claim=${claimId}`,
      `${baseUrl}/chef/payments/cancel?damage_claim=${claimId}`
    );
    if ("checkoutUrl" in checkoutResult) {
      const [chef] = await db.select({ email: users.username }).from(users).where(eq5(users.id, claim.chefId)).limit(1);
      if (chef?.email) {
        const amount = ((claim.finalAmountCents || claim.claimedAmountCents) / 100).toFixed(2);
        await sendEmail({
          to: chef.email,
          subject: `\u26A0\uFE0F Action Required: Damage Claim Payment \u2014 $${amount} CAD`,
          html: `
            <h2>\u26A0\uFE0F Damage Claim \u2014 Payment Required</h2>
            <p>We were unable to automatically charge your saved payment method for the damage claim.</p>
            <p><strong>Reason:</strong> ${failureReason}</p>
            <p><strong>Claim:</strong> ${claim.claimTitle}</p>
            <p><strong>Amount:</strong> $${amount} CAD</p>
            <p>Please pay immediately using the secure link below:</p>
            <p><a href="${checkoutResult.checkoutUrl}" style="display: inline-block; padding: 12px 24px; background-color: #DC2626; color: white; text-decoration: none; border-radius: 6px; font-weight: bold;">Pay Now \u2014 $${amount} CAD</a></p>
            <p>This link will expire in 24 hours.</p>
            <p><em>You will not be able to make new bookings until this claim is resolved. If payment is not received, this matter may be referred for manual collection.</em></p>
          `,
          text: `Damage Claim \u2014 Payment Required

Reason: ${failureReason}
Claim: ${claim.claimTitle}
Amount: $${amount} CAD

Pay now: ${checkoutResult.checkoutUrl}

This link expires in 24 hours.`
        });
        logger.info(`[DamageClaimService] Sent escalation payment link to chef ${chef.email} for claim ${claimId}`);
      }
      await createHistoryEntry(
        claimId,
        "escalated",
        "escalated",
        "escalation_payment_link_sent",
        "system",
        void 0,
        `Escalation payment link sent to chef (reason: ${failureReason})`,
        { checkoutUrl: checkoutResult.checkoutUrl, failureReason }
      );
    } else {
      logger.error(`[DamageClaimService] Failed to create payment link for claim ${claimId}:`, checkoutResult);
    }
  } catch (error) {
    logger.error(`[DamageClaimService] Failed to send escalation payment link for claim ${claimId}:`, error);
  }
}
async function sendDamageClaimEscalationAdminEmail(claimId, claim, failureReason) {
  try {
    const [chef] = await db.select({ email: users.username }).from(users).where(eq5(users.id, claim.chefId)).limit(1);
    const chefEmail = chef?.email || "Unknown";
    const amount = ((claim.finalAmountCents || claim.claimedAmountCents) / 100).toFixed(2);
    const admins = await db.select({ username: users.username }).from(users).where(eq5(users.role, "admin"));
    if (admins.length === 0) {
      logger.warn(`[DamageClaimService] No admin users found \u2014 escalation email NOT sent for claim ${claimId}`);
      return;
    }
    for (const admin2 of admins) {
      if (admin2.username) {
        await sendEmail({
          to: admin2.username,
          subject: `\u26A0\uFE0F Escalated Damage Claim \u2014 Auto-Charge Failed`,
          html: `
            <h2>Damage Claim Escalated</h2>
            <p>A damage claim auto-charge failed and has been escalated. A self-serve payment link has been sent to the chef.</p>
            <h3>Details:</h3>
            <ul>
              <li><strong>Claim ID:</strong> ${claimId}</li>
              <li><strong>Claim:</strong> ${claim.claimTitle}</li>
              <li><strong>Chef Email:</strong> ${chefEmail}</li>
              <li><strong>Amount:</strong> $${amount} CAD</li>
              <li><strong>Failure Reason:</strong> ${failureReason}</li>
            </ul>
            <p>If the chef does not pay via the link, please take appropriate collection action.</p>
          `,
          text: `Damage Claim Escalated

Claim ID: ${claimId}
Claim: ${claim.claimTitle}
Chef: ${chefEmail}
Amount: $${amount} CAD
Reason: ${failureReason}`
        });
      }
    }
    logger.info(`[DamageClaimService] Sent escalation notification to ${admins.length} admin(s) for claim ${claimId}`);
  } catch (emailError) {
    logger.error(`[DamageClaimService] Failed to send admin escalation email for claim ${claimId}:`, emailError);
  }
}
async function createDamageClaimPaymentCheckout(claimId, chefId, successUrl, cancelUrl) {
  if (!stripe3) {
    return { error: "Stripe not configured" };
  }
  try {
    const [claim] = await db.select().from(damageClaims).where(eq5(damageClaims.id, claimId)).limit(1);
    if (!claim) return { error: "Claim not found" };
    if (claim.chefId !== chefId) {
      return { error: "Unauthorized: This claim does not belong to you" };
    }
    const payableStatuses = ["approved", "partially_approved", "chef_accepted", "charge_failed", "escalated"];
    if (!payableStatuses.includes(claim.status)) {
      return { error: `Cannot pay claim in status: ${claim.status}` };
    }
    const chargeAmount = claim.finalAmountCents || claim.claimedAmountCents;
    if (!chargeAmount || chargeAmount <= 0) {
      return { error: "No amount to charge" };
    }
    let customerId = null;
    if (claim.bookingType === "storage" && claim.storageBookingId) {
      const [booking] = await db.select({ stripeCustomerId: storageBookings.stripeCustomerId }).from(storageBookings).where(eq5(storageBookings.id, claim.storageBookingId)).limit(1);
      customerId = booking?.stripeCustomerId || null;
    } else if (claim.bookingType === "kitchen" && claim.kitchenBookingId) {
      const [booking] = await db.select({ stripeCustomerId: kitchenBookings.stripeCustomerId }).from(kitchenBookings).where(eq5(kitchenBookings.id, claim.kitchenBookingId)).limit(1);
      customerId = booking?.stripeCustomerId || null;
    }
    if (!customerId) {
      const [user] = await db.select({ stripeCustomerId: users.stripeCustomerId }).from(users).where(eq5(users.id, chefId)).limit(1);
      customerId = user?.stripeCustomerId || null;
    }
    let managerStripeAccountId = null;
    const [manager] = await db.select({ stripeConnectAccountId: users.stripeConnectAccountId }).from(users).where(eq5(users.id, claim.managerId)).limit(1);
    managerStripeAccountId = manager?.stripeConnectAccountId || null;
    let applicationFeeAmount;
    if (managerStripeAccountId) {
      const { calculateCheckoutFees: calculateCheckoutFees2 } = await Promise.resolve().then(() => (init_stripe_checkout_fee_service(), stripe_checkout_fee_service_exports));
      const feeResult = calculateCheckoutFees2(chargeAmount / 100);
      applicationFeeAmount = feeResult.stripeProcessingFeeInCents;
    }
    const [chef] = await db.select({ email: users.username }).from(users).where(eq5(users.id, chefId)).limit(1);
    const sessionParams = {
      payment_method_types: ["card"],
      mode: "payment",
      line_items: [{
        price_data: {
          currency: "cad",
          product_data: {
            name: `Damage Claim: ${claim.claimTitle}`,
            description: `Damage claim #${claimId}`
          },
          unit_amount: chargeAmount
        },
        quantity: 1
      }],
      success_url: successUrl,
      cancel_url: cancelUrl,
      metadata: {
        type: "damage_claim",
        damage_claim_id: claimId.toString(),
        chef_id: chefId.toString(),
        manager_id: claim.managerId.toString()
      },
      invoice_creation: {
        enabled: true,
        invoice_data: {
          description: `Damage Claim: ${claim.claimTitle}`,
          metadata: {
            type: "damage_claim",
            damage_claim_id: claimId.toString()
          }
        }
      }
    };
    if (customerId) {
      sessionParams.customer = customerId;
    } else if (chef?.email) {
      sessionParams.customer_email = chef.email;
    }
    if (chef?.email) {
      sessionParams.payment_intent_data = {
        receipt_email: chef.email
      };
    }
    if (managerStripeAccountId) {
      sessionParams.payment_intent_data = {
        ...sessionParams.payment_intent_data,
        transfer_data: {
          destination: managerStripeAccountId
        }
      };
      if (applicationFeeAmount && applicationFeeAmount > 0) {
        sessionParams.payment_intent_data.application_fee_amount = applicationFeeAmount;
      }
    }
    const session = await stripe3.checkout.sessions.create(sessionParams);
    logger.info(`[DamageClaimService] Created Checkout session for claim ${claimId}: ${session.url}`);
    return { checkoutUrl: session.url };
  } catch (error) {
    logger.error(`[DamageClaimService] Failed to create Checkout session for claim ${claimId}:`, error);
    return { error: error instanceof Error ? error.message : "Failed to create payment session" };
  }
}
async function getClaimById(claimId) {
  const [row] = await db.select({
    claim: damageClaims,
    chefEmail: users.username,
    chefName: users.username,
    locationName: locations.name
  }).from(damageClaims).innerJoin(users, eq5(damageClaims.chefId, users.id)).innerJoin(locations, eq5(damageClaims.locationId, locations.id)).where(eq5(damageClaims.id, claimId)).limit(1);
  if (!row) return null;
  const [manager] = await db.select({ username: users.username }).from(users).where(eq5(users.id, row.claim.managerId)).limit(1);
  let kitchenName = null;
  let bookingStartDate = null;
  let bookingEndDate = null;
  if (row.claim.bookingType === "kitchen" && row.claim.kitchenBookingId) {
    const [booking] = await db.select({
      kitchenName: kitchens.name,
      bookingDate: kitchenBookings.bookingDate
    }).from(kitchenBookings).innerJoin(kitchens, eq5(kitchenBookings.kitchenId, kitchens.id)).where(eq5(kitchenBookings.id, row.claim.kitchenBookingId)).limit(1);
    if (booking) {
      kitchenName = booking.kitchenName;
      bookingStartDate = booking.bookingDate;
      bookingEndDate = booking.bookingDate;
    }
  } else if (row.claim.bookingType === "storage" && row.claim.storageBookingId) {
    const [booking] = await db.select({
      kitchenName: kitchens.name,
      startDate: storageBookings.startDate,
      endDate: storageBookings.endDate
    }).from(storageBookings).innerJoin(storageListings, eq5(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq5(storageListings.kitchenId, kitchens.id)).where(eq5(storageBookings.id, row.claim.storageBookingId)).limit(1);
    if (booking) {
      kitchenName = booking.kitchenName;
      bookingStartDate = booking.startDate;
      bookingEndDate = booking.endDate;
    }
  }
  const evidence = await db.select().from(damageEvidence).where(eq5(damageEvidence.damageClaimId, claimId));
  return {
    ...row.claim,
    chefEmail: row.chefEmail,
    chefName: row.chefName,
    managerName: manager?.username || null,
    locationName: row.locationName,
    kitchenName,
    bookingStartDate,
    bookingEndDate,
    evidence
  };
}
async function getManagerClaims(managerId, includeAll = false) {
  const [manager] = await db.select({ username: users.username }).from(users).where(eq5(users.id, managerId)).limit(1);
  const managerName = manager?.username || null;
  const managerLocations = await db.select({ id: locations.id }).from(locations).where(eq5(locations.managerId, managerId));
  const locationIds = managerLocations.map((l) => l.id);
  if (locationIds.length === 0) {
    return [];
  }
  const query = db.select({
    claim: damageClaims,
    chefEmail: users.username,
    chefName: users.username,
    locationName: locations.name
  }).from(damageClaims).innerJoin(users, eq5(damageClaims.chefId, users.id)).innerJoin(locations, eq5(damageClaims.locationId, locations.id)).where(inArray2(damageClaims.locationId, locationIds)).orderBy(desc2(damageClaims.createdAt));
  const claims = await query;
  const result = [];
  for (const row of claims) {
    if (!includeAll && ["resolved", "rejected", "expired"].includes(row.claim.status)) {
      continue;
    }
    let kitchenName = null;
    let bookingStartDate = null;
    let bookingEndDate = null;
    if (row.claim.bookingType === "kitchen" && row.claim.kitchenBookingId) {
      const [booking] = await db.select({
        kitchenName: kitchens.name,
        bookingDate: kitchenBookings.bookingDate
      }).from(kitchenBookings).innerJoin(kitchens, eq5(kitchenBookings.kitchenId, kitchens.id)).where(eq5(kitchenBookings.id, row.claim.kitchenBookingId)).limit(1);
      if (booking) {
        kitchenName = booking.kitchenName;
        bookingStartDate = booking.bookingDate;
        bookingEndDate = booking.bookingDate;
      }
    } else if (row.claim.bookingType === "storage" && row.claim.storageBookingId) {
      const [booking] = await db.select({
        kitchenName: kitchens.name,
        startDate: storageBookings.startDate,
        endDate: storageBookings.endDate
      }).from(storageBookings).innerJoin(storageListings, eq5(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq5(storageListings.kitchenId, kitchens.id)).where(eq5(storageBookings.id, row.claim.storageBookingId)).limit(1);
      if (booking) {
        kitchenName = booking.kitchenName;
        bookingStartDate = booking.startDate;
        bookingEndDate = booking.endDate;
      }
    }
    const evidence = await db.select().from(damageEvidence).where(eq5(damageEvidence.damageClaimId, row.claim.id));
    result.push({
      ...row.claim,
      chefEmail: row.chefEmail,
      chefName: row.chefName,
      managerName,
      locationName: row.locationName,
      kitchenName,
      bookingStartDate,
      bookingEndDate,
      evidence
    });
  }
  return result;
}
async function getClaimHistory(claimId) {
  return db.select().from(damageClaimHistory).where(eq5(damageClaimHistory.damageClaimId, claimId)).orderBy(desc2(damageClaimHistory.createdAt));
}
async function processExpiredClaims() {
  const now = /* @__PURE__ */ new Date();
  const results = [];
  try {
    const expiredClaims = await db.select().from(damageClaims).where(and2(
      eq5(damageClaims.status, "submitted"),
      sql5`${damageClaims.chefResponseDeadline} < ${now}`
    ));
    logger.info(`[DamageClaimService] Found ${expiredClaims.length} expired claims to process`);
    for (const claim of expiredClaims) {
      try {
        await db.update(damageClaims).set({
          status: "approved",
          approvedAmountCents: claim.claimedAmountCents,
          finalAmountCents: claim.claimedAmountCents,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq5(damageClaims.id, claim.id));
        await createHistoryEntry(
          claim.id,
          "submitted",
          "approved",
          "deadline_expired",
          "system",
          void 0,
          "Chef did not respond by deadline - claim auto-approved"
        );
        results.push({
          claimId: claim.id,
          chefId: claim.chefId,
          managerId: claim.managerId,
          previousStatus: "submitted",
          action: "auto_approved"
        });
        logger.info(`[DamageClaimService] Auto-approved claim ${claim.id} due to expired deadline`);
        try {
          const [chefUser] = await db.select({ username: users.username }).from(users).where(eq5(users.id, claim.chefId)).limit(1);
          const [managerUser] = await db.select({ username: users.username }).from(users).where(eq5(users.id, claim.managerId)).limit(1);
          if (chefUser?.username) {
            const chefEmail = generateDamageClaimDecisionEmail({
              recipientEmail: chefUser.username,
              recipientName: chefUser.username,
              recipientRole: "chef",
              claimTitle: claim.claimTitle,
              claimedAmount: `$${(claim.claimedAmountCents / 100).toFixed(2)}`,
              decision: "approved",
              finalAmount: `$${(claim.claimedAmountCents / 100).toFixed(2)}`,
              decisionReason: "You did not respond by the deadline. The claim has been automatically approved.",
              claimId: claim.id
            });
            await sendEmail(chefEmail);
          }
          if (managerUser?.username) {
            const managerEmail = generateDamageClaimDecisionEmail({
              recipientEmail: managerUser.username,
              recipientName: managerUser.username,
              recipientRole: "manager",
              claimTitle: claim.claimTitle,
              claimedAmount: `$${(claim.claimedAmountCents / 100).toFixed(2)}`,
              decision: "approved",
              finalAmount: `$${(claim.claimedAmountCents / 100).toFixed(2)}`,
              decisionReason: "Chef did not respond by the deadline. The claim has been automatically approved. You can now charge the chef.",
              claimId: claim.id
            });
            await sendEmail(managerEmail);
          }
        } catch (emailError) {
          logger.error(`[DamageClaimService] Failed to send deadline expiry emails for claim ${claim.id}:`, emailError);
        }
      } catch (claimError) {
        logger.error(`[DamageClaimService] Error processing expired claim ${claim.id}:`, claimError);
      }
    }
    return results;
  } catch (error) {
    logger.error("[DamageClaimService] Error in processExpiredClaims:", error);
    return results;
  }
}
async function refundDamageClaim(claimId, refundReason, refundedBy, partialAmountCents) {
  try {
    const [claim] = await db.select().from(damageClaims).where(eq5(damageClaims.id, claimId)).limit(1);
    if (!claim) {
      return { success: false, error: "Damage claim not found" };
    }
    if (claim.status !== "charge_succeeded") {
      return {
        success: false,
        error: `Cannot refund claim in status '${claim.status}'. Only 'charge_succeeded' claims can be refunded.`
      };
    }
    if (!claim.stripePaymentIntentId) {
      return { success: false, error: "No payment intent found for this claim. Manual refund required in Stripe Dashboard." };
    }
    const chargedAmount = claim.finalAmountCents || claim.approvedAmountCents || claim.claimedAmountCents;
    const refundAmount = partialAmountCents || chargedAmount;
    if (refundAmount <= 0) {
      return { success: false, error: "Refund amount must be greater than 0" };
    }
    if (refundAmount > chargedAmount) {
      return { success: false, error: `Refund amount ($${(refundAmount / 100).toFixed(2)}) cannot exceed charged amount ($${(chargedAmount / 100).toFixed(2)})` };
    }
    if (!stripe3) {
      return { success: false, error: "Stripe not configured" };
    }
    logger.info(`[DamageClaimService] Issuing refund for claim ${claimId}:`, {
      paymentIntentId: claim.stripePaymentIntentId,
      chargedAmount: `$${(chargedAmount / 100).toFixed(2)}`,
      refundAmount: `$${(refundAmount / 100).toFixed(2)}`,
      reason: refundReason
    });
    const refund = await stripe3.refunds.create({
      payment_intent: claim.stripePaymentIntentId,
      amount: refundAmount,
      reason: "requested_by_customer",
      metadata: {
        damage_claim_id: claimId.toString(),
        refund_reason: refundReason,
        refunded_by: refundedBy.toString()
      }
    });
    const isFullRefund = refundAmount >= chargedAmount;
    await db.update(damageClaims).set({
      status: "resolved",
      resolvedAt: /* @__PURE__ */ new Date(),
      resolvedBy: refundedBy,
      resolutionType: isFullRefund ? "refunded" : "partially_refunded",
      resolutionNotes: `${isFullRefund ? "Full" : "Partial"} refund of $${(refundAmount / 100).toFixed(2)} issued. Reason: ${refundReason}`,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq5(damageClaims.id, claimId));
    await createHistoryEntry(
      claimId,
      "charge_succeeded",
      "resolved",
      "refund",
      "admin",
      refundedBy,
      `${isFullRefund ? "Full" : "Partial"} refund of $${(refundAmount / 100).toFixed(2)} issued. Reason: ${refundReason}`,
      {
        refundId: refund.id,
        refundAmount,
        chargedAmount,
        isFullRefund,
        reason: refundReason
      }
    );
    if (claim.paymentTransactionId) {
      try {
        const { updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
        await updatePaymentTransaction2(claim.paymentTransactionId, {
          status: isFullRefund ? "refunded" : "partially_refunded",
          refundAmount,
          refundId: refund.id,
          refundedAt: /* @__PURE__ */ new Date()
        }, db);
      } catch (ptError) {
        logger.warn(`[DamageClaimService] Could not update payment_transactions for refund:`, ptError);
      }
    }
    try {
      const [chef] = await db.select({ email: users.username }).from(users).where(eq5(users.id, claim.chefId)).limit(1);
      if (chef?.email) {
        await sendEmail({
          to: chef.email,
          subject: `Damage Claim Refund - $${(refundAmount / 100).toFixed(2)}`,
          html: `
            <h2>Damage Claim Refund</h2>
            <p>A ${isFullRefund ? "full" : "partial"} refund has been issued for your damage claim.</p>
            <p><strong>Claim:</strong> ${claim.claimTitle}</p>
            <p><strong>Refund Amount:</strong> $${(refundAmount / 100).toFixed(2)}</p>
            <p><strong>Reason:</strong> ${refundReason}</p>
            <p>The refund should appear on your statement within 5-10 business days.</p>
          `,
          text: `Damage Claim Refund

A ${isFullRefund ? "full" : "partial"} refund of $${(refundAmount / 100).toFixed(2)} has been issued for your damage claim.

Claim: ${claim.claimTitle}
Reason: ${refundReason}`
        });
        logger.info(`[DamageClaimService] Sent refund notification email to chef ${chef.email}`);
      }
    } catch (emailError) {
      logger.error(`[DamageClaimService] Error sending refund notification email:`, emailError);
    }
    logger.info(`[DamageClaimService] \u2705 Refund successful for claim ${claimId}:`, {
      refundId: refund.id,
      amount: `$${(refundAmount / 100).toFixed(2)}`,
      isFullRefund
    });
    return { success: true, refundId: refund.id };
  } catch (error) {
    logger.error(`[DamageClaimService] Error refunding claim ${claimId}:`, error);
    if (error.type === "StripeInvalidRequestError") {
      return { success: false, error: `Stripe error: ${error.message}` };
    }
    return { success: false, error: error.message || "Failed to process refund" };
  }
}
async function hasChefUnpaidDamageClaims(chefId) {
  const blockingStatuses = [
    "approved",
    "partially_approved",
    "chef_accepted",
    "charge_pending",
    "charge_failed",
    "escalated"
  ];
  const [result] = await db.select({ count: sql5`count(*)` }).from(damageClaims).where(
    and2(
      eq5(damageClaims.chefId, chefId),
      inArray2(damageClaims.status, blockingStatuses)
    )
  );
  return (result?.count || 0) > 0;
}
async function getChefUnpaidDamageClaims(chefId) {
  const blockingStatuses = [
    "approved",
    "partially_approved",
    "chef_accepted",
    "charge_pending",
    "charge_failed",
    "escalated"
  ];
  const claims = await db.select({
    claimId: damageClaims.id,
    claimTitle: damageClaims.claimTitle,
    status: damageClaims.status,
    claimedAmountCents: damageClaims.claimedAmountCents,
    approvedAmountCents: damageClaims.approvedAmountCents,
    finalAmountCents: damageClaims.finalAmountCents,
    bookingType: damageClaims.bookingType,
    createdAt: damageClaims.createdAt,
    kitchenBookingId: damageClaims.kitchenBookingId,
    storageBookingId: damageClaims.storageBookingId
  }).from(damageClaims).where(
    and2(
      eq5(damageClaims.chefId, chefId),
      inArray2(damageClaims.status, blockingStatuses)
    )
  ).orderBy(desc2(damageClaims.createdAt));
  const enrichedClaims = await Promise.all(claims.map(async (claim) => {
    let kitchenName = null;
    if (claim.bookingType === "kitchen" && claim.kitchenBookingId) {
      const [booking] = await db.select({ kitchenName: kitchens.name }).from(kitchenBookings).innerJoin(kitchens, eq5(kitchenBookings.kitchenId, kitchens.id)).where(eq5(kitchenBookings.id, claim.kitchenBookingId)).limit(1);
      kitchenName = booking?.kitchenName || null;
    } else if (claim.bookingType === "storage" && claim.storageBookingId) {
      const [booking] = await db.select({ kitchenName: kitchens.name }).from(storageBookings).innerJoin(storageListings, eq5(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq5(storageListings.kitchenId, kitchens.id)).where(eq5(storageBookings.id, claim.storageBookingId)).limit(1);
      kitchenName = booking?.kitchenName || null;
    }
    const finalAmount = claim.finalAmountCents || claim.approvedAmountCents || claim.claimedAmountCents;
    return {
      claimId: claim.claimId,
      claimTitle: claim.claimTitle,
      status: claim.status,
      claimedAmountCents: claim.claimedAmountCents,
      finalAmountCents: finalAmount,
      approvedAmountCents: claim.approvedAmountCents,
      requiresImmediatePayment: ["approved", "partially_approved", "chef_accepted", "charge_failed", "escalated"].includes(claim.status),
      kitchenName,
      bookingType: claim.bookingType,
      createdAt: claim.createdAt
    };
  }));
  return enrichedClaims;
}
var stripeSecretKey3, stripe3, damageClaimService;
var init_damage_claim_service = __esm({
  "server/services/damage-claim-service.ts"() {
    "use strict";
    init_db();
    init_reference_code();
    init_schema();
    init_logger();
    init_email();
    stripeSecretKey3 = process.env.STRIPE_SECRET_KEY;
    stripe3 = stripeSecretKey3 ? new Stripe3(stripeSecretKey3, {
      apiVersion: "2025-12-15.clover"
    }) : null;
    damageClaimService = {
      createDamageClaim,
      updateDraftClaim,
      deleteDraftClaim,
      submitClaim,
      addEvidence,
      removeEvidence,
      getChefPendingClaims,
      chefRespondToClaim,
      getDisputedClaims,
      adminDecision,
      chargeApprovedClaim,
      getClaimById,
      getManagerClaims,
      getClaimHistory,
      processExpiredClaims,
      refundDamageClaim,
      hasChefUnpaidDamageClaims,
      getChefUnpaidDamageClaims,
      createDamageClaimPaymentCheckout
    };
  }
});

// server/domains/users/user.service.ts
import { eq as eq6 } from "drizzle-orm";
var UserService, userService;
var init_user_service = __esm({
  "server/domains/users/user.service.ts"() {
    "use strict";
    init_logger();
    init_user_repository();
    init_schema();
    init_db();
    init_passwordUtils();
    init_domain_error();
    UserService = class {
      repo;
      constructor(repo) {
        this.repo = repo || new UserRepository();
      }
      async checkUsernameExists(username) {
        const user = await this.repo.findByUsername(username);
        return !!user;
      }
      async getUser(id) {
        return this.repo.findById(id);
      }
      async getUserByUsername(username) {
        return this.repo.findByUsername(username);
      }
      async getUserByFirebaseUid(uid) {
        return this.repo.findByFirebaseUid(uid);
      }
      async createUser(data) {
        if (!data.username) {
          throw new Error("Username is required");
        }
        const exists = await this.repo.usernameExists(data.username);
        if (exists) {
          throw new DomainError(
            UserErrorCodes.USERNAME_TAKEN,
            `Username ${data.username} is already taken`,
            409
          );
        }
        let hashedPassword = "";
        if (data.password) {
          hashedPassword = await hashPassword(data.password);
        }
        const userToCreate = {
          username: data.username,
          password: hashedPassword,
          role: data.role,
          firebaseUid: data.firebaseUid,
          email: data.email,
          isVerified: data.isVerified ?? false,
          has_seen_welcome: data.has_seen_welcome ?? false
        };
        return this.repo.create(userToCreate);
      }
      async updateUser(id, data) {
        if (data.password) {
          data.password = await hashPassword(data.password);
        }
        return this.repo.update(id, data);
      }
      async updateUserFirebaseUid(id, firebaseUid) {
        const user = await this.repo.findById(id);
        if (user && user.firebaseUid) {
          throw new DomainError(
            UserErrorCodes.VALIDATION_ERROR,
            "User already has a linked Firebase account",
            400
          );
        }
        return this.repo.update(id, { firebaseUid });
      }
      async setHasSeenWelcome(id) {
        await this.repo.update(id, { has_seen_welcome: true });
      }
      async updateUserRoles(id, roles) {
        const mainRole = roles.isChef ? "chef" : void 0;
        const updateData = {
          isChef: roles.isChef
        };
        if (mainRole) {
          updateData.role = mainRole;
        } else {
          updateData.role = roles.isChef ? "chef" : null;
        }
        await this.repo.update(id, updateData);
      }
      async getCompleteProfile(id) {
        const user = await this.repo.findById(id);
        if (!user) {
          throw new DomainError(
            UserErrorCodes.USER_NOT_FOUND,
            `User not found: ${id}`,
            404
          );
        }
        return {
          ...user,
          firebaseUser: {
            uid: user.firebaseUid,
            email: user.username,
            // Assuming username is email
            emailVerified: user.isVerified
          }
        };
      }
      async resetPassword(firebaseUid, newPassword) {
        const user = await this.repo.findByFirebaseUid(firebaseUid);
        if (!user) {
          throw new Error(`User not found for firebaseUid: ${firebaseUid}`);
        }
        const hashedPassword = await hashPassword(newPassword);
        await this.repo.update(user.id, { password: hashedPassword });
      }
      async verifyUser(id, isVerified) {
        return this.repo.update(id, { isVerified });
      }
      async markWelcomeSeen(id) {
        await this.repo.update(id, { has_seen_welcome: true });
      }
      /**
       * Check if user has any outstanding financial obligations
       * ENTERPRISE STANDARD: Block account deletion if user owes money
       */
      async hasOutstandingObligations(userId) {
        try {
          const { hasChefUnpaidPenalties: hasChefUnpaidPenalties2, getChefUnpaidPenalties: getChefUnpaidPenalties2 } = await Promise.resolve().then(() => (init_overstay_penalty_service(), overstay_penalty_service_exports));
          const { hasChefUnpaidDamageClaims: hasChefUnpaidDamageClaims2, getChefUnpaidDamageClaims: getChefUnpaidDamageClaims2 } = await Promise.resolve().then(() => (init_damage_claim_service(), damage_claim_service_exports));
          const hasUnpaidPenalties = await hasChefUnpaidPenalties2(userId);
          const hasUnpaidClaims = await hasChefUnpaidDamageClaims2(userId);
          let penaltyTotal = 0;
          let claimTotal = 0;
          if (hasUnpaidPenalties) {
            const penalties = await getChefUnpaidPenalties2(userId);
            penaltyTotal = penalties.reduce((sum, p) => sum + p.penaltyAmountCents, 0);
          }
          if (hasUnpaidClaims) {
            const claims = await getChefUnpaidDamageClaims2(userId);
            claimTotal = claims.reduce((sum, c) => sum + c.finalAmountCents, 0);
          }
          return {
            hasObligations: hasUnpaidPenalties || hasUnpaidClaims,
            overstayPenalties: hasUnpaidPenalties ? (await getChefUnpaidPenalties2(userId)).length : 0,
            damageClaims: hasUnpaidClaims ? (await getChefUnpaidDamageClaims2(userId)).length : 0,
            totalOwedCents: penaltyTotal + claimTotal
          };
        } catch (error) {
          logger.error(`[UserService] Error checking obligations for user ${userId}:`, error);
          return { hasObligations: false, overstayPenalties: 0, damageClaims: 0, totalOwedCents: 0 };
        }
      }
      async deleteUser(id) {
        const obligations = await this.hasOutstandingObligations(id);
        if (obligations.hasObligations) {
          throw new Error(
            `Cannot delete account with outstanding obligations. ${obligations.overstayPenalties} unpaid overstay penalty(ies), ${obligations.damageClaims} unpaid damage claim(s), totaling $${(obligations.totalOwedCents / 100).toFixed(2)}. Please resolve all obligations before deleting your account.`
          );
        }
        await db.transaction(async (tx) => {
          const managedLocations = await tx.select().from(locations).where(eq6(locations.managerId, id));
          if (managedLocations.length > 0) {
            await tx.update(locations).set({ managerId: null }).where(eq6(locations.managerId, id));
            logger.info(`Removed manager ${id} from ${managedLocations.length} locations`);
          }
          await tx.delete(users).where(eq6(users.id, id));
          logger.info(`Deleted user ${id}`);
        });
      }
    };
    userService = new UserService();
  }
});

// server/firebase-auth-middleware.ts
import * as Sentry3 from "@sentry/node";
async function requireFirebaseAuthWithUser(req, res, next) {
  try {
    if (res.headersSent) {
      return;
    }
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({
        error: "Unauthorized",
        message: "No auth token provided"
      });
    }
    const token = authHeader.substring(7);
    const decodedToken = await verifyFirebaseToken(token);
    if (!decodedToken) {
      return res.status(401).json({
        error: "Unauthorized",
        message: "Invalid auth token"
      });
    }
    req.firebaseUser = {
      uid: decodedToken.uid,
      email: decodedToken.email,
      email_verified: decodedToken.email_verified,
      name: decodedToken.name,
      picture: decodedToken.picture
    };
    const neonUser = await userService.getUserByFirebaseUid(req.firebaseUser.uid);
    if (!neonUser) {
      return res.status(404).json({
        error: "User not found",
        message: "This account is not registered with Local Cooks. Please create an account first."
      });
    }
    req.neonUser = {
      ...neonUser,
      uid: neonUser.firebaseUid || void 0
      // Support legacy code that uses .uid
    };
    Sentry3.setUser({
      id: String(neonUser.id),
      email: req.firebaseUser.email,
      username: neonUser.username || void 0,
      data: {
        role: neonUser.role,
        firebaseUid: req.firebaseUser.uid
      }
    });
    next();
  } catch (error) {
    if (res.headersSent) {
      logger.error("Firebase auth with user verification error (response already sent):", error);
      return;
    }
    logger.error("Firebase auth with user verification error:", error);
    return res.status(500).json({
      error: "Internal server error",
      message: "Authentication verification failed"
    });
  }
}
async function optionalFirebaseAuth(req, res, next) {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return next();
    }
    const token = authHeader.substring(7);
    const decodedToken = await verifyFirebaseToken(token);
    if (decodedToken) {
      req.firebaseUser = {
        uid: decodedToken.uid,
        email: decodedToken.email,
        email_verified: decodedToken.email_verified,
        name: decodedToken.name,
        picture: decodedToken.picture
      };
      const neonUser = await userService.getUserByFirebaseUid(decodedToken.uid);
      if (neonUser) {
        req.neonUser = {
          ...neonUser,
          uid: neonUser.firebaseUid || void 0
        };
      }
    }
    next();
  } catch (error) {
    logger.error("Optional Firebase auth error:", error);
    next();
  }
}
function requireAdmin(req, res, next) {
  if (res.headersSent) {
    return;
  }
  if (!req.neonUser) {
    return res.status(401).json({
      error: "Unauthorized",
      message: "Authentication required"
    });
  }
  if (req.neonUser.role !== "admin") {
    return res.status(403).json({
      error: "Forbidden",
      message: "Admin access required"
    });
  }
  next();
}
function requireManager(req, res, next) {
  if (res.headersSent) {
    return;
  }
  if (!req.neonUser) {
    return res.status(401).json({
      error: "Unauthorized",
      message: "Authentication required"
    });
  }
  if (req.neonUser.role !== "manager") {
    return res.status(403).json({
      error: "Forbidden",
      message: "Manager access required"
    });
  }
  next();
}
var init_firebase_auth_middleware = __esm({
  "server/firebase-auth-middleware.ts"() {
    "use strict";
    init_logger();
    init_firebase_setup();
    init_user_service();
  }
});

// server/r2-storage.ts
var r2_storage_exports = {};
__export(r2_storage_exports, {
  deleteFromR2: () => deleteFromR2,
  fileExistsInR2: () => fileExistsInR2,
  getPresignedUrl: () => getPresignedUrl,
  isR2Configured: () => isR2Configured,
  uploadToR2: () => uploadToR2
});
import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand, HeadObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
function getR2Config() {
  return {
    accountId: process.env.CLOUDFLARE_ACCOUNT_ID,
    accessKeyId: process.env.CLOUDFLARE_R2_ACCESS_KEY_ID,
    secretAccessKey: process.env.CLOUDFLARE_R2_SECRET_ACCESS_KEY,
    bucketName: process.env.CLOUDFLARE_R2_BUCKET_NAME,
    publicUrl: process.env.CLOUDFLARE_R2_PUBLIC_URL
  };
}
function getR2PublicUrl() {
  const config = getR2Config();
  if (config.publicUrl) {
    return config.publicUrl;
  }
  if (config.accountId && config.bucketName) {
    return `https://${config.accountId}.r2.cloudflarestorage.com/${config.bucketName}`;
  }
  return "";
}
function getR2Endpoint() {
  const config = getR2Config();
  return config.accountId ? `https://${config.accountId}.r2.cloudflarestorage.com` : "";
}
function getS3Client() {
  if (!s3Client) {
    const config = getR2Config();
    const endpoint = getR2Endpoint();
    if (!config.accountId || !config.accessKeyId || !config.secretAccessKey || !config.bucketName) {
      throw new Error("Cloudflare R2 credentials not configured. Please set CLOUDFLARE_ACCOUNT_ID, CLOUDFLARE_R2_ACCESS_KEY_ID, CLOUDFLARE_R2_SECRET_ACCESS_KEY, and CLOUDFLARE_R2_BUCKET_NAME environment variables.");
    }
    if (!endpoint) {
      throw new Error("R2 endpoint could not be constructed. Please check CLOUDFLARE_ACCOUNT_ID is set.");
    }
    s3Client = new S3Client({
      region: "auto",
      // R2 uses 'auto' as the region
      endpoint,
      credentials: {
        accessKeyId: config.accessKeyId,
        secretAccessKey: config.secretAccessKey
      },
      // Force path style for R2 compatibility
      forcePathStyle: false
    });
  }
  return s3Client;
}
async function uploadToR2(file, userId, folder = "documents") {
  try {
    const client = getS3Client();
    const timestamp2 = Date.now();
    const documentType = file.fieldname || "file";
    const ext = file.originalname.split(".").pop() || "";
    const baseName = file.originalname.replace(/\.[^/.]+$/, "");
    const sanitizedBaseName = baseName.replace(/[^a-zA-Z0-9-_]/g, "_");
    const filename = `${userId}_${documentType}_${timestamp2}_${sanitizedBaseName}.${ext}`;
    const key = `${folder}/${filename}`;
    let fileBuffer;
    if (file.buffer) {
      fileBuffer = file.buffer;
    } else if (file.path) {
      const fs7 = await import("fs");
      fileBuffer = fs7.readFileSync(file.path);
    } else {
      throw new Error("File buffer or path not available");
    }
    const config = getR2Config();
    const command = new PutObjectCommand({
      Bucket: config.bucketName,
      Key: key,
      Body: fileBuffer,
      ContentType: file.mimetype
      // Make file publicly accessible (if your R2 bucket allows public access)
      // Note: You need to configure CORS and public access in Cloudflare dashboard
    });
    await client.send(command);
    let publicUrl;
    const r2PublicUrl = getR2PublicUrl();
    if (r2PublicUrl) {
      publicUrl = r2PublicUrl.endsWith("/") ? `${r2PublicUrl}${key}` : `${r2PublicUrl}/${key}`;
    } else {
      publicUrl = `https://${config.accountId}.r2.cloudflarestorage.com/${config.bucketName}/${key}`;
    }
    logger.info(`\u2705 File uploaded to R2: ${key} -> ${publicUrl}`);
    return publicUrl;
  } catch (error) {
    logger.error("\u274C Error uploading to R2:", error);
    throw new Error(`Failed to upload file to R2: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
async function deleteFromR2(fileUrl) {
  try {
    const client = getS3Client();
    let actualFileUrl = fileUrl;
    if (fileUrl.includes("/api/files/r2-proxy")) {
      try {
        const urlObj2 = new URL(fileUrl, "http://localhost");
        const urlParam = urlObj2.searchParams.get("url");
        if (urlParam) {
          actualFileUrl = decodeURIComponent(urlParam);
          logger.info(`\u{1F50D} Extracted R2 URL from proxy: ${actualFileUrl}`);
        } else {
          logger.error("\u274C Proxy URL missing url parameter:", fileUrl);
          return false;
        }
      } catch (urlError) {
        logger.error("\u274C Error parsing proxy URL:", urlError);
        return false;
      }
    }
    const urlObj = new URL(actualFileUrl);
    const pathname = urlObj.pathname.startsWith("/") ? urlObj.pathname.slice(1) : urlObj.pathname;
    const pathParts = pathname.split("/").filter((p) => p);
    const config = getR2Config();
    const bucketIndex = pathParts.indexOf(config.bucketName);
    let key;
    if (bucketIndex >= 0) {
      key = pathParts.slice(bucketIndex + 1).join("/");
    } else {
      const knownFolders = ["documents", "kitchen-applications", "images", "profiles"];
      const firstPart = pathParts[0];
      if (knownFolders.includes(firstPart)) {
        key = pathname;
      } else {
        key = pathname;
      }
    }
    key = key.replace(/^\/+|\/+$/g, "");
    if (!key || key.length === 0) {
      logger.error(`\u274C Invalid key extracted from URL: ${fileUrl} -> ${actualFileUrl}`);
      return false;
    }
    logger.info("\u{1F50D} R2 Delete Debug:", {
      originalUrl: fileUrl,
      actualFileUrl,
      extractedKey: key,
      bucketName: config.bucketName,
      pathname: urlObj.pathname,
      pathParts,
      bucketIndex
    });
    const command = new DeleteObjectCommand({
      Bucket: config.bucketName,
      Key: key
    });
    await client.send(command);
    logger.info(`\u2705 File deleted from R2: ${key}`);
    return true;
  } catch (error) {
    logger.error("\u274C Error deleting from R2:", {
      error: error instanceof Error ? error.message : "Unknown error",
      fileUrl,
      stack: error instanceof Error ? error.stack : void 0
    });
    return false;
  }
}
async function fileExistsInR2(fileUrl) {
  try {
    const client = getS3Client();
    const config = getR2Config();
    const urlObj = new URL(fileUrl);
    const key = urlObj.pathname.startsWith("/") ? urlObj.pathname.slice(1) : urlObj.pathname;
    const keyParts = key.split("/");
    const bucketIndex = keyParts.indexOf(config.bucketName);
    const actualKey = bucketIndex >= 0 ? keyParts.slice(bucketIndex + 1).join("/") : key;
    const command = new HeadObjectCommand({
      Bucket: config.bucketName,
      Key: actualKey
    });
    await client.send(command);
    return true;
  } catch (_error) {
    return false;
  }
}
async function getPresignedUrl(fileUrl, expiresIn = 3600) {
  try {
    const client = getS3Client();
    const config = getR2Config();
    const urlObj = new URL(fileUrl);
    const pathname = urlObj.pathname.startsWith("/") ? urlObj.pathname.slice(1) : urlObj.pathname;
    const pathParts = pathname.split("/").filter((p) => p);
    const bucketIndex = pathParts.indexOf(config.bucketName);
    let key;
    if (bucketIndex >= 0) {
      key = pathParts.slice(bucketIndex + 1).join("/");
    } else {
      const knownFolders = ["documents", "kitchen-applications", "images", "profiles"];
      const firstPart = pathParts[0];
      if (knownFolders.includes(firstPart)) {
        key = pathname;
      } else {
        key = pathname;
      }
    }
    key = key.replace(/^\/+|\/+$/g, "");
    if (!key || key.length === 0) {
      throw new Error(`Invalid key extracted from URL: ${fileUrl}`);
    }
    try {
      await client.send(new HeadObjectCommand({ Bucket: config.bucketName, Key: key }));
    } catch (headError) {
      const err = headError;
      if (err.name === "NotFound" || err.$metadata?.httpStatusCode === 404) {
        if (key.startsWith("documents/") && (key.includes("foodSafetyLicenseFile") || key.includes("foodEstablishmentCert"))) {
          const remappedKey = key.replace("documents/", "kitchen-applications/");
          logger.info(`[R2 Storage] Key ${key} not found. Checking remapped: ${remappedKey}`);
          try {
            await client.send(new HeadObjectCommand({ Bucket: config.bucketName, Key: remappedKey }));
            key = remappedKey;
            logger.info(`[R2 Storage] Using remapped key: ${key}`);
          } catch (_remapError) {
            logger.info(`[R2 Storage] Remapped key also not found: ${remappedKey}`);
          }
        }
      } else {
        logger.warn(`[R2 Storage] Warning: HeadObject validation failed for ${key}:`, err.message);
      }
    }
    const command = new GetObjectCommand({
      Bucket: config.bucketName,
      Key: key
    });
    const presignedUrl = await getSignedUrl(client, command, { expiresIn });
    return presignedUrl;
  } catch (error) {
    logger.error("\u274C Error generating presigned URL:", {
      error: error instanceof Error ? error.message : "Unknown error",
      fileUrl,
      stack: error instanceof Error ? error.stack : void 0
    });
    throw new Error(`Failed to generate presigned URL: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
function isR2Configured() {
  const config = getR2Config();
  return !!(config.accountId && config.accessKeyId && config.secretAccessKey && config.bucketName);
}
var s3Client;
var init_r2_storage = __esm({
  "server/r2-storage.ts"() {
    "use strict";
    init_logger();
    s3Client = null;
  }
});

// server/fileUpload.ts
import multer from "multer";
import path from "path";
import fs from "fs";
function getUploadsDir() {
  if (isVercel2) {
    return "/tmp/uploads/documents";
  }
  return path.join(process.cwd(), "uploads", "documents");
}
function ensureUploadsDirExists() {
  if (useCloudStorage) {
    return;
  }
  const dir = getUploadsDir();
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}
var isVercel2, isProduction, useCloudStorage, uploadsDir, diskStorage, memoryStorage, fileFilter, upload, uploadToBlob, getFileUrl;
var init_fileUpload = __esm({
  "server/fileUpload.ts"() {
    "use strict";
    init_logger();
    init_r2_storage();
    isVercel2 = !!process.env.VERCEL;
    isProduction = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
    useCloudStorage = isR2Configured() || isProduction || isVercel2;
    uploadsDir = getUploadsDir();
    diskStorage = multer.diskStorage({
      destination: (req, file, cb) => {
        ensureUploadsDirExists();
        cb(null, uploadsDir);
      },
      filename: (req, file, cb) => {
        const userId = req.neonUser?.id || req.user?.id || "unknown";
        const timestamp2 = Date.now();
        const documentType = file.fieldname;
        const ext = path.extname(file.originalname);
        const baseName = path.basename(file.originalname, ext);
        const filename = `${userId}_${documentType}_${timestamp2}_${baseName}${ext}`;
        cb(null, filename);
      }
    });
    memoryStorage = multer.memoryStorage();
    fileFilter = (req, file, cb) => {
      const allowedMimes = [
        "application/pdf",
        "image/jpeg",
        "image/jpg",
        "image/png",
        "image/webp",
        // DOC and DOCX support for terms & policies
        "application/msword",
        // .doc
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
        // .docx
      ];
      if (allowedMimes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        logger.info(`[FileUpload] Rejected file with mimetype: ${file.mimetype}`);
        cb(new Error("Invalid file type. Only PDF, JPG, JPEG, PNG, WebP, DOC, and DOCX files are allowed."));
      }
    };
    logger.info(` File Upload Config: R2 configured = ${isR2Configured()}, using ${useCloudStorage ? "memory (R2)" : "disk (local)"} storage`);
    upload = multer({
      storage: useCloudStorage ? memoryStorage : diskStorage,
      limits: {
        fileSize: 10 * 1024 * 1024
        // 10MB limit
      },
      fileFilter
    });
    uploadToBlob = async (file, userId, folder = "documents") => {
      try {
        const r2Available = isR2Configured();
        logger.info(`\u{1F4E6} uploadToBlob: R2 configured = ${r2Available}, file has buffer = ${!!file.buffer}, file has path = ${!!file.path}`);
        if (r2Available) {
          logger.info(`\u2601\uFE0F Uploading to Cloudflare R2...`);
          const url = await uploadToR2(file, userId, folder);
          logger.info(`\u2705 R2 upload complete: ${url}`);
          return url;
        } else {
          logger.info(`\u{1F4C1} R2 not configured, using local storage`);
          const filename = file.filename || `${userId}_${Date.now()}_${file.originalname}`;
          return getFileUrl(filename);
        }
      } catch (error) {
        logger.error("\u274C Error uploading file:", error);
        throw new Error("Failed to upload file to cloud storage");
      }
    };
    getFileUrl = (filename) => {
      return `/api/files/documents/${filename}`;
    };
  }
});

// server/domains/applications/application.repository.ts
import { eq as eq7, desc as desc3, and as and3 } from "drizzle-orm";
var ApplicationRepository;
var init_application_repository = __esm({
  "server/domains/applications/application.repository.ts"() {
    "use strict";
    init_db();
    init_schema();
    ApplicationRepository = class {
      async getAll() {
        return db.select().from(applications).orderBy(desc3(applications.createdAt));
      }
      async findById(id) {
        const [application] = await db.select().from(applications).where(eq7(applications.id, id));
        return application || null;
      }
      async findByUserId(userId) {
        return db.select().from(applications).where(eq7(applications.userId, userId)).orderBy(desc3(applications.createdAt));
      }
      async hasPendingApplication(userId) {
        const results = await db.select({ id: applications.id }).from(applications).where(
          and3(
            eq7(applications.userId, userId),
            eq7(applications.status, "inReview")
          )
        ).limit(1);
        return results.length > 0;
      }
      async create(data) {
        const now = /* @__PURE__ */ new Date();
        const [application] = await db.insert(applications).values({
          ...data,
          status: "inReview",
          createdAt: now,
          foodSafetyLicenseStatus: data.foodSafetyLicenseUrl ? "pending" : "pending",
          // Default
          foodEstablishmentCertStatus: data.foodEstablishmentCertUrl ? "pending" : "pending"
          // Default
        }).returning();
        return application;
      }
      async updateStatus(id, status) {
        const [updated] = await db.update(applications).set({ status }).where(eq7(applications.id, id)).returning();
        return updated || null;
      }
      async updateDocuments(id, updates) {
        const resetStatus = {};
        if (updates.foodSafetyLicenseUrl) resetStatus.foodSafetyLicenseStatus = "pending";
        if (updates.foodEstablishmentCertUrl) resetStatus.foodEstablishmentCertStatus = "pending";
        const [updated] = await db.update(applications).set({
          ...updates,
          ...resetStatus
        }).where(eq7(applications.id, id)).returning();
        return updated || null;
      }
      async verifyDocuments(data) {
        const [updated] = await db.update(applications).set({
          foodSafetyLicenseStatus: data.foodSafetyLicenseStatus,
          foodEstablishmentCertStatus: data.foodEstablishmentCertStatus,
          documentsAdminFeedback: data.documentsAdminFeedback,
          documentsReviewedBy: data.documentsReviewedBy,
          documentsReviewedAt: /* @__PURE__ */ new Date()
        }).where(eq7(applications.id, data.id)).returning();
        return updated || null;
      }
    };
  }
});

// server/domains/applications/application.service.ts
var ApplicationService, applicationService;
var init_application_service = __esm({
  "server/domains/applications/application.service.ts"() {
    "use strict";
    init_application_repository();
    init_domain_error();
    ApplicationService = class {
      repo;
      constructor(repo) {
        this.repo = repo || new ApplicationRepository();
      }
      async getAllApplications() {
        return this.repo.getAll();
      }
      async getApplicationById(id) {
        const app2 = await this.repo.findById(id);
        if (!app2) {
          throw new DomainError("APPLICATION_NOT_FOUND", `Application ${id} not found`, 404);
        }
        return app2;
      }
      async getApplicationsByUserId(userId) {
        return this.repo.findByUserId(userId);
      }
      async submitApplication(data) {
        if (!data.userId) {
          throw new DomainError(ApplicationErrorCodes.VALIDATION_ERROR, "User ID is required", 400);
        }
        const hasPending = await this.repo.hasPendingApplication(data.userId);
        if (hasPending) {
          throw new DomainError(
            ApplicationErrorCodes.VALIDATION_ERROR,
            "You already have a pending application. Please wait for it to be processed.",
            409
          );
        }
        return this.repo.create(data);
      }
      async approveApplication(id, adminId) {
        const app2 = await this.repo.findById(id);
        if (!app2) {
          throw new DomainError(ApplicationErrorCodes.APPLICATION_NOT_FOUND, `Application ${id} not found`, 404);
        }
        if (app2.status !== "inReview") {
          throw new DomainError(
            ApplicationErrorCodes.VALIDATION_ERROR,
            `Application is already processed (Status: ${app2.status})`,
            400
          );
        }
        const updated = await this.repo.updateStatus(id, "approved");
        if (!updated) throw new Error("Failed to approve application");
        return updated;
      }
      async updateStatus(id, status) {
        const app2 = await this.repo.updateStatus(id, status);
        if (!app2) {
          throw new DomainError("APPLICATION_NOT_FOUND", `Application ${id} not found`, 404);
        }
        return app2;
      }
      async updateDocuments(id, updates) {
        const app2 = await this.repo.updateDocuments(id, updates);
        if (!app2) {
          throw new DomainError("APPLICATION_NOT_FOUND", `Application ${id} not found`, 404);
        }
        return app2;
      }
      async cancelApplication(id, userId) {
        const app2 = await this.repo.findById(id);
        if (!app2) {
          throw new DomainError("APPLICATION_NOT_FOUND", `Application ${id} not found`, 404);
        }
        if (app2.userId !== userId) {
          throw new DomainError("FORBIDDEN", "You can only cancel your own applications", 403);
        }
        const updated = await this.repo.updateStatus(id, "cancelled");
        if (!updated) throw new Error("Failed to cancel application");
        return updated;
      }
      async verifyDocuments(data) {
        const app2 = await this.repo.verifyDocuments(data);
        if (!app2) {
          throw new DomainError("APPLICATION_NOT_FOUND", `Application ${data.id} not found`, 404);
        }
        return app2;
      }
    };
    applicationService = new ApplicationService();
  }
});

// server/phone-utils.ts
import { eq as eq8, and as and4, desc as desc4 } from "drizzle-orm";
async function getManagerPhone(location, managerId, pool3) {
  let phone = location?.notificationPhone || location?.notification_phone || null;
  if (phone) {
    const normalized = validateAndNormalizePhone(phone);
    if (normalized) {
      return normalized;
    }
    logger.warn(`\u26A0\uFE0F Location notification phone is invalid format: ${phone}`);
  }
  if (!phone && managerId) {
    try {
      const result = await db.select({ phone: applications.phone }).from(applications).where(eq8(applications.userId, managerId)).orderBy(desc4(applications.createdAt)).limit(1);
      if (result.length > 0 && result[0].phone) {
        phone = result[0].phone;
        const normalized = validateAndNormalizePhone(phone);
        if (normalized) {
          return normalized;
        }
        logger.warn(`\u26A0\uFE0F Manager application phone is invalid format: ${phone}`);
      }
    } catch (error) {
      logger.warn("Could not retrieve manager phone from application:", error);
    }
  }
  return null;
}
async function getChefPhone(chefId, pool3) {
  if (!chefId) return null;
  try {
    const result = await db.select({ phone: applications.phone }).from(applications).where(eq8(applications.userId, chefId)).orderBy(desc4(applications.createdAt)).limit(1);
    if (result.length > 0 && result[0].phone) {
      const phone = result[0].phone;
      const normalized = validateAndNormalizePhone(phone);
      if (normalized) {
        return normalized;
      }
      logger.warn(`\u26A0\uFE0F Chef application phone is invalid format: ${phone}`);
    }
  } catch (error) {
    logger.warn("Could not retrieve chef phone from application:", error);
  }
  return null;
}
function normalizePhoneForStorage(phone) {
  if (!phone) return null;
  return validateAndNormalizePhone(phone);
}
var init_phone_utils = __esm({
  "server/phone-utils.ts"() {
    "use strict";
    init_logger();
    init_phone_validation();
    init_db();
    init_schema();
  }
});

// server/domains/microlearning/microlearning.repository.ts
import { eq as eq9, desc as desc5, sql as sql6 } from "drizzle-orm";
var MicrolearningRepository;
var init_microlearning_repository = __esm({
  "server/domains/microlearning/microlearning.repository.ts"() {
    "use strict";
    init_db();
    init_schema();
    MicrolearningRepository = class {
      async getProgress(userId) {
        return db.select().from(videoProgress).where(eq9(videoProgress.userId, userId)).orderBy(desc5(videoProgress.updatedAt));
      }
      async getCompletion(userId) {
        const [completion] = await db.select().from(microlearningCompletions).where(eq9(microlearningCompletions.userId, userId));
        return completion || null;
      }
      async upsertVideoProgress(data) {
        return db.insert(videoProgress).values(data).onConflictDoUpdate({
          target: [videoProgress.userId, videoProgress.videoId],
          set: {
            progress: data.completed ? data.progress : sql6`GREATEST(${videoProgress.progress}, ${data.progress})`,
            completed: data.completed ? sql6`true` : sql6`${videoProgress.completed}`,
            watchedPercentage: sql6`GREATEST(${videoProgress.watchedPercentage}, ${data.watchedPercentage})`,
            isRewatching: data.isRewatching,
            updatedAt: /* @__PURE__ */ new Date(),
            completedAt: data.completedAt ? data.completedAt : sql6`${videoProgress.completedAt}`
          }
        });
      }
      async createCompletion(data) {
        const [completion] = await db.insert(microlearningCompletions).values(data).returning();
        return completion;
      }
    };
  }
});

// server/domains/microlearning/microlearning.service.ts
var MicrolearningService, microlearningService;
var init_microlearning_service = __esm({
  "server/domains/microlearning/microlearning.service.ts"() {
    "use strict";
    init_microlearning_repository();
    MicrolearningService = class {
      repo;
      constructor(repo) {
        this.repo = repo || new MicrolearningRepository();
      }
      async getUserProgress(userId) {
        return this.repo.getProgress(userId);
      }
      async getUserCompletion(userId) {
        return this.repo.getCompletion(userId);
      }
      async updateVideoProgress(data) {
        return this.repo.upsertVideoProgress({
          userId: data.userId,
          videoId: data.videoId,
          progress: String(data.progress),
          completed: data.completed,
          watchedPercentage: String(data.watchedPercentage),
          isRewatching: data.isRewatching ?? false,
          updatedAt: /* @__PURE__ */ new Date(),
          completedAt: data.completedAt || null
        });
      }
      async completeMicrolearning(data) {
        return this.repo.createCompletion(data);
      }
    };
    microlearningService = new MicrolearningService();
  }
});

// server/domains/locations/location.repository.ts
import { eq as eq12, and as and8, desc as desc7 } from "drizzle-orm";
var LocationRepository;
var init_location_repository = __esm({
  "server/domains/locations/location.repository.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_schema();
    init_domain_error();
    LocationRepository = class {
      /**
       * Find location by ID
       */
      async findById(id) {
        try {
          const [location] = await db.select().from(locations).where(eq12(locations.id, id)).limit(1);
          return location || null;
        } catch (error) {
          logger.error(`[LocationRepository] Error finding location by ID ${id}:`, error);
          throw new DomainError(
            LocationErrorCodes.LOCATION_NOT_FOUND,
            "Failed to find location",
            500
          );
        }
      }
      /**
       * Find locations by manager ID
       */
      async findByManagerId(managerId) {
        try {
          const results = await db.select().from(locations).where(eq12(locations.managerId, managerId)).orderBy(desc7(locations.createdAt));
          return results;
        } catch (error) {
          logger.error(`[LocationRepository] Error finding locations by manager ${managerId}:`, error);
          throw new DomainError(
            LocationErrorCodes.NO_MANAGER_ASSIGNED,
            "Failed to find locations",
            500
          );
        }
      }
      /**
       * Create new location
       */
      async create(dto) {
        try {
          const [location] = await db.insert(locations).values({
            name: dto.name,
            address: dto.address,
            managerId: dto.managerId,
            notificationEmail: dto.notificationEmail || null,
            notificationPhone: dto.notificationPhone || null,
            contactEmail: dto.contactEmail || null,
            contactPhone: dto.contactPhone || null,
            preferredContactMethod: dto.preferredContactMethod || "email",
            cancellationPolicyHours: dto.cancellationPolicyHours ?? 24,
            cancellationPolicyMessage: dto.cancellationPolicyMessage || "Bookings cannot be cancelled within {hours} hours of the scheduled time.",
            defaultDailyBookingLimit: dto.defaultDailyBookingLimit || 2,
            minimumBookingWindowHours: dto.minimumBookingWindowHours ?? 1,
            logoUrl: dto.logoUrl || null,
            brandImageUrl: dto.brandImageUrl || null,
            description: dto.description || null,
            customOnboardingLink: dto.customOnboardingLink || null,
            timezone: dto.timezone || "America/St_Johns",
            kitchenLicenseUrl: dto.kitchenLicenseUrl || null,
            kitchenLicenseStatus: dto.kitchenLicenseStatus || "pending",
            kitchenLicenseExpiry: dto.kitchenLicenseExpiry || null,
            kitchenTermsUrl: dto.kitchenTermsUrl || null,
            kitchenTermsUploadedAt: dto.kitchenTermsUrl ? /* @__PURE__ */ new Date() : null
          }).returning();
          return location;
        } catch (error) {
          logger.error("[LocationRepository] Error creating location:", error);
          throw new DomainError(
            LocationErrorCodes.INVALID_ADDRESS,
            "Failed to create location",
            500
          );
        }
      }
      /**
       * Update existing location
       */
      async update(id, dto) {
        try {
          const [location] = await db.update(locations).set({
            name: dto.name,
            address: dto.address,
            managerId: dto.managerId,
            notificationEmail: dto.notificationEmail,
            notificationPhone: dto.notificationPhone,
            contactEmail: dto.contactEmail,
            contactPhone: dto.contactPhone,
            preferredContactMethod: dto.preferredContactMethod,
            cancellationPolicyHours: dto.cancellationPolicyHours,
            cancellationPolicyMessage: dto.cancellationPolicyMessage,
            defaultDailyBookingLimit: dto.defaultDailyBookingLimit,
            minimumBookingWindowHours: dto.minimumBookingWindowHours,
            logoUrl: dto.logoUrl,
            brandImageUrl: dto.brandImageUrl,
            description: dto.description,
            customOnboardingLink: dto.customOnboardingLink,
            timezone: dto.timezone,
            kitchenLicenseUrl: dto.kitchenLicenseUrl,
            kitchenLicenseStatus: dto.kitchenLicenseStatus,
            kitchenLicenseExpiry: dto.kitchenLicenseExpiry,
            kitchenTermsUrl: dto.kitchenTermsUrl,
            kitchenTermsUploadedAt: dto.kitchenTermsUploadedAt
          }).where(eq12(locations.id, id)).returning();
          return location || null;
        } catch (error) {
          logger.error(`[LocationRepository] Error updating location ${id}:`, error);
          throw new DomainError(
            LocationErrorCodes.LOCATION_NOT_FOUND,
            "Failed to update location",
            500
          );
        }
      }
      /**
       * Verify kitchen license
       */
      async verifyKitchenLicense(dto) {
        try {
          const [location] = await db.update(locations).set({
            kitchenLicenseStatus: dto.kitchenLicenseStatus,
            kitchenLicenseFeedback: dto.kitchenLicenseFeedback || null,
            kitchenLicenseApprovedBy: dto.kitchenLicenseApprovedBy,
            kitchenLicenseApprovedAt: /* @__PURE__ */ new Date(),
            kitchenLicenseExpiry: dto.kitchenLicenseExpiry || null
          }).where(eq12(locations.id, dto.locationId)).returning();
          return location || null;
        } catch (error) {
          logger.error(`[LocationRepository] Error verifying kitchen license for location ${dto.locationId}:`, error);
          throw new DomainError(
            LocationErrorCodes.LOCATION_NOT_FOUND,
            "Failed to verify kitchen license",
            500
          );
        }
      }
      /**
       * Update kitchen license URL
       */
      async updateKitchenLicenseUrl(locationId, licenseUrl) {
        try {
          const [location] = await db.update(locations).set({ kitchenLicenseUrl: licenseUrl }).where(eq12(locations.id, locationId)).returning();
          return location || null;
        } catch (error) {
          logger.error(`[LocationRepository] Error updating kitchen license URL for location ${locationId}:`, error);
          throw new DomainError(
            LocationErrorCodes.LOCATION_NOT_FOUND,
            "Failed to update kitchen license URL",
            500
          );
        }
      }
      /**
       * Find all locations
       */
      async findAll() {
        try {
          const results = await db.select().from(locations).orderBy(desc7(locations.createdAt));
          return results;
        } catch (error) {
          logger.error("[LocationRepository] Error finding all locations:", error);
          throw new DomainError(
            LocationErrorCodes.LOCATION_NOT_FOUND,
            "Failed to find locations",
            500
          );
        }
      }
      /**
       * Check if location name exists
       */
      async nameExists(name, excludeId) {
        try {
          const result = await db.select({ id: locations.id }).from(locations).where(
            excludeId ? and8(eq12(locations.name, name), eq12(locations.id, excludeId)) : eq12(locations.name, name)
          ).limit(1);
          return result.length > 0;
        } catch (error) {
          logger.error(`[LocationRepository] Error checking name existence ${name}:`, error);
          return false;
        }
      }
      /**
       * Find locations by manager
       */
      async countByManagerId(managerId) {
        try {
          const results = await db.select({ id: locations.id }).from(locations).where(eq12(locations.managerId, managerId));
          return results.length;
        } catch (error) {
          logger.error(`[LocationRepository] Error counting locations by manager ${managerId}:`, error);
          return 0;
        }
      }
      /**
       * Find requirements by location ID
       */
      async findRequirementsByLocationId(locationId) {
        try {
          const [requirements] = await db.select().from(locationRequirements).where(eq12(locationRequirements.locationId, locationId));
          return requirements || null;
        } catch (error) {
          logger.error(`[LocationRepository] Error finding requirements for location ${locationId}:`, error);
          return null;
        }
      }
      /**
       * Upsert location requirements
       */
      async upsertRequirements(locationId, dto) {
        try {
          const existing = await this.findRequirementsByLocationId(locationId);
          if (existing) {
            const [updated] = await db.update(locationRequirements).set({
              ...dto,
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq12(locationRequirements.locationId, locationId)).returning();
            return updated;
          } else {
            const [created] = await db.insert(locationRequirements).values({
              locationId,
              ...dto,
              // Ensure custom fields default to empty array if not provided
              customFields: dto.customFields ?? [],
              tier1_custom_fields: dto.tier1_custom_fields ?? [],
              tier2_custom_fields: dto.tier2_custom_fields ?? []
            }).returning();
            return created;
          }
        } catch (error) {
          logger.error(`[LocationRepository] Error upserting requirements for location ${locationId}:`, error);
          throw new DomainError(
            LocationErrorCodes.LOCATION_NOT_FOUND,
            "Failed to update location requirements",
            500
          );
        }
      }
      /**
       * Delete location
       */
      async delete(id) {
        try {
          await db.delete(locations).where(eq12(locations.id, id));
        } catch (error) {
          logger.error(`[LocationRepository] Error deleting location ${id}:`, error);
          throw new DomainError(
            LocationErrorCodes.LOCATION_NOT_FOUND,
            "Failed to delete location",
            500
          );
        }
      }
    };
  }
});

// server/shared/validators/input-validator.ts
import { z as z3 } from "zod";
async function validateLocationInput(data) {
  const locationSchema = z3.object({
    managerId: z3.number().positive("Manager ID must be positive"),
    name: z3.string().min(2, "Location name must be at least 2 characters"),
    address: z3.string().min(5, "Address must be at least 5 characters"),
    notificationEmail: z3.string().email("Invalid email format").optional(),
    notificationPhone: z3.string().optional(),
    cancellationPolicyHours: z3.number().int().min(0, "Cancellation policy hours cannot be negative").optional(),
    cancellationPolicyMessage: z3.string().optional(),
    defaultDailyBookingLimit: z3.number().positive("Daily booking limit must be positive").optional(),
    minimumBookingWindowHours: z3.number().int().min(0, "Minimum booking window cannot be negative").max(168, "Minimum booking window cannot exceed 168 hours").optional(),
    logoUrl: z3.string().optional(),
    brandImageUrl: z3.string().optional(),
    timezone: z3.string().optional(),
    kitchenLicenseUrl: z3.string().optional(),
    kitchenLicenseStatus: z3.enum(["pending", "approved", "rejected"]).optional(),
    kitchenLicenseExpiry: z3.string().optional(),
    // Terms & Policies document URL
    kitchenTermsUrl: z3.string().optional(),
    // Contact fields
    contactEmail: z3.string().email("Invalid contact email format").optional().or(z3.literal("")),
    contactPhone: z3.string().optional(),
    preferredContactMethod: z3.enum(["email", "phone", "both"]).optional(),
    description: z3.string().optional(),
    customOnboardingLink: z3.string().optional()
  });
  try {
    return locationSchema.parse(data);
  } catch (error) {
    if (error instanceof z3.ZodError) {
      throw new Error(`Validation failed: ${error.message}`);
    }
    throw error;
  }
}
async function validateKitchenInput(data) {
  const kitchenSchema = z3.object({
    locationId: z3.number().positive("Location ID must be positive"),
    name: z3.string().min(1, "Kitchen name is required"),
    description: z3.string().optional(),
    imageUrl: z3.string().optional(),
    // Allow relative paths for local dev (starts with /)
    galleryImages: z3.array(z3.string()).optional(),
    amenities: z3.array(z3.string()).optional(),
    isActive: z3.boolean().optional(),
    hourlyRate: z3.number().positive("Hourly rate must be positive").optional(),
    currency: z3.string().length(3).optional(),
    minimumBookingHours: z3.number().int("Minimum booking hours must be a whole number").min(0, "Minimum booking hours cannot be negative").max(24, "Minimum booking hours cannot exceed 24").optional(),
    pricingModel: z3.enum(["hourly", "daily", "weekly", "monthly-flat", "per-cubic-foot"]).optional()
  });
  try {
    return kitchenSchema.parse(data);
  } catch (error) {
    if (error instanceof z3.ZodError) {
      throw new Error(`Validation failed: ${error.message}`);
    }
    throw error;
  }
}
var init_input_validator = __esm({
  "server/shared/validators/input-validator.ts"() {
    "use strict";
  }
});

// server/chat-service.ts
var chat_service_exports = {};
__export(chat_service_exports, {
  deleteConversation: () => deleteConversation,
  getUnreadCounts: () => getUnreadCounts,
  initializeConversation: () => initializeConversation,
  notifyTierTransition: () => notifyTierTransition,
  sendSystemNotification: () => sendSystemNotification
});
import { getFirestore, FieldValue } from "firebase-admin/firestore";
import { eq as eq13 } from "drizzle-orm";
async function getAdminDb() {
  if (!adminDb) {
    const app2 = initializeFirebaseAdmin();
    if (!app2) {
      throw new Error("Failed to initialize Firebase Admin");
    }
    adminDb = getFirestore(app2);
    adminDb.settings({ ignoreUndefinedProperties: true });
  }
  return adminDb;
}
async function initializeConversation(applicationData) {
  try {
    const adminDb2 = await getAdminDb();
    const [location] = await db.select({ managerId: locations.managerId }).from(locations).where(eq13(locations.id, applicationData.locationId)).limit(1);
    if (!location || !location.managerId) {
      logger.error("Location not found or has no manager");
      return null;
    }
    const managerId = location.managerId;
    const existingQuery = await adminDb2.collection("conversations").where("applicationId", "==", applicationData.id).limit(1).get();
    if (!existingQuery.empty) {
      return existingQuery.docs[0].id;
    }
    const conversationRef = await adminDb2.collection("conversations").add({
      applicationId: applicationData.id,
      chefId: applicationData.chefId,
      managerId,
      locationId: applicationData.locationId,
      createdAt: FieldValue.serverTimestamp(),
      lastMessageAt: FieldValue.serverTimestamp(),
      unreadChefCount: 0,
      unreadManagerCount: 0
    });
    await db.update(chefKitchenApplications).set({ chat_conversation_id: conversationRef.id }).where(eq13(chefKitchenApplications.id, applicationData.id));
    return conversationRef.id;
  } catch (error) {
    logger.error("Error initializing conversation:", error);
    return null;
  }
}
async function sendSystemNotification(conversationId, eventType, data) {
  try {
    const adminDb2 = await getAdminDb();
    let content = "";
    switch (eventType) {
      case "TIER1_APPROVED":
        content = `\u2705 Step 1 Approved: Your food handler certificate has been verified. You can now proceed to Step 2 - Kitchen Coordination.`;
        break;
      case "TIER1_REJECTED":
        content = `\u274C Step 1 Rejected: ${data?.reason || "Your application did not meet the requirements."}`;
        break;
      case "TIER2_COMPLETE":
        content = `\u2705 Step 2 Complete: All kitchen coordination requirements have been met. Your application is now fully approved.`;
        break;
      case "TIER3_SUBMITTED":
        content = `\u{1F4CB} Step 3 Submitted: Your government application has been submitted. We'll notify you once it's approved.`;
        break;
      case "TIER4_APPROVED":
        content = `\u{1F389} Step 4 Approved: Congratulations! Your license has been entered and you're fully approved to use the kitchen.`;
        break;
      case "DOCUMENT_UPLOADED":
        content = `\u{1F4C4} Document Uploaded: ${data?.fileName || "A document"} has been uploaded for review.`;
        break;
      case "DOCUMENT_VERIFIED":
        content = `\u2705 Document Verified: ${data?.documentName || "Your document"} has been verified.`;
        break;
      case "STATUS_CHANGED":
        content = `\u{1F4CA} Status Changed: Application status updated to ${data?.status || "new status"}.`;
        break;
      default:
        content = data?.message || "System notification";
    }
    const recentMessages = await adminDb2.collection("conversations").doc(conversationId).collection("messages").where("type", "==", "system").where("content", "==", content).get();
    if (!recentMessages.empty) {
      const now = (/* @__PURE__ */ new Date()).getTime();
      const isDuplicate = recentMessages.docs.some((doc) => {
        const msg = doc.data();
        const createdAt = msg.createdAt?.toDate?.() || (msg.createdAt instanceof Date ? msg.createdAt : null);
        return createdAt && now - createdAt.getTime() < 1e4;
      });
      if (isDuplicate) {
        logger.info(`[CHAT] Skipping duplicate system message: "${content.substring(0, 30)}..."`);
        return;
      }
    }
    await adminDb2.collection("conversations").doc(conversationId).collection("messages").add({
      senderId: 0,
      senderRole: "system",
      content,
      type: "system",
      createdAt: FieldValue.serverTimestamp(),
      readAt: null
    });
    await adminDb2.collection("conversations").doc(conversationId).update({
      lastMessageAt: FieldValue.serverTimestamp()
    });
  } catch (error) {
    logger.error("Error sending system notification:", error);
  }
}
async function getUnreadCounts(userId, role) {
  try {
    const adminDb2 = await getAdminDb();
    const field = role === "chef" ? "chefId" : "managerId";
    const unreadField = role === "chef" ? "unreadChefCount" : "unreadManagerCount";
    const { AggregateField } = await import("firebase-admin/firestore");
    const snapshot = await adminDb2.collection("conversations").where(field, "==", userId).aggregate({
      totalUnread: AggregateField.sum(unreadField)
    }).get();
    return snapshot.data().totalUnread || 0;
  } catch (error) {
    logger.error("Error getting unread counts:", error);
    return 0;
  }
}
async function deleteConversation(conversationId) {
  try {
    const adminDb2 = await getAdminDb();
    const messagesRef = adminDb2.collection("conversations").doc(conversationId).collection("messages");
    const messagesSnapshot = await messagesRef.get();
    const batchSize = 10;
    for (let i = 0; i < messagesSnapshot.docs.length; i += batchSize) {
      const batch = adminDb2.batch();
      const batchDocs = messagesSnapshot.docs.slice(i, i + batchSize);
      for (const doc of batchDocs) {
        batch.delete(doc.ref);
      }
      await batch.commit();
    }
    await adminDb2.collection("conversations").doc(conversationId).delete();
    logger.info(`Successfully deleted conversation ${conversationId} and all its messages`);
  } catch (error) {
    logger.error("Error deleting conversation:", error);
    throw error;
  }
}
async function notifyTierTransition(applicationId, fromTier, toTier, reason) {
  try {
    const [application] = await db.select().from(chefKitchenApplications).where(eq13(chefKitchenApplications.id, applicationId)).limit(1);
    if (!application) {
      logger.error("Application not found for tier transition notification");
      return;
    }
    let conversationId = application.chat_conversation_id;
    if (!conversationId) {
      conversationId = await initializeConversation({
        id: applicationId,
        chefId: application.chefId,
        locationId: application.locationId
      });
      if (!conversationId) {
        logger.error("Failed to initialize conversation for tier transition");
        return;
      }
    }
    let eventType = "";
    if (toTier === 2 && fromTier === 1) {
      eventType = "TIER1_APPROVED";
    } else if (toTier === 3 && fromTier === 2) {
      eventType = "TIER2_COMPLETE";
    } else if (toTier === 4) {
      eventType = "TIER4_APPROVED";
    }
    if (eventType && conversationId) {
      await sendSystemNotification(conversationId, eventType, { reason });
    }
  } catch (error) {
    logger.error("Error notifying tier transition:", error);
  }
}
var adminDb;
var init_chat_service = __esm({
  "server/chat-service.ts"() {
    "use strict";
    init_logger();
    init_firebase_setup();
    init_db();
    init_schema();
    adminDb = null;
  }
});

// server/domains/locations/location.service.ts
var location_service_exports = {};
__export(location_service_exports, {
  LocationService: () => LocationService,
  locationService: () => locationService
});
import { eq as eq14 } from "drizzle-orm";
var LocationService, locationService;
var init_location_service = __esm({
  "server/domains/locations/location.service.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_schema();
    init_location_repository();
    init_domain_error();
    init_input_validator();
    LocationService = class {
      constructor(locationRepo) {
        this.locationRepo = locationRepo;
      }
      /**
       * Create new location with validation
       */
      async createLocation(dto) {
        try {
          const validatedData = await validateLocationInput(dto);
          if (validatedData.managerId) {
            const locationCount = await this.locationRepo.countByManagerId(validatedData.managerId);
            if (locationCount >= 10) {
              throw new DomainError(
                LocationErrorCodes.NO_MANAGER_ASSIGNED,
                "Manager cannot have more than 10 locations",
                400
              );
            }
          }
          const location = await this.locationRepo.create(validatedData);
          return location;
        } catch (error) {
          if (error instanceof DomainError) {
            throw error;
          }
          logger.error("[LocationService] Error creating location:", error);
          throw new DomainError(
            LocationErrorCodes.INVALID_ADDRESS,
            "Failed to create location",
            500
          );
        }
      }
      /**
       * Update location with validation
       */
      async updateLocation(dto) {
        try {
          const existingLocation = await this.locationRepo.findById(dto.id);
          if (!existingLocation) {
            throw new DomainError(
              LocationErrorCodes.LOCATION_NOT_FOUND,
              "Location not found",
              404
            );
          }
          if (dto.managerId && dto.managerId !== existingLocation.managerId) {
            throw new DomainError(
              LocationErrorCodes.NO_MANAGER_ASSIGNED,
              "Cannot change location manager",
              400
            );
          }
          const updated = await this.locationRepo.update(dto.id, dto);
          if (!updated) {
            throw new DomainError(
              LocationErrorCodes.LOCATION_NOT_FOUND,
              "Failed to update location",
              404
            );
          }
          return updated;
        } catch (error) {
          if (error instanceof DomainError) {
            throw error;
          }
          logger.error("[LocationService] Error updating location:", error);
          throw new DomainError(
            LocationErrorCodes.LOCATION_NOT_FOUND,
            "Failed to update location",
            500
          );
        }
      }
      /**
       * Verify kitchen license
       */
      async verifyKitchenLicense(dto) {
        try {
          const existingLocation = await this.locationRepo.findById(dto.locationId);
          if (!existingLocation) {
            throw new DomainError(
              LocationErrorCodes.LOCATION_NOT_FOUND,
              "Location not found",
              404
            );
          }
          if (dto.kitchenLicenseStatus === "approved" && !dto.kitchenLicenseExpiry) {
            throw new DomainError(
              LocationErrorCodes.INVALID_ADDRESS,
              "License expiry date is required when approving",
              400
            );
          }
          if (dto.kitchenLicenseStatus === "approved" && !dto.kitchenLicenseApprovedBy) {
            throw new DomainError(
              LocationErrorCodes.NO_MANAGER_ASSIGNED,
              "Approved by user ID is required when approving",
              400
            );
          }
          const updated = await this.locationRepo.verifyKitchenLicense(dto);
          if (!updated) {
            throw new DomainError(
              LocationErrorCodes.LOCATION_NOT_FOUND,
              "Failed to verify kitchen license",
              404
            );
          }
          return updated;
        } catch (error) {
          logger.error("[LocationService] Error verifying kitchen license:", error);
          throw new DomainError(
            LocationErrorCodes.LOCATION_NOT_FOUND,
            "Failed to verify kitchen license",
            500
          );
        }
      }
      /**
       * Update kitchen license URL
       */
      async updateKitchenLicenseUrl(locationId, licenseUrl) {
        try {
          const existingLocation = await this.locationRepo.findById(locationId);
          if (!existingLocation) {
            throw new DomainError(
              LocationErrorCodes.LOCATION_NOT_FOUND,
              "Location not found",
              404
            );
          }
          const updated = await this.locationRepo.updateKitchenLicenseUrl(locationId, licenseUrl);
          if (!updated) {
            throw new DomainError(
              LocationErrorCodes.LOCATION_NOT_FOUND,
              "Failed to update kitchen license URL",
              404
            );
          }
          return updated;
        } catch (error) {
          logger.error("[LocationService] Error updating kitchen license URL:", error);
          throw new DomainError(
            LocationErrorCodes.LOCATION_NOT_FOUND,
            "Failed to update kitchen license URL",
            500
          );
        }
      }
      /**
       * Get location by ID
       */
      async getLocationById(id) {
        try {
          const location = await this.locationRepo.findById(id);
          if (!location) {
            throw new DomainError(
              LocationErrorCodes.LOCATION_NOT_FOUND,
              "Location not found",
              404
            );
          }
          return location;
        } catch (error) {
          if (error instanceof DomainError) {
            throw error;
          }
          logger.error("[LocationService] Error getting location by ID:", error);
          throw new DomainError(
            LocationErrorCodes.LOCATION_NOT_FOUND,
            "Failed to get location",
            500
          );
        }
      }
      /**
       * Get locations by manager ID
       */
      async getLocationsByManagerId(managerId) {
        try {
          return await this.locationRepo.findByManagerId(managerId);
        } catch (error) {
          logger.error("[LocationService] Error getting locations by manager:", error);
          throw new DomainError(
            LocationErrorCodes.NO_MANAGER_ASSIGNED,
            "Failed to get locations",
            500
          );
        }
      }
      /**
       * Get all locations
       */
      async getAllLocations() {
        try {
          return await this.locationRepo.findAll();
        } catch (error) {
          logger.error("[LocationService] Error getting all locations:", error);
          throw new DomainError(
            LocationErrorCodes.LOCATION_NOT_FOUND,
            "Failed to get locations",
            500
          );
        }
      }
      /**
       * Get location requirements with defaults if not configured
       */
      async getLocationRequirementsWithDefaults(locationId) {
        try {
          const requirements = await this.locationRepo.findRequirementsByLocationId(locationId);
          if (requirements) {
            return {
              ...requirements,
              customFields: Array.isArray(requirements.customFields) ? requirements.customFields : [],
              tier1_custom_fields: Array.isArray(requirements.tier1_custom_fields) ? requirements.tier1_custom_fields : [],
              tier2_custom_fields: Array.isArray(requirements.tier2_custom_fields) ? requirements.tier2_custom_fields : []
            };
          }
          return {
            id: -1,
            locationId,
            requireFirstName: true,
            requireLastName: true,
            requireEmail: true,
            requirePhone: true,
            requireBusinessName: true,
            requireBusinessType: true,
            requireExperience: true,
            requireBusinessDescription: false,
            requireFoodHandlerCert: true,
            requireFoodHandlerExpiry: true,
            requireUsageFrequency: true,
            requireSessionDuration: true,
            requireTermsAgree: true,
            requireAccuracyAgree: true,
            customFields: [],
            tier1_years_experience_required: false,
            tier1_years_experience_minimum: 0,
            tier1_custom_fields: [],
            tier2_food_establishment_cert_required: false,
            tier2_food_establishment_expiry_required: false,
            tier2_insurance_document_required: false,
            tier2_insurance_minimum_amount: 0,
            tier2_kitchen_experience_required: false,
            tier2_allergen_plan_required: false,
            tier2_supplier_list_required: false,
            tier2_quality_control_required: false,
            tier2_traceability_system_required: false,
            tier2_custom_fields: [],
            floor_plans_url: "",
            ventilation_specs: "",
            ventilation_specs_url: "",
            equipment_list: [],
            materials_description: "",
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          };
        } catch (error) {
          logger.error(`[LocationService] Error getting requirements for location ${locationId}:`, error);
          throw new DomainError(
            LocationErrorCodes.LOCATION_NOT_FOUND,
            "Failed to get location requirements",
            500
          );
        }
      }
      /**
       * Upsert location requirements
       */
      async upsertLocationRequirements(locationId, dto) {
        try {
          await this.getLocationById(locationId);
          const requirements = await this.locationRepo.upsertRequirements(locationId, dto);
          return requirements;
        } catch (error) {
          if (error instanceof DomainError) throw error;
          logger.error(`[LocationService] Error upserting requirements for location ${locationId}:`, error);
          throw new DomainError(
            LocationErrorCodes.LOCATION_NOT_FOUND,
            "Failed to update location requirements",
            500
          );
        }
      }
      async deleteLocation(id) {
        try {
          const locationApps = await db.select({
            id: chefKitchenApplications.id,
            conversationId: chefKitchenApplications.chat_conversation_id
          }).from(chefKitchenApplications).where(eq14(chefKitchenApplications.locationId, id));
          if (locationApps.length > 0) {
            const { deleteConversation: deleteConversation2 } = await Promise.resolve().then(() => (init_chat_service(), chat_service_exports));
            const cleanupPromises = locationApps.filter((app2) => app2.conversationId).map(
              (app2) => deleteConversation2(app2.conversationId).catch((err) => logger.error(`Failed to delete conversation ${app2.conversationId}:`, err))
            );
            await Promise.all(cleanupPromises);
            logger.info(`[LocationService] Cleaned up ${cleanupPromises.length} conversations for deleted location ${id}`);
          }
          await this.locationRepo.delete(id);
        } catch (error) {
          logger.error("[LocationService] Error deleting location:", error);
          throw error;
        }
      }
    };
    locationService = new LocationService(new LocationRepository());
  }
});

// server/domains/kitchens/kitchen.repository.ts
import { eq as eq15, and as and9, desc as desc8, gte, lte, sql as sql8 } from "drizzle-orm";
var KitchenRepository;
var init_kitchen_repository = __esm({
  "server/domains/kitchens/kitchen.repository.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_schema();
    init_domain_error();
    KitchenRepository = class {
      /**
       * Helper to map DB result to DTO
       */
      mapToDTO(row) {
        return {
          ...row,
          description: row.description || void 0,
          hourlyRate: row.hourlyRate ? parseFloat(row.hourlyRate) : null,
          galleryImages: row.galleryImages || [],
          // Ensure type safety for JSONB
          amenities: row.amenities || [],
          // Ensure type safety for JSONB
          // Cast enum to specific string union type if needed, or trust strict match
          pricingModel: row.pricingModel,
          taxRatePercent: row.taxRatePercent ? parseFloat(row.taxRatePercent) : null
        };
      }
      /**
       * Find kitchen by ID
       */
      async findById(id) {
        try {
          const [kitchen] = await db.select().from(kitchens).where(eq15(kitchens.id, id)).limit(1);
          return kitchen ? this.mapToDTO(kitchen) : null;
        } catch (error) {
          logger.error(`[KitchenRepository] Error finding kitchen by ID ${id}:`, error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to find kitchen",
            500
          );
        }
      }
      /**
       * Find kitchens by location ID
       */
      async findByLocationId(locationId) {
        try {
          const results = await db.select().from(kitchens).where(eq15(kitchens.locationId, locationId)).orderBy(desc8(kitchens.createdAt));
          return results.map((k) => this.mapToDTO(k));
        } catch (error) {
          logger.error(`[KitchenRepository] Error finding kitchens by location ${locationId}:`, error);
          throw new DomainError(
            KitchenErrorCodes.LOCATION_NOT_FOUND,
            "Failed to find kitchens",
            500
          );
        }
      }
      /**
       * Find active kitchens by location ID
       */
      async findActiveByLocationId(locationId) {
        try {
          const results = await db.select().from(kitchens).where(
            and9(
              eq15(kitchens.locationId, locationId),
              eq15(kitchens.isActive, true)
            )
          ).orderBy(desc8(kitchens.createdAt));
          return results.map((k) => this.mapToDTO(k));
        } catch (error) {
          logger.error(`[KitchenRepository] Error finding active kitchens by location ${locationId}:`, error);
          throw new DomainError(
            KitchenErrorCodes.LOCATION_NOT_FOUND,
            "Failed to find kitchens",
            500
          );
        }
      }
      /**
       * Find all active kitchens
       */
      async findAllActive() {
        try {
          const results = await db.select().from(kitchens).where(eq15(kitchens.isActive, true)).orderBy(desc8(kitchens.createdAt));
          return results.map((k) => this.mapToDTO(k));
        } catch (error) {
          logger.error("[KitchenRepository] Error finding all active kitchens:", error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to find kitchens",
            500
          );
        }
      }
      /**
       * Create new kitchen
       */
      async create(dto) {
        try {
          const [kitchen] = await db.insert(kitchens).values({
            locationId: dto.locationId,
            name: dto.name,
            description: dto.description || null,
            imageUrl: dto.imageUrl || null,
            galleryImages: dto.galleryImages || [],
            amenities: dto.amenities || [],
            isActive: dto.isActive !== void 0 ? dto.isActive : true,
            hourlyRate: dto.hourlyRate ? dto.hourlyRate.toString() : null,
            // Convert number to string for numeric column
            currency: dto.currency || "CAD",
            minimumBookingHours: dto.minimumBookingHours || 1,
            pricingModel: dto.pricingModel || "hourly",
            taxRatePercent: dto.taxRatePercent ? dto.taxRatePercent.toString() : null
          }).returning();
          return this.mapToDTO(kitchen);
        } catch (error) {
          logger.error("[KitchenRepository] Error creating kitchen:", error);
          throw new DomainError(
            KitchenErrorCodes.INVALID_PRICING,
            "Failed to create kitchen",
            500
          );
        }
      }
      /**
       * Update existing kitchen
       */
      async update(id, dto) {
        try {
          const [kitchen] = await db.update(kitchens).set({
            locationId: dto.locationId,
            name: dto.name,
            description: dto.description,
            imageUrl: dto.imageUrl,
            galleryImages: dto.galleryImages,
            amenities: dto.amenities,
            isActive: dto.isActive,
            hourlyRate: dto.hourlyRate ? dto.hourlyRate.toString() : void 0,
            // Convert number to string
            currency: dto.currency,
            minimumBookingHours: dto.minimumBookingHours,
            pricingModel: dto.pricingModel,
            taxRatePercent: dto.taxRatePercent ? dto.taxRatePercent.toString() : dto.taxRatePercent === null ? null : void 0
          }).where(eq15(kitchens.id, id)).returning();
          return kitchen ? this.mapToDTO(kitchen) : null;
        } catch (error) {
          logger.error(`[KitchenRepository] Error updating kitchen ${id}:`, error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to update kitchen",
            500
          );
        }
      }
      /**
       * Activate kitchen
       */
      async activate(id) {
        try {
          const [kitchen] = await db.update(kitchens).set({ isActive: true }).where(eq15(kitchens.id, id)).returning();
          return kitchen ? this.mapToDTO(kitchen) : null;
        } catch (error) {
          logger.error(`[KitchenRepository] Error activating kitchen ${id}:`, error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to activate kitchen",
            500
          );
        }
      }
      /**
       * Deactivate kitchen
       */
      async deactivate(id) {
        try {
          const [kitchen] = await db.update(kitchens).set({ isActive: false }).where(eq15(kitchens.id, id)).returning();
          return kitchen ? this.mapToDTO(kitchen) : null;
        } catch (error) {
          logger.error(`[KitchenRepository] Error deactivating kitchen ${id}:`, error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to deactivate kitchen",
            500
          );
        }
      }
      /**
       * Check if kitchen name exists for location
       */
      async nameExistsForLocation(name, locationId, excludeId) {
        try {
          const result = await db.select({ id: kitchens.id }).from(kitchens).where(
            and9(
              eq15(kitchens.locationId, locationId),
              eq15(kitchens.name, name),
              excludeId ? eq15(kitchens.id, excludeId) : void 0
            )
          ).limit(1);
          return result.length > 0;
        } catch (error) {
          logger.error(`[KitchenRepository] Error checking name existence for location ${locationId}:`, error);
          return false;
        }
      }
      /**
       * Update kitchen image
       */
      async updateImage(id, imageUrl) {
        try {
          const [kitchen] = await db.update(kitchens).set({ imageUrl }).where(eq15(kitchens.id, id)).returning();
          return kitchen ? this.mapToDTO(kitchen) : null;
        } catch (error) {
          logger.error(`[KitchenRepository] Error updating image for kitchen ${id}:`, error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to update kitchen image",
            500
          );
        }
      }
      /**
       * Update kitchen gallery
       */
      async updateGallery(id, galleryImages) {
        try {
          const [kitchen] = await db.update(kitchens).set({ galleryImages }).where(eq15(kitchens.id, id)).returning();
          return kitchen ? this.mapToDTO(kitchen) : null;
        } catch (error) {
          logger.error(`[KitchenRepository] Error updating gallery for kitchen ${id}:`, error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to update kitchen gallery",
            500
          );
        }
      }
      /**
       * Find all kitchens
       */
      async findAll() {
        try {
          const results = await db.select().from(kitchens).orderBy(desc8(kitchens.createdAt));
          return results.map((k) => this.mapToDTO(k));
        } catch (error) {
          logger.error("[KitchenRepository] Error finding all kitchens:", error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to find kitchens",
            500
          );
        }
      }
      /**
       * Find all kitchens with location details
       */
      async findAllWithLocation() {
        try {
          const results = await db.select({
            kitchen: kitchens,
            location: locations
          }).from(kitchens).leftJoin(locations, eq15(kitchens.locationId, locations.id)).orderBy(desc8(kitchens.createdAt));
          return results.map(({ kitchen, location }) => ({
            ...this.mapToDTO(kitchen),
            location: location ? {
              ...location,
              logoUrl: location.logoUrl || null,
              brandImageUrl: location.brandImageUrl || null,
              kitchenLicenseUrl: location.kitchenLicenseUrl || null,
              kitchenLicenseFeedback: location.kitchenLicenseFeedback || null,
              kitchenLicenseExpiry: location.kitchenLicenseExpiry || null,
              notificationEmail: location.notificationEmail || null,
              notificationPhone: location.notificationPhone || null,
              kitchenLicenseApprovedBy: location.kitchenLicenseApprovedBy || null
            } : void 0
          }));
        } catch (error) {
          logger.error("[KitchenRepository] Error finding kitchens with location:", error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to find kitchens with location",
            500
          );
        }
      }
      /**
       * Delete kitchen
       */
      async delete(id) {
        try {
          await db.delete(kitchens).where(eq15(kitchens.id, id));
        } catch (error) {
          logger.error(`[KitchenRepository] Error deleting kitchen ${id}:`, error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to delete kitchen",
            500
          );
        }
      }
      // ==========================================
      // Date Overrides
      // ==========================================
      mapOverrideToDTO(row) {
        return {
          ...row,
          startTime: row.startTime,
          endTime: row.endTime,
          reason: row.reason || null
        };
      }
      async findOverrides(kitchenId, startDate, endDate) {
        try {
          const results = await db.select().from(kitchenDateOverrides).where(
            and9(
              eq15(kitchenDateOverrides.kitchenId, kitchenId),
              gte(kitchenDateOverrides.specificDate, startDate),
              lte(kitchenDateOverrides.specificDate, endDate)
            )
          ).orderBy(kitchenDateOverrides.specificDate);
          return results.map((o) => this.mapOverrideToDTO(o));
        } catch (error) {
          logger.error(`[KitchenRepository] Error finding overrides for kitchen ${kitchenId}:`, error);
          throw new DomainError(KitchenErrorCodes.KITCHEN_NOT_FOUND, "Failed to find overrides", 500);
        }
      }
      async findOverrideById(id) {
        try {
          const [override] = await db.select().from(kitchenDateOverrides).where(eq15(kitchenDateOverrides.id, id)).limit(1);
          return override ? this.mapOverrideToDTO(override) : null;
        } catch (error) {
          logger.error(`[KitchenRepository] Error finding override ${id}:`, error);
          throw new DomainError(KitchenErrorCodes.KITCHEN_NOT_FOUND, "Failed to find override", 500);
        }
      }
      async createOverride(dto) {
        try {
          const [override] = await db.insert(kitchenDateOverrides).values({
            kitchenId: dto.kitchenId,
            specificDate: new Date(dto.specificDate),
            startTime: dto.startTime,
            endTime: dto.endTime,
            isAvailable: dto.isAvailable !== void 0 ? dto.isAvailable : false,
            reason: dto.reason
          }).returning();
          return this.mapOverrideToDTO(override);
        } catch (error) {
          logger.error(`[KitchenRepository] Error creating override:`, error);
          throw new DomainError(KitchenErrorCodes.KITCHEN_NOT_FOUND, "Failed to create override", 500);
        }
      }
      async updateOverride(id, dto) {
        try {
          const [override] = await db.update(kitchenDateOverrides).set({
            startTime: dto.startTime,
            endTime: dto.endTime,
            isAvailable: dto.isAvailable,
            reason: dto.reason,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq15(kitchenDateOverrides.id, id)).returning();
          return override ? this.mapOverrideToDTO(override) : null;
        } catch (error) {
          logger.error(`[KitchenRepository] Error updating override ${id}:`, error);
          throw new DomainError(KitchenErrorCodes.KITCHEN_NOT_FOUND, "Failed to update override", 500);
        }
      }
      async deleteOverride(id) {
        try {
          await db.delete(kitchenDateOverrides).where(eq15(kitchenDateOverrides.id, id));
        } catch (error) {
          logger.error(`[KitchenRepository] Error deleting override ${id}:`, error);
          throw new DomainError(KitchenErrorCodes.KITCHEN_NOT_FOUND, "Failed to delete override", 500);
        }
      }
      // ==========================================
      // Availability
      // ==========================================
      async findAvailability(kitchenId) {
        try {
          return await db.select().from(kitchenAvailability).where(eq15(kitchenAvailability.kitchenId, kitchenId));
        } catch (error) {
          logger.error(`[KitchenRepository] Error finding availability for kitchen ${kitchenId}:`, error);
          throw new DomainError(KitchenErrorCodes.KITCHEN_NOT_FOUND, "Failed to find availability", 500);
        }
      }
      async findOverrideForDate(kitchenId, date2) {
        try {
          const dateStr = date2.toISOString().split("T")[0];
          const [override] = await db.select().from(kitchenDateOverrides).where(
            and9(
              eq15(kitchenDateOverrides.kitchenId, kitchenId),
              sql8`DATE(${kitchenDateOverrides.specificDate}) = ${dateStr}::date`
            )
          ).limit(1);
          return override ? this.mapOverrideToDTO(override) : null;
        } catch (error) {
          logger.error(`[KitchenRepository] Error finding override for date:`, error);
          return null;
        }
      }
    };
  }
});

// server/domains/kitchens/kitchen.service.ts
var KitchenService, kitchenService;
var init_kitchen_service = __esm({
  "server/domains/kitchens/kitchen.service.ts"() {
    "use strict";
    init_logger();
    init_kitchen_repository();
    init_domain_error();
    init_input_validator();
    KitchenService = class {
      constructor(kitchenRepo) {
        this.kitchenRepo = kitchenRepo;
      }
      /**
       * Create new kitchen with validation
       */
      async createKitchen(dto) {
        try {
          const validatedData = await validateKitchenInput(dto);
          const nameExists = await this.kitchenRepo.nameExistsForLocation(validatedData.name, validatedData.locationId);
          if (nameExists) {
            throw new DomainError(
              KitchenErrorCodes.INVALID_PRICING,
              "Kitchen with this name already exists for this location",
              409
            );
          }
          const kitchen = await this.kitchenRepo.create(validatedData);
          return kitchen;
        } catch (error) {
          if (error instanceof DomainError) {
            throw error;
          }
          logger.error("[KitchenService] Error creating kitchen:", error);
          throw new DomainError(
            KitchenErrorCodes.INVALID_PRICING,
            `Failed to create kitchen: ${error.message || "Unknown error"}`,
            500,
            { originalError: error }
          );
        }
      }
      /**
       * Update kitchen with validation
       */
      async updateKitchen(dto) {
        try {
          const existingKitchen = await this.kitchenRepo.findById(dto.id);
          if (!existingKitchen) {
            throw new DomainError(
              KitchenErrorCodes.KITCHEN_NOT_FOUND,
              "Kitchen not found",
              404
            );
          }
          if (dto.locationId && dto.locationId !== existingKitchen.locationId) {
            throw new DomainError(
              KitchenErrorCodes.LOCATION_NOT_FOUND,
              "Cannot change kitchen location",
              400
            );
          }
          if (dto.name && dto.locationId) {
            const nameExists = await this.kitchenRepo.nameExistsForLocation(dto.name, dto.locationId, dto.id);
            if (nameExists) {
              throw new DomainError(
                KitchenErrorCodes.INVALID_PRICING,
                "Kitchen with this name already exists for this location",
                409
              );
            }
          }
          const updated = await this.kitchenRepo.update(dto.id, dto);
          if (!updated) {
            throw new DomainError(
              KitchenErrorCodes.KITCHEN_NOT_FOUND,
              "Failed to update kitchen",
              404
            );
          }
          return updated;
        } catch (error) {
          if (error instanceof DomainError) {
            throw error;
          }
          logger.error("[KitchenService] Error updating kitchen:", error);
          throw new DomainError(
            KitchenErrorCodes.INVALID_PRICING,
            "Failed to update kitchen",
            500
          );
        }
      }
      /**
       * Activate kitchen
       */
      async activateKitchen(id) {
        try {
          const existingKitchen = await this.kitchenRepo.findById(id);
          if (!existingKitchen) {
            throw new DomainError(
              KitchenErrorCodes.KITCHEN_NOT_FOUND,
              "Kitchen not found",
              404
            );
          }
          if (existingKitchen.isActive) {
            throw new DomainError(
              KitchenErrorCodes.INVALID_PRICING,
              "Kitchen is already active",
              400
            );
          }
          const updated = await this.kitchenRepo.activate(id);
          if (!updated) {
            throw new DomainError(
              KitchenErrorCodes.KITCHEN_NOT_FOUND,
              "Failed to activate kitchen",
              404
            );
          }
          return updated;
        } catch (error) {
          if (error instanceof DomainError) {
            throw error;
          }
          logger.error("[KitchenService] Error activating kitchen:", error);
          throw new DomainError(
            KitchenErrorCodes.INVALID_PRICING,
            "Failed to activate kitchen",
            500
          );
        }
      }
      /**
       * Deactivate kitchen
       */
      async deactivateKitchen(id) {
        try {
          const existingKitchen = await this.kitchenRepo.findById(id);
          if (!existingKitchen) {
            throw new DomainError(
              KitchenErrorCodes.KITCHEN_NOT_FOUND,
              "Kitchen not found",
              404
            );
          }
          if (!existingKitchen.isActive) {
            throw new DomainError(
              KitchenErrorCodes.INVALID_PRICING,
              "Kitchen is already inactive",
              400
            );
          }
          const updated = await this.kitchenRepo.deactivate(id);
          if (!updated) {
            throw new DomainError(
              KitchenErrorCodes.KITCHEN_NOT_FOUND,
              "Failed to deactivate kitchen",
              404
            );
          }
          return updated;
        } catch (error) {
          if (error instanceof DomainError) {
            throw error;
          }
          logger.error("[KitchenService] Error deactivating kitchen:", error);
          throw new DomainError(
            KitchenErrorCodes.INVALID_PRICING,
            "Failed to deactivate kitchen",
            500
          );
        }
      }
      /**
       * Update kitchen image
       */
      async updateKitchenImage(id, imageUrl) {
        try {
          const existingKitchen = await this.kitchenRepo.findById(id);
          if (!existingKitchen) {
            throw new DomainError(
              KitchenErrorCodes.KITCHEN_NOT_FOUND,
              "Kitchen not found",
              404
            );
          }
          const updated = await this.kitchenRepo.updateImage(id, imageUrl);
          if (!updated) {
            throw new DomainError(
              KitchenErrorCodes.KITCHEN_NOT_FOUND,
              "Failed to update kitchen image",
              404
            );
          }
          return updated;
        } catch (error) {
          if (error instanceof DomainError) {
            throw error;
          }
          logger.error("[KitchenService] Error updating kitchen image:", error);
          throw new DomainError(
            KitchenErrorCodes.INVALID_PRICING,
            "Failed to update kitchen image",
            500
          );
        }
      }
      /**
       * Update kitchen gallery
       */
      async updateKitchenGallery(id, galleryImages) {
        try {
          const existingKitchen = await this.kitchenRepo.findById(id);
          if (!existingKitchen) {
            throw new DomainError(
              KitchenErrorCodes.KITCHEN_NOT_FOUND,
              "Kitchen not found",
              404
            );
          }
          const updated = await this.kitchenRepo.updateGallery(id, galleryImages);
          if (!updated) {
            throw new DomainError(
              KitchenErrorCodes.KITCHEN_NOT_FOUND,
              "Failed to update kitchen gallery",
              404
            );
          }
          return updated;
        } catch (error) {
          if (error instanceof DomainError) {
            throw error;
          }
          logger.error("[KitchenService] Error updating kitchen gallery:", error);
          throw new DomainError(
            KitchenErrorCodes.INVALID_PRICING,
            "Failed to update kitchen gallery",
            500
          );
        }
      }
      /**
       * Get kitchen by ID
       */
      async getKitchenById(id) {
        try {
          const kitchen = await this.kitchenRepo.findById(id);
          if (!kitchen) {
            throw new DomainError(
              KitchenErrorCodes.KITCHEN_NOT_FOUND,
              "Kitchen not found",
              404
            );
          }
          return kitchen;
        } catch (error) {
          if (error instanceof DomainError) {
            throw error;
          }
          logger.error("[KitchenService] Error getting kitchen by ID:", error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to get kitchen",
            500
          );
        }
      }
      /**
       * Get kitchens by location ID
       */
      async getKitchensByLocationId(locationId, activeOnly) {
        try {
          if (activeOnly) {
            return await this.kitchenRepo.findActiveByLocationId(locationId);
          } else {
            return await this.kitchenRepo.findByLocationId(locationId);
          }
        } catch (error) {
          logger.error("[KitchenService] Error getting kitchens by location:", error);
          throw new DomainError(
            KitchenErrorCodes.LOCATION_NOT_FOUND,
            "Failed to get kitchens",
            500
          );
        }
      }
      /**
       * Get all active kitchens
       */
      async getAllActiveKitchens() {
        try {
          return await this.kitchenRepo.findAllActive();
        } catch (error) {
          logger.error("[KitchenService] Error getting all active kitchens:", error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to get kitchens",
            500
          );
        }
      }
      /**
       * Get all kitchens
       */
      async getAllKitchens() {
        try {
          return await this.kitchenRepo.findAll();
        } catch (error) {
          logger.error("[KitchenService] Error getting all kitchens:", error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to get kitchens",
            500
          );
        }
      }
      /**
       * Get all kitchens with location details
       */
      async getAllKitchensWithLocation() {
        try {
          return await this.kitchenRepo.findAllWithLocation();
        } catch (error) {
          logger.error("[KitchenService] Error getting all kitchens with location:", error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to get kitchens with location",
            500
          );
        }
      }
      /**
       * Delete kitchen
       */
      async deleteKitchen(id) {
        try {
          await this.getKitchenById(id);
          await this.kitchenRepo.delete(id);
        } catch (error) {
          if (error instanceof DomainError) {
            throw error;
          }
          logger.error("[KitchenService] Error deleting kitchen:", error);
          throw new DomainError(
            KitchenErrorCodes.KITCHEN_NOT_FOUND,
            "Failed to delete kitchen",
            500
          );
        }
      }
      // ==========================================
      // Date Overrides
      // ==========================================
      async getKitchenDateOverrides(kitchenId, start, end) {
        try {
          await this.getKitchenById(kitchenId);
          return await this.kitchenRepo.findOverrides(kitchenId, start, end);
        } catch (error) {
          if (error instanceof DomainError) throw error;
          logger.error("[KitchenService] Error getting overrides:", error);
          throw new DomainError(KitchenErrorCodes.KITCHEN_NOT_FOUND, "Failed to get overrides", 500);
        }
      }
      async createKitchenDateOverride(dto) {
        try {
          await this.getKitchenById(dto.kitchenId);
          return await this.kitchenRepo.createOverride(dto);
        } catch (error) {
          if (error instanceof DomainError) throw error;
          logger.error("[KitchenService] Error creating override:", error);
          throw new DomainError(KitchenErrorCodes.KITCHEN_NOT_FOUND, "Failed to create override", 500);
        }
      }
      async updateKitchenDateOverride(id, dto) {
        try {
          const existing = await this.kitchenRepo.findOverrideById(id);
          if (!existing) {
            throw new DomainError(KitchenErrorCodes.KITCHEN_NOT_FOUND, "Override not found", 404);
          }
          const updated = await this.kitchenRepo.updateOverride(id, dto);
          if (!updated) throw new DomainError(KitchenErrorCodes.KITCHEN_NOT_FOUND, "Failed to update override", 500);
          return updated;
        } catch (error) {
          if (error instanceof DomainError) throw error;
          logger.error("[KitchenService] Error updating override:", error);
          throw new DomainError(KitchenErrorCodes.KITCHEN_NOT_FOUND, "Failed to update override", 500);
        }
      }
      async deleteKitchenDateOverride(id) {
        try {
          await this.kitchenRepo.deleteOverride(id);
        } catch (error) {
          logger.error("[KitchenService] Error deleting override:", error);
          throw new DomainError(KitchenErrorCodes.KITCHEN_NOT_FOUND, "Failed to delete override", 500);
        }
      }
      // ==========================================
      // Availability Helpers
      // ==========================================
      async getKitchenAvailability(kitchenId) {
        try {
          return this.kitchenRepo.findAvailability(kitchenId);
        } catch (error) {
          logger.error("[KitchenService] Error getting availability:", error);
          throw new DomainError(KitchenErrorCodes.KITCHEN_NOT_FOUND, "Failed to get availability", 500);
        }
      }
      async getKitchenDateOverrideForDate(kitchenId, date2) {
        try {
          return this.kitchenRepo.findOverrideForDate(kitchenId, date2);
        } catch (error) {
          logger.error("[KitchenService] Error getting override for date:", error);
          throw new DomainError(KitchenErrorCodes.KITCHEN_NOT_FOUND, "Failed to get override", 500);
        }
      }
    };
    kitchenService = new KitchenService(new KitchenRepository());
  }
});

// server/domains/applications/tier-validation.ts
var tier_validation_exports = {};
__export(tier_validation_exports, {
  TierValidationService: () => TierValidationService,
  tierValidationService: () => tierValidationService
});
var TierValidationService, tierValidationService;
var init_tier_validation = __esm({
  "server/domains/applications/tier-validation.ts"() {
    "use strict";
    TierValidationService = class {
      /**
       * Validate if an application meets all requirements for a specific tier
       * This ensures enterprise-grade compliance with manager-set rules
       */
      validateTierRequirements(application, requirements, targetTier) {
        const missing = [];
        if (targetTier >= 1) {
          const tier1Fields = requirements.tier1_custom_fields || [];
          this.validateTier1CustomFields(application, tier1Fields, missing);
        }
        if (targetTier >= 2) {
          if (requirements.tier2_food_establishment_cert_required) {
            if (application.foodEstablishmentCertStatus !== "approved") {
              missing.push("Food Establishment Certificate must be approved");
            }
            if (requirements.tier2_food_establishment_expiry_required && !application.foodEstablishmentCertExpiry) {
              missing.push("Food Establishment Certificate expiry date is required");
            }
          }
          if (requirements.tier2_insurance_document_required) {
            const tierData = this.getTierData(application);
            const hasInsurance = tierData.tierFiles?.["tier2_insurance_document"] || tierData.insuranceUrl;
            if (!hasInsurance) {
              missing.push("Insurance Document is required");
            }
          }
          if (requirements.tier2_kitchen_experience_required) {
            const tierData = this.getTierData(application);
            if (!tierData.kitchen_experience_description) {
              missing.push("Kitchen Experience Description is required");
            }
          }
          const tier2Fields = requirements.tier2_custom_fields || [];
          this.validateTier2CustomFields(application, tier2Fields, missing);
        }
        return {
          valid: missing.length === 0,
          missingRequirements: missing
        };
      }
      /**
       * Extract tier_data from application with proper typing
       */
      getTierData(application) {
        return application.tier_data || {};
      }
      /**
       * Validate Tier 1 custom fields
       * Tier 1 fields are stored in `application.customFieldsData`
       */
      validateTier1CustomFields(application, fields, missing) {
        if (!fields || fields.length === 0) return;
        const customData = application.customFieldsData || {};
        const tierData = this.getTierData(application);
        for (const field of fields) {
          if (field.required) {
            const value = customData[field.id];
            const fileValue = tierData.tierFiles?.[field.id];
            if (!this.hasValidValue(value) && !fileValue) {
              missing.push(`Missing required field: ${field.label}`);
            }
          }
        }
      }
      /**
       * Validate Tier 2 custom fields
       * Tier 2 fields are stored in `application.tier_data.tier2_custom_fields_data`
       */
      validateTier2CustomFields(application, fields, missing) {
        if (!fields || fields.length === 0) return;
        const tierData = this.getTierData(application);
        const tier2CustomData = tierData.tier2_custom_fields_data || {};
        for (const field of fields) {
          if (field.required) {
            const value = tier2CustomData[field.id];
            const fileValue = tierData.tierFiles?.[field.id];
            if (!this.hasValidValue(value) && !fileValue) {
              missing.push(`Missing required field: ${field.label}`);
            }
          }
        }
      }
      /**
       * Check if a value is considered "filled" for validation purposes
       * Handles different field types: strings, numbers, booleans, arrays
       */
      hasValidValue(value) {
        if (value === void 0 || value === null) return false;
        if (typeof value === "string" && value.trim() === "") return false;
        if (Array.isArray(value) && value.length === 0) return false;
        return true;
      }
    };
    tierValidationService = new TierValidationService();
  }
});

// server/routes/user.ts
var user_exports = {};
__export(user_exports, {
  default: () => user_default
});
import { Router as Router8 } from "express";
var router8, user_default;
var init_user = __esm({
  "server/routes/user.ts"() {
    "use strict";
    init_logger();
    init_user_service();
    init_firebase_auth_middleware();
    init_email();
    init_firebase_setup();
    router8 = Router8();
    router8.get("/profile", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        let user = req.neonUser;
        const firebaseEmailVerified = req.firebaseUser?.email_verified;
        if (firebaseEmailVerified && !user.isVerified) {
          logger.info(`\u{1F4E7} Updating is_verified for user ${user.id} - Firebase email verified (profile fetch)`);
          const updatedUser = await userService.updateUser(user.id, { isVerified: true });
          if (updatedUser) {
            user = updatedUser;
          }
        }
        const responseUser = {
          ...user,
          is_verified: user.isVerified
        };
        res.json(responseUser);
      } catch (error) {
        logger.error("Error fetching user profile:", error);
        res.status(500).json({ error: "Failed to fetch user profile" });
      }
    });
    router8.post("/seen-welcome", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        const user = req.neonUser;
        logger.info(`\u{1F389} Marking welcome screen as seen for user ${user.id}`);
        await userService.updateUser(user.id, { has_seen_welcome: true });
        res.json({ success: true });
      } catch (error) {
        logger.error("Error setting has_seen_welcome:", error);
        res.status(500).json({ error: "Internal server error" });
      }
    });
    router8.post("/logout", async (req, res) => {
      logger.info("\u{1F6AA} Logout request received (Firebase Auth is stateless)");
      res.json({ success: true, message: "Logged out successfully" });
    });
    router8.post("/sync", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        let user = req.neonUser;
        const firebaseEmailVerified = req.firebaseUser?.email_verified;
        if (firebaseEmailVerified && !user.isVerified) {
          logger.info(`\u{1F4E7} Updating is_verified for user ${user.id} - Firebase email verified`);
          const updatedUser = await userService.updateUser(user.id, { isVerified: true });
          if (updatedUser) {
            user = updatedUser;
          }
        }
        res.json(user);
      } catch (error) {
        logger.error("Error syncing user:", error);
        res.status(500).json({ error: "Failed to sync user" });
      }
    });
    router8.post("/chef-onboarding-complete", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        const user = req.neonUser;
        const { selectedPaths } = req.body;
        logger.info(`\u{1F393} Marking chef onboarding complete for user ${user.id}, paths: ${JSON.stringify(selectedPaths)}`);
        await userService.updateUser(user.id, {
          chefOnboardingCompleted: true,
          chefOnboardingPaths: selectedPaths || []
        });
        res.json({ success: true });
      } catch (error) {
        logger.error("Error marking chef onboarding complete:", error);
        res.status(500).json({ error: "Failed to mark onboarding complete" });
      }
    });
    router8.post("/sync-password", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        const user = req.neonUser;
        const { newPassword } = req.body;
        if (!newPassword || typeof newPassword !== "string" || newPassword.length < 8) {
          return res.status(400).json({ error: "Valid password (min 8 characters) is required" });
        }
        await userService.updateUser(user.id, { password: newPassword });
        logger.info(`[sync-password] Password synced to Neon for user ${user.id} (${user.username})`);
        res.json({ success: true });
      } catch (error) {
        logger.error("[sync-password] Error syncing password:", error);
        res.status(500).json({ error: "Failed to sync password" });
      }
    });
    router8.post("/sync-verification-status", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        let user = req.neonUser;
        const firebaseEmailVerified = req.firebaseUser?.email_verified;
        const firebaseDisplayName = req.firebaseUser?.name;
        logger.info(`\u{1F504} SYNC VERIFICATION STATUS for user ${user.id} (${user.username})`);
        logger.info(`   - Firebase email_verified: ${firebaseEmailVerified}`);
        logger.info(`   - Database isVerified: ${user.isVerified}`);
        logger.info(`   - Welcome email already sent: ${user.welcomeEmailSentAt ? "YES" : "NO"}`);
        let welcomeEmailSent = false;
        let verificationUpdated = false;
        if (firebaseEmailVerified) {
          if (!user.isVerified) {
            logger.info(`\u{1F4E7} Updating is_verified for user ${user.id} - Firebase email verified`);
            const updatedUser = await userService.updateUser(user.id, { isVerified: true });
            if (updatedUser) {
              user = updatedUser;
              verificationUpdated = true;
            }
          }
          if (!user.welcomeEmailSentAt) {
            logger.info(`\u{1F4E7} SENDING WELCOME EMAIL to newly verified user: ${user.username}`);
            try {
              const displayName = firebaseDisplayName || user.username.split("@")[0];
              const welcomeEmail = generateWelcomeEmail({
                fullName: displayName,
                email: user.username,
                role: user.role
              });
              const emailResult = await sendEmail(welcomeEmail, {
                trackingId: `welcome_verified_${user.id}_${Date.now()}`
              });
              if (emailResult) {
                await userService.updateUser(user.id, {
                  welcomeEmailSentAt: /* @__PURE__ */ new Date()
                });
                welcomeEmailSent = true;
                logger.info(`\u2705 Welcome email sent successfully to ${user.username}`);
              } else {
                logger.error(`\u274C Failed to send welcome email to ${user.username} - sendEmail returned false`);
              }
            } catch (emailError) {
              logger.error(`\u274C Error sending welcome email to ${user.username}:`, emailError);
            }
          } else {
            logger.info(`\u2139\uFE0F Welcome email already sent at ${user.welcomeEmailSentAt} - skipping duplicate`);
          }
        } else {
          logger.info(`\u26A0\uFE0F Firebase email not verified - no action taken`);
        }
        res.json({
          success: true,
          userId: user.id,
          email: user.username,
          firebaseVerified: firebaseEmailVerified,
          databaseVerified: user.isVerified,
          verificationUpdated,
          welcomeEmailSent,
          welcomeEmailPreviouslySent: !!user.welcomeEmailSentAt && !welcomeEmailSent
        });
      } catch (error) {
        logger.error("\u274C Error in sync-verification-status:", error);
        res.status(500).json({
          error: "Failed to sync verification status",
          details: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    router8.post("/verify-email-complete", async (req, res) => {
      try {
        const { email } = req.body;
        if (!email) {
          return res.status(400).json({ error: "Email is required" });
        }
        logger.info(`\u{1F504} PUBLIC VERIFY-EMAIL-COMPLETE for email: ${email}`);
        const firebaseUser = await getFirebaseUserByEmail(email);
        if (!firebaseUser) {
          logger.info(`\u274C Firebase user not found for email: ${email}`);
          return res.status(404).json({ error: "User not found in Firebase" });
        }
        logger.info(`   - Firebase emailVerified: ${firebaseUser.emailVerified}`);
        logger.info(`   - Firebase UID: ${firebaseUser.uid}`);
        if (!firebaseUser.emailVerified) {
          logger.info(`\u26A0\uFE0F Firebase email NOT verified for: ${email}`);
          return res.status(400).json({
            error: "Email not verified in Firebase",
            firebaseVerified: false
          });
        }
        const user = await userService.getUserByUsername(email);
        if (!user) {
          logger.info(`\u274C User not found in Neon DB for email: ${email}`);
          return res.status(404).json({ error: "User not found in database" });
        }
        logger.info(`   - Neon user ID: ${user.id}`);
        logger.info(`   - Neon isVerified: ${user.isVerified}`);
        logger.info(`   - Welcome email already sent: ${user.welcomeEmailSentAt ? "YES" : "NO"}`);
        let verificationUpdated = false;
        let welcomeEmailSent = false;
        if (!user.isVerified) {
          logger.info(`\u{1F4E7} Updating is_verified for user ${user.id}`);
          await userService.updateUser(user.id, { isVerified: true });
          verificationUpdated = true;
        }
        if (!user.welcomeEmailSentAt) {
          logger.info(`\u{1F4E7} SENDING WELCOME EMAIL to newly verified user: ${email}`);
          logger.info(`\u{1F4E7} Email configuration check:`, {
            hasEmailUser: !!process.env.EMAIL_USER,
            hasEmailPass: !!process.env.EMAIL_PASS,
            hasEmailFrom: !!process.env.EMAIL_FROM,
            environment: process.env.VERCEL_ENV || process.env.NODE_ENV || "unknown"
          });
          const displayName = firebaseUser.displayName || email.split("@")[0];
          const welcomeEmail = generateWelcomeEmail({
            fullName: displayName,
            email,
            role: user.role
          });
          logger.info(`\u{1F4E7} Generated welcome email:`, {
            to: welcomeEmail.to,
            subject: welcomeEmail.subject,
            hasHtml: !!welcomeEmail.html,
            hasText: !!welcomeEmail.text,
            htmlLength: welcomeEmail.html?.length || 0,
            textLength: welcomeEmail.text?.length || 0
          });
          const MAX_RETRIES = 3;
          let lastError = null;
          for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
            try {
              logger.info(`\u{1F4E7} Welcome email attempt ${attempt}/${MAX_RETRIES} for ${email}`);
              const emailResult = await sendEmail(welcomeEmail, {
                trackingId: `welcome_verified_public_${user.id}_${Date.now()}_attempt${attempt}`
              });
              if (emailResult) {
                await userService.updateUser(user.id, { welcomeEmailSentAt: /* @__PURE__ */ new Date() });
                welcomeEmailSent = true;
                logger.info(`\u2705 Welcome email sent successfully to ${email} on attempt ${attempt}`);
                break;
              } else {
                logger.error(`\u274C sendEmail returned false for ${email} on attempt ${attempt}`);
                lastError = new Error("sendEmail returned false");
              }
            } catch (emailError) {
              lastError = emailError instanceof Error ? emailError : new Error(String(emailError));
              logger.error(`\u274C Error sending welcome email to ${email} on attempt ${attempt}:`, {
                error: lastError.message,
                stack: lastError.stack
              });
            }
            if (attempt < MAX_RETRIES) {
              const backoffMs = Math.pow(2, attempt - 1) * 1e3;
              logger.info(`\u23F3 Waiting ${backoffMs}ms before retry...`);
              await new Promise((resolve) => setTimeout(resolve, backoffMs));
            }
          }
          if (!welcomeEmailSent) {
            logger.error(`\u274C CRITICAL: All ${MAX_RETRIES} attempts to send welcome email failed for ${email}`);
            logger.error(`\u274C Last error:`, lastError?.message || "Unknown error");
          }
        } else {
          logger.info(`\u2139\uFE0F Welcome email already sent at ${user.welcomeEmailSentAt} - skipping`);
        }
        res.json({
          success: true,
          userId: user.id,
          email,
          firebaseVerified: true,
          databaseVerified: true,
          verificationUpdated,
          welcomeEmailSent,
          welcomeEmailPreviouslySent: !!user.welcomeEmailSentAt && !welcomeEmailSent,
          // ENTERPRISE: Include email config status for debugging
          emailConfigStatus: {
            hasEmailUser: !!process.env.EMAIL_USER,
            hasEmailPass: !!process.env.EMAIL_PASS,
            hasEmailFrom: !!process.env.EMAIL_FROM,
            environment: process.env.VERCEL_ENV || process.env.NODE_ENV || "unknown"
          }
        });
      } catch (error) {
        logger.error("\u274C Error in verify-email-complete:", error);
        res.status(500).json({
          error: "Failed to complete email verification",
          details: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    user_default = router8;
  }
});

// server/routes/places.ts
var places_exports = {};
__export(places_exports, {
  default: () => places_default
});
import { Router as Router9 } from "express";
function checkRateLimit(ip) {
  const now = Date.now();
  const record = rateLimitMap.get(ip);
  if (!record || now > record.resetTime) {
    rateLimitMap.set(ip, { count: 1, resetTime: now + RATE_LIMIT_WINDOW_MS });
    return true;
  }
  if (record.count >= RATE_LIMIT_MAX_REQUESTS) {
    return false;
  }
  record.count++;
  return true;
}
var router9, GOOGLE_PLACES_API_KEY, rateLimitMap, RATE_LIMIT_WINDOW_MS, RATE_LIMIT_MAX_REQUESTS, places_default;
var init_places = __esm({
  "server/routes/places.ts"() {
    "use strict";
    init_logger();
    router9 = Router9();
    GOOGLE_PLACES_API_KEY = process.env.GOOGLE_MAPS_API_KEY;
    rateLimitMap = /* @__PURE__ */ new Map();
    RATE_LIMIT_WINDOW_MS = 6e4;
    RATE_LIMIT_MAX_REQUESTS = 100;
    router9.get("/autocomplete", async (req, res) => {
      try {
        const clientIp = req.ip || req.socket.remoteAddress || "unknown";
        if (!checkRateLimit(clientIp)) {
          return res.status(429).json({
            error: "Too many requests",
            message: "Rate limit exceeded. Please try again later."
          });
        }
        const { input, types = "address", components = "country:us|country:ca" } = req.query;
        if (!input || typeof input !== "string") {
          return res.status(400).json({
            error: "Bad Request",
            message: "Input parameter is required"
          });
        }
        if (input.length < 3) {
          return res.status(400).json({
            error: "Bad Request",
            message: "Input must be at least 3 characters"
          });
        }
        if (!GOOGLE_PLACES_API_KEY) {
          logger.error("[Places API] GOOGLE_MAPS_API_KEY is not configured");
          return res.status(500).json({
            error: "Server Configuration Error",
            message: "Places API is not configured"
          });
        }
        const url = new URL("https://maps.googleapis.com/maps/api/place/autocomplete/json");
        url.searchParams.set("input", input);
        url.searchParams.set("types", types);
        url.searchParams.set("components", components);
        url.searchParams.set("key", GOOGLE_PLACES_API_KEY);
        const response = await fetch(url.toString());
        const data = await response.json();
        if (data.status === "REQUEST_DENIED") {
          logger.error("[Places API] Request denied:", data.error_message);
          return res.status(403).json({
            error: "API Error",
            message: "Places API request was denied"
          });
        }
        const predictions = (data.predictions || []).map((p) => ({
          place_id: p.place_id,
          description: p.description,
          structured_formatting: {
            main_text: p.structured_formatting?.main_text,
            secondary_text: p.structured_formatting?.secondary_text
          }
        }));
        res.json({
          status: data.status,
          predictions
        });
      } catch (error) {
        logger.error("[Places API] Autocomplete error:", error);
        res.status(500).json({
          error: "Internal Server Error",
          message: "Failed to fetch address suggestions"
        });
      }
    });
    router9.get("/details", async (req, res) => {
      try {
        const clientIp = req.ip || req.socket.remoteAddress || "unknown";
        if (!checkRateLimit(clientIp)) {
          return res.status(429).json({
            error: "Too many requests",
            message: "Rate limit exceeded. Please try again later."
          });
        }
        const { place_id } = req.query;
        if (!place_id || typeof place_id !== "string") {
          return res.status(400).json({
            error: "Bad Request",
            message: "place_id parameter is required"
          });
        }
        if (!GOOGLE_PLACES_API_KEY) {
          logger.error("[Places API] GOOGLE_MAPS_API_KEY is not configured");
          return res.status(500).json({
            error: "Server Configuration Error",
            message: "Places API is not configured"
          });
        }
        const url = new URL("https://maps.googleapis.com/maps/api/place/details/json");
        url.searchParams.set("place_id", place_id);
        url.searchParams.set("fields", "formatted_address,geometry,address_components");
        url.searchParams.set("key", GOOGLE_PLACES_API_KEY);
        const response = await fetch(url.toString());
        const data = await response.json();
        if (data.status === "REQUEST_DENIED") {
          logger.error("[Places API] Request denied:", data.error_message);
          return res.status(403).json({
            error: "API Error",
            message: "Places API request was denied"
          });
        }
        if (data.status !== "OK" || !data.result) {
          return res.status(404).json({
            error: "Not Found",
            message: "Place details not found"
          });
        }
        res.json({
          status: data.status,
          result: {
            formatted_address: data.result.formatted_address,
            geometry: data.result.geometry,
            address_components: data.result.address_components
          }
        });
      } catch (error) {
        logger.error("[Places API] Details error:", error);
        res.status(500).json({
          error: "Internal Server Error",
          message: "Failed to fetch place details"
        });
      }
    });
    places_default = router9;
  }
});

// server/routes/applications.ts
var applications_exports = {};
__export(applications_exports, {
  default: () => applications_default
});
import { Router as Router10 } from "express";
import fs4 from "fs";
import { fromZodError as fromZodError3 } from "zod-validation-error";
var router10, appRepo, appService, userRepo, userService2, applications_default;
var init_applications = __esm({
  "server/routes/applications.ts"() {
    "use strict";
    init_logger();
    init_schema();
    init_fileUpload();
    init_email();
    init_phone_utils();
    init_firebase_auth_middleware();
    init_notification_service();
    init_application_repository();
    init_application_service();
    init_user_repository();
    init_user_service();
    init_domain_error();
    router10 = Router10();
    appRepo = new ApplicationRepository();
    appService = new ApplicationService(appRepo);
    userRepo = new UserRepository();
    userService2 = new UserService(userRepo);
    router10.post(
      "/",
      upload.fields([
        { name: "foodSafetyLicense", maxCount: 1 },
        { name: "foodEstablishmentCert", maxCount: 1 }
      ]),
      async (req, res) => {
        try {
          if (!req.neonUser) {
            if (req.files) {
              const files2 = req.files;
              Object.values(files2).flat().forEach((file) => {
                try {
                  fs4.unlinkSync(file.path);
                } catch (e) {
                  logger.error("Error cleaning up file:", e);
                }
              });
            }
            return res.status(401).json({ message: "You must be logged in to submit an application" });
          }
          const parsedData = insertApplicationSchema.safeParse(req.body);
          if (!parsedData.success) {
            if (req.files) {
              const files2 = req.files;
              Object.values(files2).flat().forEach((file) => {
                try {
                  fs4.unlinkSync(file.path);
                } catch (e) {
                  logger.error("Error cleaning up file:", e);
                }
              });
            }
            const validationError = fromZodError3(parsedData.error);
            return res.status(400).json({
              message: "Validation error",
              errors: validationError.details
            });
          }
          const applicationData = {
            // Map fields from parsedData to CreateApplicationDTO
            userId: req.neonUser.id,
            fullName: parsedData.data.fullName,
            email: parsedData.data.email,
            phone: normalizePhoneForStorage(parsedData.data.phone) || parsedData.data.phone,
            foodSafetyLicense: parsedData.data.foodSafetyLicense,
            foodEstablishmentCert: parsedData.data.foodEstablishmentCert,
            kitchenPreference: parsedData.data.kitchenPreference,
            feedback: parsedData.data.feedback,
            // Files handled below
            foodSafetyLicenseUrl: void 0,
            foodEstablishmentCertUrl: void 0
          };
          logger.info("=== APPLICATION SUBMISSION WITH DOCUMENTS ===");
          const files = req.files;
          if (files) {
            const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
            if (files.foodSafetyLicense && files.foodSafetyLicense[0]) {
              logger.info("\u{1F4C4} Uploading food safety license file...");
              if (isProduction2) {
                applicationData.foodSafetyLicenseUrl = await uploadToBlob(files.foodSafetyLicense[0], req.neonUser.id);
              } else {
                applicationData.foodSafetyLicenseUrl = getFileUrl(files.foodSafetyLicense[0].filename);
              }
            }
            if (files.foodEstablishmentCert && files.foodEstablishmentCert[0]) {
              logger.info("\u{1F4C4} Uploading food establishment cert file...");
              if (isProduction2) {
                applicationData.foodEstablishmentCertUrl = await uploadToBlob(files.foodEstablishmentCert[0], req.neonUser.id);
              } else {
                applicationData.foodEstablishmentCertUrl = getFileUrl(files.foodEstablishmentCert[0].filename);
              }
            }
          }
          if (req.body.foodSafetyLicenseUrl && !applicationData.foodSafetyLicenseUrl) {
            applicationData.foodSafetyLicenseUrl = req.body.foodSafetyLicenseUrl;
          }
          if (req.body.foodEstablishmentCertUrl && !applicationData.foodEstablishmentCertUrl) {
            applicationData.foodEstablishmentCertUrl = req.body.foodEstablishmentCertUrl;
          }
          const application = await appService.submitApplication(applicationData);
          logger.info("\u2705 Application created successfully:", {
            id: application.id,
            hasDocuments: !!(application.foodSafetyLicenseUrl || application.foodEstablishmentCertUrl)
          });
          try {
            if (application.email) {
              const hasDocuments = !!(application.foodSafetyLicenseUrl || application.foodEstablishmentCertUrl);
              if (hasDocuments) {
                const emailContent = generateApplicationWithDocumentsEmail({
                  fullName: application.fullName || "Applicant",
                  email: application.email
                });
                await sendEmail(emailContent, {
                  trackingId: `app_with_docs_${application.id}_${Date.now()} `
                });
              } else {
                const emailContent = generateApplicationWithoutDocumentsEmail({
                  fullName: application.fullName || "Applicant",
                  email: application.email
                });
                await sendEmail(emailContent, {
                  trackingId: `app_no_docs_${application.id}_${Date.now()} `
                });
              }
            }
          } catch (emailError) {
            logger.error("Error sending new application email:", emailError);
          }
          logger.info("=== APPLICATION SUBMISSION COMPLETE ===");
          return res.status(201).json(application);
        } catch (error) {
          logger.error("Error creating application:", error);
          if (req.files) {
            const files = req.files;
            Object.values(files).flat().forEach((file) => {
              try {
                if (file.path) {
                  fs4.unlinkSync(file.path);
                }
              } catch (e) {
                logger.error("Error cleaning up file:", e);
              }
            });
          }
          if (error instanceof DomainError) {
            return res.status(error.statusCode).json({ message: error.message });
          }
          return res.status(500).json({ message: "Internal server error" });
        }
      }
    );
    router10.patch(
      "/:id/documents",
      requireFirebaseAuthWithUser,
      upload.fields([
        { name: "foodSafetyLicense", maxCount: 1 },
        { name: "foodEstablishmentCert", maxCount: 1 }
      ]),
      async (req, res) => {
        try {
          const id = parseInt(req.params.id);
          if (isNaN(id)) {
            return res.status(400).json({ message: "Invalid application ID" });
          }
          logger.info(`\u{1F4DD} PATCH /api/applications/${id}/documents - User ${req.neonUser.id} updating documents`);
          const application = await appService.getApplicationById(id);
          if (!application) {
            return res.status(404).json({ message: "Application not found" });
          }
          if (application.userId !== req.neonUser.id) {
            return res.status(403).json({ message: "Access denied" });
          }
          const files = req.files;
          let foodSafetyLicenseUrl;
          let foodEstablishmentCertUrl;
          const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
          if (files) {
            if (files.foodSafetyLicense && files.foodSafetyLicense[0]) {
              logger.info("\u{1F4C4} Uploading food safety license file...");
              if (isProduction2) {
                foodSafetyLicenseUrl = await uploadToBlob(files.foodSafetyLicense[0], req.neonUser.id, "documents");
              } else {
                foodSafetyLicenseUrl = getFileUrl(files.foodSafetyLicense[0].filename);
              }
            }
            if (files.foodEstablishmentCert && files.foodEstablishmentCert[0]) {
              logger.info("\u{1F4C4} Uploading food establishment cert file...");
              if (isProduction2) {
                foodEstablishmentCertUrl = await uploadToBlob(files.foodEstablishmentCert[0], req.neonUser.id, "documents");
              } else {
                foodEstablishmentCertUrl = getFileUrl(files.foodEstablishmentCert[0].filename);
              }
            }
          }
          const updates = {};
          if (foodSafetyLicenseUrl) {
            updates.foodSafetyLicenseUrl = foodSafetyLicenseUrl;
          }
          if (foodEstablishmentCertUrl) {
            updates.foodEstablishmentCertUrl = foodEstablishmentCertUrl;
          }
          if (Object.keys(updates).length === 0) {
            return res.status(400).json({ message: "No documents provided for update" });
          }
          const updatedApplication = await appService.updateDocuments(id, updates);
          if (!updatedApplication) {
            return res.status(500).json({ message: "Failed to update application documents" });
          }
          res.json(updatedApplication);
        } catch (error) {
          logger.error("Error updating application documents:", error);
          res.status(500).json({
            error: "Failed to update application documents",
            message: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    );
    router10.get("/", async (req, res) => {
      if (!req.neonUser) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      if (req.neonUser.role !== "admin") {
        return res.status(403).json({ message: "Access denied. Admin role required." });
      }
      try {
        const applications4 = await appService.getAllApplications();
        return res.status(200).json(applications4);
      } catch (error) {
        logger.error("Error fetching applications:", error);
        if (error instanceof DomainError) {
          return res.status(error.statusCode).json({ message: error.message });
        }
        return res.status(500).json({ message: "Internal server error" });
      }
    });
    router10.get("/my-applications", async (req, res) => {
      if (!req.neonUser) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      try {
        const userId = req.neonUser.id;
        const applications4 = await appService.getApplicationsByUserId(userId);
        return res.status(200).json(applications4);
      } catch (error) {
        logger.error("Error fetching user applications:", error);
        if (error instanceof DomainError) {
          return res.status(error.statusCode).json({ message: error.message });
        }
        return res.status(500).json({ message: "Internal server error" });
      }
    });
    router10.get("/:id", async (req, res) => {
      try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
          return res.status(400).json({ message: "Invalid application ID" });
        }
        const application = await appService.getApplicationById(id);
        return res.status(200).json(application);
      } catch (error) {
        logger.error("Error fetching application:", error);
        if (error instanceof DomainError) {
          return res.status(error.statusCode).json({ message: error.message });
        }
        return res.status(500).json({ message: "Internal server error" });
      }
    });
    router10.patch("/:id/status", async (req, res) => {
      try {
        if (!req.neonUser) {
          return res.status(401).json({ message: "Not authenticated" });
        }
        if (req.neonUser.role !== "admin") {
          return res.status(403).json({ message: "Access denied. Admin role required." });
        }
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
          return res.status(400).json({ message: "Invalid application ID" });
        }
        const parsedData = updateApplicationStatusSchema.safeParse({
          id,
          ...req.body
        });
        if (!parsedData.success) {
          const validationError = fromZodError3(parsedData.error);
          return res.status(400).json({
            message: "Validation error",
            errors: validationError.details
          });
        }
        const updatedApplication = await appService.updateStatus(id, parsedData.data.status);
        try {
          if (updatedApplication.email) {
            const emailContent = generateStatusChangeEmail({
              fullName: updatedApplication.fullName || "Applicant",
              email: updatedApplication.email,
              status: updatedApplication.status
            });
            await sendEmail(emailContent, {
              trackingId: `status_${updatedApplication.id}_${updatedApplication.status}_${Date.now()} `
            });
          }
        } catch (emailError) {
          logger.error("Error sending status change email:", emailError);
        }
        return res.status(200).json(updatedApplication);
      } catch (error) {
        logger.error("Error updating application status:", error);
        if (error instanceof DomainError) {
          return res.status(error.statusCode).json({ message: error.message });
        }
        return res.status(500).json({ message: "Internal server error" });
      }
    });
    router10.patch("/:id/cancel", async (req, res) => {
      const userId = req.neonUser?.id;
      if (!userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
          return res.status(400).json({ message: "Invalid application ID" });
        }
        const updatedApplication = await appService.cancelApplication(id, userId);
        try {
          if (updatedApplication.email) {
            const emailContent = generateStatusChangeEmail({
              fullName: updatedApplication.fullName || "Applicant",
              email: updatedApplication.email,
              status: "cancelled"
            });
            await sendEmail(emailContent, {
              trackingId: `cancel_${updatedApplication.id}_${Date.now()} `
            });
          }
        } catch (emailError) {
          logger.error("Error sending cancellation email:", emailError);
        }
        return res.status(200).json(updatedApplication);
      } catch (error) {
        logger.error("Error cancelling application:", error);
        if (error instanceof DomainError) {
          return res.status(error.statusCode).json({ message: error.message });
        }
        return res.status(500).json({ message: "Internal server error" });
      }
    });
    router10.patch("/:id/document-verification", async (req, res) => {
      try {
        if (!req.neonUser) {
          return res.status(401).json({ message: "Not authenticated" });
        }
        if (req.neonUser.role !== "admin") {
          return res.status(403).json({ message: "Access denied. Admin role required." });
        }
        const applicationId = parseInt(req.params.id);
        if (isNaN(applicationId)) {
          return res.status(400).json({ message: "Invalid application ID" });
        }
        const parsedData = updateDocumentVerificationSchema.safeParse({
          id: applicationId,
          ...req.body,
          documentsReviewedBy: req.neonUser.id
        });
        if (!parsedData.success) {
          const validationError = fromZodError3(parsedData.error);
          return res.status(400).json({
            message: "Validation error",
            errors: validationError.details
          });
        }
        const existingApplication = await appService.getApplicationById(applicationId);
        const verifyDto = {
          id: applicationId,
          foodSafetyLicenseStatus: parsedData.data.foodSafetyLicenseStatus || existingApplication.foodSafetyLicenseStatus,
          foodEstablishmentCertStatus: parsedData.data.foodEstablishmentCertStatus || existingApplication.foodEstablishmentCertStatus,
          documentsAdminFeedback: parsedData.data.documentsAdminFeedback,
          documentsReviewedBy: req.neonUser.id
        };
        const updatedApplication = await appService.verifyDocuments(verifyDto);
        if (updatedApplication.foodSafetyLicenseStatus === "approved" && (!updatedApplication.foodEstablishmentCertUrl || updatedApplication.foodEstablishmentCertStatus === "approved")) {
          if (updatedApplication.userId) {
            await userService2.verifyUser(updatedApplication.userId, true);
            logger.info(`User ${updatedApplication.userId} has been fully verified`);
            try {
              if (updatedApplication.email && updatedApplication.fullName && updatedApplication.phone) {
                const emailContent = generateFullVerificationEmail({
                  fullName: updatedApplication.fullName,
                  email: updatedApplication.email,
                  phone: updatedApplication.phone
                });
                await sendEmail(emailContent, {
                  trackingId: `full_verification_${updatedApplication.id}_${Date.now()}`
                });
                logger.info(`\u2705 Full verification email with login credentials sent to ${updatedApplication.email}`);
              }
            } catch (emailError) {
              logger.error("\u274C Error sending full verification email:", emailError);
            }
          }
        }
        try {
          const { locationService: locationService4 } = await Promise.resolve().then(() => (init_location_service(), location_service_exports));
          if (updatedApplication.locationId) {
            const location = await locationService4.getLocationById(updatedApplication.locationId);
            if (location && location.managerId) {
              const isApproved = updatedApplication.foodSafetyLicenseStatus === "approved" || updatedApplication.foodEstablishmentCertStatus === "approved";
              const isRejected = updatedApplication.foodSafetyLicenseStatus === "rejected" || updatedApplication.foodEstablishmentCertStatus === "rejected";
              if (isApproved) {
                await notificationService.notifyLicenseApproved({
                  managerId: location.managerId,
                  locationId: location.id,
                  locationName: location.name,
                  feedback: updatedApplication.documentsAdminFeedback || void 0
                });
              } else if (isRejected) {
                await notificationService.notifyLicenseRejected({
                  managerId: location.managerId,
                  locationId: location.id,
                  locationName: location.name,
                  feedback: updatedApplication.documentsAdminFeedback || void 0
                });
              }
            }
          }
        } catch (notifError) {
          logger.error("Error creating license notification:", notifError);
        }
        return res.status(200).json(updatedApplication);
      } catch (error) {
        logger.error("Error updating application document verification:", error);
        if (error instanceof DomainError) {
          return res.status(error.statusCode).json({ message: error.message });
        }
        return res.status(500).json({ message: "Internal server error" });
      }
    });
    applications_default = router10;
  }
});

// server/routes/utils.ts
var utils_exports = {};
__export(utils_exports, {
  normalizeImageUrl: () => normalizeImageUrl
});
function normalizeImageUrl(url, req) {
  if (!url) return null;
  const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
  const getOrigin = () => {
    let protocol;
    let host;
    if (isProduction2) {
      protocol = (req.get("x-forwarded-proto") || "https").split(",")[0].trim();
      host = req.get("x-forwarded-host") || req.get("host") || req.headers.host || "";
      if (protocol !== "https") protocol = "https";
    } else {
      protocol = req.protocol || "http";
      host = req.get("host") || req.headers.host || "localhost:5001";
    }
    return `${protocol}://${host}`;
  };
  if (url.startsWith("https://files.localcooks.ca/")) {
    const r2Path = url.replace("https://files.localcooks.ca/", "");
    const origin = getOrigin();
    return `${origin}/api/files/images/r2/${encodeURIComponent(r2Path)}`;
  }
  if (url.startsWith("http://") || url.startsWith("https://")) {
    if (url.includes("r2.localcooks.com/documents/") || url.includes(".r2.dev/documents/")) {
      const filename = url.split("/").pop();
      if (filename) {
        const origin = getOrigin();
        return `${origin}/api/files/documents/${filename}`;
      }
    }
    return url;
  }
  if (url.startsWith("/")) {
    const origin = getOrigin();
    if (!origin || origin === "://") {
      logger.warn(`[normalizeImageUrl] Could not determine host for URL: ${url}`);
      return url;
    }
    return `${origin}${url}`;
  }
  return url;
}
var init_utils = __esm({
  "server/routes/utils.ts"() {
    "use strict";
    init_logger();
  }
});

// server/routes/locations.ts
var locations_exports = {};
__export(locations_exports, {
  default: () => locations_default
});
import { Router as Router11 } from "express";
import { fromZodError as fromZodError4 } from "zod-validation-error";
var router11, locationRepository2, locationService3, kitchenRepository2, kitchenService3, locations_default;
var init_locations = __esm({
  "server/routes/locations.ts"() {
    "use strict";
    init_logger();
    init_firebase_auth_middleware();
    init_utils();
    init_schema();
    init_location_repository();
    init_location_service();
    init_kitchen_repository();
    init_kitchen_service();
    init_domain_error();
    router11 = Router11();
    locationRepository2 = new LocationRepository();
    locationService3 = new LocationService(locationRepository2);
    kitchenRepository2 = new KitchenRepository();
    kitchenService3 = new KitchenService(kitchenRepository2);
    router11.get("/public/locations", async (req, res) => {
      try {
        const [allLocations, allKitchens] = await Promise.all([
          locationService3.getAllLocations(),
          kitchenService3.getAllActiveKitchens()
        ]);
        const publicLocations = allLocations.map((location) => {
          const locationKitchens = allKitchens.filter((k) => k.locationId === location.id);
          const featuredKitchen = locationKitchens.find((k) => k.imageUrl) || locationKitchens[0];
          const featuredKitchenImage = normalizeImageUrl(featuredKitchen?.imageUrl || null, req);
          const logoUrl = normalizeImageUrl(location.logoUrl || null, req);
          const brandImageUrl = normalizeImageUrl(location.brandImageUrl || null, req);
          const kitchenCount = locationKitchens.length;
          const allAmenities = locationKitchens.reduce((acc, kitchen) => {
            const amenities = kitchen.amenities || [];
            return [...acc, ...amenities];
          }, []);
          const uniqueAmenities = Array.from(new Set(allAmenities));
          const rates = locationKitchens.map((k) => parseFloat(String(k.hourlyRate || 0))).filter((r) => r > 0);
          const minRate = rates.length > 0 ? Math.min(...rates) : null;
          const maxRate = rates.length > 0 ? Math.max(...rates) : null;
          const isApproved = location.kitchenLicenseStatus === "approved";
          const hasActiveKitchens = locationKitchens.some((k) => k.isActive);
          const canAcceptBookings = isApproved && hasActiveKitchens;
          return {
            id: location.id,
            name: location.name,
            address: location.address,
            brandImageUrl,
            brand_image_url: brandImageUrl,
            // compatibility
            logoUrl,
            logo_url: logoUrl,
            // compatibility
            featuredKitchenImage,
            featured_kitchen_image: featuredKitchenImage,
            // compatibility
            kitchenCount,
            kitchen_count: kitchenCount,
            // compatibility
            description: location.description || null,
            // New fields for enhanced discovery
            amenities: uniqueAmenities,
            minHourlyRate: minRate,
            maxHourlyRate: maxRate,
            canAcceptBookings,
            isApproved,
            // Kitchen terms and policies for chef applications
            kitchenTermsUrl: location.kitchenTermsUrl || null
          };
        });
        res.json(publicLocations);
      } catch (error) {
        logger.error("Error fetching public locations:", error);
        res.status(500).json({ error: "Failed to fetch locations" });
      }
    });
    router11.get("/public/kitchens", async (req, res) => {
      try {
        const allKitchens = await kitchenService3.getAllActiveKitchens();
        const allLocations = await locationService3.getAllLocations();
        const locationMap = new Map(allLocations.map((loc) => [loc.id, loc]));
        const { storageListings: storageListings3, equipmentListings: equipmentListings3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
        const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
        const { eq: eq38 } = await import("drizzle-orm");
        const allStorageListings = await db2.select({
          kitchenId: storageListings3.kitchenId,
          storageType: storageListings3.storageType,
          name: storageListings3.name,
          isActive: storageListings3.isActive
        }).from(storageListings3).where(eq38(storageListings3.isActive, true));
        const allEquipmentListings = await db2.select({
          kitchenId: equipmentListings3.kitchenId,
          equipmentType: equipmentListings3.equipmentType,
          category: equipmentListings3.category
        }).from(equipmentListings3).where(eq38(equipmentListings3.isActive, true));
        const storageByKitchen = /* @__PURE__ */ new Map();
        for (const storage of allStorageListings) {
          if (!storage.kitchenId) continue;
          const existing = storageByKitchen.get(storage.kitchenId) || [];
          existing.push({ type: storage.storageType || "other", name: storage.name || "Storage" });
          storageByKitchen.set(storage.kitchenId, existing);
        }
        const equipmentByKitchen = /* @__PURE__ */ new Map();
        for (const equip of allEquipmentListings) {
          if (!equip.kitchenId) continue;
          const existing = equipmentByKitchen.get(equip.kitchenId) || [];
          existing.push(equip.equipmentType || "Equipment");
          equipmentByKitchen.set(equip.kitchenId, existing);
        }
        const publicKitchens = allKitchens.map((kitchen) => {
          const location = locationMap.get(kitchen.locationId);
          if (!location) return null;
          const imageUrl = normalizeImageUrl(kitchen.imageUrl || null, req);
          const galleryImages = (kitchen.galleryImages || []).map(
            (img) => normalizeImageUrl(img, req)
          );
          const equipment = equipmentByKitchen.get(kitchen.id) || [];
          const storageItems = storageByKitchen.get(kitchen.id) || [];
          const storageSummary = {
            hasDryStorage: storageItems.some((s) => s.type === "dry"),
            hasColdStorage: storageItems.some((s) => s.type === "cold"),
            hasFreezerStorage: storageItems.some((s) => s.type === "freezer"),
            totalStorageUnits: storageItems.length
          };
          const isLocationApproved = location.kitchenLicenseStatus === "approved";
          const canAcceptBookings = isLocationApproved && kitchen.isActive;
          const customOnboardingLink = location.customOnboardingLink || null;
          return {
            id: kitchen.id,
            name: kitchen.name,
            description: kitchen.description || null,
            imageUrl,
            galleryImages,
            equipment,
            hourlyRate: kitchen.hourlyRate ? parseFloat(String(kitchen.hourlyRate)) : null,
            currency: kitchen.currency || "CAD",
            minimumBookingHours: kitchen.minimumBookingHours ? parseFloat(String(kitchen.minimumBookingHours)) : null,
            // Location info
            locationId: location.id,
            locationName: location.name,
            address: location.address,
            // Booking status
            canAcceptBookings,
            isLocationApproved,
            // Custom application link (if location has one)
            customOnboardingLink,
            // Storage summary
            storageSummary
          };
        }).filter(Boolean);
        res.json(publicKitchens);
      } catch (error) {
        logger.error("Error fetching public kitchens:", error);
        res.status(500).json({ error: "Failed to fetch kitchens" });
      }
    });
    router11.get("/public/locations/:locationId/details", async (req, res) => {
      try {
        const locationId = parseInt(req.params.locationId);
        if (isNaN(locationId)) {
          return res.status(400).json({ error: "Invalid location ID" });
        }
        const location = await locationService3.getLocationById(locationId);
        if (!location) {
          return res.status(404).json({ error: "Location not found" });
        }
        const activeKitchens = await kitchenService3.getKitchensByLocationId(locationId, true);
        const brandImageUrl = normalizeImageUrl(
          location.brandImageUrl || null,
          req
        );
        const logoUrl = normalizeImageUrl(
          location.logoUrl || null,
          req
        );
        const sanitizedKitchens = activeKitchens.map((kitchen) => {
          const kImageUrl = normalizeImageUrl(
            kitchen.imageUrl || null,
            req
          );
          const kGalleryImages = (kitchen.galleryImages || []).map(
            (img) => normalizeImageUrl(img, req)
          ).filter((url) => url !== null);
          const hourlyRateCents = kitchen.hourlyRate !== null && kitchen.hourlyRate !== void 0 ? typeof kitchen.hourlyRate === "string" ? parseFloat(kitchen.hourlyRate) : kitchen.hourlyRate : null;
          return {
            id: kitchen.id,
            name: kitchen.name,
            description: kitchen.description,
            imageUrl: kImageUrl,
            image_url: kImageUrl,
            galleryImages: kGalleryImages,
            gallery_images: kGalleryImages,
            amenities: kitchen.amenities || [],
            hourlyRate: hourlyRateCents,
            hourly_rate: hourlyRateCents,
            pricingModel: kitchen.pricingModel || "hourly",
            currency: kitchen.currency || "CAD"
          };
        });
        const isLicenseApproved = location.kitchenLicenseStatus === "approved";
        const hasActiveKitchens = sanitizedKitchens.length > 0;
        const canAcceptApplications = isLicenseApproved && hasActiveKitchens;
        res.json({
          id: location.id,
          name: location.name,
          address: location.address,
          brandImageUrl,
          brand_image_url: brandImageUrl,
          // compatibility
          logoUrl,
          logo_url: logoUrl,
          // compatibility
          description: location.description || null,
          customOnboardingLink: location.customOnboardingLink || null,
          kitchens: sanitizedKitchens,
          // Kitchen terms and policies for chef applications
          kitchenTermsUrl: location.kitchenTermsUrl || null,
          // License status for application eligibility (enterprise-grade consistency)
          kitchenLicenseStatus: location.kitchenLicenseStatus || "pending",
          canAcceptApplications,
          isLicenseApproved
        });
      } catch (error) {
        logger.error("Error fetching location details:", error);
        if (error instanceof DomainError) {
          return res.status(error.statusCode).json({ error: error.message });
        }
        res.status(500).json({ error: "Failed to fetch location details" });
      }
    });
    router11.get("/public/locations/:locationId/requirements", async (req, res) => {
      try {
        const locationId = parseInt(req.params.locationId);
        if (isNaN(locationId)) {
          return res.status(400).json({ error: "Invalid location ID" });
        }
        const requirements = await locationService3.getLocationRequirementsWithDefaults(locationId);
        res.json(requirements);
      } catch (error) {
        logger.error("Error getting location requirements:", error);
        res.status(500).json({ error: "Failed to get requirements" });
      }
    });
    router11.get(
      "/manager/locations/:locationId/requirements",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const locationId = parseInt(req.params.locationId);
          if (isNaN(locationId)) {
            return res.status(400).json({ error: "Invalid location ID" });
          }
          const location = await locationService3.getLocationById(locationId);
          if (!location || location.managerId !== user.id) {
            return res.status(403).json({ error: "Access denied" });
          }
          const requirements = await locationService3.getLocationRequirementsWithDefaults(locationId);
          res.json(requirements);
        } catch (error) {
          logger.error("Error getting location requirements:", error);
          res.status(500).json({ error: "Failed to get requirements" });
        }
      }
    );
    router11.put(
      "/manager/locations/:locationId/requirements",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const locationId = parseInt(req.params.locationId);
          if (isNaN(locationId)) {
            return res.status(400).json({ error: "Invalid location ID" });
          }
          const location = await locationService3.getLocationById(locationId);
          if (!location || location.managerId !== user.id) {
            return res.status(403).json({ error: "Access denied" });
          }
          const parseResult = updateLocationRequirementsSchema.safeParse(req.body);
          if (!parseResult.success) {
            const validationError = fromZodError4(parseResult.error);
            logger.error("\u274C Validation error updating location requirements:", validationError.message);
            return res.status(400).json({
              error: "Validation error",
              message: validationError.message,
              details: validationError.details
            });
          }
          const updates = parseResult.data;
          const requirements = await locationService3.upsertLocationRequirements(locationId, updates);
          logger.info(`\u2705 Location requirements updated for location ${locationId} by manager ${user.id} `);
          res.json({ success: true, requirements });
        } catch (error) {
          logger.error("\u274C Error updating location requirements:", error);
          res.status(500).json({
            error: "Failed to update requirements",
            message: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    );
    locations_default = router11;
  }
});

// server/alwaysFoodSafeAPI.ts
async function submitToAlwaysFoodSafe(submission) {
  const apiKey = process.env.ALWAYS_FOOD_SAFE_API_KEY;
  const apiUrl = process.env.ALWAYS_FOOD_SAFE_API_URL || "https://api.alwaysfoodsafe.com";
  if (!apiKey) {
    throw new Error("Always Food Safe API key not configured");
  }
  try {
    const response = await fetch(`${apiUrl}/api/v1/completions`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
        "User-Agent": "LocalCooks-Platform/1.0"
      },
      body: JSON.stringify({
        user: {
          id: submission.userId,
          name: submission.userName,
          email: submission.email
        },
        completion: {
          date: submission.completionDate.toISOString(),
          modules: submission.videoProgress.map((video) => ({
            id: video.videoId,
            completed: video.completed,
            progress: video.progress,
            completedAt: video.completedAt
          }))
        },
        course: {
          type: "microlearning",
          provider: "LocalCooks",
          modules: ["food-handling", "contamination-prevention", "allergen-awareness"]
        }
      })
    });
    if (!response.ok) {
      throw new Error(`Always Food Safe API error: ${response.status} ${response.statusText}`);
    }
    const data = await response.json();
    return {
      success: true,
      certificateId: data.certificate?.id,
      certificateUrl: data.certificate?.url,
      message: data.message || "Completion submitted successfully"
    };
  } catch (error) {
    logger.error("Always Food Safe API submission failed:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error occurred"
    };
  }
}
function isAlwaysFoodSafeConfigured() {
  return !!(process.env.ALWAYS_FOOD_SAFE_API_KEY && process.env.ALWAYS_FOOD_SAFE_API_URL);
}
var init_alwaysFoodSafeAPI = __esm({
  "server/alwaysFoodSafeAPI.ts"() {
    "use strict";
    init_logger();
  }
});

// server/routes/microlearning.ts
var microlearning_exports = {};
__export(microlearning_exports, {
  default: () => microlearning_default
});
import { Router as Router12 } from "express";
var router12, hasApprovedApplication, microlearning_default;
var init_microlearning = __esm({
  "server/routes/microlearning.ts"() {
    "use strict";
    init_logger();
    init_user_service();
    init_microlearning_service();
    init_application_service();
    init_alwaysFoodSafeAPI();
    router12 = Router12();
    hasApprovedApplication = async (userId) => {
      try {
        const applications4 = await applicationService.getApplicationsByUserId(userId);
        return applications4.some((app2) => app2.status === "approved");
      } catch (error) {
        logger.error("Error checking application status:", error);
        return false;
      }
    };
    router12.get("/progress", async (req, res) => {
      try {
        if (!req.neonUser) {
          return res.status(401).json({ message: "Authentication required" });
        }
        const userId = req.neonUser.id;
        const progress = await microlearningService.getUserProgress(userId);
        const completionStatus = await microlearningService.getUserCompletion(userId);
        const hasApproval = await hasApprovedApplication(userId);
        const isAdmin = req.neonUser.role === "admin";
        const isCompleted = completionStatus?.confirmed || false;
        const accessLevel = isAdmin || hasApproval || isCompleted ? "full" : "limited";
        res.json({
          success: true,
          progress: progress || [],
          confirmed: completionStatus?.confirmed || false,
          completionConfirmed: completionStatus?.confirmed || false,
          completedAt: completionStatus?.completedAt,
          hasApprovedApplication: hasApproval,
          accessLevel,
          isAdmin
        });
      } catch (error) {
        logger.error("Error fetching microlearning progress:", error);
        res.status(500).json({ message: "Failed to fetch progress" });
      }
    });
    router12.get("/progress/:userId", async (req, res) => {
      try {
        if (!req.neonUser) {
          return res.status(401).json({ message: "Authentication required" });
        }
        const paramUserId = req.params.userId;
        let userId;
        if (isNaN(parseInt(paramUserId))) {
          userId = req.neonUser.id;
        } else {
          userId = parseInt(paramUserId);
        }
        if (req.neonUser.id !== userId && req.neonUser.role !== "admin") {
          return res.status(403).json({ message: "Access denied" });
        }
        const progress = await microlearningService.getUserProgress(userId);
        const completionStatus = await microlearningService.getUserCompletion(userId);
        const hasApproval = await hasApprovedApplication(userId);
        const isAdmin = req.neonUser.role === "admin";
        const isCompleted = completionStatus?.confirmed || false;
        const accessLevel = isAdmin || hasApproval || isCompleted ? "full" : "limited";
        res.json({
          success: true,
          progress: progress || [],
          completionConfirmed: completionStatus?.confirmed || false,
          completedAt: completionStatus?.completedAt,
          hasApprovedApplication: hasApproval,
          accessLevel,
          // admins get full access, others limited to first video only
          isAdmin
        });
      } catch (error) {
        logger.error("Error fetching microlearning progress:", error);
        res.status(500).json({ message: "Failed to fetch progress" });
      }
    });
    router12.post("/progress", async (req, res) => {
      try {
        if (!req.neonUser) {
          return res.status(401).json({ message: "Authentication required" });
        }
        const { userId: requestUserId, videoId, progress, completed, completedAt, watchedPercentage } = req.body;
        let userId;
        if (!requestUserId || typeof requestUserId === "string") {
          userId = req.neonUser.id;
        } else {
          userId = requestUserId;
          if (req.neonUser.id !== userId && req.neonUser.role !== "admin") {
            return res.status(403).json({ message: "Access denied" });
          }
        }
        const hasApproval = await hasApprovedApplication(userId);
        const completionStatus = await microlearningService.getUserCompletion(userId);
        const isCompleted = completionStatus?.confirmed || false;
        const firstVideoId = "basics-cross-contamination";
        const isAdmin = req.neonUser.role === "admin";
        if (!hasApproval && !isAdmin && !isCompleted && videoId !== firstVideoId) {
          return res.status(403).json({
            message: "Application approval required to access this video",
            accessLevel: "limited",
            firstVideoOnly: true
          });
        }
        const actualCompleted = completed;
        const progressData = {
          userId,
          videoId,
          progress: Math.max(0, Math.min(100, progress)),
          // Clamp between 0-100
          watchedPercentage: Math.max(0, Math.min(100, watchedPercentage || 0)),
          // Clamp between 0-100
          completed: actualCompleted,
          completedAt: actualCompleted ? completedAt ? new Date(completedAt) : /* @__PURE__ */ new Date() : null,
          updatedAt: /* @__PURE__ */ new Date()
        };
        await microlearningService.updateVideoProgress(progressData);
        res.json({
          success: true,
          message: "Progress updated successfully"
        });
      } catch (error) {
        logger.error("Error updating video progress:", error);
        res.status(500).json({ message: "Failed to update progress" });
      }
    });
    router12.post("/complete", async (req, res) => {
      try {
        if (!req.neonUser) {
          return res.status(401).json({ message: "Authentication required" });
        }
        const { userId, completionDate, videoProgress: videoProgress2 } = req.body;
        if (req.neonUser.id !== userId && req.neonUser.role !== "admin") {
          return res.status(403).json({ message: "Access denied" });
        }
        const hasApproval = await hasApprovedApplication(userId);
        const isAdmin = req.neonUser.role === "admin";
        if (!hasApproval && !isAdmin) {
          return res.status(403).json({
            message: "Application approval required to complete full certification",
            accessLevel: "limited",
            requiresApproval: true
          });
        }
        const requiredVideos = [
          // Food Safety Basics Module (14 videos)
          "basics-personal-hygiene",
          "basics-temperature-danger",
          "basics-cross-contamination",
          "basics-allergen-awareness",
          "basics-food-storage",
          "basics-cooking-temps",
          "basics-cooling-reheating",
          "basics-thawing",
          "basics-receiving",
          "basics-fifo",
          "basics-illness-reporting",
          "basics-pest-control",
          "basics-chemical-safety",
          "basics-food-safety-plan",
          // Safety and Hygiene How-To's Module (8 videos)
          "howto-handwashing",
          "howto-sanitizing",
          "howto-thermometer",
          "howto-cleaning-schedule",
          "howto-equipment-cleaning",
          "howto-uniform-care",
          "howto-wound-care",
          "howto-inspection-prep"
        ];
        const completedVideos = videoProgress2.filter((v) => v.completed).map((v) => v.videoId);
        const allRequired = requiredVideos.every((videoId) => completedVideos.includes(videoId));
        if (!allRequired) {
          return res.status(400).json({
            message: "All required videos must be completed before certification",
            missingVideos: requiredVideos.filter((id) => !completedVideos.includes(id))
          });
        }
        const user = await userService.getUser(userId);
        if (!user) {
          return res.status(404).json({ message: "User not found" });
        }
        const completionData = {
          userId,
          completedAt: new Date(completionDate),
          videoProgress: videoProgress2,
          confirmed: true,
          certificateGenerated: false
        };
        await microlearningService.completeMicrolearning(completionData);
        let alwaysFoodSafeResult = null;
        if (isAlwaysFoodSafeConfigured()) {
          try {
            alwaysFoodSafeResult = await submitToAlwaysFoodSafe({
              userId,
              userName: user.username,
              email: `${user.username}@localcooks.ca`,
              // Placeholder email since User type doesn't have email
              completionDate: new Date(completionDate),
              videoProgress: videoProgress2
            });
          } catch (afsError) {
            logger.error("Always Food Safe API error:", afsError);
          }
        }
        res.json({
          success: true,
          message: "Microlearning completed successfully",
          completionConfirmed: true,
          alwaysFoodSafeIntegration: alwaysFoodSafeResult?.success ? "success" : "not_configured",
          certificateId: alwaysFoodSafeResult?.certificateId,
          certificateUrl: alwaysFoodSafeResult?.certificateUrl
        });
      } catch (error) {
        logger.error("Error completing microlearning:", error);
        res.status(500).json({ message: "Failed to complete microlearning" });
      }
    });
    router12.get("/completion/:userId", async (req, res) => {
      try {
        if (!req.neonUser) {
          return res.status(401).json({ message: "Authentication required" });
        }
        const paramUserId = req.params.userId;
        let userId;
        if (isNaN(parseInt(paramUserId))) {
          userId = req.neonUser.id;
        } else {
          userId = parseInt(paramUserId);
        }
        if (req.neonUser.id !== userId && req.neonUser.role !== "admin") {
          return res.status(403).json({ message: "Access denied" });
        }
        const completion = await microlearningService.getUserCompletion(userId);
        if (!completion) {
          return res.json({ confirmed: false, completedAt: null });
        }
        res.json(completion);
      } catch (error) {
        logger.error("Error getting microlearning completion status:", error);
        res.status(500).json({ message: "Failed to get completion status" });
      }
    });
    router12.get("/certificate/:userId", async (req, res) => {
      try {
        if (!req.neonUser) {
          return res.status(401).json({ message: "Authentication required" });
        }
        const userId = parseInt(req.params.userId);
        if (req.neonUser.id !== userId && req.neonUser.role !== "admin") {
          return res.status(403).json({ message: "Access denied" });
        }
        const completion = await microlearningService.getUserCompletion(userId);
        if (!completion || !completion.confirmed) {
          return res.status(404).json({ message: "No confirmed completion found" });
        }
        const user = await userService.getUser(userId);
        if (!user) {
          return res.status(404).json({ message: "User not found" });
        }
        const certificateUrl = `/api/certificates/microlearning-${userId}-${Date.now()}.pdf`;
        res.json({
          success: true,
          certificateUrl,
          completionDate: completion.completedAt,
          message: "Certificate for skillpass.nl food safety training preparation - Complete your official certification at skillpass.nl"
        });
      } catch (error) {
        logger.error("Error generating certificate:", error);
        res.status(500).json({ message: "Failed to generate certificate" });
      }
    });
    microlearning_default = router12;
  }
});

// server/routes/files.ts
var files_exports = {};
__export(files_exports, {
  default: () => files_default
});
import express, { Router as Router13 } from "express";
import path2 from "path";
import fs5 from "fs";
function isAllowedR2Url(url) {
  try {
    const parsed = new URL(url);
    return parsed.hostname === "files.localcooks.ca";
  } catch {
    return false;
  }
}
var router13, isVercel3, files_default;
var init_files = __esm({
  "server/routes/files.ts"() {
    "use strict";
    init_logger();
    init_r2_storage();
    init_fileUpload();
    init_firebase_auth_middleware();
    init_user_service();
    router13 = Router13();
    router13.post(
      "/upload-file",
      optionalFirebaseAuth,
      // Auth first so req.neonUser is set for multer filename generation
      upload.single("file"),
      // Then process file
      async (req, res) => {
        try {
          const userId = req.neonUser?.id || req.user?.id;
          if (!userId) {
            if (req.file && req.file.path) {
              try {
                fs5.unlinkSync(req.file.path);
              } catch (e) {
                logger.error("Error cleaning up file:", e);
              }
            }
            return res.status(401).json({ error: "Not authenticated" });
          }
          if (!req.file) {
            return res.status(400).json({ error: "No file uploaded" });
          }
          const folder = req.body.folder || "documents";
          const fileUrl = await uploadToBlob(req.file, userId, folder);
          const fileName = fileUrl.split("/").pop() || req.file.originalname;
          return res.status(200).json({
            success: true,
            url: fileUrl,
            fileName,
            size: req.file.size,
            type: req.file.mimetype
          });
        } catch (error) {
          logger.error("File upload error:", error);
          if (req.file && req.file.path) {
            try {
              fs5.unlinkSync(req.file.path);
            } catch (e) {
              logger.error("Error cleaning up file:", e);
            }
          }
          return res.status(500).json({
            error: "File upload failed",
            details: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    );
    router13.post("/images/presigned-url", optionalFirebaseAuth, async (req, res) => {
      try {
        const user = req.neonUser;
        const { imageUrl } = req.body;
        if (!imageUrl || typeof imageUrl !== "string") {
          return res.status(400).json({ error: "imageUrl is required" });
        }
        const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
        const isDevelopment = process.env.NODE_ENV === "development" || !isProduction2 && !process.env.VERCEL_ENV;
        if (isDevelopment) {
          logger.info("\u{1F4BB} Development mode: Returning original URL without presigned URL");
          return res.json({ url: imageUrl });
        }
        if (isProduction2) {
          try {
            if (!isR2Configured()) {
              logger.warn("R2 not configured, returning original URL");
              return res.json({ url: imageUrl });
            }
            const isPublic = imageUrl.includes("/public/") || imageUrl.includes("/kitchens/");
            if (!isPublic) {
              if (!user) {
                return res.status(401).json({ error: "Not authenticated" });
              }
              logger.info(`\u2705 Presigned URL request from authenticated user: ${user.id} (${user.role || "no role"})`);
            }
            const presignedUrl = await getPresignedUrl(imageUrl, 3600);
            return res.json({ url: presignedUrl });
          } catch (error) {
            logger.error("Error generating presigned URL, falling back to original URL:", {
              error: error instanceof Error ? error.message : "Unknown error",
              imageUrl
            });
            return res.json({ url: imageUrl });
          }
        }
        return res.json({ url: imageUrl });
      } catch (error) {
        logger.error("Error in presigned URL endpoint:", error);
        return res.status(500).json({
          error: "Failed to generate presigned URL",
          details: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    router13.get("/images/r2/:path(*)", async (req, res) => {
      try {
        const pathParam = req.params.path;
        if (!pathParam) {
          return res.status(400).send("Missing path parameter");
        }
        const decodedPath = decodeURIComponent(pathParam);
        const isPublicPath = decodedPath.includes("public/") || decodedPath.includes("kitchens/");
        const isImageFile = /\.(jpg|jpeg|png|gif|webp|svg|ico)$/i.test(decodedPath);
        const isPublic = isPublicPath || isImageFile;
        logger.info(`[R2 Images Proxy] Auth check - neonUser: ${req.neonUser?.id || "none"}, role: ${req.neonUser?.role || "none"}, isPublic: ${isPublic}, path: ${decodedPath}`);
        if (!isPublic && !req.neonUser) {
          logger.info(`[R2 Images Proxy] Unauthorized access attempt for protected file: ${decodedPath}`);
          return res.status(401).send("Authentication required for protected files");
        }
        const fullR2Url = `https://files.localcooks.ca/${decodedPath}`;
        logger.info(`[R2 Images Proxy] Request for: ${decodedPath} (user: ${req.neonUser?.id || "anonymous"}, role: ${req.neonUser?.role || "none"})`);
        const presignedUrl = await getPresignedUrl(fullR2Url);
        res.redirect(307, presignedUrl);
      } catch (error) {
        logger.error("[R2 Images Proxy] Error:", error);
        res.status(404).send("File not found or access denied");
      }
    });
    router13.get("/r2-proxy", async (req, res) => {
      try {
        const { url, filename } = req.query;
        let targetUrl;
        if (filename && typeof filename === "string") {
          const isImage = /\.(jpg|jpeg|png|gif|webp|svg|ico)$/i.test(filename);
          const folder = isImage ? "images" : "documents";
          targetUrl = `https://files.localcooks.ca/${folder}/${filename}`;
          logger.info(`[R2 Proxy] Resolved filename "${filename}" to: ${targetUrl}`);
        } else if (url && typeof url === "string") {
          targetUrl = url;
        } else {
          return res.status(400).send("Missing url or filename parameter");
        }
        if (!isAllowedR2Url(targetUrl)) {
          logger.warn(`[R2 Proxy] SSRF blocked: ${targetUrl}`);
          return res.status(400).send("Invalid URL domain");
        }
        const isPublicPath = targetUrl.includes("/public/") || targetUrl.includes("/kitchens/");
        const isImageFile = /\.(jpg|jpeg|png|gif|webp|svg|ico)(\?|$)/i.test(targetUrl);
        const isPublic = isPublicPath || isImageFile;
        logger.info(`[R2 Proxy] Auth check - neonUser: ${req.neonUser?.id || "none"}, role: ${req.neonUser?.role || "none"}, isPublic: ${isPublic}, isImage: ${isImageFile}`);
        if (!isPublic && !req.neonUser) {
          logger.info(`[R2 Proxy] Unauthorized access attempt for protected file: ${targetUrl}`);
          return res.status(401).send("Authentication required for protected files");
        }
        logger.info(`[R2 Proxy] Request for: ${targetUrl} (user: ${req.neonUser?.id || "anonymous"}, role: ${req.neonUser?.role || "none"}, public: ${isPublic})`);
        const presignedUrl = await getPresignedUrl(targetUrl);
        res.redirect(307, presignedUrl);
      } catch (error) {
        logger.error("[R2 Proxy] Error:", error);
        res.status(500).send("Failed to proxy image");
      }
    });
    router13.get("/r2-presigned", async (req, res) => {
      try {
        const { url } = req.query;
        if (!url || typeof url !== "string") {
          return res.status(400).json({ error: "Missing or invalid url parameter" });
        }
        const isPublicPath = url.includes("/public/") || url.includes("/kitchens/");
        const isImageFile = /\.(jpg|jpeg|png|gif|webp|svg|ico)(\?|$)/i.test(url);
        const isPublic = isPublicPath || isImageFile;
        logger.info(`[R2 Presigned] Auth check - neonUser: ${req.neonUser?.id || "none"}, role: ${req.neonUser?.role || "none"}, isPublic: ${isPublic}, isImage: ${isImageFile}`);
        if (!isPublic && !req.neonUser) {
          logger.info(`[R2 Presigned] Unauthorized access attempt for protected file: ${url}`);
          return res.status(401).json({ error: "Not authenticated" });
        }
        logger.info(`[R2 Presigned] Request for: ${url} (user: ${req.neonUser?.id || "anonymous"}, role: ${req.neonUser?.role || "none"}, public: ${isPublic})`);
        const presignedUrl = await getPresignedUrl(url);
        return res.json({ url: presignedUrl });
      } catch (error) {
        logger.error("[R2 Presigned] Error:", error);
        res.status(500).json({ error: "Failed to generate presigned URL" });
      }
    });
    isVercel3 = !!process.env.VERCEL;
    if (!isVercel3) {
      router13.use("/documents", express.static(path2.join(process.cwd(), "uploads/documents")));
    }
    router13.get("/documents/:filename", optionalFirebaseAuth, async (req, res) => {
      try {
        let userId = null;
        let userRole = null;
        if (req.neonUser) {
          userId = req.neonUser.id;
          userRole = req.neonUser.role || null;
        } else if (req.query.token && typeof req.query.token === "string") {
          try {
            const { verifyFirebaseToken: verifyFirebaseToken2 } = await Promise.resolve().then(() => (init_firebase_setup(), firebase_setup_exports));
            const decodedToken = await verifyFirebaseToken2(req.query.token);
            if (decodedToken) {
              const neonUser = await userService.getUserByFirebaseUid(decodedToken.uid);
              if (neonUser) {
                userId = neonUser.id;
                userRole = neonUser.role || null;
              }
            }
          } catch (error) {
            logger.error("Error verifying query token:", error);
          }
        }
        const filename = req.params.filename;
        if (!userId) {
          logger.info("[FILE ACCESS] Authentication failed for:", filename);
          return res.status(401).json({
            message: "Not authenticated",
            hint: "Files must be accessed with authentication. Use the presigned URL endpoint or include an auth token."
          });
        }
        logger.info("[FILE ACCESS] Authenticated user:", userId, "role:", userRole, "accessing:", filename);
        const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
        if (filename.startsWith("http://") || filename.startsWith("https://")) {
          if (isProduction2) {
            try {
              if (isR2Configured()) {
                const urlParts = filename.split("/");
                const fileUserIdMatch = urlParts.find((part) => /^\d+$/.test(part));
                const fileUserId2 = fileUserIdMatch ? parseInt(fileUserIdMatch) : null;
                if (fileUserId2 && userId !== fileUserId2 && userRole !== "admin" && userRole !== "manager") {
                  return res.status(403).json({ message: "Access denied" });
                }
                const presignedUrl = await getPresignedUrl(filename, 3600);
                return res.redirect(presignedUrl);
              }
            } catch (error) {
              logger.error("Error generating presigned URL:", error);
              return res.status(500).json({ message: "Error accessing file" });
            }
          }
        }
        const filePath = path2.join(process.cwd(), "uploads", "documents", filename);
        const filenameParts = filename.split("_");
        let fileUserId = null;
        let isPublicAccess = false;
        if (filenameParts[0] === "unknown") {
          if (userRole === "admin" || userRole === "manager") {
            isPublicAccess = true;
          }
        } else {
          const userIdMatch = filenameParts[0].match(/^\d+$/);
          if (userIdMatch) {
            fileUserId = parseInt(userIdMatch[0]);
          }
        }
        const isOwner = fileUserId !== null && userId === fileUserId;
        const isAdminOrManager = userRole === "admin" || userRole === "manager";
        if (!isOwner && !isAdminOrManager) {
          try {
            const searchPattern = `%${filename}`;
            const { kitchens: kitchens3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
            const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
            const { or: or7, like, sql: sql22 } = await import("drizzle-orm");
            const [kitchenMatch] = await db2.select({ id: kitchens3.id }).from(kitchens3).where(
              or7(
                like(kitchens3.imageUrl, searchPattern),
                sql22`${kitchens3.galleryImages} @> ${JSON.stringify([`/api/files/documents/${filename}`])}::jsonb`,
                // also try with just filename if that's how it's stored in array
                sql22`${kitchens3.galleryImages} @> ${JSON.stringify([filename])}::jsonb`
              )
            ).limit(1);
            if (kitchenMatch) {
              logger.info(`[FILE ACCESS] Public access granted for kitchen image: ${filename}`);
              isPublicAccess = true;
            }
          } catch (dbError) {
            logger.error("Error checking public access:", dbError);
          }
        }
        if (!isOwner && !isAdminOrManager && !isPublicAccess) {
          return res.status(403).json({ message: "Access denied" });
        }
        if (fs5.existsSync(filePath)) {
          const stat = fs5.statSync(filePath);
          const ext = path2.extname(filename).toLowerCase();
          let contentType = "application/octet-stream";
          if (ext === ".pdf") contentType = "application/pdf";
          else if ([".jpg", ".jpeg"].includes(ext)) contentType = "image/jpeg";
          else if (ext === ".png") contentType = "image/png";
          else if (ext === ".webp") contentType = "image/webp";
          res.setHeader("Content-Type", contentType);
          res.setHeader("Content-Length", stat.size);
          res.setHeader("Content-Disposition", `inline; filename="${filename}"`);
          const readStream = fs5.createReadStream(filePath);
          readStream.pipe(res);
        } else {
          const isProduction3 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
          const { getPresignedUrl: getPresignedUrl2, isR2Configured: isR2Configured2 } = await Promise.resolve().then(() => (init_r2_storage(), r2_storage_exports));
          if (isR2Configured2()) {
            try {
              const fakeUrl = `https://r2.localcooks.com/documents/${filename}`;
              const presignedUrl = await getPresignedUrl2(fakeUrl, 3600);
              logger.info(`[FILE ACCESS] Redirecting to R2 for: ${filename}`);
              return res.redirect(307, presignedUrl);
            } catch (r2Error) {
              logger.error("[FILE ACCESS] R2 fallback failed:", r2Error);
              return res.status(404).json({ message: "File not found" });
            }
          } else {
            return res.status(404).json({ message: "File not found" });
          }
        }
      } catch (error) {
        logger.error("Error serving file:", error);
        return res.status(500).json({ message: "Internal server error" });
      }
    });
    files_default = router13;
  }
});

// server/sms.ts
var sms_exports = {};
__export(sms_exports, {
  formatPhoneNumber: () => formatPhoneNumber,
  generateChefBookingCancellationSMS: () => generateChefBookingCancellationSMS,
  generateChefBookingConfirmationSMS: () => generateChefBookingConfirmationSMS,
  generateChefSelfCancellationSMS: () => generateChefSelfCancellationSMS,
  generateManagerBookingCancellationSMS: () => generateManagerBookingCancellationSMS,
  generateManagerBookingSMS: () => generateManagerBookingSMS,
  generateManagerPortalBookingSMS: () => generateManagerPortalBookingSMS,
  generatePortalUserBookingCancellationSMS: () => generatePortalUserBookingCancellationSMS,
  generatePortalUserBookingConfirmationSMS: () => generatePortalUserBookingConfirmationSMS,
  sendSMS: () => sendSMS,
  testSMS: () => testSMS
});
import twilio from "twilio";
var getSMSConfig, formatPhoneNumber, sendSMS, generateManagerBookingSMS, generateManagerPortalBookingSMS, generateChefBookingConfirmationSMS, generateChefBookingCancellationSMS, generatePortalUserBookingConfirmationSMS, generatePortalUserBookingCancellationSMS, generateManagerBookingCancellationSMS, generateChefSelfCancellationSMS, testSMS;
var init_sms = __esm({
  "server/sms.ts"() {
    "use strict";
    init_logger();
    getSMSConfig = () => {
      const accountSid = process.env.TWILIO_ACCOUNT_SID;
      const authToken = process.env.TWILIO_AUTH_TOKEN;
      const fromNumber = process.env.TWILIO_PHONE_NUMBER;
      if (!accountSid || !authToken || !fromNumber) {
        const missing = [];
        if (!accountSid) missing.push("TWILIO_ACCOUNT_SID");
        if (!authToken) missing.push("TWILIO_AUTH_TOKEN");
        if (!fromNumber) missing.push("TWILIO_PHONE_NUMBER");
        logger.warn("\u26A0\uFE0F Twilio configuration is missing. SMS functionality will be disabled.");
        logger.warn(`   Missing variables: ${missing.join(", ")}`);
        logger.warn("   Please set these environment variables to enable SMS functionality.");
        return null;
      }
      if (!fromNumber.startsWith("+")) {
        logger.warn(`\u26A0\uFE0F TWILIO_PHONE_NUMBER should be in E.164 format (e.g., +14161234567 for Canada, +12125551234 for US). Current value: ${fromNumber}`);
      }
      if (fromNumber.startsWith("+1") && fromNumber.length === 12) {
        const areaCode = fromNumber.substring(2, 5);
        const firstDigit = parseInt(areaCode[0]);
        if (firstDigit >= 2 && firstDigit <= 9) {
          logger.info(`\u2705 Twilio phone number detected as North American (US/Canada): ${fromNumber}`);
        }
      }
      return {
        accountSid,
        authToken,
        fromNumber
      };
    };
    formatPhoneNumber = (phone) => {
      if (!phone) return null;
      const trimmed = phone.trim();
      if (!trimmed) return null;
      const cleaned = trimmed.replace(/[^\d+]/g, "");
      if (cleaned.startsWith("+")) {
        const digitsAfterPlus = cleaned.substring(1);
        if (digitsAfterPlus.length >= 1 && digitsAfterPlus.length <= 15 && /^\d+$/.test(digitsAfterPlus)) {
          return cleaned;
        }
        logger.warn(`\u26A0\uFE0F Invalid E.164 format (must be + followed by 1-15 digits): ${phone}`);
        return null;
      }
      const digitsOnly = cleaned.replace(/\D/g, "");
      if (digitsOnly.length === 11 && digitsOnly.startsWith("1")) {
        return `+${digitsOnly}`;
      }
      if (digitsOnly.length === 10) {
        const areaCode = digitsOnly.substring(0, 3);
        const exchangeCode = digitsOnly.substring(3, 6);
        const firstDigit = parseInt(digitsOnly[0]);
        const fourthDigit = parseInt(digitsOnly[3]);
        if (firstDigit >= 2 && firstDigit <= 9 && fourthDigit >= 2 && fourthDigit <= 9) {
          return `+1${digitsOnly}`;
        } else {
          logger.warn(`\u26A0\uFE0F Invalid North American phone number format: ${phone}`);
          logger.warn("   Area code and exchange code must start with digits 2-9");
          return null;
        }
      }
      logger.warn(`\u26A0\uFE0F Could not format phone number: ${phone} (digits only: ${digitsOnly}, length: ${digitsOnly.length})`);
      logger.warn("   Phone numbers should be in E.164 format (e.g., +14161234567 for Canada, +12125551234 for US)");
      logger.warn("   Or 10-digit North American numbers (e.g., 4161234567 for Canada, 2125551234 for US)");
      return null;
    };
    sendSMS = async (to, message, options) => {
      const startTime = Date.now();
      try {
        const config = getSMSConfig();
        if (!config) {
          logger.warn("\u26A0\uFE0F SMS not sent - Twilio configuration missing");
          return false;
        }
        const formattedPhone = formatPhoneNumber(to);
        if (!formattedPhone) {
          logger.error(`\u274C SMS not sent - Invalid phone number: ${to}`);
          logger.error("   Phone numbers should be in E.164 format (e.g., +14161234567 for Canada, +12125551234 for US)");
          logger.error("   Or 10-digit North American numbers (e.g., 4161234567 for Canada, 2125551234 for US)");
          return false;
        }
        if (message.length > 1600) {
          logger.warn(`\u26A0\uFE0F SMS message is ${message.length} characters (limit: 1600). Message will be split into multiple parts.`);
        }
        const client = twilio(config.accountSid, config.authToken);
        const formattedFrom = formatPhoneNumber(config.fromNumber);
        if (!formattedFrom) {
          logger.error(`\u274C SMS not sent - Invalid TWILIO_PHONE_NUMBER format: ${config.fromNumber}`);
          logger.error("   TWILIO_PHONE_NUMBER must be in E.164 format (e.g., +1234567890)");
          return false;
        }
        const messageResult = await client.messages.create({
          body: message,
          from: formattedFrom,
          // Use formatted from number
          to: formattedPhone
        });
        const duration = Date.now() - startTime;
        logger.info(`\u2705 SMS sent successfully:`, {
          to: formattedPhone,
          messageSid: messageResult.sid,
          status: messageResult.status,
          duration: `${duration}ms`,
          trackingId: options?.trackingId || `auto_${Date.now()}`,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        return true;
      } catch (error) {
        const duration = Date.now() - startTime;
        const errorMessage = error instanceof Error ? error.message : String(error);
        const errorDetails = {
          to,
          formattedTo: formatPhoneNumber(to),
          error: errorMessage,
          duration: `${duration}ms`,
          trackingId: options?.trackingId || `auto_${Date.now()}`,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
        if (error && typeof error === "object" && "code" in error) {
          errorDetails.twilioCode = error.code;
          errorDetails.twilioMessage = error.message;
          errorDetails.twilioStatus = error.status;
          errorDetails.twilioMoreInfo = error.moreInfo;
        }
        logger.error(`\u274C SMS sending failed:`, errorDetails);
        if (error && typeof error === "object" && "code" in error) {
          const twilioCode = error.code;
          switch (twilioCode) {
            case 21211:
              logger.error("   \u2192 Invalid phone number format. Ensure phone numbers are in E.164 format (e.g., +1234567890)");
              break;
            case 21212:
              logger.error("   \u2192 Invalid phone number. The number provided is not a valid phone number.");
              break;
            case 21408:
              logger.error("   \u2192 Permission denied. Check your Twilio account permissions.");
              break;
            case 21608:
              logger.error("   \u2192 Unsubscribed recipient. The recipient has opted out of receiving messages.");
              break;
            case 21610:
              logger.error('   \u2192 Invalid "from" phone number. Check TWILIO_PHONE_NUMBER is correct and verified in Twilio.');
              break;
            case 21614:
              logger.error('   \u2192 "To" number is not a valid mobile number.');
              break;
            case 30003:
              logger.error("   \u2192 Unreachable destination. The phone number may be invalid or unreachable.");
              break;
            case 30004:
              logger.error("   \u2192 Message blocked. The message may be blocked by carrier or Twilio.");
              break;
            case 30005:
              logger.error("   \u2192 Unknown destination. The destination number is not recognized.");
              break;
            case 30006:
              logger.error("   \u2192 Landline or unreachable. The number may be a landline that cannot receive SMS.");
              break;
            default:
              logger.error(`   \u2192 Twilio error code: ${twilioCode}. Check Twilio documentation for details.`);
          }
        }
        return false;
      }
    };
    generateManagerBookingSMS = (data) => {
      const date2 = new Date(data.bookingDate).toLocaleDateString();
      return `New kitchen booking from ${data.chefName}:

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}

Please check your dashboard to confirm or manage this booking.

We've also sent you an email. If not found, please check your spam folder.`;
    };
    generateManagerPortalBookingSMS = (data) => {
      const date2 = new Date(data.bookingDate).toLocaleDateString();
      return `New kitchen booking from portal user ${data.portalUserName}:

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}

Please check your dashboard to confirm or manage this booking.

We've also sent you an email. If not found, please check your spam folder.`;
    };
    generateChefBookingConfirmationSMS = (data) => {
      const date2 = new Date(data.bookingDate).toLocaleDateString();
      return `Your kitchen booking has been confirmed!

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}

See you there!

We've also sent you an email. If not found, please check your spam folder.`;
    };
    generateChefBookingCancellationSMS = (data) => {
      const date2 = new Date(data.bookingDate).toLocaleDateString();
      const reasonText = data.reason ? `
Reason: ${data.reason}` : "";
      return `Your kitchen booking has been cancelled.

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}${reasonText}

Please contact the manager if you have questions.

We've also sent you an email. If not found, please check your spam folder.`;
    };
    generatePortalUserBookingConfirmationSMS = (data) => {
      const date2 = new Date(data.bookingDate).toLocaleDateString();
      return `Your kitchen booking has been confirmed!

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}

See you there!

We've also sent you an email. If not found, please check your spam folder.`;
    };
    generatePortalUserBookingCancellationSMS = (data) => {
      const date2 = new Date(data.bookingDate).toLocaleDateString();
      const reasonText = data.reason ? `
Reason: ${data.reason}` : "";
      return `Your kitchen booking has been cancelled.

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}${reasonText}

Please contact the manager if you have questions.

We've also sent you an email. If not found, please check your spam folder.`;
    };
    generateManagerBookingCancellationSMS = (data) => {
      const date2 = new Date(data.bookingDate).toLocaleDateString();
      return `Chef ${data.chefName} has cancelled their booking:

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}

Please check your dashboard for details.

We've also sent you an email. If not found, please check your spam folder.`;
    };
    generateChefSelfCancellationSMS = (data) => {
      const date2 = new Date(data.bookingDate).toLocaleDateString();
      return `Your kitchen booking has been cancelled:

Kitchen: ${data.kitchenName}
Date: ${date2}
Time: ${data.startTime} - ${data.endTime}

If you need to book again, please visit the dashboard.

We've also sent you an email. If not found, please check your spam folder.`;
    };
    testSMS = async (to) => {
      try {
        const config = getSMSConfig();
        if (!config) {
          return {
            success: false,
            message: "Twilio configuration is missing. Please set TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, and TWILIO_PHONE_NUMBER environment variables."
          };
        }
        const formattedPhone = formatPhoneNumber(to);
        if (!formattedPhone) {
          return {
            success: false,
            message: `Invalid phone number format: ${to}. Phone numbers should be in E.164 format (e.g., +14161234567 for Canada, +12125551234 for US) or 10-digit North American numbers.`
          };
        }
        const formattedFrom = formatPhoneNumber(config.fromNumber);
        if (!formattedFrom) {
          return {
            success: false,
            message: `Invalid TWILIO_PHONE_NUMBER format: ${config.fromNumber}. Must be in E.164 format (e.g., +1234567890).`
          };
        }
        const client = twilio(config.accountSid, config.authToken);
        const testMessage = "Test SMS from Local Cooks Community. If you received this, SMS is working correctly!";
        const messageResult = await client.messages.create({
          body: testMessage,
          from: formattedFrom,
          to: formattedPhone
        });
        return {
          success: true,
          message: "SMS sent successfully!",
          details: {
            messageSid: messageResult.sid,
            status: messageResult.status,
            to: formattedPhone,
            from: formattedFrom
          }
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        const details = { error: errorMessage };
        if (error && typeof error === "object" && "code" in error) {
          details.twilioCode = error.code;
          details.twilioMessage = error.message;
          details.twilioStatus = error.status;
        }
        return {
          success: false,
          message: `SMS test failed: ${errorMessage}`,
          details
        };
      }
    };
  }
});

// shared/timezone-utils.ts
import { TZDate } from "@date-fns/tz";
import { format as format3, isBefore, isAfter, isWithinInterval } from "date-fns";
var DEFAULT_TIMEZONE;
var init_timezone_utils = __esm({
  "shared/timezone-utils.ts"() {
    "use strict";
    DEFAULT_TIMEZONE = "America/St_Johns";
  }
});

// server/api-response.ts
function errorResponse(res, error, statusCode = 500) {
  const message = process.env.NODE_ENV === "production" ? "An unexpected error occurred" : error?.message || "Unknown error";
  logger.error("[API Error]", error);
  return res.status(statusCode).json({ error: message });
}
var init_api_response = __esm({
  "server/api-response.ts"() {
    "use strict";
    init_logger();
  }
});

// server/config.ts
function getAppBaseUrl(subdomain = "main") {
  const isDev = process.env.NODE_ENV === "development";
  const isVercel4 = !!process.env.VERCEL;
  const isVercelPreview2 = process.env.VERCEL_ENV === "preview";
  if (isDev && !isVercel4) {
    const port = process.env.PORT || "5001";
    if (subdomain === "main" || !subdomain) {
      return `http://localhost:${port}`;
    }
    return `http://${subdomain}.localhost:${port}`;
  }
  const baseDomain = process.env.APP_BASE_DOMAIN || "localcooks.ca";
  const prefix = isVercelPreview2 ? "dev-" : "";
  if (subdomain === "main" || !subdomain) {
    return isVercelPreview2 ? `https://dev.${baseDomain}` : `https://${baseDomain}`;
  }
  return `https://${prefix}${subdomain}.${baseDomain}`;
}
var init_config = __esm({
  "server/config.ts"() {
    "use strict";
  }
});

// server/domains/bookings/booking.repository.ts
import { eq as eq17, and as and11, desc as desc9, asc as asc2, lt as lt2, not as not2, or as or2, sql as sql9, ne as ne2 } from "drizzle-orm";
function getKitchenBookingSelection() {
  return {
    id: kitchenBookings.id,
    referenceCode: kitchenBookings.referenceCode,
    chefId: kitchenBookings.chefId,
    kitchenId: kitchenBookings.kitchenId,
    bookingDate: kitchenBookings.bookingDate,
    startTime: kitchenBookings.startTime,
    endTime: kitchenBookings.endTime,
    status: kitchenBookings.status,
    specialNotes: kitchenBookings.specialNotes,
    bookingType: kitchenBookings.bookingType,
    totalPrice: kitchenBookings.totalPrice,
    // string in DB
    hourlyRate: kitchenBookings.hourlyRate,
    durationHours: kitchenBookings.durationHours,
    paymentStatus: kitchenBookings.paymentStatus,
    createdAt: kitchenBookings.createdAt,
    cancellationRequestedAt: kitchenBookings.cancellationRequestedAt
  };
}
function getStorageBookingSelection() {
  return {
    id: storageBookings.id,
    referenceCode: storageBookings.referenceCode,
    storageListingId: storageBookings.storageListingId,
    kitchenBookingId: storageBookings.kitchenBookingId,
    chefId: storageBookings.chefId,
    startDate: storageBookings.startDate,
    endDate: storageBookings.endDate,
    status: storageBookings.status,
    totalPrice: storageBookings.totalPrice,
    pricingModel: storageBookings.pricingModel,
    paymentStatus: storageBookings.paymentStatus,
    paymentIntentId: storageBookings.paymentIntentId,
    serviceFee: storageBookings.serviceFee,
    currency: storageBookings.currency,
    createdAt: storageBookings.createdAt,
    updatedAt: storageBookings.updatedAt,
    // Checkout workflow fields (hybrid verification system)
    checkoutStatus: storageBookings.checkoutStatus,
    checkoutRequestedAt: storageBookings.checkoutRequestedAt,
    checkoutApprovedAt: storageBookings.checkoutApprovedAt,
    checkoutDeniedAt: storageBookings.checkoutDeniedAt,
    checkoutDenialReason: storageBookings.checkoutDenialReason,
    checkoutNotes: storageBookings.checkoutNotes,
    checkoutPhotoUrls: storageBookings.checkoutPhotoUrls,
    cancellationRequestedAt: storageBookings.cancellationRequestedAt
  };
}
var BookingRepository;
var init_booking_repository = __esm({
  "server/domains/bookings/booking.repository.ts"() {
    "use strict";
    init_db();
    init_reference_code();
    init_schema();
    BookingRepository = class {
      // ===== DTO MAPPING HELPERS =====
      // Postgres numeric columns are returned as strings by node-postgres.
      // These helpers cast them to JavaScript numbers for frontend compatibility.
      mapKitchenBookingToDTO(row) {
        if (!row) return null;
        return {
          ...row,
          totalPrice: row.totalPrice ? parseFloat(row.totalPrice) : null,
          hourlyRate: row.hourlyRate ? parseFloat(row.hourlyRate) : null,
          durationHours: row.durationHours ? parseFloat(row.durationHours) : null,
          serviceFee: row.serviceFee ? parseFloat(row.serviceFee) : null,
          damageDeposit: row.damageDeposit ? parseFloat(row.damageDeposit) : null
        };
      }
      mapStorageBookingToDTO(row) {
        if (!row) return null;
        return {
          ...row,
          totalPrice: row.totalPrice ? parseFloat(row.totalPrice) : null,
          serviceFee: row.serviceFee ? parseFloat(row.serviceFee) : null,
          basePrice: row.basePrice ? parseFloat(row.basePrice) : null
        };
      }
      mapEquipmentBookingToDTO(row) {
        if (!row) return null;
        return {
          ...row,
          totalPrice: row.totalPrice ? parseFloat(row.totalPrice) : null,
          damageDeposit: row.damageDeposit ? parseFloat(row.damageDeposit) : null,
          serviceFee: row.serviceFee ? parseFloat(row.serviceFee) : null
        };
      }
      // ===== KITCHEN BOOKINGS =====
      async createKitchenBooking(data) {
        const [booking] = await db.insert(kitchenBookings).values(data).returning();
        return this.mapKitchenBookingToDTO(booking);
      }
      async getKitchenBookingById(id) {
        const [booking] = await db.select().from(kitchenBookings).where(eq17(kitchenBookings.id, id));
        return this.mapKitchenBookingToDTO(booking);
      }
      async updateKitchenBooking(id, updates) {
        const [updated] = await db.update(kitchenBookings).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq17(kitchenBookings.id, id)).returning();
        return this.mapKitchenBookingToDTO(updated);
      }
      async getKitchenBookingsByKitchenId(kitchenId) {
        const rows = await db.select().from(kitchenBookings).where(eq17(kitchenBookings.kitchenId, kitchenId));
        return rows.map((row) => this.mapKitchenBookingToDTO(row));
      }
      async getKitchenBookingsByChefId(chefId) {
        const results = await db.select({
          booking: kitchenBookings,
          kitchen: kitchens,
          location: locations,
          // Payment transaction data for accurate payment state display
          transactionStatus: paymentTransactions.status,
          transactionAmount: paymentTransactions.amount,
          transactionRefundAmount: paymentTransactions.refundAmount
        }).from(kitchenBookings).innerJoin(kitchens, eq17(kitchenBookings.kitchenId, kitchens.id)).innerJoin(locations, eq17(kitchens.locationId, locations.id)).leftJoin(paymentTransactions, and11(
          eq17(paymentTransactions.bookingId, kitchenBookings.id),
          eq17(paymentTransactions.paymentIntentId, kitchenBookings.paymentIntentId),
          or2(
            eq17(paymentTransactions.bookingType, "kitchen"),
            eq17(paymentTransactions.bookingType, "bundle")
          )
        )).where(eq17(kitchenBookings.chefId, chefId)).orderBy(desc9(kitchenBookings.createdAt));
        return results.map((row) => {
          const mappedBooking = this.mapKitchenBookingToDTO(row.booking);
          const transactionStatus = row.transactionStatus || null;
          const isVoidedAuthorization = transactionStatus === "canceled";
          const isAuthorizedHold = mappedBooking.paymentStatus === "authorized";
          const rawTransactionAmount = row.transactionAmount ? parseFloat(row.transactionAmount) : null;
          const originalAuthorizedAmount = isVoidedAuthorization ? rawTransactionAmount ?? mappedBooking.totalPrice : null;
          const refundAmount = isVoidedAuthorization ? 0 : row.transactionRefundAmount ? parseFloat(row.transactionRefundAmount) : 0;
          return {
            ...mappedBooking,
            kitchen: row.kitchen,
            location: row.location,
            kitchenName: row.kitchen.name,
            locationName: row.location.name,
            locationTimezone: row.location.timezone,
            // â”€â”€ Payment State Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            isVoidedAuthorization,
            // true when PT was canceled before capture â€” $0 charged
            isAuthorizedHold,
            // true when payment is held but not yet captured
            originalAuthorizedAmount,
            // Original auth amount for voided display context
            refundAmount,
            // Actual refund amount in cents (for display)
            // â”€â”€ Tax-inclusive amount from PT (what chef actually paid/authorized) â”€â”€
            // kb.total_price is pre-tax subtotal; PT.amount is the tax-inclusive charge
            chargedAmount: rawTransactionAmount
            // null if no PT record
          };
        });
      }
      async getBookingsByManagerId(managerId) {
        const results = await db.select({
          booking: kitchenBookings,
          kitchen: kitchens,
          location: locations,
          chef: users,
          // Chef's full name from chef_kitchen_applications table
          chefFullName: chefKitchenApplications.fullName,
          // Kitchen tax rate for revenue calculations
          taxRatePercent: kitchens.taxRatePercent,
          // Payment transaction data for accurate display (actual Stripe data)
          transactionId: paymentTransactions.id,
          transactionAmount: paymentTransactions.amount,
          transactionServiceFee: paymentTransactions.serviceFee,
          transactionManagerRevenue: paymentTransactions.managerRevenue,
          transactionStatus: paymentTransactions.status,
          transactionRefundAmount: paymentTransactions.refundAmount,
          transactionStripeProcessingFee: paymentTransactions.stripeProcessingFee
        }).from(kitchenBookings).innerJoin(kitchens, eq17(kitchenBookings.kitchenId, kitchens.id)).innerJoin(locations, eq17(kitchens.locationId, locations.id)).leftJoin(users, eq17(kitchenBookings.chefId, users.id)).leftJoin(chefKitchenApplications, and11(
          eq17(chefKitchenApplications.chefId, kitchenBookings.chefId),
          eq17(chefKitchenApplications.locationId, locations.id)
        )).leftJoin(paymentTransactions, and11(
          eq17(paymentTransactions.bookingId, kitchenBookings.id),
          eq17(paymentTransactions.paymentIntentId, kitchenBookings.paymentIntentId),
          // Include both 'kitchen' and 'bundle' booking types for accurate payment data
          or2(
            eq17(paymentTransactions.bookingType, "kitchen"),
            eq17(paymentTransactions.bookingType, "bundle")
          )
        )).where(and11(
          eq17(locations.managerId, managerId),
          // CRITICAL: Only show bookings where payment has been initiated (not abandoned at checkout)
          // 'pending' paymentStatus means chef never completed checkout - don't show to manager
          ne2(kitchenBookings.paymentStatus, "pending")
        )).orderBy(desc9(kitchenBookings.createdAt));
        return results.map((row) => {
          const mappedBooking = this.mapKitchenBookingToDTO(row.booking);
          const transactionStatus = row.transactionStatus || null;
          const isVoidedAuthorization = transactionStatus === "canceled";
          const isAuthorizedHold = mappedBooking.paymentStatus === "authorized";
          const transactionId = row.transactionId || null;
          const rawTransactionAmount = row.transactionAmount ? parseFloat(row.transactionAmount) : null;
          const transactionAmount = isVoidedAuthorization ? 0 : rawTransactionAmount;
          const serviceFee = isVoidedAuthorization ? 0 : row.transactionServiceFee ? parseFloat(row.transactionServiceFee) : 0;
          const managerRevenue = isVoidedAuthorization ? 0 : row.transactionManagerRevenue ? parseFloat(row.transactionManagerRevenue) : null;
          const refundAmount = isVoidedAuthorization ? 0 : row.transactionRefundAmount ? parseFloat(row.transactionRefundAmount) : 0;
          const stripeProcessingFee = isVoidedAuthorization ? 0 : row.transactionStripeProcessingFee ? parseFloat(row.transactionStripeProcessingFee) : 0;
          const kbTotalPrice = mappedBooking.totalPrice || 0;
          const taxRatePercent = row.taxRatePercent ? parseFloat(String(row.taxRatePercent)) : 0;
          const taxAmount = isVoidedAuthorization ? 0 : Math.round(kbTotalPrice * taxRatePercent / 100);
          const totalCharged = transactionAmount ?? kbTotalPrice;
          const netRevenue = isVoidedAuthorization ? 0 : totalCharged - taxAmount - stripeProcessingFee;
          const managerRemainingBalance = isVoidedAuthorization ? 0 : managerRevenue ? Math.max(0, managerRevenue - refundAmount) : 0;
          const refundableAmount = managerRemainingBalance;
          const originalAuthorizedAmount = isVoidedAuthorization ? rawTransactionAmount ?? kbTotalPrice : null;
          return {
            ...mappedBooking,
            kitchen: row.kitchen,
            location: row.location,
            chef: row.chef,
            // Use full name from chef_kitchen_applications if available, otherwise fall back to username (email)
            chefName: row.chefFullName || row.chef?.username,
            kitchenName: row.kitchen.name,
            locationName: row.location.name,
            locationTimezone: row.location.timezone,
            // Include storage and equipment items from JSONB fields
            // ENTERPRISE STANDARD: Keep cancelled items visible (with rejected=true for strikethrough)
            // but filter out 'failed' items (abandoned at checkout, never part of the booking).
            // Cancelled items must remain visible so the Rentals column shows the full audit trail.
            storageItems: (Array.isArray(row.booking.storageItems) ? row.booking.storageItems : []).filter((item) => item.status !== "failed").map((item) => item.status === "cancelled" && !item.rejected ? { ...item, rejected: true } : item),
            equipmentItems: (Array.isArray(row.booking.equipmentItems) ? row.booking.equipmentItems : []).filter((item) => item.status !== "failed").map((item) => item.status === "cancelled" && !item.rejected ? { ...item, rejected: true } : item),
            // Kitchen's tax rate for revenue calculations (consistent with transaction history)
            taxRatePercent,
            // Use actual Stripe transaction data for accurate payment display
            transactionId,
            // Payment transaction ID (for refunds)
            transactionAmount,
            // Actual amount charged (0 for voided auths, captured amount otherwise)
            taxAmount,
            // Tax = kb.total_price * tax_rate / 100 (0 for voided auths)
            serviceFee,
            // Platform fee (from payment_transactions)
            managerRevenue,
            // What manager receives (0 for voided auths)
            netRevenue,
            // Net = transactionAmount - taxAmount - stripeFee (0 for voided auths)
            refundAmount,
            // Amount already refunded (0 for voided auths)
            refundableAmount,
            // SIMPLE: Max refundable = manager's remaining balance (0 for voided auths)
            stripeProcessingFee,
            // Total Stripe processing fee (0 for voided auths)
            managerRemainingBalance,
            // Manager's remaining balance from this transaction (0 for voided auths)
            // â”€â”€ Voided Authorization Context â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // These fields let the client distinguish between "never charged" vs "$0 booking"
            isVoidedAuthorization,
            // true when PT was canceled before capture â€” no money moved
            isAuthorizedHold,
            // true when payment is held but not yet captured
            originalAuthorizedAmount
            // Original auth amount for voided display (e.g., "Hold of $88 released")
          };
        });
      }
      async getBookingsByKitchen(kitchenId) {
        return db.select({
          ...getKitchenBookingSelection(),
          chefName: sql9`COALESCE(${chefKitchenApplications.fullName}, ${users.username})`.as("chef_name"),
          chefEmail: sql9`COALESCE(${chefKitchenApplications.email}, ${users.username})`.as("chef_email")
        }).from(kitchenBookings).innerJoin(kitchens, eq17(kitchenBookings.kitchenId, kitchens.id)).innerJoin(locations, eq17(kitchens.locationId, locations.id)).leftJoin(users, eq17(kitchenBookings.chefId, users.id)).leftJoin(chefKitchenApplications, and11(
          eq17(chefKitchenApplications.chefId, kitchenBookings.chefId),
          eq17(chefKitchenApplications.locationId, locations.id)
        )).where(eq17(kitchenBookings.kitchenId, kitchenId)).orderBy(desc9(kitchenBookings.createdAt));
      }
      async findConflictingBookings(kitchenId, date2, startTime, endTime, excludeBookingId) {
        const dateStr = date2.toISOString().split("T")[0];
        const conditions = [
          eq17(kitchenBookings.kitchenId, kitchenId),
          not2(eq17(kitchenBookings.status, "cancelled")),
          sql9`DATE(${kitchenBookings.bookingDate}) = ${dateStr}::date`,
          sql9`${kitchenBookings.startTime} < ${endTime}`,
          sql9`${kitchenBookings.endTime} > ${startTime}`
        ];
        if (excludeBookingId) {
          conditions.push(not2(eq17(kitchenBookings.id, excludeBookingId)));
        }
        const conflicts = await db.select().from(kitchenBookings).where(and11(...conditions));
        return conflicts;
      }
      // ===== STORAGE BOOKINGS =====
      async createStorageBooking(data) {
        const [booking] = await db.insert(storageBookings).values(data).returning();
        return this.mapStorageBookingToDTO(booking);
      }
      async getStorageBookingsByChefId(chefId) {
        const result = await db.select({
          ...getStorageBookingSelection(),
          storageName: storageListings.name,
          storageType: storageListings.storageType,
          kitchenId: storageListings.kitchenId,
          kitchenName: kitchens.name,
          basePrice: storageListings.basePrice,
          minimumBookingDuration: storageListings.minimumBookingDuration,
          // ENTERPRISE STANDARD: Include location data to prevent "Unknown Location" on chef UI
          locationName: locations.name,
          locationAddress: locations.address
        }).from(storageBookings).innerJoin(storageListings, eq17(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq17(storageListings.kitchenId, kitchens.id)).innerJoin(locations, eq17(kitchens.locationId, locations.id)).where(eq17(storageBookings.chefId, chefId)).orderBy(desc9(storageBookings.createdAt));
        const bookingIds = result.map((r) => r.id);
        const paidPenalties = bookingIds.length > 0 ? await db.select({
          storageBookingId: storageOverstayRecords.storageBookingId,
          status: storageOverstayRecords.status,
          finalPenaltyCents: storageOverstayRecords.finalPenaltyCents,
          calculatedPenaltyCents: storageOverstayRecords.calculatedPenaltyCents,
          daysOverdue: storageOverstayRecords.daysOverdue,
          resolvedAt: storageOverstayRecords.resolvedAt,
          resolutionType: storageOverstayRecords.resolutionType,
          // BACKWARDS COMPATIBILITY: Include additional fields to determine payment status
          chargeSucceededAt: storageOverstayRecords.chargeSucceededAt,
          stripeChargeId: storageOverstayRecords.stripeChargeId
        }).from(storageOverstayRecords).where(
          sql9`${storageOverstayRecords.storageBookingId} IN (${sql9.join(bookingIds.map((id) => sql9`${id}`), sql9`, `)})`
        ) : [];
        const isPenaltyPaid = (p) => {
          return p.status === "charge_succeeded" || !!p.stripeChargeId || p.resolutionType === "paid" || !!p.chargeSucceededAt;
        };
        const penaltyMap = new Map(
          paidPenalties.filter(isPenaltyPaid).map((p) => [p.storageBookingId, p])
        );
        return result.map((row) => {
          const penalty = penaltyMap.get(row.id);
          const dailyRateCents = row.basePrice ? parseFloat(row.basePrice.toString()) : 0;
          const startDate = new Date(row.startDate);
          const endDate = new Date(row.endDate);
          const bookingDays = Math.max(1, Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24)));
          const minDays = row.minimumBookingDuration || 1;
          const effectiveDays = Math.max(bookingDays, minDays);
          const originalBookingPrice = dailyRateCents * effectiveDays / 100;
          return {
            ...row,
            totalPrice: originalBookingPrice,
            // Show calculated price based on current dates
            serviceFee: 0,
            // Don't show service fee to chef
            basePrice: dailyRateCents,
            // Keep as cents for compatibility
            minimumBookingDuration: row.minimumBookingDuration || 1,
            // Paid penalty info (with backwards compatibility for paidAt field)
            paidPenalty: penalty ? {
              amountCents: penalty.finalPenaltyCents || penalty.calculatedPenaltyCents || 0,
              amountDollars: ((penalty.finalPenaltyCents || penalty.calculatedPenaltyCents || 0) / 100).toFixed(2),
              daysOverdue: penalty.daysOverdue,
              paidAt: penalty.chargeSucceededAt || penalty.resolvedAt,
              resolutionType: penalty.resolutionType
            } : null
          };
        });
      }
      async getStorageBookingById(id) {
        const [booking] = await db.select({
          ...getStorageBookingSelection(),
          storageName: storageListings.name,
          storageType: storageListings.storageType,
          kitchenId: storageListings.kitchenId,
          kitchenName: kitchens.name,
          basePrice: storageListings.basePrice,
          minimumBookingDuration: storageListings.minimumBookingDuration
        }).from(storageBookings).innerJoin(storageListings, eq17(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq17(storageListings.kitchenId, kitchens.id)).where(eq17(storageBookings.id, id));
        return this.mapStorageBookingToDTO(booking);
      }
      async updateStorageBooking(id, updates) {
        const [updated] = await db.update(storageBookings).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq17(storageBookings.id, id)).returning();
        return this.mapStorageBookingToDTO(updated);
      }
      async deleteStorageBooking(id) {
        return db.delete(storageBookings).where(eq17(storageBookings.id, id));
      }
      async getStorageBookingsByKitchenBookingId(kitchenBookingId) {
        const rows = await db.select({
          ...getStorageBookingSelection(),
          storageName: storageListings.name,
          storageType: storageListings.storageType,
          kitchenId: storageListings.kitchenId,
          kitchenName: kitchens.name,
          listingBasePrice: storageListings.basePrice,
          minimumBookingDuration: storageListings.minimumBookingDuration
        }).from(storageBookings).innerJoin(storageListings, eq17(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq17(storageListings.kitchenId, kitchens.id)).where(eq17(storageBookings.kitchenBookingId, kitchenBookingId));
        return rows.map((row) => {
          const dailyRateCents = row.listingBasePrice ? parseFloat(row.listingBasePrice.toString()) : 0;
          const startDate = new Date(row.startDate);
          const endDate = new Date(row.endDate);
          const bookingDays = Math.max(1, Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24)));
          const minDays = row.minimumBookingDuration || 1;
          const effectiveDays = Math.max(bookingDays, minDays);
          const basePriceCents = dailyRateCents * effectiveDays;
          return {
            ...this.mapStorageBookingToDTO(row),
            totalPrice: basePriceCents,
            // Override with calculated base price (no service fee)
            serviceFee: 0,
            // Don't expose service fee
            storageName: row.storageName,
            storageType: row.storageType,
            kitchenName: row.kitchenName,
            listingBasePrice: dailyRateCents
            // Daily rate in cents from listing
          };
        });
      }
      async getExpiredStorageBookings(today) {
        return db.select({
          id: storageBookings.id,
          storageListingId: storageBookings.storageListingId,
          chefId: storageBookings.chefId,
          endDate: storageBookings.endDate,
          totalPrice: storageBookings.totalPrice,
          serviceFee: storageBookings.serviceFee,
          paymentStatus: storageBookings.paymentStatus,
          paymentIntentId: storageBookings.paymentIntentId,
          basePrice: storageListings.basePrice,
          minimumBookingDuration: storageListings.minimumBookingDuration
        }).from(storageBookings).innerJoin(storageListings, eq17(storageBookings.storageListingId, storageListings.id)).where(and11(
          lt2(storageBookings.endDate, today),
          not2(eq17(storageBookings.status, "cancelled")),
          not2(eq17(storageBookings.paymentStatus, "failed"))
        )).orderBy(asc2(storageBookings.endDate));
      }
      // ===== PENDING STORAGE EXTENSIONS =====
      async createPendingStorageExtension(data) {
        const extRefCode = await generateReferenceCode("storage_extension");
        const [extension] = await db.insert(pendingStorageExtensions).values({
          referenceCode: extRefCode,
          storageBookingId: data.storageBookingId,
          newEndDate: data.newEndDate,
          extensionDays: data.extensionDays,
          extensionBasePriceCents: data.extensionBasePriceCents,
          extensionServiceFeeCents: data.extensionServiceFeeCents,
          extensionTotalPriceCents: data.extensionTotalPriceCents,
          stripeSessionId: data.stripeSessionId,
          stripePaymentIntentId: data.stripePaymentIntentId,
          status: data.status
        }).returning();
        return extension;
      }
      async getPendingStorageExtension(storageBookingId, stripeSessionId) {
        const [extension] = await db.select().from(pendingStorageExtensions).where(and11(
          eq17(pendingStorageExtensions.storageBookingId, storageBookingId),
          eq17(pendingStorageExtensions.stripeSessionId, stripeSessionId)
        )).limit(1);
        return extension || null;
      }
      async updatePendingStorageExtension(id, updates) {
        const [updated] = await db.update(pendingStorageExtensions).set({
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq17(pendingStorageExtensions.id, id)).returning();
        return updated;
      }
      async getPendingStorageExtensionBySessionId(stripeSessionId) {
        const [extension] = await db.select().from(pendingStorageExtensions).where(eq17(pendingStorageExtensions.stripeSessionId, stripeSessionId)).limit(1);
        return extension || null;
      }
      // ===== EQUIPMENT BOOKINGS =====
      async getEquipmentBookingsByChefId(chefId) {
        const result = await db.select({
          id: equipmentBookings.id,
          equipmentListingId: equipmentBookings.equipmentListingId,
          kitchenBookingId: equipmentBookings.kitchenBookingId,
          chefId: equipmentBookings.chefId,
          startDate: equipmentBookings.startDate,
          endDate: equipmentBookings.endDate,
          status: equipmentBookings.status,
          totalPrice: equipmentBookings.totalPrice,
          pricingModel: equipmentBookings.pricingModel,
          paymentStatus: equipmentBookings.paymentStatus,
          paymentIntentId: equipmentBookings.paymentIntentId,
          damageDeposit: equipmentBookings.damageDeposit,
          serviceFee: equipmentBookings.serviceFee,
          currency: equipmentBookings.currency,
          createdAt: equipmentBookings.createdAt,
          updatedAt: equipmentBookings.updatedAt,
          equipmentType: equipmentListings.equipmentType,
          brand: equipmentListings.brand,
          availabilityType: equipmentListings.availabilityType,
          kitchenId: equipmentListings.kitchenId,
          kitchenName: kitchens.name
        }).from(equipmentBookings).innerJoin(equipmentListings, eq17(equipmentBookings.equipmentListingId, equipmentListings.id)).innerJoin(kitchens, eq17(equipmentListings.kitchenId, kitchens.id)).where(eq17(equipmentBookings.chefId, chefId)).orderBy(desc9(equipmentBookings.createdAt));
        return result.map((row) => ({
          ...row,
          totalPrice: row.totalPrice ? parseFloat(row.totalPrice.toString()) / 100 : 0,
          damageDeposit: row.damageDeposit ? parseFloat(row.damageDeposit.toString()) / 100 : 0,
          serviceFee: row.serviceFee ? parseFloat(row.serviceFee.toString()) / 100 : 0
        }));
      }
      async createEquipmentBooking(data) {
        const [booking] = await db.insert(equipmentBookings).values(data).returning();
        return this.mapEquipmentBookingToDTO(booking);
      }
      async updateEquipmentBooking(id, updates) {
        const [updated] = await db.update(equipmentBookings).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq17(equipmentBookings.id, id)).returning();
        return this.mapEquipmentBookingToDTO(updated);
      }
      async getEquipmentBookingsByKitchenBookingId(kitchenBookingId) {
        const rows = await db.select({
          // Select fields manually as helper doesn't exist
          id: equipmentBookings.id,
          equipmentListingId: equipmentBookings.equipmentListingId,
          kitchenBookingId: equipmentBookings.kitchenBookingId,
          chefId: equipmentBookings.chefId,
          startDate: equipmentBookings.startDate,
          endDate: equipmentBookings.endDate,
          status: equipmentBookings.status,
          totalPrice: equipmentBookings.totalPrice,
          pricingModel: equipmentBookings.pricingModel,
          paymentStatus: equipmentBookings.paymentStatus,
          paymentIntentId: equipmentBookings.paymentIntentId,
          damageDeposit: equipmentBookings.damageDeposit,
          serviceFee: equipmentBookings.serviceFee,
          currency: equipmentBookings.currency,
          createdAt: equipmentBookings.createdAt,
          updatedAt: equipmentBookings.updatedAt,
          // Joined fields
          equipmentType: equipmentListings.equipmentType,
          brand: equipmentListings.brand
        }).from(equipmentBookings).innerJoin(equipmentListings, eq17(equipmentBookings.equipmentListingId, equipmentListings.id)).where(eq17(equipmentBookings.kitchenBookingId, kitchenBookingId));
        return rows.map((row) => ({
          ...this.mapEquipmentBookingToDTO(row),
          equipmentType: row.equipmentType,
          brand: row.brand
        }));
      }
      async deleteEquipmentBooking(id) {
        return db.delete(equipmentBookings).where(eq17(equipmentBookings.id, id));
      }
    };
  }
});

// server/services/pricing-service.ts
var pricing_service_exports = {};
__export(pricing_service_exports, {
  calculateDurationHours: () => calculateDurationHours,
  calculateKitchenBookingPrice: () => calculateKitchenBookingPrice,
  calculatePlatformFee: () => calculatePlatformFee,
  calculatePlatformFeeDynamic: () => calculatePlatformFeeDynamic,
  calculateTax: () => calculateTax,
  calculateTotalWithFees: () => calculateTotalWithFees,
  getKitchenPricing: () => getKitchenPricing,
  getServiceFeeRate: () => getServiceFeeRate
});
import { eq as eq18 } from "drizzle-orm";
function calculateDurationHours(startTime, endTime) {
  const [startHours, startMinutes] = startTime.split(":").map(Number);
  const [endHours, endMinutes] = endTime.split(":").map(Number);
  const startTotalMinutes = startHours * 60 + startMinutes;
  const endTotalMinutes = endHours * 60 + endMinutes;
  const durationMinutes = endTotalMinutes - startTotalMinutes;
  const durationHours = durationMinutes / 60;
  return Math.max(0, durationHours);
}
async function getKitchenPricing(kitchenId) {
  try {
    const [kitchen] = await db.select({
      hourlyRate: kitchens.hourlyRate,
      currency: kitchens.currency,
      minimumBookingHours: kitchens.minimumBookingHours,
      taxRatePercent: kitchens.taxRatePercent
    }).from(kitchens).where(eq18(kitchens.id, kitchenId));
    if (!kitchen) {
      return null;
    }
    const hourlyRateCents = kitchen.hourlyRate ? parseFloat(kitchen.hourlyRate) : 0;
    return {
      hourlyRate: hourlyRateCents,
      currency: kitchen.currency || "CAD",
      minimumBookingHours: kitchen.minimumBookingHours || 1,
      taxRatePercent: kitchen.taxRatePercent ? parseFloat(kitchen.taxRatePercent) : null
    };
  } catch (error) {
    logger.error("Error getting kitchen pricing:", error);
    throw error;
  }
}
async function calculateKitchenBookingPrice(kitchenId, startTime, endTime) {
  try {
    const pricing = await getKitchenPricing(kitchenId);
    if (!pricing || !pricing.hourlyRate || pricing.hourlyRate <= 0) {
      const durationHours2 = calculateDurationHours(startTime, endTime);
      return {
        totalPriceCents: 0,
        durationHours: durationHours2,
        hourlyRateCents: 0,
        currency: pricing?.currency || "CAD",
        taxRatePercent: pricing?.taxRatePercent ?? null,
        taxAmountCents: 0
      };
    }
    const durationHours = calculateDurationHours(startTime, endTime);
    const effectiveDuration = Math.max(durationHours, pricing.minimumBookingHours);
    const basePriceCents = Math.round(pricing.hourlyRate * effectiveDuration);
    const taxAmountCents = calculateTax(basePriceCents, pricing.taxRatePercent ?? null);
    return {
      totalPriceCents: basePriceCents,
      // This is the subtotal
      durationHours: effectiveDuration,
      hourlyRateCents: pricing.hourlyRate,
      currency: pricing.currency,
      taxRatePercent: pricing.taxRatePercent ?? null,
      taxAmountCents
      // New field
    };
  } catch (error) {
    logger.error("Error calculating kitchen booking price:", error);
    throw error;
  }
}
async function getServiceFeeRate() {
  try {
    const [setting] = await db.select({ value: platformSettings.value }).from(platformSettings).where(eq18(platformSettings.key, "service_fee_rate"));
    if (!setting) {
      return 0.05;
    }
    const rate = parseFloat(setting.value);
    if (isNaN(rate) || rate < 0 || rate > 1) {
      return 0.05;
    }
    return rate;
  } catch (error) {
    logger.error("Error getting service fee rate from platform_settings:", error);
    return 0.05;
  }
}
function calculatePlatformFee(basePriceCents, commissionRate = 0.05) {
  return Math.round(basePriceCents * commissionRate);
}
async function calculatePlatformFeeDynamic(basePriceCents) {
  const rate = await getServiceFeeRate();
  return calculatePlatformFee(basePriceCents, rate);
}
function calculateTax(basePriceCents, taxRatePercent) {
  if (!taxRatePercent || taxRatePercent <= 0) {
    return 0;
  }
  return Math.round(basePriceCents * (taxRatePercent / 100));
}
function calculateTotalWithFees(basePriceCents, serviceFeeCents = 0, damageDepositCents = 0, taxAmountCents = 0) {
  return basePriceCents + serviceFeeCents + damageDepositCents + taxAmountCents;
}
var init_pricing_service = __esm({
  "server/services/pricing-service.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_schema();
  }
});

// server/domains/inventory/inventory.repository.ts
import { eq as eq19 } from "drizzle-orm";
var InventoryRepository;
var init_inventory_repository = __esm({
  "server/domains/inventory/inventory.repository.ts"() {
    "use strict";
    init_db();
    init_schema();
    InventoryRepository = class {
      // ===== STORAGE =====
      /**
       * Helper to map DB result to DTO with proper numeric type conversions.
       * Postgres numeric columns are returned as strings by node-postgres.
       */
      mapStorageToDTO(row) {
        return {
          ...row,
          // Convert numeric string fields to numbers for frontend compatibility
          basePrice: row.basePrice ? parseFloat(row.basePrice) : null,
          pricePerCubicFoot: row.pricePerCubicFoot ? parseFloat(row.pricePerCubicFoot) : null,
          dimensionsLength: row.dimensionsLength ? parseFloat(row.dimensionsLength) : null,
          dimensionsWidth: row.dimensionsWidth ? parseFloat(row.dimensionsWidth) : null,
          dimensionsHeight: row.dimensionsHeight ? parseFloat(row.dimensionsHeight) : null,
          totalVolume: row.totalVolume ? parseFloat(row.totalVolume) : null,
          basePricePerSqft: row.basePricePerSqft ? parseFloat(row.basePricePerSqft) : null,
          squareFeet: row.squareFeet ? parseFloat(row.squareFeet) : null,
          availableSquareFeet: row.availableSquareFeet ? parseFloat(row.availableSquareFeet) : null,
          bookedSquareFeet: row.bookedSquareFeet ? parseFloat(row.bookedSquareFeet) : null
        };
      }
      async createStorageListing(data) {
        const [listing] = await db.insert(storageListings).values(data).returning();
        return this.mapStorageToDTO(listing);
      }
      async getStorageListingsByKitchenId(kitchenId) {
        const rows = await db.select().from(storageListings).where(eq19(storageListings.kitchenId, kitchenId));
        return rows.map((row) => this.mapStorageToDTO(row));
      }
      async getStorageListingById(id) {
        const [listing] = await db.select().from(storageListings).where(eq19(storageListings.id, id));
        return listing ? this.mapStorageToDTO(listing) : null;
      }
      async updateStorageListing(id, updates) {
        const { id: _id, createdAt, updatedAt, approvedAt, ...safeUpdates } = updates;
        const [updated] = await db.update(storageListings).set({
          ...safeUpdates,
          updatedAt: /* @__PURE__ */ new Date()
          // Always use fresh Date
        }).where(eq19(storageListings.id, id)).returning();
        return updated ? this.mapStorageToDTO(updated) : null;
      }
      async deleteStorageListing(id) {
        return db.delete(storageListings).where(eq19(storageListings.id, id));
      }
      // ===== EQUIPMENT =====
      /**
       * Helper to map DB result to DTO with proper numeric type conversions.
       * Postgres numeric columns are returned as strings by node-postgres.
       */
      mapEquipmentToDTO(row) {
        return {
          ...row,
          // Convert numeric string fields to numbers for frontend compatibility
          sessionRate: row.sessionRate ? parseFloat(row.sessionRate) : 0,
          damageDeposit: row.damageDeposit ? parseFloat(row.damageDeposit) : 0
        };
      }
      async createEquipmentListing(data) {
        const [listing] = await db.insert(equipmentListings).values(data).returning();
        return this.mapEquipmentToDTO(listing);
      }
      async getEquipmentListingsByKitchenId(kitchenId) {
        const rows = await db.select().from(equipmentListings).where(eq19(equipmentListings.kitchenId, kitchenId));
        return rows.map((row) => this.mapEquipmentToDTO(row));
      }
      async getEquipmentListingById(id) {
        const [listing] = await db.select().from(equipmentListings).where(eq19(equipmentListings.id, id));
        return listing ? this.mapEquipmentToDTO(listing) : null;
      }
      async updateEquipmentListing(id, updates) {
        const { id: _id, createdAt, updatedAt, ...safeUpdates } = updates;
        const [updated] = await db.update(equipmentListings).set({
          ...safeUpdates,
          updatedAt: /* @__PURE__ */ new Date()
          // Always use fresh Date
        }).where(eq19(equipmentListings.id, id)).returning();
        return updated ? this.mapEquipmentToDTO(updated) : null;
      }
      async deleteEquipmentListing(id) {
        return db.delete(equipmentListings).where(eq19(equipmentListings.id, id));
      }
    };
  }
});

// server/domains/inventory/inventory.service.ts
var inventory_service_exports = {};
__export(inventory_service_exports, {
  InventoryService: () => InventoryService,
  inventoryService: () => inventoryService
});
var InventoryService, inventoryService;
var init_inventory_service = __esm({
  "server/domains/inventory/inventory.service.ts"() {
    "use strict";
    init_inventory_repository();
    InventoryService = class {
      repo;
      constructor(repo) {
        this.repo = repo || new InventoryRepository();
      }
      // ===== STORAGE =====
      async createStorageListing(data) {
        return this.repo.createStorageListing(data);
      }
      async getStorageListingsByKitchen(kitchenId) {
        return this.repo.getStorageListingsByKitchenId(kitchenId);
      }
      async getStorageListingById(id) {
        return this.repo.getStorageListingById(id);
      }
      async updateStorageListing(id, updates) {
        return this.repo.updateStorageListing(id, updates);
      }
      async deleteStorageListing(id) {
        return this.repo.deleteStorageListing(id);
      }
      // ===== EQUIPMENT =====
      async createEquipmentListing(data) {
        return this.repo.createEquipmentListing(data);
      }
      async getEquipmentListingsByKitchen(kitchenId) {
        return this.repo.getEquipmentListingsByKitchenId(kitchenId);
      }
      async getEquipmentListingById(id) {
        return this.repo.getEquipmentListingById(id);
      }
      async updateEquipmentListing(id, updates) {
        return this.repo.updateEquipmentListing(id, updates);
      }
      async deleteEquipmentListing(id) {
        return this.repo.deleteEquipmentListing(id);
      }
    };
    inventoryService = new InventoryService();
  }
});

// server/domains/bookings/booking.service.ts
var booking_service_exports = {};
__export(booking_service_exports, {
  BookingService: () => BookingService,
  bookingService: () => bookingService
});
import { eq as eq20, and as and12 } from "drizzle-orm";
var BookingService, bookingService;
var init_booking_service = __esm({
  "server/domains/bookings/booking.service.ts"() {
    "use strict";
    init_booking_repository();
    init_pricing_service();
    init_schema();
    init_logger();
    init_db();
    init_kitchen_service();
    BookingService = class {
      repo;
      constructor(repo) {
        this.repo = repo || new BookingRepository();
      }
      /**
       * Create a new kitchen booking
       */
      async createKitchenBooking(data) {
        const pricing = await calculateKitchenBookingPrice(
          data.kitchenId,
          data.startTime,
          data.endTime
        );
        const kitchen = await kitchenService.getKitchenById(data.kitchenId);
        if (!kitchen) throw new Error("Kitchen not found");
        if (!data.chefId) {
          throw new Error("Chef ID is required for booking");
        }
        const hasAccess = await db.query.chefLocationAccess.findFirst({
          where: and12(
            eq20(chefLocationAccess.chefId, data.chefId),
            eq20(chefLocationAccess.locationId, kitchen.locationId)
          )
        });
        if (!hasAccess) {
          const [kitchenApplication] = await db.select().from(chefKitchenApplications).where(
            and12(
              eq20(chefKitchenApplications.chefId, data.chefId),
              eq20(chefKitchenApplications.locationId, kitchen.locationId)
            )
          );
          const currentTier = kitchenApplication?.currentTier ?? kitchenApplication?.current_tier ?? 0;
          const isApprovedTier2Plus = kitchenApplication && kitchenApplication.status === "approved" && currentTier >= 2;
          if (!isApprovedTier2Plus) {
            throw new Error("You do not have approved access to this kitchen location. Please complete all required application steps (Tier 2) to book.");
          }
          try {
            await db.insert(chefLocationAccess).values({
              chefId: data.chefId,
              locationId: kitchen.locationId,
              grantedBy: kitchenApplication.reviewedBy || data.chefId,
              grantedAt: /* @__PURE__ */ new Date()
            }).onConflictDoNothing();
            logger.info(`\u2705 [BookingService] Auto-created chef_location_access for chef ${data.chefId} at location ${kitchen.locationId}`);
          } catch (err) {
            logger.error("[BookingService] Error auto-creating chef_location_access:", err);
          }
        }
        const serviceFeeCents = await calculatePlatformFeeDynamic(pricing.totalPriceCents);
        let selectedSlots = data.selectedSlots;
        if (!selectedSlots || selectedSlots.length === 0) {
          selectedSlots = [];
          const [startHours, startMins] = data.startTime.split(":").map(Number);
          const [endHours, endMins] = data.endTime.split(":").map(Number);
          const startMinutes = startHours * 60 + startMins;
          const endMinutes = endHours * 60 + endMins;
          for (let mins = startMinutes; mins < endMinutes; mins += 60) {
            const slotStartH = Math.floor(mins / 60);
            const slotStartM = mins % 60;
            const slotEndMins = mins + 60;
            const slotEndH = Math.floor(slotEndMins / 60);
            const slotEndM = slotEndMins % 60;
            selectedSlots.push({
              startTime: `${slotStartH.toString().padStart(2, "0")}:${slotStartM.toString().padStart(2, "0")}`,
              endTime: `${slotEndH.toString().padStart(2, "0")}:${slotEndM.toString().padStart(2, "0")}`
            });
          }
        }
        const booking = await this.repo.createKitchenBooking({
          ...data,
          totalPrice: "0",
          // Will be updated after calculating addons
          hourlyRate: pricing.hourlyRateCents.toString(),
          durationHours: pricing.durationHours.toString(),
          serviceFee: serviceFeeCents.toString(),
          currency: pricing.currency,
          storageItems: [],
          equipmentItems: [],
          selectedSlots,
          paymentStatus: data.paymentStatus || "pending"
        });
        let storageTotalCents = 0;
        const storageItemsForJson = [];
        if (data.selectedStorage && data.selectedStorage.length > 0) {
          try {
            const { inventoryService: inventoryService2 } = await Promise.resolve().then(() => (init_inventory_service(), inventory_service_exports));
            for (const storage of data.selectedStorage) {
              const listing = await inventoryService2.getStorageListingById(storage.storageListingId);
              if (listing) {
                const listingBasePriceCents = Math.round(parseFloat(String(listing.basePrice || "0")));
                const minDays = listing.minimumBookingDuration || 1;
                const storageStartDate = new Date(storage.startDate);
                const storageEndDate = new Date(storage.endDate);
                const days = Math.ceil((storageEndDate.getTime() - storageStartDate.getTime()) / (1e3 * 60 * 60 * 24));
                const effectiveDays = Math.max(days, minDays);
                let priceCents = listingBasePriceCents * effectiveDays;
                if (listing.pricingModel === "hourly") {
                  const durationHours = Math.max(1, Math.ceil((storageEndDate.getTime() - storageStartDate.getTime()) / (1e3 * 60 * 60)));
                  priceCents = listingBasePriceCents * durationHours;
                } else if (listing.pricingModel === "monthly-flat") {
                  priceCents = listingBasePriceCents;
                }
                const storageBooking = await this.repo.createStorageBooking({
                  kitchenBookingId: booking.id,
                  storageListingId: listing.id,
                  chefId: data.chefId,
                  startDate: storageStartDate,
                  endDate: storageEndDate,
                  status: "pending",
                  totalPrice: priceCents.toString(),
                  pricingModel: listing.pricingModel || "daily",
                  serviceFee: "0",
                  currency: pricing.currency
                });
                if (storageBooking) {
                  storageItemsForJson.push({
                    id: storageBooking.id,
                    storageListingId: listing.id,
                    name: listing.name || "Storage",
                    storageType: listing.storageType || "other",
                    totalPrice: priceCents,
                    startDate: storageStartDate.toISOString(),
                    endDate: storageEndDate.toISOString()
                  });
                }
                storageTotalCents += priceCents;
              }
            }
          } catch (err) {
            logger.error("Error creating storage bookings with explicit dates:", err);
          }
        } else if (data.selectedStorageIds && data.selectedStorageIds.length > 0) {
          try {
            const { inventoryService: inventoryService2 } = await Promise.resolve().then(() => (init_inventory_service(), inventory_service_exports));
            for (const storageId of data.selectedStorageIds) {
              const listing = await inventoryService2.getStorageListingById(storageId);
              if (listing) {
                let priceCents = 0;
                const listingBasePriceCents = Math.round(parseFloat(String(listing.basePrice || "0")));
                if (listing.pricingModel === "hourly") {
                  const duration = calculateDurationHours(data.startTime, data.endTime);
                  const effectiveDuration = Math.max(1, Math.ceil(duration));
                  priceCents = listingBasePriceCents * effectiveDuration;
                } else {
                  priceCents = listingBasePriceCents;
                }
                const storageBooking = await this.repo.createStorageBooking({
                  kitchenBookingId: booking.id,
                  storageListingId: listing.id,
                  chefId: data.chefId,
                  startDate: data.bookingDate,
                  endDate: data.bookingDate,
                  // Single day for hourly
                  status: "pending",
                  totalPrice: priceCents.toString(),
                  pricingModel: listing.pricingModel || "daily",
                  serviceFee: "0",
                  // No service fee for customer
                  currency: pricing.currency
                });
                if (storageBooking) {
                  storageItemsForJson.push({
                    id: storageBooking.id,
                    storageListingId: listing.id,
                    name: listing.name || "Storage",
                    storageType: listing.storageType || "other",
                    totalPrice: priceCents,
                    startDate: storageBooking.startDate?.toISOString?.() || data.bookingDate.toISOString(),
                    endDate: storageBooking.endDate?.toISOString?.() || data.bookingDate.toISOString()
                  });
                }
                storageTotalCents += priceCents;
              }
            }
          } catch (err) {
            logger.error("Error creating storage bookings:", err);
          }
        }
        let equipmentTotalCents = 0;
        const equipmentItemsForJson = [];
        logger.info(`[BookingService] Equipment IDs received: ${JSON.stringify(data.selectedEquipmentIds)}`);
        if (data.selectedEquipmentIds && data.selectedEquipmentIds.length > 0) {
          try {
            const { inventoryService: inventoryService2 } = await Promise.resolve().then(() => (init_inventory_service(), inventory_service_exports));
            for (const eqId of data.selectedEquipmentIds) {
              logger.info(`[BookingService] Processing equipment ID: ${eqId}`);
              const listing = await inventoryService2.getEquipmentListingById(eqId);
              logger.info(`[BookingService] Equipment listing found: ${JSON.stringify(listing)}`);
              if (listing && listing.availabilityType !== "included") {
                const sessionRateCents = Math.round(parseFloat(String(listing.sessionRate || "0")));
                logger.info(`[BookingService] Creating equipment booking: kitchenBookingId=${booking.id}, equipmentListingId=${listing.id}, sessionRateCents=${sessionRateCents}`);
                const eqBooking = await this.repo.createEquipmentBooking({
                  kitchenBookingId: booking.id,
                  equipmentListingId: listing.id,
                  chefId: data.chefId,
                  startDate: data.bookingDate,
                  endDate: data.bookingDate,
                  status: "pending",
                  totalPrice: sessionRateCents.toString(),
                  damageDeposit: (listing.damageDeposit || "0").toString(),
                  serviceFee: "0",
                  currency: pricing.currency,
                  pricingModel: "daily"
                  // Equipment uses flat session rate
                });
                if (eqBooking) {
                  equipmentItemsForJson.push({
                    id: eqBooking.id,
                    equipmentListingId: listing.id,
                    name: listing.equipmentType || "Equipment",
                    totalPrice: sessionRateCents
                  });
                }
                logger.info(`[BookingService] Equipment booking created successfully for listing ${listing.id}`);
                equipmentTotalCents += sessionRateCents;
              }
            }
          } catch (err) {
            logger.error("[BookingService] Error creating equipment bookings:", {
              error: err?.message || err,
              stack: err?.stack,
              selectedEquipmentIds: data.selectedEquipmentIds
            });
          }
        } else {
          logger.info(`[BookingService] No equipment IDs provided in booking data`);
        }
        const grandTotalCents = pricing.totalPriceCents + storageTotalCents + equipmentTotalCents;
        const newServiceFeeCents = await calculatePlatformFeeDynamic(grandTotalCents);
        await this.repo.updateKitchenBooking(booking.id, {
          totalPrice: grandTotalCents.toString(),
          serviceFee: newServiceFeeCents.toString(),
          storageItems: storageItemsForJson,
          equipmentItems: equipmentItemsForJson
        });
        const updatedBooking = await this.repo.getKitchenBookingById(booking.id);
        return updatedBooking || booking;
      }
      async getBookingById(id) {
        return this.repo.getKitchenBookingById(id);
      }
      async updateBookingStatus(id, status) {
        return this.repo.updateKitchenBooking(id, { status });
      }
      async cancelBooking(bookingId, cancelledByUserId, isChef) {
        const booking = await this.repo.getKitchenBookingById(bookingId);
        if (!booking) throw new Error("Booking not found");
        await this.repo.updateKitchenBooking(bookingId, { status: "cancelled" });
      }
      async getBookingsByKitchenId(kitchenId) {
        return this.repo.getKitchenBookingsByKitchenId(kitchenId);
      }
      // For the MVP of this refactor, I will focus on the DB Operation.
      // Notification logic is typically in the ROUTE in the current codebase (bookings.ts lines 426+)
      // We should eventually move that here.
      // We should eventually move that here.
      async createPortalBooking(data) {
        const dbData = {
          ...data,
          // If externalContact object is passed, flatten it
          externalContactName: data.externalContact?.name,
          externalContactEmail: data.externalContact?.email,
          externalContactPhone: data.externalContact?.phone,
          externalContactCompany: data.externalContact?.company,
          // Ensure bookingType is set
          bookingType: data.bookingType || "portal"
        };
        return this.repo.createKitchenBooking(dbData);
      }
      // Proxy methods for repository
      async getBookingsByKitchen(kitchenId) {
        return this.repo.getBookingsByKitchen(kitchenId);
      }
      async getKitchenBookingsByChef(chefId) {
        return this.repo.getKitchenBookingsByChefId(chefId);
      }
      async getBookingsByManager(managerId) {
        return this.repo.getBookingsByManagerId(managerId);
      }
      // ===== STORAGE BOOKINGS =====
      async getStorageBookingsByChef(chefId) {
        return this.repo.getStorageBookingsByChefId(chefId);
      }
      async getEquipmentBookingsByChef(chefId) {
        return this.repo.getEquipmentBookingsByChefId(chefId);
      }
      async getStorageBookingsByKitchenBooking(kitchenBookingId) {
        return this.repo.getStorageBookingsByKitchenBookingId(kitchenBookingId);
      }
      async getEquipmentBookingsByKitchenBooking(kitchenBookingId) {
        return this.repo.getEquipmentBookingsByKitchenBookingId(kitchenBookingId);
      }
      async updateStorageBooking(id, updates) {
        return this.repo.updateStorageBooking(id, updates);
      }
      async updateEquipmentBooking(id, updates) {
        return this.repo.updateEquipmentBooking(id, updates);
      }
      // ===== AVAILABILITY LOGIC =====
      async validateBookingAvailability(kitchenId, bookingDate, startTime, endTime) {
        try {
          if (startTime >= endTime) {
            return { valid: false, error: "End time must be after start time" };
          }
          const dateOverride = await kitchenService.getKitchenDateOverrideForDate(kitchenId, bookingDate);
          let availabilityStartTime;
          let availabilityEndTime;
          if (dateOverride) {
            if (!dateOverride.isAvailable) {
              return { valid: false, error: "Kitchen is closed on this date" };
            }
            if (dateOverride.startTime && dateOverride.endTime) {
              availabilityStartTime = dateOverride.startTime;
              availabilityEndTime = dateOverride.endTime;
            } else {
              return { valid: false, error: "Kitchen availability not properly configured for this date" };
            }
          } else {
            const dayOfWeek = bookingDate.getUTCDay();
            const availability = await kitchenService.getKitchenAvailability(kitchenId);
            const dayAvailability = availability.find((a) => a.dayOfWeek === dayOfWeek);
            if (!dayAvailability || !dayAvailability.isAvailable) {
              return { valid: false, error: "Kitchen is not available on this day" };
            }
            availabilityStartTime = dayAvailability.startTime;
            availabilityEndTime = dayAvailability.endTime;
          }
          if (startTime < availabilityStartTime || endTime > availabilityEndTime) {
            return { valid: false, error: "Booking time must be within manager-set available hours" };
          }
          const startHour = parseInt(startTime.split(":")[0]);
          const availabilityStartHour = parseInt(availabilityStartTime.split(":")[0]);
          const availabilityEndHour = parseInt(availabilityEndTime.split(":")[0]);
          if (startHour < availabilityStartHour || startHour >= availabilityEndHour) {
            return { valid: false, error: "Start time must be within manager-set available slot times" };
          }
          return { valid: true };
        } catch (error) {
          logger.error("Error validating booking availability:", error);
          return { valid: false, error: "Error validating booking availability" };
        }
      }
      async getAvailableTimeSlots(kitchenId, date2) {
        try {
          const dateOverride = await kitchenService.getKitchenDateOverrideForDate(kitchenId, date2);
          let startHour;
          let endHour;
          if (dateOverride) {
            if (!dateOverride.isAvailable) {
              return [];
            }
            if (dateOverride.startTime && dateOverride.endTime) {
              startHour = parseInt(dateOverride.startTime.split(":")[0]);
              endHour = parseInt(dateOverride.endTime.split(":")[0]);
            } else {
              return [];
            }
          } else {
            const dayOfWeek = date2.getUTCDay();
            const availability = await kitchenService.getKitchenAvailability(kitchenId);
            const dayAvailability = availability.find((a) => a.dayOfWeek === dayOfWeek);
            if (!dayAvailability || !dayAvailability.isAvailable) {
              return [];
            }
            startHour = parseInt(dayAvailability.startTime.split(":")[0]);
            endHour = parseInt(dayAvailability.endTime.split(":")[0]);
          }
          const slots = [];
          for (let hour = startHour; hour < endHour; hour++) {
            slots.push(`${hour.toString().padStart(2, "0")}:00`);
          }
          const bookings = await this.getBookingsByKitchen(kitchenId);
          const dateStr = date2.toISOString().split("T")[0];
          const dayBookings = bookings.filter((b) => {
            const bookingDateStr = new Date(b.bookingDate).toISOString().split("T")[0];
            return bookingDateStr === dateStr && b.status !== "cancelled";
          });
          const bookedSlots = /* @__PURE__ */ new Set();
          dayBookings.forEach((booking) => {
            const [startHours, startMins] = booking.startTime.split(":").map(Number);
            const [endHours, endMins] = booking.endTime.split(":").map(Number);
            const startTotalMins = startHours * 60 + startMins;
            const endTotalMins = endHours * 60 + endMins;
            for (const slot of slots) {
              const [slotHours, slotMins] = slot.split(":").map(Number);
              const slotTotalMins = slotHours * 60 + slotMins;
              if (slotTotalMins >= startTotalMins && slotTotalMins < endTotalMins) {
                bookedSlots.add(slot);
              }
            }
          });
          return slots.filter((slot) => !bookedSlots.has(slot));
        } catch (error) {
          logger.error("Error getting available time slots:", error);
          throw error;
        }
      }
      async getAvailableSlots(kitchenId, dateStr) {
        try {
          const date2 = new Date(dateStr);
          const slots = await this.getAvailableTimeSlots(kitchenId, date2);
          return slots.map((time) => ({ time, available: true }));
        } catch (error) {
          logger.error("Error getting available slots:", error);
          return [];
        }
      }
      async getAllTimeSlotsWithBookingInfo(kitchenId, date2) {
        try {
          const dateOverride = await kitchenService.getKitchenDateOverrideForDate(kitchenId, date2);
          let startHour;
          let endHour;
          let capacity;
          if (dateOverride) {
            if (!dateOverride.isAvailable) {
              return [];
            }
            if (dateOverride.startTime && dateOverride.endTime) {
              startHour = parseInt(dateOverride.startTime.split(":")[0]);
              endHour = parseInt(dateOverride.endTime.split(":")[0]);
              capacity = dateOverride.maxConcurrentBookings ?? 1;
            } else {
              return [];
            }
          } else {
            const dayOfWeek = date2.getUTCDay();
            const availability = await kitchenService.getKitchenAvailability(kitchenId);
            const dayAvailability = availability.find((a) => a.dayOfWeek === dayOfWeek);
            if (!dayAvailability || !dayAvailability.isAvailable) {
              return [];
            }
            startHour = parseInt(dayAvailability.startTime.split(":")[0]);
            endHour = parseInt(dayAvailability.endTime.split(":")[0]);
            capacity = dayAvailability.maxConcurrentBookings ?? 1;
          }
          const allSlots = [];
          for (let hour = startHour; hour < endHour; hour++) {
            allSlots.push(`${hour.toString().padStart(2, "0")}:00`);
          }
          const bookings = await this.getBookingsByKitchen(kitchenId);
          const dateStr = date2.toISOString().split("T")[0];
          const dayBookings = bookings.filter((b) => {
            const bookingDateStr = new Date(b.bookingDate).toISOString().split("T")[0];
            return bookingDateStr === dateStr && b.status !== "cancelled";
          });
          const slotBookingCounts = /* @__PURE__ */ new Map();
          allSlots.forEach((slot) => slotBookingCounts.set(slot, 0));
          dayBookings.forEach((booking) => {
            const [startHours, startMins] = booking.startTime.split(":").map(Number);
            const [endHours, endMins] = booking.endTime.split(":").map(Number);
            const startTotalMins = startHours * 60 + startMins;
            const endTotalMins = endHours * 60 + endMins;
            allSlots.forEach((slot) => {
              const [slotHours, slotMins] = slot.split(":").map(Number);
              const slotTotalMins = slotHours * 60 + slotMins;
              if (slotTotalMins >= startTotalMins && slotTotalMins < endTotalMins) {
                slotBookingCounts.set(slot, (slotBookingCounts.get(slot) || 0) + 1);
              }
            });
          });
          return allSlots.map((slot) => {
            const bookedCount = slotBookingCounts.get(slot) || 0;
            return {
              time: slot,
              available: Math.max(0, capacity - bookedCount),
              capacity,
              isFullyBooked: bookedCount >= capacity
            };
          });
        } catch (error) {
          logger.error("Error getting all time slots with booking info:", error);
          throw error;
        }
      }
      async getStorageBookingById(id) {
        return this.repo.getStorageBookingById(id);
      }
      async extendStorageBooking(id, newEndDate) {
        const booking = await this.repo.getStorageBookingById(id);
        if (!booking) throw new Error(`Storage booking with id ${id} not found`);
        if (booking.status === "cancelled") throw new Error("Cannot extend a cancelled booking");
        if (booking.status === "completed") throw new Error("Cannot extend a completed booking. Storage has already been cleared.");
        const currentEndDate = new Date(booking.endDate);
        if (newEndDate <= currentEndDate) throw new Error("New end date must be after the current end date");
        const extensionDays = Math.ceil((newEndDate.getTime() - currentEndDate.getTime()) / (1e3 * 60 * 60 * 24));
        const minDays = booking.minimumBookingDuration || 1;
        if (extensionDays < minDays) throw new Error(`Extension must be at least ${minDays} day${minDays > 1 ? "s" : ""}`);
        const { getServiceFeeRate: getServiceFeeRate2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
        const serviceFeeRate = await getServiceFeeRate2();
        const basePricePerDayDollars = booking.basePrice ? parseFloat(booking.basePrice.toString()) / 100 : 0;
        const extensionBasePrice = basePricePerDayDollars * extensionDays;
        const extensionServiceFee = extensionBasePrice * serviceFeeRate;
        const extensionTotalPrice = extensionBasePrice + extensionServiceFee;
        const extensionTotalPriceCents = Math.round(extensionTotalPrice * 100);
        const extensionServiceFeeCents = Math.round(extensionServiceFee * 100);
        const existingTotalPriceCents = Math.round(parseFloat((booking.totalPrice || "0").toString()));
        const existingServiceFeeCents = Math.round(parseFloat((booking.serviceFee || "0").toString()));
        const newTotalPriceCents = existingTotalPriceCents + extensionTotalPriceCents;
        const newServiceFeeCents = existingServiceFeeCents + extensionServiceFeeCents;
        await this.repo.updateStorageBooking(id, {
          endDate: newEndDate,
          totalPrice: newTotalPriceCents.toString(),
          serviceFee: newServiceFeeCents.toString()
        });
        const updatedBooking = await this.repo.getStorageBookingById(id);
        if (booking.kitchenBookingId) {
          try {
            const kitchenBooking = await this.repo.getKitchenBookingById(booking.kitchenBookingId);
            if (kitchenBooking && kitchenBooking.storageItems && Array.isArray(kitchenBooking.storageItems)) {
              const updatedStorageItems = kitchenBooking.storageItems.map((item) => {
                if (item.storageListingId === booking.storageListingId || item.id === id) {
                  return {
                    ...item,
                    endDate: newEndDate.toISOString(),
                    totalPrice: newTotalPriceCents
                    // Update price too
                  };
                }
                return item;
              });
              await this.repo.updateKitchenBooking(booking.kitchenBookingId, {
                storageItems: updatedStorageItems
              });
              logger.info(`[BookingService] Updated storageItems JSONB in kitchen booking ${booking.kitchenBookingId} for storage extension`, {
                storageBookingId: id,
                newEndDate: newEndDate.toISOString()
              });
            }
          } catch (error) {
            logger.warn(`[BookingService] Failed to update storageItems JSONB in kitchen booking: ${error}`);
          }
        }
        return {
          ...updatedBooking,
          // We should format money fields if the caller expects dollars, but here we return mixed struct?
          // storage-firebase returned formatted dollars.
          // I should probably stick to returning what DB returns but add the extensionDetails.
          extensionDetails: {
            extensionDays,
            extensionBasePrice,
            extensionServiceFee,
            extensionTotalPrice,
            newEndDate: newEndDate.toISOString()
          }
        };
      }
      // ===== PENDING STORAGE EXTENSIONS =====
      async createPendingStorageExtension(data) {
        return this.repo.createPendingStorageExtension(data);
      }
      async getPendingStorageExtension(storageBookingId, stripeSessionId) {
        return this.repo.getPendingStorageExtension(storageBookingId, stripeSessionId);
      }
      async updatePendingStorageExtension(id, updates) {
        return this.repo.updatePendingStorageExtension(id, updates);
      }
      /**
       * @deprecated Use overstayPenaltyService.detectOverstays() instead.
       * This method is kept for backward compatibility but no longer auto-charges.
       * The new system requires manager approval before any charges.
       */
      async processOverstayerPenalties(_maxDaysToCharge = 7) {
        logger.warn("[DEPRECATED] processOverstayerPenalties called - use overstayPenaltyService instead");
        const { overstayPenaltyService: overstayPenaltyService2 } = await Promise.resolve().then(() => (init_overstay_penalty_service(), overstay_penalty_service_exports));
        return overstayPenaltyService2.detectOverstays();
      }
    };
    bookingService = new BookingService();
  }
});

// server/domains/users/chef.repository.ts
import { eq as eq21, and as and13, inArray as inArray5 } from "drizzle-orm";
var ChefRepository;
var init_chef_repository = __esm({
  "server/domains/users/chef.repository.ts"() {
    "use strict";
    init_db();
    init_schema();
    ChefRepository = class {
      // ===== Access Management =====
      async grantLocationAccess(chefId, locationId, grantedBy) {
        const [access] = await db.insert(chefLocationAccess).values({
          chefId,
          locationId,
          grantedBy
        }).onConflictDoNothing().returning();
        return access;
      }
      async revokeLocationAccess(chefId, locationId) {
        await db.delete(chefLocationAccess).where(
          and13(
            eq21(chefLocationAccess.chefId, chefId),
            eq21(chefLocationAccess.locationId, locationId)
          )
        );
      }
      async getLocationAccess(chefId) {
        return db.select().from(chefLocationAccess).where(eq21(chefLocationAccess.chefId, chefId));
      }
      async hasLocationAccess(chefId, locationId) {
        const access = await db.select().from(chefLocationAccess).where(
          and13(
            eq21(chefLocationAccess.chefId, chefId),
            eq21(chefLocationAccess.locationId, locationId)
          )
        ).limit(1);
        return access.length > 0;
      }
      // ===== Profile Management =====
      async findProfile(chefId, locationId) {
        const [profile] = await db.select().from(chefLocationProfiles).where(
          and13(
            eq21(chefLocationProfiles.chefId, chefId),
            eq21(chefLocationProfiles.locationId, locationId)
          )
        );
        return profile || null;
      }
      async getProfilesByChefId(chefId) {
        return db.select().from(chefLocationProfiles).where(eq21(chefLocationProfiles.chefId, chefId));
      }
      async createProfile(chefId, locationId) {
        const [profile] = await db.insert(chefLocationProfiles).values({
          chefId,
          locationId,
          status: "pending"
        }).returning();
        return profile;
      }
      async updateProfile(id, updates) {
        const [updated] = await db.update(chefLocationProfiles).set(updates).where(eq21(chefLocationProfiles.id, id)).returning();
        return updated || null;
      }
      // Complex query for Manager Dashboard
      async getProfilesForManager(locationIds) {
        if (locationIds.length === 0) return [];
        const profiles = await db.select().from(chefLocationProfiles).where(inArray5(chefLocationProfiles.locationId, locationIds));
        return profiles;
      }
    };
  }
});

// server/domains/users/chef.service.ts
import { eq as eq22, and as and14 } from "drizzle-orm";
var ChefService, chefService;
var init_chef_service = __esm({
  "server/domains/users/chef.service.ts"() {
    "use strict";
    init_logger();
    init_chef_repository();
    init_user_service();
    init_location_service();
    init_application_service();
    init_db();
    init_schema();
    ChefService = class {
      constructor(repo) {
        this.repo = repo;
      }
      // ===== Access Management =====
      async grantLocationAccess(chefId, locationId, grantedBy) {
        return this.repo.grantLocationAccess(chefId, locationId, grantedBy);
      }
      async revokeLocationAccess(chefId, locationId) {
        return this.repo.revokeLocationAccess(chefId, locationId);
      }
      async getLocationAccess(chefId) {
        return this.repo.getLocationAccess(chefId);
      }
      async hasLocationAccess(chefId, locationId) {
        return this.repo.hasLocationAccess(chefId, locationId);
      }
      // ===== Profile Management =====
      async shareProfileWithLocation(chefId, locationId) {
        const existing = await this.repo.findProfile(chefId, locationId);
        if (existing) {
          if (existing.status === "rejected") {
            return this.repo.updateProfile(existing.id, {
              status: "pending",
              sharedAt: /* @__PURE__ */ new Date(),
              reviewedBy: null,
              reviewedAt: null,
              reviewFeedback: null
            });
          }
          return existing;
        }
        return this.repo.createProfile(chefId, locationId);
      }
      async getProfile(chefId, locationId) {
        return this.repo.findProfile(chefId, locationId);
      }
      async getChefProfiles(chefId) {
        return this.repo.getProfilesByChefId(chefId);
      }
      async updateProfileStatus(profileId, status, reviewedBy, feedback) {
        return this.repo.updateProfile(profileId, {
          status,
          reviewedBy,
          reviewedAt: /* @__PURE__ */ new Date(),
          reviewFeedback: feedback || null
        });
      }
      async getApplicationStatusForBooking(chefId, locationId) {
        const [accessRecord] = await db.select().from(chefLocationAccess).where(
          and14(
            eq22(chefLocationAccess.chefId, chefId),
            eq22(chefLocationAccess.locationId, locationId)
          )
        );
        if (accessRecord) {
          return {
            hasApplication: true,
            status: "approved",
            canBook: true,
            message: "Application approved. You can book kitchens at this location."
          };
        }
        const [kitchenApplication] = await db.select().from(chefKitchenApplications).where(
          and14(
            eq22(chefKitchenApplications.chefId, chefId),
            eq22(chefKitchenApplications.locationId, locationId)
          )
        );
        if (kitchenApplication) {
          const currentTier = kitchenApplication.currentTier ?? kitchenApplication.current_tier ?? 1;
          if (kitchenApplication.status === "approved" && currentTier >= 2) {
            try {
              await db.insert(chefLocationAccess).values({
                chefId,
                locationId,
                grantedBy: kitchenApplication.reviewedBy || chefId,
                grantedAt: /* @__PURE__ */ new Date()
              }).onConflictDoNothing();
              logger.info(`\u2705 Auto-created chef_location_access for chef ${chefId} at location ${locationId}`);
            } catch (err) {
              logger.error("Error auto-creating chef_location_access:", err);
            }
            return {
              hasApplication: true,
              status: "approved",
              canBook: true,
              message: "Application approved. You can book kitchens at this location."
            };
          } else if (kitchenApplication.status === "rejected") {
            return {
              hasApplication: true,
              status: "rejected",
              canBook: false,
              message: "Your application was rejected by the manager."
            };
          } else {
            return {
              hasApplication: true,
              status: kitchenApplication.status || "pending",
              canBook: false,
              message: "Your application is pending manager review or requires additional steps."
            };
          }
        }
        const profile = await this.getProfile(chefId, locationId);
        if (!profile) {
          return {
            hasApplication: false,
            status: null,
            canBook: false,
            message: "You must apply to this location before booking."
          };
        }
        if (profile.status === "approved") {
          return {
            hasApplication: true,
            status: "approved",
            canBook: true,
            message: "Application approved. You can book kitchens at this location."
          };
        } else if (profile.status === "rejected") {
          return {
            hasApplication: true,
            status: "rejected",
            canBook: false,
            message: "Your profile was rejected by the manager."
          };
        } else {
          return {
            hasApplication: true,
            status: "pending",
            canBook: false,
            message: "Your profile is pending manager review."
          };
        }
      }
      async getChefProfilesForManager(managerId) {
        const managerLocations = await locationService.getLocationsByManagerId(managerId);
        if (managerLocations.length === 0) {
          return [];
        }
        const locationIds = managerLocations.map((l) => l.id);
        const profiles = await this.repo.getProfilesForManager(locationIds);
        const enrichedProfiles = await Promise.all(
          profiles.map(async (profile) => {
            const chef = await userService.getUser(profile.chefId);
            const location = managerLocations.find((l) => l.id === profile.locationId);
            const apps = await applicationService.getApplicationsByUserId(profile.chefId);
            const approvedApps = apps.filter((a) => a.status === "approved").sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
            const latestApp = approvedApps.length > 0 ? approvedApps[approvedApps.length - 1] : null;
            return {
              ...profile,
              chef: chef ? {
                id: chef.id,
                username: chef.username
              } : null,
              location: location ? {
                id: location.id,
                name: location.name,
                address: location.address
              } : null,
              application: latestApp ? {
                id: latestApp.id,
                fullName: latestApp.fullName,
                email: latestApp.email,
                phone: latestApp.phone,
                foodSafetyLicenseUrl: latestApp.foodSafetyLicenseUrl,
                foodEstablishmentCertUrl: latestApp.foodEstablishmentCertUrl
              } : null
            };
          })
        );
        return enrichedProfiles;
      }
    };
    chefService = new ChefService(new ChefRepository());
  }
});

// server/domains/managers/manager.repository.ts
import { eq as eq23, sql as sql10 } from "drizzle-orm";
var ManagerRepository, managerRepository;
var init_manager_repository = __esm({
  "server/domains/managers/manager.repository.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_logger();
    ManagerRepository = class {
      async findAllManagers() {
        return await db.select().from(users).where(eq23(users.role, "manager"));
      }
      async findManagerByUserId(userId) {
        const [user] = await db.select().from(users).where(eq23(users.id, userId));
        return user;
      }
      async updateOnboardingStatus(userId, updates) {
        const dbUpdates = {};
        if (updates.completed !== void 0) dbUpdates.managerOnboardingCompleted = updates.completed;
        if (updates.skipped !== void 0) dbUpdates.managerOnboardingSkipped = updates.skipped;
        if (updates.steps !== void 0) dbUpdates.managerOnboardingStepsCompleted = updates.steps;
        const [updated] = await db.update(users).set(dbUpdates).where(eq23(users.id, userId)).returning();
        return updated;
      }
      // Moved from server/routes/manager.ts
      async findInvoices(managerId, filters) {
        const { startDate, endDate, locationId, limit = 50, offset = 0 } = filters;
        const kitchenResult = await db.execute(sql10`
            SELECT 
                kb.id,
                kb.booking_date,
                kb.start_time,
                kb.end_time,
                COALESCE(pt.amount, kb.total_price) as total_price,
                kb.hourly_rate,
                kb.duration_hours,
                COALESCE(pt.service_fee, kb.service_fee) as service_fee,
                kb.payment_status,
                kb.payment_intent_id,
                kb.currency,
                k.name as kitchen_name,
                l.name as location_name,
                COALESCE(cka.full_name, u.username) as chef_name,
                COALESCE(cka.email, u.username) as chef_email,
                kb.created_at,
                'kitchen' as booking_type
            FROM kitchen_bookings kb
            INNER JOIN kitchens k ON kb.kitchen_id = k.id
            INNER JOIN locations l ON k.location_id = l.id
            LEFT JOIN users u ON kb.chef_id = u.id
            LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = kb.chef_id AND cka.location_id = l.id
            LEFT JOIN payment_transactions pt ON pt.booking_id = kb.id 
                AND pt.booking_type = 'kitchen' 
                AND pt.status = 'succeeded'
            WHERE l.manager_id = ${managerId}
              AND kb.status != 'cancelled'
              AND kb.payment_status = 'paid'
              ${startDate ? sql10`AND (DATE(kb.booking_date) >= ${Array.isArray(startDate) ? startDate[0] : String(startDate)}::date OR DATE(kb.created_at) >= ${Array.isArray(startDate) ? startDate[0] : String(startDate)}::date)` : sql10``}
              ${endDate ? sql10`AND (DATE(kb.booking_date) <= ${Array.isArray(endDate) ? endDate[0] : String(endDate)}::date OR DATE(kb.created_at) <= ${Array.isArray(endDate) ? endDate[0] : String(endDate)}::date)` : sql10``}
              ${locationId ? sql10`AND l.id = ${Number(locationId)}` : sql10``}
            ORDER BY kb.created_at DESC, kb.booking_date DESC
            LIMIT ${limit}
            OFFSET ${offset}
        `);
        const rows = kitchenResult.rows.map((row) => ({
          id: row.id,
          bookingDate: row.booking_date,
          startTime: row.start_time,
          endTime: row.end_time,
          totalPrice: row.total_price,
          hourlyRate: row.hourly_rate,
          durationHours: row.duration_hours,
          serviceFee: row.service_fee,
          paymentStatus: row.payment_status,
          paymentIntentId: row.payment_intent_id,
          currency: row.currency,
          kitchenName: row.kitchen_name,
          locationName: row.location_name,
          chefName: row.chef_name,
          chefEmail: row.chef_email,
          createdAt: row.created_at,
          bookingType: row.booking_type
        }));
        logger.info(`[ManagerRepository] Kitchen invoices query for manager ${managerId}: Found ${rows.length} invoices`);
        const storageRows = await db.execute(sql10`
            SELECT 
                pt.booking_id as id,
                sb.start_date as booking_date,
                NULL as start_time,
                NULL as end_time,
                pt.amount as total_price,
                pt.service_fee as service_fee,
                pt.status as payment_status,
                pt.payment_intent_id,
                pt.currency,
                k.name as kitchen_name,
                sl.name as storage_name,
                l.name as location_name,
                COALESCE(cka.full_name, u.username) as chef_name,
                COALESCE(cka.email, u.username) as chef_email,
                pt.created_at,
                pt.metadata,
                'storage' as booking_type
            FROM payment_transactions pt
            JOIN storage_bookings sb ON pt.booking_id = sb.id
            JOIN storage_listings sl ON sb.storage_listing_id = sl.id
            JOIN kitchens k ON sl.kitchen_id = k.id
            JOIN locations l ON k.location_id = l.id
            LEFT JOIN users u ON sb.chef_id = u.id
            LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = sb.chef_id AND cka.location_id = l.id
            WHERE pt.manager_id = ${managerId}
              AND pt.booking_type = 'storage'
              AND pt.status = 'succeeded'
            ORDER BY pt.created_at DESC
            LIMIT ${limit}
        `);
        const storageInvoices = storageRows.rows.map((row) => {
          const metadata = row.metadata || {};
          const isOverstayPenalty = metadata.type === "overstay_penalty";
          const isStorageExtension = metadata.storage_extension_id != null;
          let description = row.storage_name || "Storage";
          if (isOverstayPenalty) {
            description = `Overstay Penalty - ${row.storage_name || "Storage"}`;
          } else if (isStorageExtension) {
            description = `Storage Extension - ${row.storage_name || "Storage"}`;
          }
          return {
            id: row.id,
            bookingDate: row.booking_date,
            startTime: row.start_time,
            endTime: row.end_time,
            totalPrice: row.total_price,
            serviceFee: row.service_fee || 0,
            paymentStatus: row.payment_status === "succeeded" ? "paid" : row.payment_status,
            paymentIntentId: row.payment_intent_id,
            currency: row.currency || "CAD",
            kitchenName: description,
            locationName: row.location_name,
            chefName: row.chef_name || "Guest",
            chefEmail: row.chef_email,
            createdAt: row.created_at,
            bookingType: isOverstayPenalty ? "overstay_penalty" : isStorageExtension ? "storage_extension" : "storage"
          };
        });
        const allInvoices = [...rows, ...storageInvoices].sort((a, b) => {
          return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
        }).slice(0, limit);
        logger.info(`[ManagerRepository] Total invoices for manager ${managerId}: ${allInvoices.length} (${rows.length} kitchen + ${storageInvoices.length} storage)`);
        return {
          invoices: allInvoices,
          total: allInvoices.length
        };
      }
      async getRevenueMetrics(managerId, startDate, endDate, locationId) {
        throw new Error("Method not implemented in Repository. Use RevenueService.");
      }
    };
    managerRepository = new ManagerRepository();
  }
});

// server/services/revenue-service-v2.ts
var revenue_service_v2_exports = {};
__export(revenue_service_v2_exports, {
  getRevenueByDateFromTransactions: () => getRevenueByDateFromTransactions,
  getRevenueByLocationFromTransactions: () => getRevenueByLocationFromTransactions,
  getRevenueMetricsFromTransactions: () => getRevenueMetricsFromTransactions
});
import { sql as sql11 } from "drizzle-orm";
async function getRevenueMetricsFromTransactions(managerId, db2, startDate, endDate, locationId) {
  try {
    if (managerId === void 0 || managerId === null || isNaN(managerId)) {
      logger.error("[Revenue Service V2] Invalid managerId:", managerId);
      throw new Error("Invalid manager ID");
    }
    const params = [managerId];
    if (locationId) {
      params.push(locationId);
    }
    logger.info("[Revenue Service V2] getRevenueMetricsFromTransactions params:", { managerId, locationId, startDate, endDate });
    const tableCheck = await db2.execute(sql11`
      SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'payment_transactions'
      ) as table_exists
    `);
    const tableExists = tableCheck.rows[0]?.table_exists;
    if (!tableExists) {
      logger.info("[Revenue Service V2] payment_transactions table does not exist, will fallback to legacy method");
      throw new Error("payment_transactions table does not exist");
    }
    const managerIdParam = sql11`${managerId}`;
    const countCheck = await db2.execute(sql11`
      SELECT COUNT(*) as count
      FROM payment_transactions pt
      WHERE pt.manager_id = ${managerIdParam}
        AND pt.booking_type IN ('kitchen', 'bundle', 'storage', 'equipment')
        AND (pt.status = 'succeeded' OR pt.status = 'processing' OR pt.status = 'refunded' OR pt.status = 'partially_refunded')
    `);
    const transactionCount = parseInt(countCheck.rows[0]?.count || "0");
    logger.info(`[Revenue Service V2] Found ${transactionCount} payment_transactions for manager ${managerId}`);
    const bookingCountCheck = await db2.execute(sql11`
      SELECT 
        COUNT(DISTINCT kb.id) as total_bookings,
        COUNT(DISTINCT CASE WHEN pt_kitchen.id IS NOT NULL OR pt_bundle.id IS NOT NULL THEN kb.id END) as bookings_with_transactions
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      LEFT JOIN payment_transactions pt_kitchen ON pt_kitchen.booking_id = kb.id 
        AND pt_kitchen.booking_type = 'kitchen'
        AND (pt_kitchen.manager_id = ${managerIdParam} OR (pt_kitchen.manager_id IS NULL AND l.manager_id = ${managerIdParam}))
      LEFT JOIN payment_transactions pt_bundle ON pt_bundle.booking_id = kb.id 
        AND pt_bundle.booking_type = 'bundle'
        AND (pt_bundle.manager_id = ${managerIdParam} OR (pt_bundle.manager_id IS NULL AND l.manager_id = ${managerIdParam}))
      WHERE l.manager_id = ${managerIdParam}
        AND kb.status != 'cancelled'
        AND (kb.payment_intent_id IS NOT NULL OR kb.total_price IS NOT NULL)
    `);
    const totalBookings = parseInt(bookingCountCheck.rows[0]?.total_bookings || "0");
    const bookingsWithTransactions = parseInt(bookingCountCheck.rows[0]?.bookings_with_transactions || "0");
    logger.info(`[Revenue Service V2] Booking coverage: ${bookingsWithTransactions}/${totalBookings} bookings have payment_transactions`);
    if (transactionCount === 0) {
      logger.info("[Revenue Service V2] No payment_transactions found, falling back to legacy method");
      throw new Error("No payment_transactions found for manager");
    }
    if (totalBookings > 0 && bookingsWithTransactions < totalBookings) {
      logger.info(`[Revenue Service V2] Incomplete payment_transactions coverage (${bookingsWithTransactions}/${totalBookings}), falling back to legacy method`);
      throw new Error("Incomplete payment_transactions coverage");
    }
    const metricsTimezoneResult = await db2.execute(sql11`
      SELECT COALESCE(l.timezone, 'America/St_Johns') as timezone
      FROM locations l
      WHERE l.manager_id = ${managerIdParam}
      LIMIT 1
    `);
    const metricsTimezone = metricsTimezoneResult.rows[0]?.timezone || "America/St_Johns";
    const simpleWhereConditions = [
      sql11`pt.manager_id = ${managerIdParam}`,
      sql11`(pt.status = 'succeeded' OR pt.status = 'processing' OR pt.status = 'refunded' OR pt.status = 'partially_refunded')`,
      sql11`pt.booking_type IN ('kitchen', 'bundle', 'storage', 'equipment')`
    ];
    if (startDate || endDate) {
      const start = startDate ? typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0] : null;
      const end = endDate ? typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0] : null;
      if (start && end) {
        simpleWhereConditions.push(sql11`
          (
            (pt.status = 'succeeded' AND (
              (pt.paid_at IS NOT NULL AND DATE(pt.paid_at AT TIME ZONE 'UTC' AT TIME ZONE ${metricsTimezone}) >= ${start}::date AND DATE(pt.paid_at AT TIME ZONE 'UTC' AT TIME ZONE ${metricsTimezone}) <= ${end}::date)
              OR (pt.paid_at IS NULL AND DATE(pt.created_at AT TIME ZONE 'UTC' AT TIME ZONE ${metricsTimezone}) >= ${start}::date AND DATE(pt.created_at AT TIME ZONE 'UTC' AT TIME ZONE ${metricsTimezone}) <= ${end}::date)
            ))
            OR (pt.status != 'succeeded' AND DATE(pt.created_at AT TIME ZONE 'UTC' AT TIME ZONE ${metricsTimezone}) >= ${start}::date AND DATE(pt.created_at AT TIME ZONE 'UTC' AT TIME ZONE ${metricsTimezone}) <= ${end}::date)
          )
        `);
      } else if (start) {
        simpleWhereConditions.push(sql11`
          (
            (pt.status = 'succeeded' AND (
              (pt.paid_at IS NOT NULL AND DATE(pt.paid_at AT TIME ZONE 'UTC' AT TIME ZONE ${metricsTimezone}) >= ${start}::date)
              OR (pt.paid_at IS NULL AND DATE(pt.created_at AT TIME ZONE 'UTC' AT TIME ZONE ${metricsTimezone}) >= ${start}::date)
            ))
            OR (pt.status != 'succeeded' AND DATE(pt.created_at AT TIME ZONE 'UTC' AT TIME ZONE ${metricsTimezone}) >= ${start}::date)
          )
        `);
      } else if (end) {
        simpleWhereConditions.push(sql11`
          (
            (pt.status = 'succeeded' AND (
              (pt.paid_at IS NOT NULL AND DATE(pt.paid_at AT TIME ZONE 'UTC' AT TIME ZONE ${metricsTimezone}) <= ${end}::date)
              OR (pt.paid_at IS NULL AND DATE(pt.created_at AT TIME ZONE 'UTC' AT TIME ZONE ${metricsTimezone}) <= ${end}::date)
            ))
            OR (pt.status != 'succeeded' AND DATE(pt.created_at AT TIME ZONE 'UTC' AT TIME ZONE ${metricsTimezone}) <= ${end}::date)
          )
        `);
      }
    }
    simpleWhereConditions.push(sql11`
      NOT (
        pt.booking_type = 'kitchen' 
        AND EXISTS (
          SELECT 1 FROM payment_transactions pt2
          WHERE pt2.booking_id = pt.booking_id
            AND pt2.booking_type = 'bundle'
            AND pt2.manager_id = pt.manager_id
        )
      )
    `);
    const simpleWhereClause = sql11`WHERE ${sql11.join(simpleWhereConditions, sql11` AND `)}`;
    const result = await db2.execute(sql11`
      SELECT 
        COALESCE(SUM(pt.amount::numeric), 0)::bigint as total_revenue,
        -- Platform fee: use service_fee if available, otherwise calculate as amount - manager_revenue
        -- This ensures we use Stripe-synced amounts when available
        COALESCE(
          SUM(
            CASE 
              WHEN pt.service_fee::numeric > 0 THEN pt.service_fee::numeric
              ELSE (pt.amount::numeric - pt.manager_revenue::numeric)
            END
          ), 
          0
        )::bigint as platform_fee,
        COALESCE(SUM(pt.manager_revenue::numeric), 0)::bigint as manager_revenue,
        COALESCE(SUM(CASE WHEN pt.status = 'succeeded' THEN pt.manager_revenue::numeric ELSE 0 END), 0)::bigint as deposited_manager_revenue,
        COUNT(DISTINCT CONCAT(pt.booking_id, '-', pt.booking_type)) as booking_count,
        COUNT(DISTINCT CASE WHEN pt.status = 'succeeded' THEN CONCAT(pt.booking_id, '-', pt.booking_type) END) as paid_booking_count,
        COUNT(DISTINCT CASE WHEN pt.status = 'processing' THEN CONCAT(pt.booking_id, '-', pt.booking_type) END) as processing_booking_count,
        COALESCE(SUM(CASE WHEN pt.status = 'succeeded' THEN pt.amount::numeric ELSE 0 END), 0)::bigint as completed_payments,
        COALESCE(SUM(CASE WHEN pt.status = 'processing' THEN pt.amount::numeric ELSE 0 END), 0)::bigint as processing_payments,
        COALESCE(SUM(CASE WHEN pt.status IN ('refunded', 'partially_refunded') THEN pt.refund_amount::numeric ELSE 0 END), 0)::bigint as refunded_amount,
        COALESCE(AVG(pt.amount::numeric), 0)::numeric as avg_booking_value,
        -- ENTERPRISE STANDARD: Stripe does NOT refund processing fees on refunds
        -- Manager pays the FULL original Stripe fee regardless of refunds
        -- This gives managers accurate picture of actual fees paid to Stripe
        COALESCE(SUM(pt.stripe_processing_fee::numeric), 0)::bigint as actual_stripe_fee
      FROM payment_transactions pt
      ${simpleWhereClause}
    `);
    const kitchenTaxResult = await db2.execute(sql11`
      SELECT 
        COALESCE(SUM(
          CASE
            -- PARTIAL CAPTURE: Use exact tax from capture engine metadata (source of truth)
            WHEN (pt.metadata->>'partialCapture')::boolean = true 
              AND (pt.metadata->>'approvedTax') IS NOT NULL THEN
              ROUND(
                (pt.metadata->>'approvedTax')::numeric *
                CASE 
                  WHEN pt.amount::numeric > 0 THEN 
                    (pt.amount::numeric - COALESCE(pt.refund_amount::numeric, 0)) / pt.amount::numeric
                  ELSE 1
                END
              )
            -- NORMAL BOOKINGS: Tax = kb.total_price * tax_rate / 100
            ELSE
              ROUND(
                (kb.total_price::numeric * COALESCE(k.tax_rate_percent, 0)::numeric / 100) *
                CASE 
                  WHEN pt.amount::numeric > 0 THEN 
                    (pt.amount::numeric - COALESCE(pt.refund_amount::numeric, 0)) / pt.amount::numeric
                  ELSE 1
                END
              )
          END
        ), 0)::bigint as calculated_tax_amount,
        -- ENTERPRISE STANDARD: Calculate PAYOUT amount for COMPLETED (succeeded) transactions
        -- Manager collects tax and keeps it (remits to tax authorities themselves)
        -- Payout = Amount - Stripe Fee - Refunds (tax is NOT subtracted - manager keeps it)
        COALESCE(SUM(
          CASE WHEN pt.status = 'succeeded' THEN
            pt.amount::numeric 
            - COALESCE(pt.stripe_processing_fee::numeric, 0)
            - COALESCE(pt.refund_amount::numeric, 0)
          ELSE 0 END
        ), 0)::bigint as completed_net_revenue,
        -- Get the actual tax rate from kitchens table (use MAX since it should be same for all kitchens of this manager)
        MAX(COALESCE(k.tax_rate_percent, 0))::numeric as tax_rate_percent
      FROM payment_transactions pt
      LEFT JOIN kitchen_bookings kb ON pt.booking_id = kb.id AND pt.booking_type IN ('kitchen', 'bundle')
      LEFT JOIN kitchens k ON kb.kitchen_id = k.id
      ${simpleWhereClause}
    `);
    const storageTaxResult = await db2.execute(sql11`
      SELECT 
        COALESCE(SUM(
          CASE 
            WHEN COALESCE(k.tax_rate_percent, 0) > 0 AND pt.amount::numeric > 0 
              AND pt.status NOT IN ('refunded') THEN
              -- For non-refunded: tax = ROUND(base * rate / 100) where base = ROUND(total / (1 + rate/100))
              ROUND(
                ROUND(pt.amount::numeric / (1 + COALESCE(k.tax_rate_percent, 0)::numeric / 100)) 
                * COALESCE(k.tax_rate_percent, 0)::numeric / 100
              )
            WHEN COALESCE(k.tax_rate_percent, 0) > 0 AND pt.amount::numeric > 0 
              AND pt.status = 'partially_refunded' THEN
              -- For partially refunded: proportionally reduce tax
              ROUND(
                ROUND(pt.amount::numeric / (1 + COALESCE(k.tax_rate_percent, 0)::numeric / 100)) 
                * COALESCE(k.tax_rate_percent, 0)::numeric / 100
                * (pt.amount::numeric - COALESCE(pt.refund_amount::numeric, 0)) / pt.amount::numeric
              )
            ELSE 0
          END
        ), 0)::bigint as storage_tax_amount
      FROM payment_transactions pt
      JOIN storage_bookings sb ON pt.booking_id = sb.id AND pt.booking_type = 'storage'
      JOIN storage_listings sl ON sb.storage_listing_id = sl.id
      JOIN kitchens k ON sl.kitchen_id = k.id
      WHERE pt.manager_id = ${managerId}
        AND (pt.status = 'succeeded' OR pt.status = 'processing' OR pt.status = 'partially_refunded')
    `);
    const row = result.rows[0] || {};
    const kitchenTaxRow = kitchenTaxResult.rows[0] || {};
    const storageTaxRow = storageTaxResult.rows[0] || {};
    const kitchenTax = kitchenTaxRow.calculated_tax_amount != null ? parseInt(String(kitchenTaxRow.calculated_tax_amount)) : 0;
    const storageTax = storageTaxRow.storage_tax_amount != null ? parseInt(String(storageTaxRow.storage_tax_amount)) : 0;
    const combinedTaxAmount = kitchenTax + storageTax;
    logger.info("[Revenue Service V2] Tax breakdown:", {
      kitchenTax,
      storageTax,
      combinedTaxAmount,
      kitchenTaxRaw: kitchenTaxRow.calculated_tax_amount,
      storageTaxRaw: storageTaxRow.storage_tax_amount
    });
    const taxRow = {
      calculated_tax_amount: combinedTaxAmount,
      completed_net_revenue: kitchenTaxRow.completed_net_revenue,
      tax_rate_percent: kitchenTaxRow.tax_rate_percent
    };
    logger.info("[Revenue Service V2] Query result:", {
      managerId,
      startDate: startDate ? typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0] : "none",
      endDate: endDate ? typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0] : "none",
      locationId: locationId || "none",
      total_revenue: row.total_revenue,
      platform_fee: row.platform_fee,
      manager_revenue: row.manager_revenue,
      deposited_manager_revenue: row.deposited_manager_revenue,
      booking_count: row.booking_count,
      completed_payments: row.completed_payments,
      processing_payments: row.processing_payments
    });
    const parseNumeric = (value) => {
      if (!value) return 0;
      if (typeof value === "string") return parseInt(value) || 0;
      return parseInt(String(value)) || 0;
    };
    const completedPayments = parseNumeric(row.completed_payments);
    const pendingPayments = parseNumeric(row.pending_payments);
    const platformFee = parseNumeric(row.platform_fee);
    const managerRevenue = parseNumeric(row.manager_revenue);
    const depositedManagerRevenue = parseNumeric(row.deposited_manager_revenue);
    const refundedAmount = parseNumeric(row.refunded_amount);
    const bookingCount = parseInt(row.booking_count) || 0;
    const paidBookingCount = parseInt(row.paid_booking_count) || 0;
    const cancelledBookingCount = 0;
    const averageBookingValue = row.avg_booking_value ? Math.round(parseFloat(String(row.avg_booking_value))) : 0;
    const grossRevenueRaw = parseNumeric(row.total_revenue);
    const actualStripeFee = parseNumeric(row.actual_stripe_fee);
    const stripeFee = actualStripeFee > 0 ? actualStripeFee : 0;
    const totalRevenue = grossRevenueRaw - refundedAmount;
    const finalManagerRevenue = managerRevenue;
    const actualTaxAmount = parseNumeric(taxRow.calculated_tax_amount);
    const completedNetRevenue = parseNumeric(taxRow.completed_net_revenue);
    const taxRatePercent = taxRow.tax_rate_percent ? parseFloat(String(taxRow.tax_rate_percent)) : 0;
    const taxAmount = actualTaxAmount;
    const netRevenue = totalRevenue - taxAmount - stripeFee;
    const effectiveCompletedPayments = Math.max(0, completedPayments - refundedAmount);
    logger.info("[Revenue Service V2] Fee breakdown:", {
      grossRevenueRaw,
      refundedAmount,
      totalRevenue,
      actualStripeFee,
      actualTaxAmount,
      stripeFee,
      taxAmount,
      netRevenue,
      effectiveCompletedPayments,
      usingActualStripeFee: actualStripeFee > 0,
      usingActualTaxAmount: actualTaxAmount > 0
    });
    const metrics = {
      totalRevenue: isNaN(totalRevenue) ? 0 : totalRevenue,
      platformFee: isNaN(platformFee) ? 0 : platformFee,
      taxAmount: isNaN(taxAmount) ? 0 : taxAmount || 0,
      stripeFee: isNaN(stripeFee) ? 0 : stripeFee || 0,
      netRevenue: isNaN(netRevenue) ? 0 : netRevenue || 0,
      managerRevenue: isNaN(finalManagerRevenue) ? 0 : finalManagerRevenue,
      // Use database value from Stripe (includes processing)
      depositedManagerRevenue: isNaN(depositedManagerRevenue) ? 0 : depositedManagerRevenue,
      // Only succeeded transactions (what's in bank)
      pendingPayments: isNaN(pendingPayments) ? 0 : pendingPayments,
      completedPayments: isNaN(effectiveCompletedPayments) ? 0 : effectiveCompletedPayments,
      // ENTERPRISE STANDARD: Net revenue from completed transactions only (payout-ready amount)
      // This is calculated server-side: Amount - Tax - Stripe Fee - Refunds for succeeded transactions
      completedNetRevenue: isNaN(completedNetRevenue) ? 0 : Math.max(0, completedNetRevenue),
      taxRatePercent: isNaN(taxRatePercent) ? 0 : taxRatePercent,
      // Actual tax rate from kitchens table
      averageBookingValue: isNaN(averageBookingValue) ? 0 : averageBookingValue,
      bookingCount: isNaN(bookingCount) ? 0 : bookingCount,
      paidBookingCount: isNaN(paidBookingCount) ? 0 : paidBookingCount,
      cancelledBookingCount: isNaN(cancelledBookingCount) ? 0 : cancelledBookingCount,
      refundedAmount: isNaN(refundedAmount) ? 0 : refundedAmount
    };
    logger.info("[Revenue Service V2] Final metrics:", metrics);
    return metrics;
  } catch (error) {
    logger.error("Error getting revenue metrics from transactions:", error);
    throw error;
  }
}
async function getRevenueByLocationFromTransactions(managerId, db2, startDate, endDate) {
  try {
    const tableCheck = await db2.execute(sql11`
      SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'payment_transactions'
      ) as table_exists
    `);
    if (!tableCheck.rows[0]?.table_exists) {
      throw new Error("payment_transactions table does not exist");
    }
    const whereConditions = [sql11`pt.manager_id = ${managerId}`];
    whereConditions.push(sql11`pt.booking_type IN ('kitchen', 'bundle', 'storage', 'equipment')`);
    whereConditions.push(sql11`(pt.status = 'succeeded' OR pt.status = 'processing' OR pt.status = 'refunded' OR pt.status = 'partially_refunded')`);
    whereConditions.push(sql11`
      NOT (
        pt.booking_type = 'kitchen' 
        AND EXISTS (
          SELECT 1 FROM payment_transactions pt2
          WHERE pt2.booking_id = pt.booking_id
            AND pt2.booking_type = 'bundle'
            AND pt2.manager_id = pt.manager_id
        )
      )
    `);
    const whereClause = sql11`WHERE ${sql11.join(whereConditions, sql11` AND `)}`;
    const result = await db2.execute(sql11`
      SELECT 
        l.id as location_id,
        l.name as location_name,
        COALESCE(SUM(pt.amount::numeric), 0)::bigint as total_revenue,
        -- Platform fee: use service_fee if available, otherwise calculate as amount - manager_revenue
        COALESCE(
          SUM(
            CASE 
              WHEN pt.service_fee::numeric > 0 THEN pt.service_fee::numeric
              ELSE (pt.amount::numeric - pt.manager_revenue::numeric)
            END
          ), 
          0
        )::bigint as platform_fee,
        COALESCE(SUM(pt.manager_revenue::numeric), 0)::bigint as manager_revenue,
        COUNT(DISTINCT pt.booking_id) as booking_count,
        COUNT(DISTINCT CASE WHEN pt.status = 'succeeded' THEN pt.booking_id END) as paid_count
      FROM payment_transactions pt
      JOIN kitchens k ON (
        (pt.booking_type = 'kitchen' AND pt.booking_id IN (SELECT id FROM kitchen_bookings WHERE kitchen_id = k.id))
        OR (pt.booking_type = 'bundle' AND pt.booking_id IN (SELECT id FROM kitchen_bookings WHERE kitchen_id = k.id))
        OR (pt.booking_type = 'storage' AND pt.booking_id IN (
          SELECT sb.id FROM storage_bookings sb
          JOIN storage_listings sl ON sb.storage_listing_id = sl.id
          WHERE sl.kitchen_id = k.id
        ))
        OR (pt.booking_type = 'equipment' AND pt.booking_id IN (
          SELECT eb.id FROM equipment_bookings eb
          JOIN equipment_listings el ON eb.equipment_listing_id = el.id
          WHERE el.kitchen_id = k.id
        ))
      )
      JOIN locations l ON k.location_id = l.id
      ${whereClause}
      GROUP BY l.id, l.name
      ORDER BY total_revenue DESC
    `);
    logger.info(`[Revenue Service V2] Revenue by location: ${result.rows.length} locations found`);
    return result.rows.map((row) => {
      const parseNumeric = (value) => {
        if (!value) return 0;
        if (typeof value === "string") return parseInt(value) || 0;
        return parseInt(String(value)) || 0;
      };
      const locTotalRevenue = parseNumeric(row.total_revenue);
      const locPlatformFee = parseNumeric(row.platform_fee);
      const locManagerRevenue = Math.max(0, locTotalRevenue - locPlatformFee);
      return {
        locationId: parseInt(row.location_id),
        locationName: row.location_name,
        totalRevenue: locTotalRevenue,
        platformFee: locPlatformFee,
        managerRevenue: locManagerRevenue,
        // Calculated as total - platform fee
        bookingCount: parseInt(row.booking_count) || 0,
        paidBookingCount: parseInt(row.paid_count) || 0
      };
    });
  } catch (error) {
    logger.error("Error getting revenue by location from transactions:", error);
    throw error;
  }
}
async function getRevenueByDateFromTransactions(managerId, db2, startDate, endDate) {
  try {
    const tableCheck = await db2.execute(sql11`
      SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'payment_transactions'
      ) as table_exists
    `);
    if (!tableCheck.rows[0]?.table_exists) {
      throw new Error("payment_transactions table does not exist");
    }
    const tzResult = await db2.execute(sql11`
      SELECT COALESCE(l.timezone, 'America/St_Johns') as timezone
      FROM locations l
      WHERE l.manager_id = ${managerId}
      LIMIT 1
    `);
    const managerTimezone = tzResult.rows[0]?.timezone || "America/St_Johns";
    const start = typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0];
    const end = typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0];
    const whereConditions = [sql11`pt.manager_id = ${managerId}`];
    whereConditions.push(sql11`pt.booking_type IN ('kitchen', 'bundle', 'storage', 'equipment')`);
    whereConditions.push(sql11`
      NOT (
        pt.booking_type = 'kitchen' 
        AND EXISTS (
          SELECT 1 FROM payment_transactions pt2
          WHERE pt2.booking_id = pt.booking_id
            AND pt2.booking_type = 'bundle'
            AND pt2.manager_id = pt.manager_id
        )
      )
    `);
    whereConditions.push(sql11`
      (
        (pt.status = 'succeeded' AND pt.paid_at IS NOT NULL 
          AND DATE(pt.paid_at AT TIME ZONE 'UTC' AT TIME ZONE ${managerTimezone}) >= ${start}::date 
          AND DATE(pt.paid_at AT TIME ZONE 'UTC' AT TIME ZONE ${managerTimezone}) <= ${end}::date)
        OR (pt.status != 'succeeded' 
          AND DATE(pt.created_at AT TIME ZONE 'UTC' AT TIME ZONE ${managerTimezone}) >= ${start}::date 
          AND DATE(pt.created_at AT TIME ZONE 'UTC' AT TIME ZONE ${managerTimezone}) <= ${end}::date)
      )
    `);
    const whereClause = sql11`WHERE ${sql11.join(whereConditions, sql11` AND `)}`;
    const result = await db2.execute(sql11`
      SELECT 
        DATE(
          CASE 
            WHEN pt.status = 'succeeded' AND pt.paid_at IS NOT NULL 
            THEN pt.paid_at AT TIME ZONE 'UTC' AT TIME ZONE ${managerTimezone}
            ELSE pt.created_at AT TIME ZONE 'UTC' AT TIME ZONE ${managerTimezone}
          END
        )::text as date,
        COALESCE(SUM(pt.amount::numeric), 0)::bigint as total_revenue,
        -- Platform fee: use service_fee if available, otherwise calculate as amount - manager_revenue
        COALESCE(
          SUM(
            CASE 
              WHEN pt.service_fee::numeric > 0 THEN pt.service_fee::numeric
              ELSE (pt.amount::numeric - pt.manager_revenue::numeric)
            END
          ), 
          0
        )::bigint as platform_fee,
        COALESCE(SUM(pt.manager_revenue::numeric), 0)::bigint as manager_revenue,
        COUNT(DISTINCT pt.booking_id) as booking_count
      FROM payment_transactions pt
      ${whereClause}
      GROUP BY DATE(
        CASE 
          WHEN pt.status = 'succeeded' AND pt.paid_at IS NOT NULL 
          THEN pt.paid_at AT TIME ZONE 'UTC' AT TIME ZONE ${managerTimezone}
          ELSE pt.created_at AT TIME ZONE 'UTC' AT TIME ZONE ${managerTimezone}
        END
      )
      ORDER BY date ASC
    `);
    logger.info(`[Revenue Service V2] Revenue by date: ${result.rows.length} dates found`);
    return result.rows.map((row) => {
      const parseNumeric = (value) => {
        if (!value) return 0;
        if (typeof value === "string") return parseInt(value) || 0;
        return parseInt(String(value)) || 0;
      };
      return {
        date: row.date,
        totalRevenue: parseNumeric(row.total_revenue),
        platformFee: parseNumeric(row.platform_fee),
        managerRevenue: Math.max(0, parseNumeric(row.total_revenue) - parseNumeric(row.platform_fee)),
        // Calculate as total - platform fee
        bookingCount: parseInt(row.booking_count) || 0
      };
    });
  } catch (error) {
    logger.error("Error getting revenue by date from transactions:", error);
    throw error;
  }
}
var init_revenue_service_v2 = __esm({
  "server/services/revenue-service-v2.ts"() {
    "use strict";
    init_logger();
  }
});

// server/services/revenue-service.ts
var revenue_service_exports = {};
__export(revenue_service_exports, {
  calculateManagerRevenue: () => calculateManagerRevenue,
  getCompleteRevenueMetrics: () => getCompleteRevenueMetrics,
  getRevenueByDate: () => getRevenueByDate,
  getRevenueByLocation: () => getRevenueByLocation,
  getRevenueMetrics: () => getRevenueMetrics,
  getTransactionHistory: () => getTransactionHistory
});
import { sql as sql12 } from "drizzle-orm";
function calculateManagerRevenue(totalRevenue, serviceFeeRate) {
  if (serviceFeeRate < 0 || serviceFeeRate > 1) {
    logger.warn(`Invalid service fee rate: ${serviceFeeRate}, using 0`);
    return totalRevenue;
  }
  const managerRate = 1 - serviceFeeRate;
  return Math.round(totalRevenue * managerRate);
}
async function getRevenueMetrics(managerId, db2, startDate, endDate, locationId) {
  try {
    const whereConditions = [sql12`l.manager_id = ${managerId}`, sql12`kb.status != 'cancelled'`];
    if (locationId) {
      whereConditions.push(sql12`l.id = ${locationId}`);
    }
    const whereClause = sql12`WHERE ${sql12.join(whereConditions, sql12` AND `)}`;
    const { getServiceFeeRate: getServiceFeeRate2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
    const serviceFeeRate = await getServiceFeeRate2();
    const debugQuery = await db2.execute(sql12`
      SELECT 
        COUNT(*) as total_bookings,
        COUNT(CASE WHEN kb.total_price IS NOT NULL THEN 1 END) as bookings_with_price,
        COUNT(CASE WHEN kb.total_price IS NULL THEN 1 END) as bookings_without_price,
        COUNT(CASE WHEN kb.status = 'cancelled' THEN 1 END) as cancelled_count,
        COUNT(CASE WHEN kb.payment_status = 'processing' THEN 1 END) as processing_count,
        COUNT(CASE WHEN kb.payment_status = 'processing' THEN 1 END) as processing_count,
        COUNT(CASE WHEN kb.payment_status = 'paid' THEN 1 END) as paid_count,
        COUNT(CASE WHEN kb.payment_intent_id IS NOT NULL THEN 1 END) as with_payment_intent,
        COUNT(CASE WHEN kb.payment_status IS NULL THEN 1 END) as null_payment_status
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      WHERE l.manager_id = ${managerId}
    `);
    logger.info("[Revenue Service] Debug - Manager bookings:", {
      managerId,
      debug: debugQuery.rows[0],
      locationId,
      startDate,
      endDate
    });
    const result = await db2.execute(sql12`
      SELECT 
        COALESCE(SUM(
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric
        ), 0)::bigint as total_revenue,
        COALESCE(SUM(COALESCE(kb.service_fee, 0)::numeric), 0)::bigint as platform_fee,
        -- Calculate actual tax amount from kitchen tax_rate_percent
        COALESCE(SUM(
          ROUND(
            COALESCE(
              kb.total_price,
              CASE 
                WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
                THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
                ELSE 0
              END
            )::numeric * COALESCE(k.tax_rate_percent, 0)::numeric / 100
          )
        ), 0)::bigint as calculated_tax_amount,
        COUNT(*)::int as booking_count,
        COUNT(CASE WHEN kb.payment_status = 'paid' THEN 1 END)::int as paid_count,
        COUNT(CASE WHEN kb.payment_status = 'processing' THEN 1 END)::int as processing_count,
        COUNT(CASE WHEN kb.status = 'cancelled' THEN 1 END)::int as cancelled_count,
        COUNT(CASE WHEN kb.payment_status = 'refunded' OR kb.payment_status = 'partially_refunded' THEN 1 END)::int as refunded_count,
        COALESCE(SUM(CASE WHEN kb.payment_status = 'paid' THEN 
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric ELSE 0 END), 0)::bigint as completed_payments,
        COALESCE(SUM(CASE WHEN kb.payment_status = 'processing' THEN 
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric ELSE 0 END), 0)::bigint as pending_payments,
        COALESCE(SUM(CASE WHEN kb.payment_status = 'refunded' OR kb.payment_status = 'partially_refunded' THEN 
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric ELSE 0 END), 0)::bigint as refunded_amount,
        COALESCE(AVG(
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric
        ), 0)::numeric as avg_booking_value
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${whereClause}
    `);
    const pendingWhereConditions = [
      sql12`l.manager_id = ${managerId}`,
      sql12`kb.status != 'cancelled'`,
      sql12`kb.payment_status = 'processing'`
    ];
    if (locationId) {
      pendingWhereConditions.push(sql12`l.id = ${locationId}`);
    }
    const pendingWhereClause = sql12`WHERE ${sql12.join(pendingWhereConditions, sql12` AND `)}`;
    const pendingResult = await db2.execute(sql12`
      SELECT 
        COALESCE(SUM(
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric
        ), 0)::bigint as pending_payments_all,
        COUNT(*)::int as pending_count_all
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${pendingWhereClause}
    `);
    logger.info("[Revenue Service] Pending payments query result:", {
      managerId,
      locationId,
      pendingCount: pendingResult.rows[0]?.pending_count_all || 0,
      pendingAmount: pendingResult.rows[0]?.pending_payments_all || 0
    });
    const completedWhereConditions = [
      sql12`l.manager_id = ${managerId}`,
      sql12`kb.status != 'cancelled'`,
      sql12`kb.payment_status = 'paid'`
    ];
    if (locationId) {
      completedWhereConditions.push(sql12`l.id = ${locationId}`);
    }
    const completedWhereClause = sql12`WHERE ${sql12.join(completedWhereConditions, sql12` AND `)}`;
    const completedResult = await db2.execute(sql12`
      SELECT 
        COALESCE(SUM(
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric
        ), 0)::bigint as completed_payments_all,
        COUNT(*)::int as completed_count_all
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${completedWhereClause}
    `);
    const pendingRow = pendingResult.rows[0] || {};
    const allPendingPayments = typeof pendingRow.pending_payments_all === "string" ? parseInt(pendingRow.pending_payments_all) || 0 : pendingRow.pending_payments_all ? parseInt(String(pendingRow.pending_payments_all)) : 0;
    logger.info("[Revenue Service] Pending payments result:", {
      allPendingPayments,
      pendingCount: pendingRow.pending_count_all || 0,
      rawValue: pendingRow.pending_payments_all
    });
    const completedRow = completedResult.rows[0] || {};
    const allCompletedPayments = typeof completedRow.completed_payments_all === "string" ? parseInt(completedRow.completed_payments_all) || 0 : completedRow.completed_payments_all ? parseInt(String(completedRow.completed_payments_all)) : 0;
    logger.info("[Revenue Service] Main query result count:", result.rows.length);
    if (result.rows.length > 0) {
      const dbgRow = result.rows[0];
      logger.info("[Revenue Service] Main query result:", {
        total_revenue: dbgRow.total_revenue,
        platform_fee: dbgRow.platform_fee,
        booking_count: dbgRow.booking_count
      });
    }
    if (result.rows.length === 0) {
      logger.info("[Revenue Service] No bookings in date range, checking for payments outside date range...");
      const pendingFeeResult = await db2.execute(sql12`
        SELECT 
          COALESCE(SUM(COALESCE(kb.service_fee, 0)::numeric), 0)::bigint as pending_service_fee,
          COALESCE(SUM(
            ROUND(
              COALESCE(
                kb.total_price,
                CASE 
                  WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
                  THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
                  ELSE 0
                END
              )::numeric * COALESCE(k.tax_rate_percent, 0)::numeric / 100
            )
          ), 0)::bigint as pending_tax_amount
        FROM kitchen_bookings kb
        JOIN kitchens k ON kb.kitchen_id = k.id
        JOIN locations l ON k.location_id = l.id
        ${pendingWhereClause}
      `);
      const completedFeeResult = await db2.execute(sql12`
        SELECT 
          COALESCE(SUM(COALESCE(kb.service_fee, 0)::numeric), 0)::bigint as completed_service_fee,
          COALESCE(SUM(
            ROUND(
              COALESCE(
                kb.total_price,
                CASE 
                  WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
                  THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
                  ELSE 0
                END
              )::numeric * COALESCE(k.tax_rate_percent, 0)::numeric / 100
            )
          ), 0)::bigint as completed_tax_amount
        FROM kitchen_bookings kb
        JOIN kitchens k ON kb.kitchen_id = k.id
        JOIN locations l ON k.location_id = l.id
        ${completedWhereClause}
      `);
      const pSFr = pendingFeeResult.rows[0] || {};
      const pendingServiceFee = typeof pSFr.pending_service_fee === "string" ? parseInt(pSFr.pending_service_fee) || 0 : pSFr.pending_service_fee ? parseInt(String(pSFr.pending_service_fee)) : 0;
      const pendingTaxAmount = typeof pSFr.pending_tax_amount === "string" ? parseInt(pSFr.pending_tax_amount) || 0 : pSFr.pending_tax_amount ? parseInt(String(pSFr.pending_tax_amount)) : 0;
      const cSFr = completedFeeResult.rows[0] || {};
      const completedServiceFee = typeof cSFr.completed_service_fee === "string" ? parseInt(cSFr.completed_service_fee) || 0 : cSFr.completed_service_fee ? parseInt(String(cSFr.completed_service_fee)) : 0;
      const completedTaxAmount = typeof cSFr.completed_tax_amount === "string" ? parseInt(cSFr.completed_tax_amount) || 0 : cSFr.completed_tax_amount ? parseInt(String(cSFr.completed_tax_amount)) : 0;
      const totalRevenueWithAllPayments2 = allCompletedPayments + allPendingPayments;
      const totalServiceFee2 = pendingServiceFee + completedServiceFee;
      const managerRevenue2 = totalRevenueWithAllPayments2 - totalServiceFee2;
      const depositedManagerRevenue2 = allCompletedPayments - completedServiceFee;
      const paidCount = parseInt(completedRow.completed_count_all) || 0;
      let actualStripeFeeFromDb = 0;
      try {
        const feeResult = await db2.execute(sql12`
          SELECT COALESCE(SUM(stripe_processing_fee::numeric), 0)::bigint as total_stripe_fee
          FROM payment_transactions
          WHERE manager_id = ${managerId} AND status = 'succeeded' AND stripe_processing_fee > 0
        `);
        actualStripeFeeFromDb = parseInt(feeResult.rows[0]?.total_stripe_fee || "0") || 0;
      } catch (feeError) {
        logger.warn("[Revenue Service] Could not fetch actual Stripe fees:", feeError);
      }
      const estimatedStripeFee = actualStripeFeeFromDb > 0 ? actualStripeFeeFromDb : 0;
      const taxAmount2 = pendingTaxAmount + completedTaxAmount;
      const netRevenue2 = totalRevenueWithAllPayments2 - taxAmount2 - estimatedStripeFee;
      return {
        totalRevenue: totalRevenueWithAllPayments2 || 0,
        platformFee: totalServiceFee2 || 0,
        taxAmount: taxAmount2 || 0,
        stripeFee: estimatedStripeFee || 0,
        netRevenue: netRevenue2 || 0,
        managerRevenue: managerRevenue2 || 0,
        depositedManagerRevenue: depositedManagerRevenue2 || 0,
        pendingPayments: allPendingPayments,
        completedPayments: allCompletedPayments,
        // Show ALL completed payments, not just in date range
        averageBookingValue: 0,
        bookingCount: 0,
        paidBookingCount: paidCount,
        cancelledBookingCount: 0,
        refundedAmount: 0
      };
    }
    const row = result.rows[0];
    logger.info("[Revenue Service] Query result:", {
      total_revenue: row.total_revenue,
      platform_fee: row.platform_fee,
      booking_count: row.booking_count,
      paid_count: row.paid_count,
      serviceFeeRate,
      rowData: row
    });
    const totalRevenue = typeof row.total_revenue === "string" ? parseInt(row.total_revenue) : row.total_revenue ? parseInt(String(row.total_revenue)) : 0;
    const platformFee = typeof row.platform_fee === "string" ? parseInt(row.platform_fee) : row.platform_fee ? parseInt(String(row.platform_fee)) : 0;
    const totalRevenueWithAllPayments = allCompletedPayments + allPendingPayments;
    const pendingFeeResult2 = await db2.execute(sql12`
      SELECT 
        COALESCE(SUM(COALESCE(kb.service_fee, 0)::numeric), 0)::bigint as pending_service_fee,
        COALESCE(SUM(
          ROUND(
            COALESCE(
              kb.total_price,
              CASE 
                WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
                THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
                ELSE 0
              END
            )::numeric * COALESCE(k.tax_rate_percent, 0)::numeric / 100
          )
        ), 0)::bigint as pending_tax_amount
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${pendingWhereClause}
    `);
    const completedFeeResult2 = await db2.execute(sql12`
      SELECT 
        COALESCE(SUM(COALESCE(kb.service_fee, 0)::numeric), 0)::bigint as completed_service_fee,
        COALESCE(SUM(
          ROUND(
            COALESCE(
              kb.total_price,
              CASE 
                WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
                THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
                ELSE 0
              END
            )::numeric * COALESCE(k.tax_rate_percent, 0)::numeric / 100
          )
        ), 0)::bigint as completed_tax_amount
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${completedWhereClause}
    `);
    const pSFr2 = pendingFeeResult2.rows[0] || {};
    const pendingServiceFee2 = typeof pSFr2.pending_service_fee === "string" ? parseInt(pSFr2.pending_service_fee) || 0 : pSFr2.pending_service_fee ? parseInt(String(pSFr2.pending_service_fee)) : 0;
    const pendingTaxAmount2 = typeof pSFr2.pending_tax_amount === "string" ? parseInt(pSFr2.pending_tax_amount) || 0 : pSFr2.pending_tax_amount ? parseInt(String(pSFr2.pending_tax_amount)) : 0;
    const cSFr2 = completedFeeResult2.rows[0] || {};
    const completedServiceFee2 = typeof cSFr2.completed_service_fee === "string" ? parseInt(cSFr2.completed_service_fee) || 0 : cSFr2.completed_service_fee ? parseInt(String(cSFr2.completed_service_fee)) : 0;
    const completedTaxAmount2 = typeof cSFr2.completed_tax_amount === "string" ? parseInt(cSFr2.completed_tax_amount) || 0 : cSFr2.completed_tax_amount ? parseInt(String(cSFr2.completed_tax_amount)) : 0;
    const totalServiceFee = pendingServiceFee2 + completedServiceFee2;
    const managerRevenue = totalRevenueWithAllPayments - totalServiceFee;
    const depositedManagerRevenue = allCompletedPayments - completedServiceFee2;
    const paidBookingCountVal = isNaN(parseInt(completedRow.completed_count_all)) ? 0 : parseInt(completedRow.completed_count_all) || 0;
    let actualStripeFee = 0;
    let stripeFeeSource = "estimated";
    try {
      const stripeFeeConditions = [
        sql12`pt.manager_id = ${managerId}`,
        sql12`pt.status IN ('succeeded', 'partially_refunded')`,
        // Include partially refunded but not fully refunded
        sql12`pt.stripe_processing_fee IS NOT NULL`,
        sql12`pt.stripe_processing_fee > 0`
      ];
      if (locationId) {
        stripeFeeConditions.push(sql12`EXISTS (
          SELECT 1 FROM kitchen_bookings kb 
          JOIN kitchens k ON kb.kitchen_id = k.id 
          WHERE kb.id = pt.booking_id 
          AND pt.booking_type = 'kitchen'
          AND k.location_id = ${locationId}
        )`);
      }
      const stripeFeeResult = await db2.execute(sql12`
        SELECT COALESCE(SUM(
          CASE 
            WHEN pt.amount::numeric > 0 THEN
              ROUND(pt.stripe_processing_fee::numeric * (pt.amount::numeric - COALESCE(pt.refund_amount::numeric, 0)) / pt.amount::numeric)
            ELSE 0
          END
        ), 0)::bigint as total_stripe_fee
        FROM payment_transactions pt
        WHERE ${sql12.join(stripeFeeConditions, sql12` AND `)}
      `);
      const stripeFeeRow = stripeFeeResult.rows[0] || {};
      const storedStripeFee = typeof stripeFeeRow.total_stripe_fee === "string" ? parseInt(stripeFeeRow.total_stripe_fee) || 0 : stripeFeeRow.total_stripe_fee ? parseInt(String(stripeFeeRow.total_stripe_fee)) : 0;
      if (storedStripeFee > 0) {
        actualStripeFee = storedStripeFee;
        stripeFeeSource = "stripe";
        logger.info(`[Revenue Service] Using actual Stripe fees from payment_transactions: ${actualStripeFee} cents`);
      } else {
        actualStripeFee = 0;
        logger.info(`[Revenue Service] No stored Stripe fees found - fees will sync via charge.updated webhook`);
      }
    } catch (error) {
      logger.warn("[Revenue Service] Error fetching Stripe fees from payment_transactions:", error);
      actualStripeFee = 0;
    }
    const grossTaxAmount = pendingTaxAmount2 + completedTaxAmount2;
    const refundedAmount = typeof row.refunded_amount === "string" ? isNaN(parseInt(row.refunded_amount)) ? 0 : parseInt(row.refunded_amount) || 0 : row.refunded_amount ? isNaN(parseInt(String(row.refunded_amount))) ? 0 : parseInt(String(row.refunded_amount)) : 0;
    let effectiveTaxAmount = 0;
    try {
      const effectiveTaxResult = await db2.execute(sql12`
        SELECT COALESCE(SUM(
          -- Tax = kb.total_price * tax_rate / 100 (same formula as transaction history)
          -- For partial refunds: multiply by (1 - refund_ratio) to get effective tax
          ROUND(
            (kb.total_price::numeric * COALESCE(k.tax_rate_percent, 0)::numeric / 100) *
            CASE 
              WHEN pt.amount::numeric > 0 THEN 
                (pt.amount::numeric - COALESCE(pt.refund_amount::numeric, 0)) / pt.amount::numeric
              ELSE 1
            END
          )
        ), 0)::bigint as effective_tax
        FROM payment_transactions pt
        LEFT JOIN kitchen_bookings kb ON pt.booking_id = kb.id AND pt.booking_type IN ('kitchen', 'bundle')
        LEFT JOIN kitchens k ON kb.kitchen_id = k.id
        WHERE pt.manager_id = ${managerId}
      `);
      const effectiveTaxRow = effectiveTaxResult.rows[0] || {};
      effectiveTaxAmount = typeof effectiveTaxRow.effective_tax === "string" ? parseInt(effectiveTaxRow.effective_tax) || 0 : effectiveTaxRow.effective_tax ? parseInt(String(effectiveTaxRow.effective_tax)) : 0;
    } catch (error) {
      logger.warn("[Revenue Service] Error calculating effective tax amount:", error);
    }
    const taxAmount = effectiveTaxAmount > 0 ? effectiveTaxAmount : grossTaxAmount;
    const effectiveGrossRevenue = totalRevenueWithAllPayments - refundedAmount;
    const netRevenue = effectiveGrossRevenue - taxAmount - actualStripeFee;
    const effectiveCompletedPayments = Math.max(0, allCompletedPayments - refundedAmount);
    return {
      totalRevenue: isNaN(effectiveGrossRevenue) ? 0 : effectiveGrossRevenue || 0,
      platformFee: isNaN(totalServiceFee) ? 0 : totalServiceFee || 0,
      taxAmount: isNaN(taxAmount) ? 0 : taxAmount || 0,
      stripeFee: isNaN(actualStripeFee) ? 0 : actualStripeFee || 0,
      netRevenue: isNaN(netRevenue) ? 0 : netRevenue || 0,
      managerRevenue: isNaN(managerRevenue) ? 0 : managerRevenue || 0,
      depositedManagerRevenue: isNaN(depositedManagerRevenue) ? 0 : depositedManagerRevenue || 0,
      pendingPayments: allPendingPayments,
      // Use ALL pending payments, not just those in date range
      completedPayments: isNaN(effectiveCompletedPayments) ? 0 : effectiveCompletedPayments,
      // Deduct refunds
      averageBookingValue: row.avg_booking_value ? isNaN(Math.round(parseFloat(String(row.avg_booking_value)))) ? 0 : Math.round(parseFloat(String(row.avg_booking_value))) : 0,
      bookingCount: isNaN(parseInt(row.booking_count)) ? 0 : parseInt(row.booking_count) || 0,
      paidBookingCount: paidBookingCountVal,
      cancelledBookingCount: isNaN(parseInt(row.cancelled_count)) ? 0 : parseInt(row.cancelled_count) || 0,
      refundedAmount
    };
  } catch (error) {
    logger.error("Error getting revenue metrics:", error);
    throw error;
  }
}
async function getRevenueByLocation(managerId, db2, startDate, endDate) {
  try {
    if (managerId === void 0 || managerId === null || isNaN(managerId)) {
      logger.error("[Revenue Service] Invalid managerId:", managerId);
      throw new Error("Invalid manager ID");
    }
    const managerIdParam = sql12`${managerId}`;
    const whereConditions = [sql12`l.manager_id = ${managerIdParam}`, sql12`kb.status != 'cancelled'`];
    if (startDate) {
      const start = typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0];
      whereConditions.push(sql12`DATE(kb.booking_date) >= ${start}::date`);
    }
    if (endDate) {
      const end = typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0];
      whereConditions.push(sql12`DATE(kb.booking_date) <= ${end}::date`);
    }
    const whereClause = sql12`WHERE ${sql12.join(whereConditions, sql12` AND `)}`;
    const { getServiceFeeRate: getServiceFeeRate2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
    const serviceFeeRate = await getServiceFeeRate2();
    const result = await db2.execute(sql12`
      SELECT 
        l.id as location_id,
        l.name as location_name,
        COALESCE(SUM(
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric
        ), 0)::bigint as total_revenue,
        COALESCE(SUM(COALESCE(kb.service_fee, 0)::numeric), 0)::bigint as platform_fee,
        COUNT(*)::int as booking_count,
        COUNT(CASE WHEN kb.payment_status = 'paid' THEN 1 END)::int as paid_count
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${whereClause}
      GROUP BY l.id, l.name
      ORDER BY total_revenue DESC
    `);
    return result.rows.map((row) => {
      const totalRevenue = typeof row.total_revenue === "string" ? parseInt(row.total_revenue) || 0 : row.total_revenue ? parseInt(String(row.total_revenue)) : 0;
      const platformFee = typeof row.platform_fee === "string" ? parseInt(row.platform_fee) || 0 : row.platform_fee ? parseInt(String(row.platform_fee)) : 0;
      const managerRevenue = totalRevenue - platformFee;
      return {
        locationId: parseInt(row.location_id),
        locationName: row.location_name,
        totalRevenue,
        platformFee,
        managerRevenue: managerRevenue || 0,
        bookingCount: parseInt(row.booking_count) || 0,
        paidBookingCount: parseInt(row.paid_count) || 0
      };
    });
  } catch (error) {
    logger.error("Error getting revenue by location:", error);
    throw error;
  }
}
async function getRevenueByDate(managerId, db2, startDate, endDate) {
  try {
    if (managerId === void 0 || managerId === null || isNaN(managerId)) {
      logger.error("[Revenue Service] Invalid managerId:", managerId);
      throw new Error("Invalid manager ID");
    }
    const start = typeof startDate === "string" ? startDate : startDate ? startDate.toISOString().split("T")[0] : null;
    const end = typeof endDate === "string" ? endDate : endDate ? endDate.toISOString().split("T")[0] : null;
    const managerIdParam = sql12`${managerId}`;
    if (!start || !end) {
      logger.warn("[Revenue Service] Missing date parameters for getRevenueByDate");
    }
    const startParam = start ? sql12`${start}::date` : sql12`CURRENT_DATE - INTERVAL '30 days'`;
    const endParam = end ? sql12`${end}::date` : sql12`CURRENT_DATE`;
    const tzResult = await db2.execute(sql12`
      SELECT COALESCE(l.timezone, 'America/St_Johns') as timezone
      FROM locations l
      WHERE l.manager_id = ${managerIdParam}
      LIMIT 1
    `);
    const managerTimezone = tzResult.rows[0]?.timezone || "America/St_Johns";
    const { getServiceFeeRate: getServiceFeeRate2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
    const serviceFeeRate = await getServiceFeeRate2();
    const result = await db2.execute(sql12`
      SELECT 
        DATE(kb.booking_date AT TIME ZONE 'UTC' AT TIME ZONE ${managerTimezone})::text as date,
        COALESCE(SUM(
          COALESCE(
            kb.total_price,
            CASE 
              WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
              THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
              ELSE 0
            END
          )::numeric
        ), 0)::bigint as total_revenue,
        COALESCE(SUM(COALESCE(kb.service_fee, 0)::numeric), 0)::bigint as platform_fee,
        COUNT(*)::int as booking_count
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      WHERE l.manager_id = ${managerIdParam}
        AND kb.status != 'cancelled'
        AND DATE(kb.booking_date AT TIME ZONE 'UTC' AT TIME ZONE ${managerTimezone}) >= ${startParam}
        AND DATE(kb.booking_date AT TIME ZONE 'UTC' AT TIME ZONE ${managerTimezone}) <= ${endParam}
      GROUP BY DATE(kb.booking_date AT TIME ZONE 'UTC' AT TIME ZONE ${managerTimezone})
      ORDER BY date ASC
    `);
    logger.info("[Revenue Service] Revenue by date query:", {
      managerId,
      start,
      end,
      resultCount: result.rows.length,
      rows: result.rows
    });
    return result.rows.map((row) => {
      const totalRevenue = typeof row.total_revenue === "string" ? parseInt(row.total_revenue) || 0 : row.total_revenue ? parseInt(String(row.total_revenue)) : 0;
      const platformFee = typeof row.platform_fee === "string" ? parseInt(row.platform_fee) || 0 : row.platform_fee ? parseInt(String(row.platform_fee)) : 0;
      const managerRevenue = totalRevenue - platformFee;
      return {
        date: row.date,
        totalRevenue,
        platformFee,
        managerRevenue: managerRevenue || 0,
        bookingCount: parseInt(row.booking_count) || 0
      };
    });
  } catch (error) {
    logger.error("Error getting revenue by date:", error);
    throw error;
  }
}
async function getTransactionHistory(managerId, db2, startDate, endDate, locationId, limit = 100, offset = 0, paymentStatus) {
  try {
    const start = startDate ? typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0] : void 0;
    const end = endDate ? typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0] : void 0;
    const mapPaymentStatus = (status) => {
      if (!status) return "pending";
      if (status === "succeeded") return "paid";
      if (status === "canceled") return "canceled";
      return status;
    };
    const kitchenWhereConditions = [
      sql12`l.manager_id = ${managerId}`,
      // Show all non-cancelled bookings, PLUS cancelled bookings that have a payment transaction
      // (i.e., they were paid/refunded and should appear in transaction history)
      sql12`(kb.status != 'cancelled' OR pt.id IS NOT NULL)`
    ];
    if (start) {
      kitchenWhereConditions.push(sql12`(DATE(kb.booking_date) >= ${start}::date OR DATE(kb.created_at) >= ${start}::date)`);
    }
    if (end) {
      kitchenWhereConditions.push(sql12`(DATE(kb.booking_date) <= ${end}::date OR DATE(kb.created_at) <= ${end}::date)`);
    }
    if (locationId) {
      kitchenWhereConditions.push(sql12`l.id = ${locationId}`);
    }
    const kitchenWhereClause = sql12`WHERE ${sql12.join(kitchenWhereConditions, sql12` AND `)}`;
    const kitchenResult = await db2.execute(sql12`
      SELECT 
        kb.id,
        kb.booking_date,
        kb.start_time,
        kb.end_time,
        COALESCE(
          kb.total_price,
          CASE 
            WHEN kb.hourly_rate IS NOT NULL AND kb.duration_hours IS NOT NULL 
            THEN ROUND((kb.hourly_rate::numeric * kb.duration_hours::numeric)::numeric)
            ELSE 0
          END
        )::bigint as kb_total_price,
        COALESCE(kb.service_fee, 0)::bigint as service_fee,
        COALESCE(k.tax_rate_percent, 0)::numeric as tax_rate_percent,
        kb.payment_status,
        kb.payment_intent_id,
        kb.status,
        kb.currency,
        k.name as kitchen_name,
        l.id as location_id,
        l.name as location_name,
        COALESCE(cka.full_name, u.username) as chef_name,
        COALESCE(cka.email, u.username) as chef_email,
        kb.created_at,
        kb.updated_at,
        kb.reference_code,
        -- Actual amount from payment_transactions (what was actually charged to Stripe)
        pt.amount as pt_amount,
        -- Actual Stripe fee from payment_transactions (fetched from Stripe Balance Transaction API)
        COALESCE(pt.stripe_processing_fee, 0)::bigint as actual_stripe_fee,
        -- Service fee from payment_transactions
        COALESCE(pt.service_fee, 0)::bigint as pt_service_fee,
        -- Manager revenue from payment_transactions (actual Stripe net amount)
        pt.manager_revenue as pt_manager_revenue,
        pt.id as transaction_id,
        pt.status as transaction_status,
        pt.payment_intent_id as pt_payment_intent_id,
        pt.refund_amount as pt_refund_amount,
        pt.booking_type as pt_booking_type,
        pt.currency as pt_currency,
        pt.paid_at as pt_paid_at,
        pt.metadata as pt_metadata
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      LEFT JOIN users u ON kb.chef_id = u.id
      LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = kb.chef_id AND cka.location_id = l.id
      LEFT JOIN payment_transactions pt ON pt.booking_id = kb.id AND pt.booking_type IN ('kitchen', 'bundle')
      ${kitchenWhereClause}
      ORDER BY kb.created_at DESC
    `);
    const kitchenTransactions = kitchenResult.rows.map((row) => {
      const ptAmount = row.pt_amount != null ? parseInt(String(row.pt_amount)) : 0;
      const ptServiceFee = row.pt_service_fee != null ? parseInt(String(row.pt_service_fee)) : 0;
      const ptManagerRevenue = row.pt_manager_revenue != null ? parseInt(String(row.pt_manager_revenue)) : 0;
      const actualStripeFee = row.actual_stripe_fee != null ? parseInt(String(row.actual_stripe_fee)) : 0;
      const ptRefundAmount = row.pt_refund_amount != null ? parseInt(String(row.pt_refund_amount)) : 0;
      const ptMetadata = row.pt_metadata || {};
      const isDamageClaim = ptMetadata.type === "damage_claim";
      const kbTotalPrice = row.kb_total_price != null ? parseInt(String(row.kb_total_price)) : 0;
      const kbServiceFee = row.service_fee != null ? parseInt(String(row.service_fee)) : 0;
      const taxRatePercent = row.tax_rate_percent != null ? parseFloat(String(row.tax_rate_percent)) : 0;
      const hasPaymentTransaction = ptAmount > 0;
      let totalPriceCents;
      let taxCents;
      let serviceFeeCents;
      if (hasPaymentTransaction) {
        totalPriceCents = ptAmount;
        if (isDamageClaim) {
          taxCents = 0;
        } else if (ptMetadata.partialCapture && ptMetadata.approvedTax != null) {
          taxCents = parseInt(String(ptMetadata.approvedTax)) || 0;
        } else {
          taxCents = Math.round(kbTotalPrice * taxRatePercent / 100);
        }
        serviceFeeCents = ptServiceFee > 0 ? ptServiceFee : kbServiceFee;
      } else {
        totalPriceCents = kbTotalPrice;
        taxCents = isDamageClaim ? 0 : Math.round(kbTotalPrice * taxRatePercent / 100);
        serviceFeeCents = kbServiceFee;
      }
      const calculatedManagerRevenue = totalPriceCents - serviceFeeCents;
      const managerRevenue = ptManagerRevenue > 0 ? ptManagerRevenue : calculatedManagerRevenue;
      const stripeFee = actualStripeFee > 0 ? actualStripeFee : 0;
      const netRevenue = totalPriceCents - taxCents - stripeFee;
      const resolvedBookingType = isDamageClaim ? "damage_claim" : row.pt_booking_type || "kitchen";
      const description = isDamageClaim ? `Damage Claim - ${row.kitchen_name || "Kitchen"}` : void 0;
      const transactionId = row.transaction_id != null ? parseInt(String(row.transaction_id)) : null;
      const bookingId = parseInt(String(row.id));
      return {
        id: bookingId,
        transactionId,
        bookingId,
        // Add bookingId for invoice download
        bookingType: resolvedBookingType,
        bookingDate: row.booking_date,
        startTime: row.start_time,
        endTime: row.end_time,
        chefId: row.chef_id != null ? parseInt(String(row.chef_id)) : null,
        totalPrice: totalPriceCents,
        serviceFee: serviceFeeCents,
        platformFee: serviceFeeCents,
        // Alias for frontend compatibility - DEPRECATED
        taxAmount: taxCents,
        // Tax collected (from payment_transactions or calculated)
        taxRatePercent: isDamageClaim ? 0 : taxRatePercent,
        // Tax rate percentage applied (0 for damage claims)
        stripeFee,
        // Actual Stripe processing fee (from Stripe API or estimated)
        managerRevenue: managerRevenue || 0,
        netRevenue,
        // Net after tax and Stripe fees
        paymentStatus: mapPaymentStatus(row.transaction_status || row.payment_status),
        paymentIntentId: row.pt_payment_intent_id || row.payment_intent_id,
        status: row.status,
        currency: String(row.pt_currency || row.currency || "CAD").toUpperCase(),
        kitchenId: parseInt(String(row.kitchen_id)),
        kitchenName: row.kitchen_name,
        locationId: parseInt(String(row.location_id)),
        locationName: row.location_name,
        chefName: row.chef_name || "Guest",
        chefEmail: row.chef_email,
        referenceCode: row.reference_code,
        createdAt: row.created_at,
        paidAt: row.pt_paid_at || null,
        refundAmount: ptRefundAmount,
        // SIMPLE REFUND MODEL: Manager's balance is the cap
        // refundableAmount = managerRevenue - already refunded (not totalPrice - refunded)
        refundableAmount: Math.max(0, (managerRevenue || 0) - ptRefundAmount),
        // Add description field for damage claims
        description
      };
    });
    const storageResult = await db2.execute(sql12`
      SELECT 
        pt.id as transaction_id,
        pt.booking_id,
        pt.booking_type,
        pt.amount as pt_amount,
        pt.base_amount as pt_base_amount,
        pt.service_fee as pt_service_fee,
        pt.manager_revenue as pt_manager_revenue,
        pt.refund_amount as pt_refund_amount,
        pt.status as transaction_status,
        pt.payment_intent_id as pt_payment_intent_id,
        pt.currency as pt_currency,
        pt.created_at,
        pt.paid_at as pt_paid_at,
        pt.metadata as pt_metadata,
        -- Actual Stripe fee from payment_transactions (fetched from Stripe Balance Transaction API)
        COALESCE(pt.stripe_processing_fee, 0)::bigint as actual_stripe_fee,
        -- Tax rate from kitchen (same as kitchen bookings)
        COALESCE(k.tax_rate_percent, 0)::numeric as tax_rate_percent,
        sb.start_date as booking_date,
        sb.chef_id,
        sl.name as storage_name,
        k.name as kitchen_name,
        l.id as location_id,
        l.name as location_name,
        COALESCE(cka.full_name, u.username) as chef_name,
        COALESCE(cka.email, u.username) as chef_email
      FROM payment_transactions pt
      JOIN storage_bookings sb ON pt.booking_id = sb.id
      JOIN storage_listings sl ON sb.storage_listing_id = sl.id
      JOIN kitchens k ON sl.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      LEFT JOIN users u ON sb.chef_id = u.id
      LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = sb.chef_id AND cka.location_id = l.id
      WHERE pt.manager_id = ${managerId}
        AND pt.booking_type = 'storage'
        AND (pt.status = 'succeeded' OR pt.status = 'processing' OR pt.status = 'refunded' OR pt.status = 'partially_refunded')
      ORDER BY pt.created_at DESC
    `);
    const storageTransactions = storageResult.rows.map((row) => {
      const ptAmount = row.pt_amount != null ? parseInt(String(row.pt_amount)) : 0;
      const ptBaseAmountFromDb = row.pt_base_amount != null ? parseInt(String(row.pt_base_amount)) : 0;
      const ptServiceFee = row.pt_service_fee != null ? parseInt(String(row.pt_service_fee)) : 0;
      const ptManagerRevenue = row.pt_manager_revenue != null ? parseInt(String(row.pt_manager_revenue)) : 0;
      const ptRefundAmount = row.pt_refund_amount != null ? parseInt(String(row.pt_refund_amount)) : 0;
      const actualStripeFee = row.actual_stripe_fee != null ? parseInt(String(row.actual_stripe_fee)) : 0;
      const taxRatePercent = row.tax_rate_percent != null ? parseFloat(String(row.tax_rate_percent)) : 0;
      const metadata = row.pt_metadata || {};
      const isOverstayPenalty = metadata.type === "overstay_penalty";
      const isStorageExtension = metadata.storage_extension_id != null;
      const isDamageClaim = metadata.type === "damage_claim";
      let ptBaseAmount;
      if (isStorageExtension && metadata.extension_base_price_cents) {
        const metadataBaseAmount = parseInt(String(metadata.extension_base_price_cents));
        if (!isNaN(metadataBaseAmount) && metadataBaseAmount > 0) {
          ptBaseAmount = metadataBaseAmount;
        } else if (taxRatePercent > 0 && ptAmount > 0) {
          ptBaseAmount = Math.round(ptAmount / (1 + taxRatePercent / 100));
        } else {
          ptBaseAmount = ptBaseAmountFromDb;
        }
      } else if (isStorageExtension && taxRatePercent > 0 && ptAmount > 0) {
        ptBaseAmount = Math.round(ptAmount / (1 + taxRatePercent / 100));
      } else {
        ptBaseAmount = ptBaseAmountFromDb;
      }
      let description = row.storage_name || "Storage";
      if (isDamageClaim) {
        description = `Damage Claim - ${row.storage_name || "Storage"}`;
      } else if (isOverstayPenalty) {
        description = `Overstay Penalty - ${row.storage_name || "Storage"}`;
      } else if (isStorageExtension) {
        description = `Storage Extension - ${row.storage_name || "Storage"}`;
      }
      const transactionId = row.transaction_id != null ? parseInt(String(row.transaction_id)) : null;
      const bookingId = parseInt(String(row.booking_id));
      const stripeFee = actualStripeFee > 0 ? actualStripeFee : 0;
      const taxCents = isDamageClaim ? 0 : Math.round(ptBaseAmount * taxRatePercent / 100);
      const netRevenue = ptAmount - taxCents - stripeFee;
      let resolvedBookingType;
      if (isDamageClaim) {
        resolvedBookingType = "damage_claim";
      } else if (isOverstayPenalty) {
        resolvedBookingType = "overstay_penalty";
      } else if (isStorageExtension) {
        resolvedBookingType = "storage_extension";
      } else {
        resolvedBookingType = "storage";
      }
      return {
        id: bookingId,
        transactionId,
        bookingId,
        bookingType: resolvedBookingType,
        bookingDate: row.booking_date,
        startTime: null,
        endTime: null,
        chefId: row.chef_id != null ? parseInt(String(row.chef_id)) : null,
        totalPrice: ptAmount,
        serviceFee: ptServiceFee,
        platformFee: ptServiceFee,
        taxAmount: taxCents,
        taxRatePercent: isDamageClaim ? 0 : taxRatePercent,
        // Tax rate percentage applied (0 for damage claims - reimbursements, not revenue)
        stripeFee,
        // Actual Stripe processing fee (from Stripe API or estimated)
        managerRevenue: ptManagerRevenue || ptAmount,
        netRevenue,
        paymentStatus: mapPaymentStatus(row.transaction_status),
        paymentIntentId: row.pt_payment_intent_id,
        status: "confirmed",
        currency: String(row.pt_currency || "CAD").toUpperCase(),
        kitchenId: null,
        kitchenName: row.kitchen_name,
        storageName: row.storage_name,
        description,
        locationId: parseInt(String(row.location_id)),
        locationName: row.location_name,
        chefName: row.chef_name || "Guest",
        chefEmail: row.chef_email,
        createdAt: row.created_at,
        paidAt: row.pt_paid_at || null,
        refundAmount: ptRefundAmount,
        // SIMPLE REFUND MODEL: Manager's balance is the cap
        refundableAmount: Math.max(0, (ptManagerRevenue || ptAmount) - ptRefundAmount)
      };
    });
    let allTransactions = [...kitchenTransactions, ...storageTransactions];
    if (paymentStatus && paymentStatus !== "all") {
      allTransactions = allTransactions.filter((t) => t.paymentStatus === paymentStatus);
    }
    allTransactions.sort((a, b) => {
      return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
    });
    const total = allTransactions.length;
    const pagedTransactions = allTransactions.slice(offset, offset + limit);
    return { transactions: pagedTransactions, total };
  } catch (error) {
    logger.error("Error getting transaction history:", error);
    throw error;
  }
}
async function getCompleteRevenueMetrics(managerId, db2, startDate, endDate, locationId) {
  try {
    logger.info("[Revenue Service] getCompleteRevenueMetrics called:", {
      managerId,
      startDate,
      endDate,
      locationId
    });
    try {
      const { getRevenueMetricsFromTransactions: getRevenueMetricsFromTransactions2 } = await Promise.resolve().then(() => (init_revenue_service_v2(), revenue_service_v2_exports));
      const metrics = await getRevenueMetricsFromTransactions2(managerId, db2, startDate, endDate, locationId);
      logger.info("[Revenue Service] Using payment_transactions for revenue metrics");
      return metrics;
    } catch (error) {
      logger.warn("[Revenue Service] Failed to use payment_transactions, falling back to booking tables:", error);
    }
    const kitchenMetrics = await getRevenueMetrics(managerId, db2, startDate, endDate, locationId);
    logger.info("[Revenue Service] Kitchen metrics:", kitchenMetrics);
    const whereConditions = [sql12`l.manager_id = ${managerId}`];
    if (startDate) {
      const start = typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0];
      whereConditions.push(sql12`DATE(sb.start_date) >= ${start}::date`);
    }
    if (endDate) {
      const end = typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0];
      whereConditions.push(sql12`DATE(sb.start_date) <= ${end}::date`);
    }
    if (locationId) {
      whereConditions.push(sql12`l.id = ${locationId}`);
    }
    const whereClause = sql12`WHERE ${sql12.join(whereConditions, sql12` AND `)}`;
    const storageResult = await db2.execute(sql12`
      SELECT 
        COALESCE(SUM(COALESCE(sb.total_price, 0)::numeric), 0)::bigint as total_revenue,
        COALESCE(SUM(COALESCE(sb.service_fee, 0)::numeric), 0)::bigint as platform_fee,
        COUNT(*)::int as booking_count,
        COUNT(CASE WHEN sb.payment_status = 'paid' THEN 1 END)::int as paid_count,
        COALESCE(SUM(CASE WHEN sb.payment_status = 'paid' THEN COALESCE(sb.total_price, 0)::numeric ELSE 0 END), 0)::bigint as completed_payments,
        COALESCE(SUM(CASE WHEN sb.payment_status = 'processing' THEN COALESCE(sb.total_price, 0)::numeric ELSE 0 END), 0)::bigint as processing_payments
      FROM storage_bookings sb
      JOIN storage_listings sl ON sb.storage_listing_id = sl.id
      JOIN kitchens k ON sl.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${whereClause}
        AND sb.status != 'cancelled'
    `);
    const equipmentWhereConditions = [sql12`l.manager_id = ${managerId}`];
    if (startDate) {
      const start = typeof startDate === "string" ? startDate : startDate.toISOString().split("T")[0];
      equipmentWhereConditions.push(sql12`DATE(eb.start_date) >= ${start}::date`);
    }
    if (endDate) {
      const end = typeof endDate === "string" ? endDate : endDate.toISOString().split("T")[0];
      equipmentWhereConditions.push(sql12`DATE(eb.start_date) <= ${end}::date`);
    }
    if (locationId) {
      equipmentWhereConditions.push(sql12`l.id = ${locationId}`);
    }
    const equipmentWhereClause = sql12`WHERE ${sql12.join(equipmentWhereConditions, sql12` AND `)}`;
    const equipmentResult = await db2.execute(sql12`
      SELECT 
        COALESCE(SUM(COALESCE(eb.total_price, 0)::numeric), 0)::bigint as total_revenue,
        COALESCE(SUM(COALESCE(eb.service_fee, 0)::numeric), 0)::bigint as platform_fee,
        COUNT(*)::int as booking_count,
        COUNT(CASE WHEN eb.payment_status = 'paid' THEN 1 END)::int as paid_count,
        COALESCE(SUM(CASE WHEN eb.payment_status = 'paid' THEN COALESCE(eb.total_price, 0)::numeric ELSE 0 END), 0)::bigint as completed_payments,
        COALESCE(SUM(CASE WHEN eb.payment_status = 'processing' THEN COALESCE(eb.total_price, 0)::numeric ELSE 0 END), 0)::bigint as processing_payments
      FROM equipment_bookings eb
      JOIN equipment_listings el ON eb.equipment_listing_id = el.id
      JOIN kitchens k ON el.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      ${equipmentWhereClause}
        AND eb.status != 'cancelled'
    `);
    const storageRow = storageResult.rows[0] || {};
    const equipmentRow = equipmentResult.rows[0] || {};
    const parseNumeric = (value) => {
      if (!value) return 0;
      if (typeof value === "string") return parseInt(value) || 0;
      return parseInt(String(value)) || 0;
    };
    const totalRevenue = kitchenMetrics.totalRevenue + parseNumeric(storageRow.total_revenue) + parseNumeric(equipmentRow.total_revenue);
    const platformFee = kitchenMetrics.platformFee + parseNumeric(storageRow.platform_fee) + parseNumeric(equipmentRow.platform_fee);
    const managerRevenue = totalRevenue - platformFee;
    const pendingPaymentsTotal = kitchenMetrics.pendingPayments + parseNumeric(storageRow.processing_payments) + parseNumeric(equipmentRow.processing_payments);
    const completedPaymentsTotal = kitchenMetrics.completedPayments + parseNumeric(storageRow.completed_payments) + parseNumeric(equipmentRow.completed_payments);
    const completedPlatformFee = kitchenMetrics.platformFee * (kitchenMetrics.completedPayments / (kitchenMetrics.totalRevenue || 1));
    const storageCompletedPlatformFee = parseNumeric(storageRow.platform_fee) * (parseNumeric(storageRow.completed_payments) / (parseNumeric(storageRow.total_revenue) || 1));
    const equipmentCompletedPlatformFee = parseNumeric(equipmentRow.platform_fee) * (parseNumeric(equipmentRow.completed_payments) / (parseNumeric(equipmentRow.total_revenue) || 1));
    const depositedManagerRevenue = completedPaymentsTotal - (completedPlatformFee + storageCompletedPlatformFee + equipmentCompletedPlatformFee);
    const totalBookingCount = kitchenMetrics.bookingCount + parseNumeric(storageRow.booking_count) + parseNumeric(equipmentRow.booking_count);
    const totalPaidCount = kitchenMetrics.paidBookingCount + parseNumeric(storageRow.paid_count) + parseNumeric(equipmentRow.paid_count);
    const estimatedStripeFee = kitchenMetrics.stripeFee;
    const taxAmount = kitchenMetrics.taxAmount || 0;
    const netRevenue = totalRevenue - taxAmount - estimatedStripeFee;
    const finalMetrics = {
      totalRevenue: isNaN(totalRevenue) ? 0 : totalRevenue,
      platformFee: isNaN(platformFee) ? 0 : platformFee,
      taxAmount: isNaN(taxAmount) ? 0 : taxAmount || 0,
      stripeFee: isNaN(estimatedStripeFee) ? 0 : estimatedStripeFee || 0,
      netRevenue: isNaN(netRevenue) ? 0 : netRevenue || 0,
      managerRevenue: isNaN(managerRevenue) ? 0 : managerRevenue || 0,
      depositedManagerRevenue: isNaN(depositedManagerRevenue) ? 0 : depositedManagerRevenue,
      pendingPayments: isNaN(pendingPaymentsTotal) ? 0 : pendingPaymentsTotal,
      completedPayments: isNaN(completedPaymentsTotal) ? 0 : completedPaymentsTotal,
      averageBookingValue: totalRevenue > 0 && totalBookingCount > 0 ? isNaN(Math.round(totalRevenue / totalBookingCount)) ? 0 : Math.round(totalRevenue / totalBookingCount) : 0,
      bookingCount: isNaN(totalBookingCount) ? 0 : totalBookingCount,
      paidBookingCount: isNaN(totalPaidCount) ? 0 : totalPaidCount,
      cancelledBookingCount: isNaN(kitchenMetrics.cancelledBookingCount) ? 0 : kitchenMetrics.cancelledBookingCount,
      refundedAmount: isNaN(kitchenMetrics.refundedAmount) ? 0 : kitchenMetrics.refundedAmount
    };
    logger.info("[Revenue Service] Final complete metrics:", finalMetrics);
    return finalMetrics;
  } catch (error) {
    logger.error("Error getting complete revenue metrics:", error);
    throw error;
  }
}
var init_revenue_service = __esm({
  "server/services/revenue-service.ts"() {
    "use strict";
    init_logger();
  }
});

// server/services/stripe-connect-service.ts
var stripe_connect_service_exports = {};
__export(stripe_connect_service_exports, {
  createAccountLink: () => createAccountLink,
  createAccountUpdateLink: () => createAccountUpdateLink,
  createConnectAccount: () => createConnectAccount,
  createDashboardLoginLink: () => createDashboardLoginLink,
  getAccount: () => getAccount,
  getAccountBalance: () => getAccountBalance,
  getAccountStatus: () => getAccountStatus,
  getBalanceTransactions: () => getBalanceTransactions,
  getPayout: () => getPayout,
  getPayouts: () => getPayouts,
  isAccountReady: () => isAccountReady
});
import Stripe4 from "stripe";
async function createConnectAccount(params) {
  if (!stripe4) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  const {
    managerId,
    email,
    country = "CA"
    // Default to Canada
  } = params;
  try {
    const account = await stripe4.accounts.create({
      type: "express",
      country,
      email,
      capabilities: {
        card_payments: { requested: true },
        transfers: { requested: true }
      },
      // Metadata to track which manager this belongs to
      metadata: {
        manager_id: managerId.toString(),
        platform: "localcooks"
      }
    });
    return { accountId: account.id };
  } catch (error) {
    logger.error("Error creating Stripe Connect account:", error);
    throw new Error(`Failed to create Connect account: ${error.message}`);
  }
}
async function createAccountLink(accountId, refreshUrl, returnUrl) {
  if (!stripe4) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const accountLink = await stripe4.accountLinks.create({
      account: accountId,
      refresh_url: refreshUrl,
      return_url: returnUrl,
      type: "account_onboarding"
    });
    return { url: accountLink.url };
  } catch (error) {
    logger.error("Error creating account link:", error);
    throw new Error(`Failed to create account link: ${error.message}`);
  }
}
async function createAccountUpdateLink(accountId, refreshUrl, returnUrl) {
  if (!stripe4) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const accountLink = await stripe4.accountLinks.create({
      account: accountId,
      refresh_url: refreshUrl,
      return_url: returnUrl,
      type: "account_update"
    });
    return { url: accountLink.url };
  } catch (error) {
    logger.error("Error creating account update link:", error);
    throw new Error(`Failed to create account update link: ${error.message}`);
  }
}
async function isAccountReady(accountId) {
  if (!stripe4) {
    return false;
  }
  try {
    const account = await stripe4.accounts.retrieve(accountId);
    return account.charges_enabled === true && account.payouts_enabled === true;
  } catch (error) {
    logger.error("Error checking account readiness:", error);
    return false;
  }
}
async function getAccountStatus(accountId) {
  if (!stripe4) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const account = await stripe4.accounts.retrieve(accountId);
    const reqs = account.requirements;
    return {
      accountId: account.id,
      chargesEnabled: account.charges_enabled || false,
      payoutsEnabled: account.payouts_enabled || false,
      detailsSubmitted: account.details_submitted || false,
      isReady: account.charges_enabled && account.payouts_enabled || false,
      requirements: {
        currentlyDue: reqs?.currently_due || [],
        eventuallyDue: reqs?.eventually_due || [],
        pastDue: reqs?.past_due || [],
        pendingVerification: reqs?.pending_verification || [],
        disabledReason: reqs?.disabled_reason || null,
        currentDeadline: reqs?.current_deadline || null
      }
    };
  } catch (error) {
    logger.error("Error retrieving account status:", error);
    throw new Error(`Failed to retrieve account status: ${error.message}`);
  }
}
async function getAccount(accountId) {
  if (!stripe4) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const account = await stripe4.accounts.retrieve(accountId);
    return account;
  } catch (error) {
    if (error.code === "resource_missing") {
      return null;
    }
    logger.error("Error retrieving account:", error);
    throw new Error(`Failed to retrieve account: ${error.message}`);
  }
}
async function getPayouts(accountId, limit = 100) {
  if (!stripe4) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const payouts = await stripe4.payouts.list(
      {
        limit
      },
      {
        stripeAccount: accountId
      }
    );
    return payouts.data;
  } catch (error) {
    logger.error("Error retrieving payouts:", error);
    throw new Error(`Failed to retrieve payouts: ${error.message}`);
  }
}
async function getPayout(accountId, payoutId) {
  if (!stripe4) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const payout = await stripe4.payouts.retrieve(
      payoutId,
      {
        stripeAccount: accountId
      }
    );
    return payout;
  } catch (error) {
    if (error.code === "resource_missing") {
      return null;
    }
    logger.error("Error retrieving payout:", error);
    throw new Error(`Failed to retrieve payout: ${error.message}`);
  }
}
async function getBalanceTransactions(accountId, startDate, endDate, limit = 100) {
  if (!stripe4) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const params = {
      limit
    };
    if (startDate) {
      params.created = {
        gte: Math.floor(startDate.getTime() / 1e3)
      };
    }
    if (endDate) {
      if (params.created && typeof params.created === "object" && "gte" in params.created) {
        params.created = {
          ...params.created,
          lte: Math.floor(endDate.getTime() / 1e3)
        };
      } else {
        params.created = {
          lte: Math.floor(endDate.getTime() / 1e3)
        };
      }
    }
    const transactions = await stripe4.balanceTransactions.list(
      params,
      {
        stripeAccount: accountId
      }
    );
    return transactions.data;
  } catch (error) {
    logger.error("Error retrieving balance transactions:", error);
    throw new Error(`Failed to retrieve balance transactions: ${error.message}`);
  }
}
async function getAccountBalance(accountId) {
  if (!stripe4) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const balance = await stripe4.balance.retrieve({
      stripeAccount: accountId
    });
    return balance;
  } catch (error) {
    logger.error("Error retrieving balance:", error);
    throw new Error(`Failed to retrieve balance: ${error.message}`);
  }
}
async function createDashboardLoginLink(accountId) {
  if (!stripe4) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  try {
    const loginLink = await stripe4.accounts.createLoginLink(accountId);
    return { url: loginLink.url };
  } catch (error) {
    logger.error("Error creating dashboard login link:", error);
    throw new Error(`Failed to create dashboard login link: ${error.message}`);
  }
}
var stripeSecretKey4, stripe4;
var init_stripe_connect_service = __esm({
  "server/services/stripe-connect-service.ts"() {
    "use strict";
    init_logger();
    stripeSecretKey4 = process.env.STRIPE_SECRET_KEY;
    if (!stripeSecretKey4) {
      logger.warn("\u26A0\uFE0F STRIPE_SECRET_KEY not found in environment variables");
    }
    stripe4 = stripeSecretKey4 ? new Stripe4(stripeSecretKey4, {
      apiVersion: "2025-12-15.clover"
    }) : null;
  }
});

// server/domains/managers/manager.service.ts
import { eq as eq24 } from "drizzle-orm";
var ManagerService, managerService;
var init_manager_service = __esm({
  "server/domains/managers/manager.service.ts"() {
    "use strict";
    init_manager_repository();
    init_db();
    init_revenue_service();
    init_stripe_connect_service();
    init_schema();
    ManagerService = class {
      async getAllManagers() {
        return await managerRepository.findAllManagers();
      }
      async updateOnboarding(userId, updates) {
        return await managerRepository.updateOnboardingStatus(userId, updates);
      }
      async getRevenueOverview(managerId, query) {
        return await getCompleteRevenueMetrics(
          managerId,
          db,
          query.startDate,
          query.endDate,
          query.locationId
        );
      }
      async getInvoices(managerId, query) {
        const filters = {
          startDate: query.startDate,
          endDate: query.endDate,
          locationId: query.locationId ? parseInt(query.locationId) : void 0,
          limit: query.limit ? parseInt(query.limit) : 50,
          offset: query.offset ? parseInt(query.offset) : 0
        };
        const result = await managerRepository.findInvoices(managerId, filters);
        const invoices = result.invoices.map((row) => {
          let totalPriceCents = 0;
          if (row.totalPrice != null) {
            totalPriceCents = parseInt(String(row.totalPrice));
          } else if ("hourlyRate" in row && row.hourlyRate != null && "durationHours" in row && row.durationHours != null) {
            totalPriceCents = Math.round(parseFloat(String(row.hourlyRate)) * parseFloat(String(row.durationHours)));
          }
          const serviceFeeCents = row.serviceFee != null ? parseInt(String(row.serviceFee)) : 0;
          return {
            bookingId: row.id,
            bookingType: row.bookingType || "kitchen",
            bookingDate: row.bookingDate,
            startTime: row.startTime,
            endTime: row.endTime,
            totalPrice: totalPriceCents,
            // Keep in cents for consistency with other APIs
            serviceFee: serviceFeeCents,
            // Keep in cents for consistency
            paymentStatus: row.paymentStatus,
            paymentIntentId: row.paymentIntentId,
            currency: row.currency || "CAD",
            kitchenName: row.kitchenName,
            locationName: row.locationName,
            chefName: row.chefName || "Guest",
            chefEmail: row.chefEmail,
            createdAt: row.createdAt
          };
        });
        return {
          invoices,
          total: result.total
        };
      }
      async getPayouts(managerId, limit = 50) {
        const [userResult] = await db.select({ stripeConnectAccountId: users.stripeConnectAccountId }).from(users).where(eq24(users.id, managerId)).limit(1);
        if (!userResult?.stripeConnectAccountId) {
          return {
            payouts: [],
            total: 0,
            message: "No Stripe Connect account linked"
          };
        }
        const accountId = userResult.stripeConnectAccountId;
        const payouts = await getPayouts(accountId, limit);
        return {
          payouts: payouts.map((p) => ({
            id: p.id,
            amount: p.amount,
            // Keep in cents for consistency with formatCurrency
            currency: p.currency,
            status: p.status,
            arrivalDate: new Date(p.arrival_date * 1e3).toISOString(),
            created: new Date(p.created * 1e3).toISOString(),
            description: p.description,
            method: p.method,
            type: p.type
          })),
          total: payouts.length
        };
      }
    };
    managerService = new ManagerService();
  }
});

// server/services/invoice-service.ts
var invoice_service_exports = {};
__export(invoice_service_exports, {
  generateDamageClaimInvoicePDF: () => generateDamageClaimInvoicePDF,
  generateInvoicePDF: () => generateInvoicePDF,
  generateStorageInvoicePDF: () => generateStorageInvoicePDF
});
import PDFDocument from "pdfkit";
import { eq as eq25 } from "drizzle-orm";
async function generateInvoicePDF(booking, chef, kitchen, location, storageBookings2, equipmentBookings2, paymentIntentId, options) {
  const invoiceViewer = options?.viewer ?? "chef";
  let stripePlatformFee = 0;
  let stripeTotalAmount = 0;
  let stripeBaseAmount = 0;
  let stripeNetAmount = 0;
  const stripeStorageBaseAmounts = /* @__PURE__ */ new Map();
  const stripeEquipmentBaseAmounts = /* @__PURE__ */ new Map();
  if (paymentIntentId) {
    try {
      const [paymentTransaction] = await db.select().from(paymentTransactions).where(eq25(paymentTransactions.paymentIntentId, paymentIntentId)).limit(1);
      if (paymentTransaction) {
        stripeTotalAmount = parseInt(String(paymentTransaction.amount)) || 0;
        stripePlatformFee = parseInt(String(paymentTransaction.serviceFee)) || 0;
        stripeBaseAmount = parseInt(String(paymentTransaction.baseAmount)) || 0;
        logger.info(`[Invoice] Using Stripe-synced amounts: total=${stripeTotalAmount}, base=${stripeBaseAmount}, platformFee=${stripePlatformFee}`);
      }
    } catch (error) {
      logger.warn("[Invoice] Could not fetch payment transaction, will calculate fees:", error);
    }
  }
  let totalAmount = 0;
  const items = [];
  const kitchenId = booking.kitchenId || booking.kitchen_id;
  const startTime = booking.startTime || booking.start_time;
  const endTime = booking.endTime || booking.end_time;
  if (kitchenId) {
    try {
      let kitchenAmount = 0;
      let durationHours = 0;
      let hourlyRate = 0;
      if ((booking.hourly_rate || booking.hourlyRate) && (booking.duration_hours || booking.durationHours)) {
        const hourlyRateCents = parseFloat(String(booking.hourly_rate || booking.hourlyRate));
        durationHours = parseFloat(String(booking.duration_hours || booking.durationHours));
        hourlyRate = hourlyRateCents / 100;
        kitchenAmount = hourlyRateCents * durationHours / 100;
      } else if (stripeBaseAmount > 0) {
        kitchenAmount = stripeBaseAmount / 100;
        if (booking.duration_hours || booking.durationHours) {
          durationHours = parseFloat(String(booking.duration_hours || booking.durationHours));
        }
        if (durationHours > 0) {
          hourlyRate = kitchenAmount / durationHours;
        }
      } else if (booking.total_price || booking.totalPrice) {
        const totalPriceCents = parseFloat(String(booking.total_price || booking.totalPrice));
        let addonsCents = 0;
        if (storageBookings2 && storageBookings2.length > 0) {
          for (const sb of storageBookings2) {
            const sbPrice = parseFloat(String(sb.total_price || sb.totalPrice || 0));
            if (sbPrice > 0) addonsCents += sbPrice;
          }
        }
        if (equipmentBookings2 && equipmentBookings2.length > 0) {
          for (const eb of equipmentBookings2) {
            const ebPrice = parseFloat(String(eb.total_price || eb.totalPrice || 0));
            if (ebPrice > 0) addonsCents += ebPrice;
          }
        }
        const kitchenOnlyCents = Math.max(0, totalPriceCents - addonsCents);
        kitchenAmount = kitchenOnlyCents / 100;
        if (booking.duration_hours || booking.durationHours) {
          durationHours = parseFloat(String(booking.duration_hours || booking.durationHours));
          if (durationHours > 0) hourlyRate = kitchenAmount / durationHours;
        }
      } else if (startTime && endTime) {
        try {
          const start = startTime.split(":").map(Number);
          const end = endTime.split(":").map(Number);
          const startMinutes = start[0] * 60 + start[1];
          const endMinutes = end[0] * 60 + end[1];
          durationHours = Math.max(1, (endMinutes - startMinutes) / 60);
          const kitchenRate = kitchen.hourlyRate ? Number(kitchen.hourlyRate) : 0;
          hourlyRate = kitchenRate / 100;
          kitchenAmount = kitchenRate * durationHours / 100;
        } catch (e) {
          logger.error("Error recalculating kitchen price", e);
        }
      }
      if (kitchenAmount > 0) {
        if (durationHours <= 0 && startTime && endTime) {
          const start = startTime.split(":").map(Number);
          const end = endTime.split(":").map(Number);
          durationHours = Math.max(1, (end[0] * 60 + end[1] - (start[0] * 60 + start[1])) / 60);
        }
        if (hourlyRate <= 0 && durationHours > 0) hourlyRate = kitchenAmount / durationHours;
        totalAmount += kitchenAmount;
        items.push({
          description: `Kitchen Booking (${durationHours.toFixed(1)} hour${durationHours !== 1 ? "s" : ""})`,
          quantity: durationHours,
          rate: hourlyRate,
          amount: kitchenAmount
        });
      }
    } catch (error) {
      logger.error("Error in kitchen price calculation:", error);
    }
  }
  if (storageBookings2 && storageBookings2.length > 0) {
    for (const storage of storageBookings2) {
      try {
        let quantity = 0;
        let rate = 0;
        if (storage.startDate && storage.endDate) {
          const s = new Date(storage.startDate);
          const e = new Date(storage.endDate);
          quantity = Math.max(1, Math.ceil((e.getTime() - s.getTime()) / (1e3 * 3600 * 24)));
        }
        if (storage.listingBasePrice) {
          rate = parseFloat(String(storage.listingBasePrice)) / 100;
        }
        let amount = 0;
        if (rate > 0 && quantity > 0) {
          amount = rate * quantity;
        } else if (storage.total_price || storage.totalPrice) {
          const totalPriceCents = parseFloat(String(storage.total_price || storage.totalPrice)) || 0;
          const serviceFeeCents = parseFloat(String(storage.service_fee || storage.serviceFee || "0")) || 0;
          amount = (totalPriceCents - serviceFeeCents) / 100;
        }
        if (amount > 0) {
          totalAmount += amount;
          let name = "Storage Booking";
          if (storage.storageName) {
            name = storage.storageName;
            if (storage.storageType) name += ` (${storage.storageType})`;
          } else if (storage.storageType) {
            name = `Storage - ${storage.storageType}`;
          }
          const daysNote = quantity > 1 ? ` (incl. extensions)` : "";
          items.push({
            description: `${name} - ${quantity} day${quantity !== 1 ? "s" : ""}${daysNote}`,
            quantity: quantity || 1,
            rate: rate || amount / (quantity || 1),
            amount
          });
        }
      } catch (e) {
        logger.error("[Invoice] Error processing storage booking:", e);
      }
    }
  }
  if (equipmentBookings2 && equipmentBookings2.length > 0) {
    for (const eqBooking of equipmentBookings2) {
      let amount = 0;
      if (eqBooking.total_price || eqBooking.totalPrice) {
        amount = parseFloat(String(eqBooking.total_price || eqBooking.totalPrice)) / 100;
      }
      if (amount > 0) {
        totalAmount += amount;
        let name = "Equipment Rental";
        if (eqBooking.brand) {
          name = eqBooking.brand;
          if (eqBooking.equipmentType) name += ` (${eqBooking.equipmentType})`;
        } else if (eqBooking.equipmentType) {
          name = eqBooking.equipmentType;
        }
        items.push({
          description: name,
          quantity: 1,
          rate: amount,
          amount
        });
      }
    }
  }
  let platformFee = 0;
  if (stripePlatformFee > 0) platformFee = stripePlatformFee / 100;
  let taxRatePercent = 0;
  if (kitchen && (kitchen.taxRatePercent || kitchen.tax_rate_percent)) {
    taxRatePercent = parseFloat(String(kitchen.taxRatePercent || kitchen.tax_rate_percent));
  }
  let taxAmount = 0;
  let taxFromMetadata = false;
  const taxCents = Math.round(totalAmount * 100 * taxRatePercent / 100);
  taxAmount = taxCents / 100;
  const subtotalCents = Math.round(totalAmount * 100);
  const subtotalWithTaxCents = subtotalCents + taxCents;
  if (stripeTotalAmount > 0) {
    const diff = Math.abs(subtotalWithTaxCents - stripeTotalAmount);
    if (diff > 1) {
      logger.warn(`[Invoice] MISMATCH: Calculated total (${subtotalWithTaxCents}) differs from Stripe captured amount (${stripeTotalAmount}) by ${diff} cents. Items: ${items.length}, Subtotal: ${subtotalCents}, Tax: ${taxCents}`);
    }
  }
  const platformFeeCents = Math.round(platformFee * 100);
  const platformFeeForInvoice = invoiceViewer === "manager" ? platformFee : 0;
  const totalForInvoice = invoiceViewer === "manager" ? (subtotalWithTaxCents - platformFeeCents) / 100 : subtotalWithTaxCents / 100;
  const grandTotal = totalForInvoice;
  let stripeDataForManager = null;
  if (invoiceViewer === "manager" && paymentIntentId) {
    try {
      const stripeData = await getStripePaymentAmounts(paymentIntentId);
      if (stripeData) {
        stripeDataForManager = {
          stripeProcessingFee: stripeData.stripeProcessingFee / 100,
          stripeNetPayout: stripeData.stripeNetAmount / 100,
          actualPlatformFee: stripeData.stripePlatformFee / 100,
          dataSource: "stripe"
        };
        logger.info(`[Invoice] Using Stripe BalanceTransaction data: processingFee=${stripeDataForManager.stripeProcessingFee}, netPayout=${stripeDataForManager.stripeNetPayout}, platformFee=${stripeDataForManager.actualPlatformFee}`);
      }
    } catch (error) {
      logger.warn("[Invoice] Could not fetch Stripe payment amounts, will use calculated values:", error);
    }
  }
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        margin: 50,
        size: "LETTER"
      });
      const buffers = [];
      doc.on("data", buffers.push.bind(buffers));
      doc.on("end", () => {
        const pdfBuffer = Buffer.concat(buffers);
        resolve(pdfBuffer);
      });
      doc.on("error", reject);
      doc.fontSize(28).font("Helvetica-Bold").text("INVOICE", 50, 50);
      doc.fontSize(10).font("Helvetica");
      const invoiceDate = (/* @__PURE__ */ new Date()).toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric"
      });
      const invoiceNumber = booking.reference_code || booking.referenceCode || `LC-${booking.id}-${(/* @__PURE__ */ new Date()).getFullYear()}`;
      const pageWidth = doc.page.width;
      const rightMargin = pageWidth - 50;
      const labelWidth = 80;
      const valueStartX = rightMargin - 200;
      let rightY = 50;
      doc.fontSize(10).font("Helvetica-Bold");
      doc.text("Invoice #:", valueStartX, rightY, { width: labelWidth, align: "right" });
      doc.font("Helvetica");
      doc.text(invoiceNumber, valueStartX + labelWidth + 5, rightY);
      rightY += 15;
      doc.font("Helvetica-Bold");
      doc.text("Date:", valueStartX, rightY, { width: labelWidth, align: "right" });
      doc.font("Helvetica");
      doc.text(invoiceDate, valueStartX + labelWidth + 5, rightY);
      let leftY = 120;
      doc.fontSize(14).font("Helvetica-Bold").text("Local Cooks Community", 50, leftY);
      leftY += 18;
      doc.fontSize(10).font("Helvetica").text("support@localcook.shop", 50, leftY);
      leftY += 30;
      doc.fontSize(12).font("Helvetica-Bold").text("Bill To:", 50, leftY);
      leftY += 18;
      doc.fontSize(10).font("Helvetica");
      if (chef) {
        const chefName = chef.full_name || chef.fullName || chef.username || "Chef";
        doc.text(chefName, 50, leftY);
        leftY += 15;
        if (chef.email) {
          doc.text(chef.email, 50, leftY);
          leftY += 15;
        }
      }
      leftY += 20;
      doc.fontSize(12).font("Helvetica-Bold").text("Booking Details:", 50, leftY);
      leftY += 18;
      doc.fontSize(10).font("Helvetica");
      const bookingDateStr = booking.bookingDate ? new Date(booking.bookingDate).toLocaleDateString("en-US", {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      }) : "N/A";
      doc.text(`Kitchen: ${kitchen?.name || "Kitchen"}`, 50, leftY);
      leftY += 15;
      if (location?.name) {
        doc.text(`Location: ${location.name}`, 50, leftY);
        leftY += 15;
      }
      doc.text(`Date: ${bookingDateStr}`, 50, leftY);
      leftY += 15;
      const selectedSlots = booking.selectedSlots || booking.selected_slots;
      let timeDisplay = `${booking.startTime || booking.start_time || "N/A"} - ${booking.endTime || booking.end_time || "N/A"}`;
      if (Array.isArray(selectedSlots) && selectedSlots.length > 0) {
        const sorted = [...selectedSlots].sort(
          (a, b) => (a.startTime || a).localeCompare(b.startTime || b)
        );
        let isContiguous = true;
        for (let i = 1; i < sorted.length; i++) {
          const prevSlot = sorted[i - 1];
          const currSlot = sorted[i];
          const prevEnd = typeof prevSlot === "string" ? prevSlot : prevSlot.endTime;
          const currStart = typeof currSlot === "string" ? currSlot : currSlot.startTime;
          if (prevEnd !== currStart) {
            isContiguous = false;
            break;
          }
        }
        if (!isContiguous) {
          const formatSlotTime = (time) => {
            const [h, m] = time.split(":").map(Number);
            const ampm = h >= 12 ? "PM" : "AM";
            const displayH = h % 12 || 12;
            return `${displayH}:${m.toString().padStart(2, "0")} ${ampm}`;
          };
          timeDisplay = sorted.map((slot) => {
            if (typeof slot === "string") {
              return formatSlotTime(slot);
            }
            return `${formatSlotTime(slot.startTime)}-${formatSlotTime(slot.endTime)}`;
          }).join(", ");
        }
      }
      doc.text(`Time: ${timeDisplay}`, 50, leftY);
      leftY += 30;
      const tableTop = leftY;
      const tableLeft = 50;
      const tableWidth = 500;
      const rowHeight = 25;
      const col1Width = 280;
      const col2Width = 50;
      const col3Width = 70;
      const col4Width = 100;
      const col1X = tableLeft;
      const col2X = tableLeft + col1Width;
      const col3X = col2X + col2Width;
      const col4X = col3X + col3Width;
      doc.rect(tableLeft, tableTop, tableWidth, rowHeight).fill("#f3f4f6");
      doc.rect(tableLeft, tableTop, tableWidth, rowHeight).stroke("#d1d5db");
      doc.moveTo(col2X, tableTop).lineTo(col2X, tableTop + rowHeight).stroke("#d1d5db");
      doc.moveTo(col3X, tableTop).lineTo(col3X, tableTop + rowHeight).stroke("#d1d5db");
      doc.moveTo(col4X, tableTop).lineTo(col4X, tableTop + rowHeight).stroke("#d1d5db");
      doc.fillColor("#000000").fontSize(9).font("Helvetica-Bold");
      doc.text("Description", col1X + 5, tableTop + 8, { width: col1Width - 10 });
      doc.text("Qty", col2X + 5, tableTop + 8, { width: col2Width - 10, align: "center" });
      doc.text("Rate", col3X + 5, tableTop + 8, { width: col3Width - 10, align: "center" });
      doc.text("Amount", col4X + 5, tableTop + 8, { width: col4Width - 10, align: "right" });
      let currentY = tableTop + rowHeight;
      items.forEach((item, index) => {
        doc.rect(tableLeft, currentY, tableWidth, rowHeight).stroke("#d1d5db");
        doc.moveTo(col2X, currentY).lineTo(col2X, currentY + rowHeight).stroke("#d1d5db");
        doc.moveTo(col3X, currentY).lineTo(col3X, currentY + rowHeight).stroke("#d1d5db");
        doc.moveTo(col4X, currentY).lineTo(col4X, currentY + rowHeight).stroke("#d1d5db");
        if (index % 2 === 0) {
          doc.rect(tableLeft + 1, currentY + 1, tableWidth - 2, rowHeight - 2).fill("#fafafa");
        }
        doc.fontSize(9).font("Helvetica").fillColor("#000000");
        doc.text(item.description, col1X + 5, currentY + 8, { width: col1Width - 10 });
        doc.text(item.quantity.toString(), col2X + 5, currentY + 8, { width: col2Width - 10, align: "center" });
        doc.text(`$${item.rate.toFixed(2)}`, col3X + 5, currentY + 8, { width: col3Width - 10, align: "center" });
        doc.text(`$${item.amount.toFixed(2)}`, col4X + 5, currentY + 8, { width: col4Width - 10, align: "right" });
        currentY += rowHeight;
      });
      currentY += 15;
      const formatAmount = (amount, negative = false) => {
        const normalized = Math.abs(amount);
        return `${negative ? "-" : ""}$${normalized.toFixed(2)}`;
      };
      const addTotalRow = (label, amount, negative = false, bold = false) => {
        if (bold) {
          doc.font("Helvetica-Bold");
        } else {
          doc.font("Helvetica");
        }
        doc.text(label, 380, currentY, { width: 110, align: "right" });
        doc.text(formatAmount(amount, negative), 500, currentY, { align: "right", width: 50 });
        currentY += 20;
        doc.font("Helvetica");
      };
      if (invoiceViewer === "manager") {
        const grossRevenue = totalAmount + taxAmount;
        let stripeProcessingFee;
        let stripeNetPayout;
        let actualPlatformFee;
        let dataSource;
        if (stripeDataForManager) {
          stripeProcessingFee = stripeDataForManager.stripeProcessingFee;
          stripeNetPayout = stripeDataForManager.stripeNetPayout;
          actualPlatformFee = stripeDataForManager.actualPlatformFee;
          dataSource = stripeDataForManager.dataSource;
        } else {
          actualPlatformFee = platformFee;
          stripeProcessingFee = 0;
          stripeNetPayout = grossRevenue - actualPlatformFee;
          dataSource = "pending_sync";
        }
        doc.fontSize(11).font("Helvetica-Bold").fillColor("#1f2937");
        doc.text("EARNINGS BREAKDOWN", 60, currentY);
        currentY += 25;
        doc.fontSize(10).font("Helvetica").fillColor("#000000");
        addTotalRow("Subtotal (Services):", totalAmount);
        if (taxAmount > 0) {
          addTotalRow("Tax Collected:", taxAmount);
        }
        doc.moveTo(380, currentY - 5).lineTo(550, currentY - 5).stroke("#e5e7eb");
        currentY += 5;
        addTotalRow("Gross Revenue:", grossRevenue, false, true);
        currentY += 5;
        doc.fontSize(10).fillColor("#6b7280");
        doc.text("Deductions:", 60, currentY);
        currentY += 18;
        doc.fillColor("#000000");
        if (actualPlatformFee > 0) {
          addTotalRow("Platform Fee:", actualPlatformFee, true);
        }
        const stripeFeeLabel = dataSource === "stripe" ? "Stripe Processing Fee:" : dataSource === "pending_sync" ? "Stripe Fee (pending sync):" : "Stripe Processing Fee:";
        addTotalRow(stripeFeeLabel, stripeProcessingFee, true);
        doc.moveTo(50, currentY - 5).lineTo(550, currentY - 5).stroke();
        currentY += 10;
        doc.fontSize(12).font("Helvetica-Bold").fillColor("#059669");
        doc.text("Net Payout:", 380, currentY, { align: "right", width: 110 });
        doc.text(`$${stripeNetPayout.toFixed(2)}`, 500, currentY, { align: "right", width: 50 });
        doc.font("Helvetica").fontSize(10).fillColor("#000000");
        currentY += 20;
        doc.fontSize(8).fillColor("#6b7280");
        if (dataSource === "stripe") {
          doc.text("* Fees retrieved from Stripe payment records", 60, currentY);
          currentY += 12;
        }
        if (taxAmount > 0) {
          doc.text("* Tax collected is your responsibility to remit to tax authorities", 60, currentY);
        }
        doc.fillColor("#000000").fontSize(10);
      } else {
        addTotalRow("Subtotal (Services):", totalAmount);
        if (taxAmount > 0 && taxRatePercent > 0) {
          addTotalRow(`Tax (${taxRatePercent}%):`, taxAmount);
        } else if (taxAmount > 0) {
          addTotalRow("Tax:", taxAmount);
        }
        doc.moveTo(380, currentY - 5).lineTo(550, currentY - 5).stroke("#e5e7eb");
        currentY += 10;
        doc.fontSize(12).font("Helvetica-Bold");
        doc.text("Total Paid:", 380, currentY, { align: "right", width: 110 });
        doc.text(`$${grandTotal.toFixed(2)} CAD`, 500, currentY, { align: "right", width: 50 });
        doc.font("Helvetica").fontSize(10);
      }
      currentY += 40;
      doc.rect(50, currentY, 500, 60).stroke("#e5e7eb");
      doc.rect(50, currentY, 500, 60).fill("#f9fafb");
      currentY += 15;
      doc.fontSize(10).font("Helvetica-Bold").text("Payment Information", 60, currentY);
      currentY += 18;
      doc.font("Helvetica");
      doc.text("Payment Method: Credit/Debit Card", 60, currentY);
      currentY += 15;
      doc.text("Payment Status: Paid", 60, currentY);
      currentY += 15;
      doc.fontSize(9).fillColor("#6b7280").text("Note: Payment has been processed successfully.", 60, currentY);
      doc.fillColor("#000000");
      const pageHeight = doc.page.height;
      const footerY = pageHeight - 80;
      doc.moveTo(50, footerY).lineTo(550, footerY).stroke("#e5e7eb");
      doc.fontSize(9).fillColor("#6b7280").text("For questions, contact support@localcook.shop", 50, footerY + 15, { align: "center", width: 500 });
      doc.fillColor("#000000");
      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}
async function generateStorageInvoicePDF(transaction, storageBooking, chef, extensionDetails, options) {
  const invoiceViewer = options?.viewer ?? "chef";
  return new Promise((resolve, reject) => {
    try {
      const chunks = [];
      const doc = new PDFDocument({ margin: 50 });
      doc.on("data", (chunk) => chunks.push(chunk));
      doc.on("end", () => resolve(Buffer.concat(chunks)));
      const totalAmount = parseInt(String(transaction.amount || "0")) || 0;
      const baseAmount = parseInt(String(transaction.baseAmount || transaction.base_amount || "0")) || 0;
      const taxAmount = totalAmount - baseAmount;
      const taxRatePercent = storageBooking.taxRatePercent || 0;
      const isExtension = !!extensionDetails;
      const extensionDays = extensionDetails?.extension_days || 0;
      const extensionBasePrice = extensionDetails?.extension_base_price_cents || 0;
      const extensionTotalPrice = extensionDetails?.extension_total_price_cents || 0;
      const dailyRateCents = extensionDetails?.daily_rate_cents || 0;
      const displayBaseAmount = extensionBasePrice || baseAmount;
      const displayTotalAmount = extensionTotalPrice || totalAmount;
      const displayTaxAmount = displayTotalAmount - displayBaseAmount;
      const displayDays = extensionDays || 1;
      const displayDailyRate = dailyRateCents || (displayDays > 0 ? Math.round(displayBaseAmount / displayDays) : displayBaseAmount);
      const invoiceDate = new Date(transaction.paidAt || transaction.paid_at || transaction.createdAt || transaction.created_at);
      const year = invoiceDate.getFullYear();
      const bookingIdPadded = String(storageBooking.id).padStart(6, "0");
      const isOverstayPenalty = extensionDetails?.is_overstay_penalty === true;
      const storageRefCode = storageBooking.reference_code || storageBooking.referenceCode;
      let invoiceId;
      if (storageRefCode) {
        invoiceId = storageRefCode;
      } else if (isOverstayPenalty) {
        invoiceId = `LC-OP-${year}-${bookingIdPadded}`;
      } else if (isExtension) {
        invoiceId = `LC-EXT-${year}-${bookingIdPadded}`;
      } else {
        invoiceId = `LC-STR-${year}-${bookingIdPadded}`;
      }
      doc.fontSize(24).font("Helvetica-Bold").text("INVOICE", 50, 50);
      doc.fontSize(12).font("Helvetica").fillColor("#6b7280");
      doc.text(`Invoice #: ${invoiceId}`, 50, 80);
      doc.text(`Date: ${invoiceDate.toLocaleDateString()}`, 50, 95);
      doc.fillColor("#000000");
      doc.fontSize(14).font("Helvetica-Bold").text("Billed To:", 50, 130);
      doc.fontSize(11).font("Helvetica");
      if (chef) {
        const chefName = chef.full_name || chef.fullName || chef.username || "Chef";
        doc.text(chefName, 50, 150);
      } else {
        doc.text("Chef", 50, 150);
      }
      doc.fontSize(14).font("Helvetica-Bold").text("From:", 350, 130);
      doc.fontSize(11).font("Helvetica");
      doc.text(storageBooking.kitchenName || "Kitchen", 350, 150);
      doc.text(storageBooking.locationName || "Location", 350, 165);
      let currentY = 210;
      doc.fontSize(14).font("Helvetica-Bold").text(isExtension ? "Storage Extension Details" : "Storage Booking Details", 50, currentY);
      currentY += 25;
      const tableLeft = 50;
      const tableWidth = 500;
      const rowHeight = 25;
      const col1Width = 280;
      const col2Width = 50;
      const col3Width = 70;
      const col4Width = 100;
      const col1X = tableLeft;
      const col2X = tableLeft + col1Width;
      const col3X = col2X + col2Width;
      const col4X = col3X + col3Width;
      doc.rect(tableLeft, currentY, tableWidth, rowHeight).fill("#f3f4f6");
      doc.rect(tableLeft, currentY, tableWidth, rowHeight).stroke("#d1d5db");
      doc.moveTo(col2X, currentY).lineTo(col2X, currentY + rowHeight).stroke("#d1d5db");
      doc.moveTo(col3X, currentY).lineTo(col3X, currentY + rowHeight).stroke("#d1d5db");
      doc.moveTo(col4X, currentY).lineTo(col4X, currentY + rowHeight).stroke("#d1d5db");
      doc.fillColor("#000000").fontSize(9).font("Helvetica-Bold");
      doc.text("Description", col1X + 5, currentY + 8, { width: col1Width - 10 });
      doc.text("Qty", col2X + 5, currentY + 8, { width: col2Width - 10, align: "center" });
      doc.text("Rate", col3X + 5, currentY + 8, { width: col3Width - 10, align: "center" });
      doc.text("Amount", col4X + 5, currentY + 8, { width: col4Width - 10, align: "right" });
      currentY += rowHeight;
      doc.rect(tableLeft, currentY, tableWidth, rowHeight).stroke("#d1d5db");
      doc.moveTo(col2X, currentY).lineTo(col2X, currentY + rowHeight).stroke("#d1d5db");
      doc.moveTo(col3X, currentY).lineTo(col3X, currentY + rowHeight).stroke("#d1d5db");
      doc.moveTo(col4X, currentY).lineTo(col4X, currentY + rowHeight).stroke("#d1d5db");
      doc.fontSize(9).font("Helvetica");
      const storageName = extensionDetails?.storage_name || storageBooking.storageName || "Storage";
      const description = isExtension ? `Storage Ext - ${storageName} (${displayDays}d)` : `Storage - ${storageName}`;
      doc.text(description, col1X + 5, currentY + 8, { width: col1Width - 10 });
      doc.text(String(displayDays), col2X + 5, currentY + 8, { width: col2Width - 10, align: "center" });
      doc.text(`$${(displayDailyRate / 100).toFixed(2)}`, col3X + 5, currentY + 8, { width: col3Width - 10, align: "center" });
      doc.text(`$${(displayBaseAmount / 100).toFixed(2)}`, col4X + 5, currentY + 8, { width: col4Width - 10, align: "right" });
      currentY += rowHeight + 5;
      currentY += 20;
      doc.fontSize(10).font("Helvetica");
      doc.text("Subtotal (Base Amount):", 380, currentY);
      doc.text(`$${(displayBaseAmount / 100).toFixed(2)}`, 480, currentY, { align: "right" });
      currentY += 18;
      if (displayTaxAmount > 0 && taxRatePercent > 0) {
        doc.text(`Tax (${taxRatePercent}%):`, 380, currentY);
        doc.text(`$${(displayTaxAmount / 100).toFixed(2)}`, 480, currentY, { align: "right" });
        currentY += 18;
      } else if (displayTaxAmount > 0) {
        doc.text("Tax:", 380, currentY);
        doc.text(`$${(displayTaxAmount / 100).toFixed(2)}`, 480, currentY, { align: "right" });
        currentY += 18;
      }
      doc.moveTo(380, currentY - 5).lineTo(550, currentY - 5).stroke("#e5e7eb");
      currentY += 5;
      doc.fontSize(12).font("Helvetica-Bold");
      doc.text("Total Paid:", 380, currentY);
      doc.text(`$${(displayTotalAmount / 100).toFixed(2)} CAD`, 480, currentY, { align: "right" });
      currentY += 30;
      if (invoiceViewer === "manager") {
        const stripeProcessingFee = parseInt(String(transaction.stripeProcessingFee || transaction.stripe_processing_fee || "0")) || 0;
        const managerRevenue = parseInt(String(transaction.managerRevenue || transaction.manager_revenue || "0")) || 0;
        currentY += 10;
        doc.fontSize(11).font("Helvetica-Bold").fillColor("#1f2937");
        doc.text("EARNINGS BREAKDOWN", 60, currentY);
        currentY += 20;
        doc.fontSize(10).font("Helvetica").fillColor("#000000");
        doc.text("Base Amount:", 380, currentY);
        doc.text(`$${(displayBaseAmount / 100).toFixed(2)}`, 480, currentY, { align: "right" });
        currentY += 18;
        if (displayTaxAmount > 0) {
          doc.text(`Tax Collected (${taxRatePercent}%):`, 380, currentY);
          doc.text(`$${(displayTaxAmount / 100).toFixed(2)}`, 480, currentY, { align: "right" });
          currentY += 18;
        }
        doc.moveTo(380, currentY - 5).lineTo(550, currentY - 5).stroke("#e5e7eb");
        currentY += 5;
        doc.font("Helvetica-Bold");
        doc.text("Gross Revenue:", 380, currentY);
        doc.text(`$${(displayTotalAmount / 100).toFixed(2)}`, 480, currentY, { align: "right" });
        doc.font("Helvetica");
        currentY += 20;
        doc.fontSize(10).fillColor("#6b7280");
        doc.text("Deductions:", 60, currentY);
        currentY += 18;
        doc.fillColor("#000000");
        doc.text("Stripe Processing Fee:", 380, currentY);
        doc.fillColor("#dc2626");
        if (stripeProcessingFee > 0) {
          doc.text(`-$${(stripeProcessingFee / 100).toFixed(2)}`, 480, currentY, { align: "right" });
        } else {
          doc.text("(pending sync)", 480, currentY, { align: "right" });
        }
        doc.fillColor("#000000");
        currentY += 20;
        doc.moveTo(380, currentY - 5).lineTo(550, currentY - 5).stroke("#e5e7eb");
        currentY += 5;
        doc.fontSize(12).font("Helvetica-Bold").fillColor("#059669");
        doc.text("You Receive:", 380, currentY);
        const netAmount = managerRevenue > 0 ? managerRevenue : displayTotalAmount - stripeProcessingFee;
        doc.text(`$${(netAmount / 100).toFixed(2)} CAD`, 480, currentY, { align: "right" });
        doc.fillColor("#000000");
        currentY += 25;
        doc.fontSize(8).fillColor("#6b7280");
        doc.text("* Tax collected is your responsibility to remit to tax authorities", 60, currentY);
        doc.fillColor("#000000").fontSize(10);
      }
      currentY += 20;
      doc.fontSize(12).font("Helvetica-Bold").text("Payment Information", 50, currentY);
      currentY += 20;
      doc.fontSize(10).font("Helvetica");
      doc.text("Payment Method: Credit/Debit Card", 60, currentY);
      currentY += 15;
      doc.text("Payment Status: Paid", 60, currentY);
      const pageHeight = doc.page.height;
      const footerY = pageHeight - 80;
      doc.moveTo(50, footerY).lineTo(550, footerY).stroke("#e5e7eb");
      doc.fontSize(9).fillColor("#6b7280").text("For questions, contact support@localcook.shop", 50, footerY + 15, { align: "center", width: 500 });
      doc.fillColor("#000000");
      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}
async function generateDamageClaimInvoicePDF(claim, options) {
  const invoiceViewer = options?.viewer ?? "chef";
  const { users: users5, locations: locations5 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
  let stripeProcessingFeeCents = 0;
  let managerRevenueCents = 0;
  if (invoiceViewer === "manager" && claim.stripePaymentIntentId) {
    try {
      const [transaction] = await db.select({
        stripeProcessingFee: paymentTransactions.stripeProcessingFee,
        managerRevenue: paymentTransactions.managerRevenue
      }).from(paymentTransactions).where(eq25(paymentTransactions.paymentIntentId, claim.stripePaymentIntentId)).limit(1);
      if (transaction) {
        stripeProcessingFeeCents = parseInt(String(transaction.stripeProcessingFee || "0")) || 0;
        managerRevenueCents = parseInt(String(transaction.managerRevenue || "0")) || 0;
      }
    } catch (error) {
      logger.warn("[DamageClaimInvoice] Could not fetch Stripe fees:", error);
    }
  }
  return new Promise(async (resolve, reject) => {
    try {
      const chunks = [];
      const doc = new PDFDocument({ margin: 50 });
      doc.on("data", (chunk) => chunks.push(chunk));
      doc.on("end", () => resolve(Buffer.concat(chunks)));
      const [chef] = await db.select().from(users5).where(eq25(users5.id, claim.chefId)).limit(1);
      const [location] = await db.select().from(locations5).where(eq25(locations5.id, claim.locationId)).limit(1);
      const chargeDate = claim.chargeSucceededAt ? new Date(claim.chargeSucceededAt) : /* @__PURE__ */ new Date();
      const amountCents = claim.finalAmountCents || claim.claimedAmountCents;
      doc.fontSize(24).font("Helvetica-Bold").text("DAMAGE CLAIM INVOICE", { align: "center" });
      doc.moveDown(0.5);
      doc.fontSize(10).font("Helvetica").fillColor("#6b7280").text("LocalCooks Platform", { align: "center" });
      doc.fillColor("#000000");
      doc.moveDown(2);
      doc.fontSize(12).font("Helvetica-Bold").text("Invoice Details");
      doc.moveDown(0.5);
      doc.fontSize(10).font("Helvetica");
      doc.text(`Invoice Number: LC-DC-${claim.id.toString().padStart(6, "0")}`);
      doc.text(`Date: ${chargeDate.toLocaleDateString("en-CA", { year: "numeric", month: "long", day: "numeric" })}`);
      doc.text(`Payment Status: Paid`);
      doc.moveDown(1.5);
      doc.fontSize(12).font("Helvetica-Bold").text("Billed To");
      doc.moveDown(0.5);
      doc.fontSize(10).font("Helvetica");
      doc.text(chef?.fullName || chef?.username || "Chef");
      doc.text(chef?.email || "");
      doc.moveDown(1.5);
      doc.fontSize(12).font("Helvetica-Bold").text("Location");
      doc.moveDown(0.5);
      doc.fontSize(10).font("Helvetica");
      doc.text(location?.name || "Kitchen Location");
      doc.text(location?.address || "");
      doc.moveDown(1.5);
      doc.fontSize(12).font("Helvetica-Bold").text("Damage Claim Details");
      doc.moveDown(0.5);
      doc.fontSize(10).font("Helvetica");
      doc.text(`Claim Title: ${claim.claimTitle}`);
      doc.text(`Booking Type: ${claim.bookingType === "storage" ? "Storage" : "Kitchen"}`);
      doc.text(`Damage Date: ${new Date(claim.damageDate).toLocaleDateString("en-CA", { year: "numeric", month: "long", day: "numeric" })}`);
      doc.moveDown(0.5);
      doc.text("Description:", { continued: false });
      doc.text(claim.claimDescription, { width: 450 });
      doc.moveDown(1.5);
      doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke("#e5e7eb");
      doc.moveDown(0.5);
      const tableY = doc.y;
      doc.fontSize(10).font("Helvetica-Bold");
      doc.text("Description", 50, tableY);
      doc.text("Amount", 450, tableY, { align: "right", width: 100 });
      doc.moveDown(0.5);
      doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke("#e5e7eb");
      doc.moveDown(0.5);
      doc.font("Helvetica");
      const itemY = doc.y;
      doc.text("Damage Claim Payment", 50, itemY);
      doc.text(`$${(amountCents / 100).toFixed(2)} CAD`, 450, itemY, { align: "right", width: 100 });
      doc.moveDown(1);
      doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke("#e5e7eb");
      doc.moveDown(0.5);
      doc.font("Helvetica-Bold");
      const totalY = doc.y;
      doc.text("Total Charged", 50, totalY);
      doc.text(`$${(amountCents / 100).toFixed(2)} CAD`, 450, totalY, { align: "right", width: 100 });
      doc.moveDown(1.5);
      if (invoiceViewer === "manager" && stripeProcessingFeeCents > 0) {
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke("#e5e7eb");
        doc.moveDown(0.5);
        doc.fontSize(10).font("Helvetica").fillColor("#6b7280");
        const feeY = doc.y;
        doc.text("Stripe Processing Fee:", 50, feeY);
        doc.fillColor("#dc2626");
        doc.text(`-$${(stripeProcessingFeeCents / 100).toFixed(2)} CAD`, 450, feeY, { align: "right", width: 100 });
        doc.fillColor("#000000");
        doc.moveDown(0.8);
        const netAmount = managerRevenueCents > 0 ? managerRevenueCents : amountCents - stripeProcessingFeeCents;
        doc.fontSize(12).font("Helvetica-Bold").fillColor("#059669");
        const netY = doc.y;
        doc.text("You Receive:", 50, netY);
        doc.text(`$${(netAmount / 100).toFixed(2)} CAD`, 450, netY, { align: "right", width: 100 });
        doc.fillColor("#000000");
        doc.moveDown(1);
      }
      doc.moveDown(0.5);
      doc.fontSize(10).font("Helvetica");
      doc.text("Payment Method: Credit/Debit Card");
      doc.text(`Transaction Date: ${chargeDate.toLocaleDateString("en-CA", { year: "numeric", month: "long", day: "numeric", hour: "2-digit", minute: "2-digit" })}`);
      const dcRef = claim.referenceCode;
      if (dcRef) {
        doc.text(`Reference: ${dcRef}`);
      } else if (claim.stripePaymentIntentId) {
        doc.text(`Reference: ${claim.stripePaymentIntentId.slice(-8).toUpperCase()}`);
      }
      const dcPageHeight = doc.page.height;
      const dcFooterY = dcPageHeight - 80;
      doc.moveTo(50, dcFooterY).lineTo(550, dcFooterY).stroke("#e5e7eb");
      doc.fontSize(9).fillColor("#6b7280").text("For questions, contact support@localcook.shop", 50, dcFooterY + 15, { align: "center", width: 500 });
      doc.fillColor("#000000");
      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}
var init_invoice_service = __esm({
  "server/services/invoice-service.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_schema();
    init_stripe_service();
  }
});

// server/routes/middleware.ts
import { eq as eq26, desc as desc12 } from "drizzle-orm";
async function getAuthenticatedUser(req) {
  if (req.neonUser) {
    return {
      id: req.neonUser.id,
      username: req.neonUser.username,
      role: req.neonUser.role || ""
    };
  }
  return null;
}
async function requireChef(req, res, next) {
  if (!req.neonUser) {
    return res.status(401).json({ error: "Not authenticated" });
  }
  const hasChefAccess = req.neonUser.isChef === true || // isChef flag is true
  req.neonUser.role === "chef" || // role is 'chef'
  req.neonUser.role === "admin";
  if (!hasChefAccess) {
    logger.info(`[requireChef] Access denied for user ${req.neonUser.id}:`, {
      role: req.neonUser.role,
      isChef: req.neonUser.isChef
    });
    return res.status(403).json({ error: "Access denied. Chef role required." });
  }
  next();
}
async function requireNoUnpaidPenalties(req, res, next) {
  try {
    if (!req.neonUser) {
      return res.status(401).json({ error: "Not authenticated" });
    }
    if (req.neonUser.role === "admin") {
      return next();
    }
    const chefId = req.neonUser.id;
    const { hasChefUnpaidPenalties: hasChefUnpaidPenalties2, getChefUnpaidPenalties: getChefUnpaidPenalties2 } = await Promise.resolve().then(() => (init_overstay_penalty_service(), overstay_penalty_service_exports));
    const hasUnpaidPenalties = await hasChefUnpaidPenalties2(chefId);
    const { hasChefUnpaidDamageClaims: hasChefUnpaidDamageClaims2, getChefUnpaidDamageClaims: getChefUnpaidDamageClaims2 } = await Promise.resolve().then(() => (init_damage_claim_service(), damage_claim_service_exports));
    const hasUnpaidClaims = await hasChefUnpaidDamageClaims2(chefId);
    if (!hasUnpaidPenalties && !hasUnpaidClaims) {
      return next();
    }
    const response = {
      error: "Access denied. You have unpaid obligations.",
      code: "UNPAID_OBLIGATIONS",
      totalOwedCents: 0,
      totalOwed: "$0.00",
      message: ""
    };
    let totalPenaltiesOwed = 0;
    let totalClaimsOwed = 0;
    if (hasUnpaidPenalties) {
      const unpaidPenalties = await getChefUnpaidPenalties2(chefId);
      totalPenaltiesOwed = unpaidPenalties.reduce((sum, p) => sum + p.penaltyAmountCents, 0);
      const immediatePaymentPenalties = unpaidPenalties.filter((p) => p.requiresImmediatePayment);
      response.overstayPenalties = {
        totalCount: unpaidPenalties.length,
        totalOwedCents: totalPenaltiesOwed,
        totalOwed: `$${(totalPenaltiesOwed / 100).toFixed(2)}`,
        items: unpaidPenalties.map((p) => ({
          overstayId: p.overstayId,
          storageName: p.storageName,
          kitchenName: p.kitchenName,
          daysOverdue: p.daysOverdue,
          status: p.status,
          penaltyAmountCents: p.penaltyAmountCents,
          penaltyAmount: `$${(p.penaltyAmountCents / 100).toFixed(2)}`,
          requiresImmediatePayment: p.requiresImmediatePayment
        })),
        canPayNow: immediatePaymentPenalties.length > 0
      };
    }
    if (hasUnpaidClaims) {
      const unpaidClaims = await getChefUnpaidDamageClaims2(chefId);
      totalClaimsOwed = unpaidClaims.reduce((sum, c) => sum + c.finalAmountCents, 0);
      const immediatePaymentClaims = unpaidClaims.filter((c) => c.requiresImmediatePayment);
      response.damageClaims = {
        totalCount: unpaidClaims.length,
        totalOwedCents: totalClaimsOwed,
        totalOwed: `$${(totalClaimsOwed / 100).toFixed(2)}`,
        items: unpaidClaims.map((c) => ({
          claimId: c.claimId,
          claimTitle: c.claimTitle,
          kitchenName: c.kitchenName,
          bookingType: c.bookingType,
          status: c.status,
          amountCents: c.finalAmountCents,
          amount: `$${(c.finalAmountCents / 100).toFixed(2)}`,
          requiresImmediatePayment: c.requiresImmediatePayment
        })),
        canPayNow: immediatePaymentClaims.length > 0
      };
    }
    const grandTotal = totalPenaltiesOwed + totalClaimsOwed;
    response.totalOwedCents = grandTotal;
    response.totalOwed = `$${(grandTotal / 100).toFixed(2)}`;
    const parts = [];
    if (hasUnpaidPenalties) {
      parts.push(`${response.overstayPenalties.totalCount} overstay penalty(ies)`);
    }
    if (hasUnpaidClaims) {
      parts.push(`${response.damageClaims.totalCount} damage claim(s)`);
    }
    response.message = `You have ${parts.join(" and ")} totaling ${response.totalOwed}. Please resolve these to continue using the portal.`;
    logger.info(`[requireNoUnpaidPenalties] Chef ${chefId} blocked: ${parts.join(" and ")}, $${(grandTotal / 100).toFixed(2)} owed`);
    return res.status(403).json(response);
  } catch (error) {
    logger.error("[requireNoUnpaidPenalties] Error checking obligations:", error);
    next();
  }
}
async function requirePortalUser(req, res, next) {
  try {
    const user = req.neonUser;
    if (!user) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const accessRecords = await db.select().from(portalUserLocationAccess).where(eq26(portalUserLocationAccess.portalUserId, user.id)).limit(1);
    if (accessRecords.length > 0) {
      return next();
    }
    const applications4 = await db.select().from(portalUserApplications).where(eq26(portalUserApplications.userId, user.id)).orderBy(desc12(portalUserApplications.createdAt)).limit(1);
    if (applications4.length > 0) {
      const app2 = applications4[0];
      if (app2.status === "approved") {
        return next();
      }
      return res.status(403).json({
        error: "Access denied. Your application is pending approval.",
        status: app2.status,
        applicationId: app2.id,
        awaitingApproval: app2.status === "inReview"
      });
    }
    return res.status(403).json({
      error: "Access denied. You must submit a portal application first.",
      status: "no_application"
    });
  } catch (error) {
    logger.error("Error in requirePortalUser middleware:", error);
    return res.status(401).json({ error: "Authentication failed" });
  }
}
var init_middleware = __esm({
  "server/routes/middleware.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_schema();
  }
});

// server/services/auth-expiry-service.ts
var auth_expiry_service_exports = {};
__export(auth_expiry_service_exports, {
  lazyExpireKitchenBookingAuth: () => lazyExpireKitchenBookingAuth,
  lazyExpireStorageExtensionAuth: () => lazyExpireStorageExtensionAuth,
  processExpiredAuthorizations: () => processExpiredAuthorizations
});
import { eq as eq27, and as and15, lt as lt3, sql as sql13 } from "drizzle-orm";
async function lazyExpireKitchenBookingAuth(booking) {
  if (booking.paymentStatus !== "authorized" || booking.status !== "pending") return false;
  if (!booking.paymentIntentId || !booking.createdAt) return false;
  const cutoffTime = new Date(Date.now() - AUTH_EXPIRY_HOURS * 60 * 60 * 1e3);
  if (new Date(booking.createdAt) >= cutoffTime) return false;
  try {
    logger.info(`[AuthExpiry] Lazy-expiring kitchen booking ${booking.id} \u2014 authorization older than ${AUTH_EXPIRY_HOURS}h`);
    const { cancelPaymentIntent: cancelPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
    await cancelPaymentIntent2(booking.paymentIntentId);
    await db.update(kitchenBookings).set({
      status: "cancelled",
      paymentStatus: "failed",
      updatedAt: /* @__PURE__ */ new Date()
    }).where(
      and15(
        eq27(kitchenBookings.id, booking.id),
        eq27(kitchenBookings.paymentStatus, "authorized")
        // Atomic guard
      )
    );
    await db.update(storageBookings).set({ paymentStatus: "failed", updatedAt: /* @__PURE__ */ new Date() }).where(
      and15(
        eq27(storageBookings.kitchenBookingId, booking.id),
        eq27(storageBookings.paymentStatus, "authorized")
      )
    );
    await db.update(equipmentBookings).set({ paymentStatus: "failed", updatedAt: /* @__PURE__ */ new Date() }).where(
      and15(
        eq27(equipmentBookings.kitchenBookingId, booking.id),
        eq27(equipmentBookings.paymentStatus, "authorized")
      )
    );
    try {
      const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
      const pt = await findPaymentTransactionByIntentId2(booking.paymentIntentId, db);
      if (pt) {
        await updatePaymentTransaction2(pt.id, {
          status: "canceled",
          stripeStatus: "canceled"
        }, db);
      }
    } catch (ptErr) {
      logger.warn(`[AuthExpiry] Lazy: Could not update PT for booking ${booking.id}:`, ptErr);
    }
    try {
      await sendAuthExpiryNotification(booking.chefId, booking.id, "kitchen_booking", booking.kitchenId);
    } catch (notifErr) {
      logger.warn(`[AuthExpiry] Lazy: Could not send notification for booking ${booking.id}:`, notifErr);
    }
    logger.info(`[AuthExpiry] Lazy-expired kitchen booking ${booking.id} successfully`);
    return true;
  } catch (err) {
    logger.error(`[AuthExpiry] Lazy: Error expiring booking ${booking.id}:`, err);
    return false;
  }
}
async function lazyExpireStorageExtensionAuth(extension) {
  if (extension.status !== "authorized") return false;
  if (!extension.stripePaymentIntentId || !extension.createdAt) return false;
  const cutoffTime = new Date(Date.now() - AUTH_EXPIRY_HOURS * 60 * 60 * 1e3);
  if (new Date(extension.createdAt) >= cutoffTime) return false;
  try {
    logger.info(`[AuthExpiry] Lazy-expiring storage extension ${extension.id} \u2014 authorization older than ${AUTH_EXPIRY_HOURS}h`);
    const { cancelPaymentIntent: cancelPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
    await cancelPaymentIntent2(extension.stripePaymentIntentId);
    await db.update(pendingStorageExtensions).set({
      status: "expired",
      rejectionReason: "Payment authorization expired \u2014 manager did not respond within 24 hours",
      updatedAt: /* @__PURE__ */ new Date()
    }).where(
      and15(
        eq27(pendingStorageExtensions.id, extension.id),
        eq27(pendingStorageExtensions.status, "authorized")
        // Atomic guard
      )
    );
    try {
      const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
      const pt = await findPaymentTransactionByIntentId2(extension.stripePaymentIntentId, db);
      if (pt) {
        await updatePaymentTransaction2(pt.id, {
          status: "canceled",
          stripeStatus: "canceled"
        }, db);
      }
    } catch (ptErr) {
      logger.warn(`[AuthExpiry] Lazy: Could not update PT for extension ${extension.id}:`, ptErr);
    }
    try {
      const [sb] = await db.select({ chefId: storageBookings.chefId }).from(storageBookings).where(eq27(storageBookings.id, extension.storageBookingId)).limit(1);
      if (sb?.chefId) {
        await sendAuthExpiryNotification(sb.chefId, extension.id, "storage_extension");
      }
    } catch (notifErr) {
      logger.warn(`[AuthExpiry] Lazy: Could not send notification for extension ${extension.id}:`, notifErr);
    }
    logger.info(`[AuthExpiry] Lazy-expired storage extension ${extension.id} successfully`);
    return true;
  } catch (err) {
    logger.error(`[AuthExpiry] Lazy: Error expiring extension ${extension.id}:`, err);
    return false;
  }
}
async function processExpiredAuthorizations() {
  const results = [];
  const cutoffTime = new Date(Date.now() - AUTH_EXPIRY_HOURS * 60 * 60 * 1e3);
  logger.info(`[AuthExpiry] Processing expired authorizations (cutoff: ${cutoffTime.toISOString()})`);
  try {
    const expiredBookings = await db.select({
      id: kitchenBookings.id,
      paymentIntentId: kitchenBookings.paymentIntentId,
      chefId: kitchenBookings.chefId,
      kitchenId: kitchenBookings.kitchenId,
      createdAt: kitchenBookings.createdAt
    }).from(kitchenBookings).where(
      and15(
        eq27(kitchenBookings.paymentStatus, "authorized"),
        eq27(kitchenBookings.status, "pending"),
        lt3(kitchenBookings.createdAt, cutoffTime)
      )
    );
    logger.info(`[AuthExpiry] Found ${expiredBookings.length} expired kitchen booking authorizations`);
    for (const booking of expiredBookings) {
      if (!booking.paymentIntentId) continue;
      try {
        const { cancelPaymentIntent: cancelPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
        await cancelPaymentIntent2(booking.paymentIntentId);
        await db.update(kitchenBookings).set({
          status: "cancelled",
          paymentStatus: "failed",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq27(kitchenBookings.id, booking.id));
        await db.update(storageBookings).set({
          paymentStatus: "failed",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(
          and15(
            eq27(storageBookings.kitchenBookingId, booking.id),
            eq27(storageBookings.paymentStatus, "authorized")
          )
        );
        await db.update(equipmentBookings).set({
          paymentStatus: "failed",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(
          and15(
            eq27(equipmentBookings.kitchenBookingId, booking.id),
            eq27(equipmentBookings.paymentStatus, "authorized")
          )
        );
        try {
          const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
          const pt = await findPaymentTransactionByIntentId2(booking.paymentIntentId, db);
          if (pt) {
            await updatePaymentTransaction2(pt.id, {
              status: "canceled",
              stripeStatus: "canceled"
            }, db);
          }
        } catch (ptErr) {
          logger.warn(`[AuthExpiry] Could not update PT for booking ${booking.id}:`, ptErr);
        }
        try {
          await sendAuthExpiryNotification(booking.chefId, booking.id, "kitchen_booking", booking.kitchenId);
        } catch (notifErr) {
          logger.warn(`[AuthExpiry] Could not send notification for booking ${booking.id}:`, notifErr);
        }
        results.push({
          type: "kitchen_booking",
          id: booking.id,
          paymentIntentId: booking.paymentIntentId,
          chefId: booking.chefId,
          action: "canceled"
        });
        logger.info(`[AuthExpiry] Cancelled authorization for kitchen booking ${booking.id}`);
      } catch (err) {
        logger.error(`[AuthExpiry] Error cancelling auth for booking ${booking.id}:`, err);
        results.push({
          type: "kitchen_booking",
          id: booking.id,
          paymentIntentId: booking.paymentIntentId,
          chefId: booking.chefId,
          action: "error",
          error: err.message
        });
      }
    }
  } catch (queryErr) {
    logger.error(`[AuthExpiry] Error querying expired kitchen bookings:`, queryErr);
  }
  try {
    const expiredExtensions = await db.select({
      id: pendingStorageExtensions.id,
      stripePaymentIntentId: pendingStorageExtensions.stripePaymentIntentId,
      storageBookingId: pendingStorageExtensions.storageBookingId,
      createdAt: pendingStorageExtensions.createdAt,
      chefId: sql13`(
          SELECT sb.chef_id FROM storage_bookings sb 
          WHERE sb.id = ${pendingStorageExtensions.storageBookingId}
        )`.as("chefId")
    }).from(pendingStorageExtensions).where(
      and15(
        eq27(pendingStorageExtensions.status, "authorized"),
        lt3(pendingStorageExtensions.createdAt, cutoffTime)
      )
    );
    logger.info(`[AuthExpiry] Found ${expiredExtensions.length} expired storage extension authorizations`);
    for (const ext of expiredExtensions) {
      if (!ext.stripePaymentIntentId) continue;
      try {
        const { cancelPaymentIntent: cancelPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
        await cancelPaymentIntent2(ext.stripePaymentIntentId);
        await db.update(pendingStorageExtensions).set({
          status: "expired",
          rejectionReason: "Payment authorization expired \u2014 manager did not respond within 24 hours",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq27(pendingStorageExtensions.id, ext.id));
        try {
          const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
          const pt = await findPaymentTransactionByIntentId2(ext.stripePaymentIntentId, db);
          if (pt) {
            await updatePaymentTransaction2(pt.id, {
              status: "canceled",
              stripeStatus: "canceled"
            }, db);
          }
        } catch (ptErr) {
          logger.warn(`[AuthExpiry] Could not update PT for extension ${ext.id}:`, ptErr);
        }
        try {
          await sendAuthExpiryNotification(ext.chefId, ext.id, "storage_extension");
        } catch (notifErr) {
          logger.warn(`[AuthExpiry] Could not send notification for extension ${ext.id}:`, notifErr);
        }
        results.push({
          type: "storage_extension",
          id: ext.id,
          paymentIntentId: ext.stripePaymentIntentId,
          chefId: ext.chefId,
          action: "canceled"
        });
        logger.info(`[AuthExpiry] Cancelled authorization for storage extension ${ext.id}`);
      } catch (err) {
        logger.error(`[AuthExpiry] Error cancelling auth for extension ${ext.id}:`, err);
        results.push({
          type: "storage_extension",
          id: ext.id,
          paymentIntentId: ext.stripePaymentIntentId,
          chefId: ext.chefId,
          action: "error",
          error: err.message
        });
      }
    }
  } catch (queryErr) {
    logger.error(`[AuthExpiry] Error querying expired storage extensions:`, queryErr);
  }
  logger.info(`[AuthExpiry] Processed ${results.length} expired authorizations (${results.filter((r) => r.action === "canceled").length} canceled, ${results.filter((r) => r.action === "error").length} errors)`);
  return results;
}
async function sendAuthExpiryNotification(chefId, recordId, type, kitchenId) {
  if (!chefId) return;
  try {
    const { notificationService: notificationService2 } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
    const [chef] = await db.select({ username: users.username }).from(users).where(eq27(users.id, chefId)).limit(1);
    if (!chef?.username) return;
    let kitchenName = "Kitchen";
    if (kitchenId) {
      const [kitchen] = await db.select({ name: kitchens.name }).from(kitchens).where(eq27(kitchens.id, kitchenId)).limit(1);
      if (kitchen) kitchenName = kitchen.name;
    }
    try {
      await notificationService2.createForChef({
        chefId,
        type: "booking_cancelled",
        title: "Booking Authorization Expired",
        message: type === "kitchen_booking" ? `Your kitchen booking #${recordId} at ${kitchenName} was automatically cancelled because the manager did not respond within 24 hours. Your card has not been charged.` : `Your storage extension request #${recordId} was automatically cancelled because the manager did not respond within 24 hours. Your card has not been charged.`,
        metadata: { type, recordId: String(recordId) }
      });
    } catch {
    }
  } catch (err) {
    logger.warn(`[AuthExpiry] Error sending notification to chef ${chefId}:`, err);
  }
}
var AUTH_EXPIRY_HOURS;
var init_auth_expiry_service = __esm({
  "server/services/auth-expiry-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_logger();
    AUTH_EXPIRY_HOURS = 24;
  }
});

// server/services/stripe-checkout-service.ts
var stripe_checkout_service_exports = {};
__export(stripe_checkout_service_exports, {
  createCheckoutSession: () => createCheckoutSession,
  createPendingCheckoutSession: () => createPendingCheckoutSession
});
import Stripe5 from "stripe";
async function createPendingCheckoutSession(params) {
  if (!stripe5) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  const {
    bookingPriceInCents,
    platformFeeInCents,
    managerStripeAccountId,
    customerEmail,
    currency = "cad",
    successUrl,
    cancelUrl,
    bookingData,
    lineItemName = "Kitchen Session Booking",
    lineItemBreakdown
  } = params;
  if (bookingPriceInCents <= 0) {
    throw new Error("Booking price must be greater than 0");
  }
  if (platformFeeInCents < 0) {
    throw new Error("Platform fee cannot be negative");
  }
  if (platformFeeInCents >= bookingPriceInCents) {
    throw new Error("Platform fee must be less than booking price");
  }
  if (!managerStripeAccountId) {
    throw new Error("Manager Stripe account ID is required");
  }
  if (!customerEmail) {
    throw new Error("Customer email is required");
  }
  try {
    let lineItems;
    if (lineItemBreakdown) {
      lineItems = [];
      if (lineItemBreakdown.kitchenPriceCents > 0) {
        lineItems.push({
          price_data: {
            currency: currency.toLowerCase(),
            product_data: { name: lineItemBreakdown.kitchenLabel || lineItemName },
            unit_amount: lineItemBreakdown.kitchenPriceCents
          },
          quantity: 1
        });
      }
      if (lineItemBreakdown.storageItems && lineItemBreakdown.storageItems.length > 0) {
        for (const item of lineItemBreakdown.storageItems) {
          if (item.priceCents > 0) {
            lineItems.push({
              price_data: {
                currency: currency.toLowerCase(),
                product_data: { name: item.name },
                unit_amount: item.priceCents
              },
              quantity: 1
            });
          }
        }
      }
      if (lineItemBreakdown.equipmentItems && lineItemBreakdown.equipmentItems.length > 0) {
        for (const item of lineItemBreakdown.equipmentItems) {
          if (item.priceCents > 0) {
            lineItems.push({
              price_data: {
                currency: currency.toLowerCase(),
                product_data: { name: item.name },
                unit_amount: item.priceCents
              },
              quantity: 1
            });
          }
        }
      }
      if (lineItemBreakdown.taxCents > 0) {
        lineItems.push({
          price_data: {
            currency: currency.toLowerCase(),
            product_data: { name: lineItemBreakdown.taxLabel || "Tax" },
            unit_amount: lineItemBreakdown.taxCents
          },
          quantity: 1
        });
      }
      if (lineItems.length === 0) {
        lineItems.push({
          price_data: {
            currency: currency.toLowerCase(),
            product_data: { name: lineItemName },
            unit_amount: bookingPriceInCents
          },
          quantity: 1
        });
      }
    } else {
      lineItems = [
        {
          price_data: {
            currency: currency.toLowerCase(),
            product_data: { name: lineItemName },
            unit_amount: bookingPriceInCents
          },
          quantity: 1
        }
      ];
    }
    const paymentIntentData = {
      transfer_data: { destination: managerStripeAccountId },
      metadata: {
        type: "kitchen_booking",
        kitchen_id: bookingData.kitchenId.toString(),
        chef_id: bookingData.chefId.toString()
      }
    };
    if (platformFeeInCents > 0) {
      paymentIntentData.application_fee_amount = platformFeeInCents;
    }
    const sessionMetadata = {
      type: "kitchen_booking",
      kitchen_id: bookingData.kitchenId.toString(),
      chef_id: bookingData.chefId.toString(),
      booking_date: bookingData.bookingDate,
      start_time: bookingData.startTime,
      end_time: bookingData.endTime,
      total_price_cents: bookingData.totalPriceCents.toString(),
      tax_cents: bookingData.taxCents.toString(),
      hourly_rate_cents: bookingData.hourlyRateCents.toString(),
      duration_hours: bookingData.durationHours.toString(),
      booking_price_cents: bookingPriceInCents.toString(),
      platform_fee_cents: platformFeeInCents.toString(),
      manager_account_id: managerStripeAccountId
    };
    if (bookingData.specialNotes) {
      sessionMetadata.special_notes = bookingData.specialNotes;
    }
    if (bookingData.selectedSlots && bookingData.selectedSlots.length > 0) {
      sessionMetadata.selected_slots = JSON.stringify(bookingData.selectedSlots);
    }
    if (bookingData.selectedStorage && bookingData.selectedStorage.length > 0) {
      sessionMetadata.selected_storage = JSON.stringify(bookingData.selectedStorage);
    }
    if (bookingData.selectedEquipmentIds && bookingData.selectedEquipmentIds.length > 0) {
      sessionMetadata.selected_equipment_ids = JSON.stringify(bookingData.selectedEquipmentIds);
    }
    const session = await stripe5.checkout.sessions.create({
      mode: "payment",
      customer_email: customerEmail,
      // ENTERPRISE STANDARD: Always create a Stripe Customer for off-session charging
      // This enables future charges for overstay penalties, damage deposits, etc.
      customer_creation: "always",
      line_items: lineItems,
      payment_intent_data: {
        ...paymentIntentData,
        // AUTH-THEN-CAPTURE: Authorize the payment but don't charge until manager approves
        // PaymentIntent will have status 'requires_capture' after checkout completes
        // Manager approval triggers capture, rejection triggers cancellation (no charge)
        capture_method: "manual",
        // ENTERPRISE STANDARD: Set receipt_email for Stripe to send payment receipt
        receipt_email: customerEmail,
        // ENTERPRISE STANDARD: Save payment method for off-session charging
        // Enables automatic charging for overstay penalties and damage deposits
        // The payment method is saved to the platform's Stripe Customer (not connected account)
        setup_future_usage: "off_session"
      },
      success_url: successUrl,
      cancel_url: cancelUrl,
      metadata: sessionMetadata
      // NOTE: invoice_creation removed â€” incompatible with capture_method:'manual'
      // Invoices are generated at capture time via payment_intent.succeeded webhook
      // Stripe will send receipt email when payment is actually captured
    });
    if (!session.url) {
      throw new Error("Failed to create checkout session URL");
    }
    logger.info(`[Stripe Checkout] Created pending checkout session ${session.id} for kitchen ${bookingData.kitchenId}`);
    return {
      sessionId: session.id,
      sessionUrl: session.url
    };
  } catch (error) {
    logger.error("Error creating Stripe Checkout session:", error);
    throw new Error(`Failed to create checkout session: ${error.message}`);
  }
}
async function createCheckoutSession(params) {
  if (!stripe5) {
    throw new Error("Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.");
  }
  const {
    bookingPriceInCents,
    platformFeeInCents,
    managerStripeAccountId,
    customerEmail,
    bookingId,
    currency = "cad",
    successUrl,
    cancelUrl,
    metadata = {},
    lineItemName = "Kitchen Session Booking"
  } = params;
  if (bookingPriceInCents <= 0) {
    throw new Error("Booking price must be greater than 0");
  }
  if (platformFeeInCents < 0) {
    throw new Error("Platform fee cannot be negative");
  }
  if (platformFeeInCents >= bookingPriceInCents) {
    throw new Error("Platform fee must be less than booking price");
  }
  const estimatedStripeFee = Math.round(bookingPriceInCents * 0.029 + 30);
  if (platformFeeInCents > 0 && platformFeeInCents < estimatedStripeFee) {
    logger.warn(
      `[Stripe Checkout] Platform fee (${platformFeeInCents} cents) is less than estimated Stripe fee (${estimatedStripeFee} cents). Platform may lose money on this transaction.`
    );
  }
  if (!managerStripeAccountId) {
    throw new Error("Manager Stripe account ID is required");
  }
  if (!customerEmail) {
    throw new Error("Customer email is required");
  }
  const totalAmountInCents = bookingPriceInCents;
  try {
    const lineItems = [
      {
        price_data: {
          currency: currency.toLowerCase(),
          product_data: {
            name: lineItemName
          },
          unit_amount: bookingPriceInCents
        },
        quantity: 1
      }
    ];
    const paymentIntentData = {
      transfer_data: {
        destination: managerStripeAccountId
      },
      metadata: {
        booking_id: bookingId.toString(),
        ...metadata
      }
    };
    if (platformFeeInCents > 0) {
      paymentIntentData.application_fee_amount = platformFeeInCents;
    }
    const session = await stripe5.checkout.sessions.create({
      mode: "payment",
      customer_email: customerEmail,
      // ENTERPRISE STANDARD: Always create a Stripe Customer for off-session charging
      // This enables future charges for overstay penalties, damage deposits, etc.
      customer_creation: "always",
      line_items: lineItems,
      payment_intent_data: {
        ...paymentIntentData,
        // AUTH-THEN-CAPTURE: Authorize the payment but don't charge until manager approves
        // PaymentIntent will have status 'requires_capture' after checkout completes
        // Manager approval triggers capture, rejection triggers cancellation (no charge)
        capture_method: "manual",
        // ENTERPRISE STANDARD: Set receipt_email for Stripe to send payment receipt
        receipt_email: customerEmail,
        // ENTERPRISE STANDARD: Save payment method for off-session charging
        // Enables automatic charging for overstay penalties and damage deposits
        setup_future_usage: "off_session"
      },
      success_url: successUrl,
      cancel_url: cancelUrl,
      metadata: {
        booking_id: bookingId.toString(),
        booking_price_cents: bookingPriceInCents.toString(),
        platform_fee_cents: platformFeeInCents.toString(),
        total_cents: totalAmountInCents.toString(),
        manager_account_id: managerStripeAccountId,
        ...metadata
      }
      // NOTE: invoice_creation removed â€” incompatible with capture_method:'manual'
      // Invoices are generated at capture time via payment_intent.succeeded webhook
      // Stripe will send receipt email when payment is actually captured
    });
    if (!session.url) {
      throw new Error("Failed to create checkout session URL");
    }
    return {
      sessionId: session.id,
      sessionUrl: session.url
    };
  } catch (error) {
    logger.error("Error creating Stripe Checkout session:", error);
    throw new Error(`Failed to create checkout session: ${error.message}`);
  }
}
var stripeSecretKey5, stripe5;
var init_stripe_checkout_service = __esm({
  "server/services/stripe-checkout-service.ts"() {
    "use strict";
    init_logger();
    stripeSecretKey5 = process.env.STRIPE_SECRET_KEY;
    if (!stripeSecretKey5) {
      logger.warn("\u26A0\uFE0F STRIPE_SECRET_KEY not found in environment variables");
    }
    stripe5 = stripeSecretKey5 ? new Stripe5(stripeSecretKey5, {
      apiVersion: "2025-12-15.clover"
    }) : null;
  }
});

// server/services/storage-checkout-service.ts
var storage_checkout_service_exports = {};
__export(storage_checkout_service_exports, {
  addCheckoutPhotos: () => addCheckoutPhotos,
  autoCleanExpiredCheckout: () => autoCleanExpiredCheckout,
  getCheckoutHistory: () => getCheckoutHistory,
  getCheckoutStatus: () => getCheckoutStatus,
  getPendingCheckoutReviews: () => getPendingCheckoutReviews,
  isCheckoutInProgress: () => isCheckoutInProgress,
  processCheckoutApproval: () => processCheckoutApproval,
  processExpiredCheckoutReviews: () => processExpiredCheckoutReviews,
  requestStorageCheckout: () => requestStorageCheckout
});
import { eq as eq28, desc as desc13, and as and16, or as or3, inArray as inArray6, lt as lt4 } from "drizzle-orm";
async function requestStorageCheckout(storageBookingId, chefId, checkoutNotes, checkoutPhotoUrls) {
  try {
    if (!storageBookingId || storageBookingId <= 0) {
      return { success: false, error: "Invalid storage booking ID" };
    }
    if (!chefId || chefId <= 0) {
      return { success: false, error: "Invalid chef ID" };
    }
    const [booking] = await db.select().from(storageBookings).where(eq28(storageBookings.id, storageBookingId)).limit(1);
    if (!booking) {
      return { success: false, error: "Storage booking not found" };
    }
    if (booking.chefId !== chefId) {
      return { success: false, error: "You do not have permission to checkout this storage booking" };
    }
    if (booking.status === "cancelled") {
      return { success: false, error: "Cannot checkout a cancelled booking" };
    }
    if (booking.status === "completed") {
      return { success: false, error: "This booking has already been checked out" };
    }
    if (booking.status === "pending") {
      return { success: false, error: "Cannot checkout a pending booking. The booking must be confirmed first." };
    }
    const now = /* @__PURE__ */ new Date();
    const startDate = new Date(booking.startDate);
    if (startDate > now) {
      return { success: false, error: "Cannot checkout before the booking start date. Please wait until your booking period begins." };
    }
    const currentCheckoutStatus = booking.checkoutStatus;
    if (currentCheckoutStatus === "checkout_requested") {
      return { success: false, error: "Checkout has already been requested for this booking" };
    }
    if (currentCheckoutStatus === "checkout_approved") {
      return { success: false, error: "Checkout has already been approved for this booking" };
    }
    if (currentCheckoutStatus === "completed") {
      return { success: false, error: "This booking has already been completed" };
    }
    await db.update(storageBookings).set({
      checkoutStatus: "checkout_requested",
      checkoutRequestedAt: /* @__PURE__ */ new Date(),
      checkoutNotes: checkoutNotes || null,
      checkoutPhotoUrls: checkoutPhotoUrls || [],
      // Clear any previous denial
      checkoutDeniedAt: null,
      checkoutDeniedBy: null,
      checkoutDenialReason: null,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq28(storageBookings.id, storageBookingId));
    logger.info(`[StorageCheckout] Chef ${chefId} requested checkout for storage booking ${storageBookingId}`, {
      hasPhotos: (checkoutPhotoUrls?.length || 0) > 0,
      photoCount: checkoutPhotoUrls?.length || 0
    });
    try {
      await sendCheckoutRequestNotification(storageBookingId, chefId);
    } catch (notifyError) {
      logger.error(`[StorageCheckout] Error sending checkout notification:`, notifyError);
    }
    return {
      success: true,
      storageBookingId,
      checkoutStatus: "checkout_requested"
    };
  } catch (error) {
    logger.error(`[StorageCheckout] Error requesting checkout:`, error);
    return { success: false, error: "Failed to request checkout" };
  }
}
async function addCheckoutPhotos(storageBookingId, chefId, newPhotoUrls) {
  try {
    const [booking] = await db.select().from(storageBookings).where(eq28(storageBookings.id, storageBookingId)).limit(1);
    if (!booking) {
      return { success: false, error: "Storage booking not found" };
    }
    if (booking.chefId !== chefId) {
      return { success: false, error: "You do not have permission to modify this booking" };
    }
    const currentCheckoutStatus = booking.checkoutStatus;
    if (currentCheckoutStatus !== "checkout_requested") {
      return { success: false, error: "Can only add photos to pending checkout requests" };
    }
    const existingPhotos = booking.checkoutPhotoUrls || [];
    const allPhotos = [...existingPhotos, ...newPhotoUrls];
    if (allPhotos.length > 10) {
      return { success: false, error: "Maximum 10 checkout photos allowed" };
    }
    await db.update(storageBookings).set({
      checkoutPhotoUrls: allPhotos,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq28(storageBookings.id, storageBookingId));
    logger.info(`[StorageCheckout] Added ${newPhotoUrls.length} photos to checkout request for booking ${storageBookingId}`);
    return {
      success: true,
      storageBookingId,
      checkoutStatus: "checkout_requested"
    };
  } catch (error) {
    logger.error(`[StorageCheckout] Error adding checkout photos:`, error);
    return { success: false, error: "Failed to add checkout photos" };
  }
}
async function verifyManagerPermission(storageBookingId, managerId) {
  try {
    const [result] = await db.select({ managerId: locations.managerId }).from(storageBookings).innerJoin(storageListings, eq28(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq28(storageListings.kitchenId, kitchens.id)).innerJoin(locations, eq28(kitchens.locationId, locations.id)).where(eq28(storageBookings.id, storageBookingId)).limit(1);
    return result?.managerId === managerId;
  } catch (error) {
    logger.error(`[StorageCheckout] Error verifying manager permission:`, error);
    return false;
  }
}
async function sendCheckoutRequestNotification(storageBookingId, chefId) {
  try {
    const [booking] = await db.select({
      storageName: storageListings.name,
      kitchenName: kitchens.name,
      locationName: locations.name,
      managerId: locations.managerId,
      notificationEmail: locations.notificationEmail,
      endDate: storageBookings.endDate
    }).from(storageBookings).innerJoin(storageListings, eq28(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq28(storageListings.kitchenId, kitchens.id)).innerJoin(locations, eq28(kitchens.locationId, locations.id)).where(eq28(storageBookings.id, storageBookingId)).limit(1);
    if (!booking || !booking.managerId) {
      return;
    }
    let chefEmail = "Unknown Chef";
    if (chefId) {
      const [chef] = await db.select({ username: users.username }).from(users).where(eq28(users.id, chefId)).limit(1);
      chefEmail = chef?.username || "Unknown Chef";
    }
    let managerEmail = booking.notificationEmail;
    if (!managerEmail) {
      const [manager] = await db.select({ username: users.username }).from(users).where(eq28(users.id, booking.managerId)).limit(1);
      managerEmail = manager?.username;
    }
    if (!managerEmail) {
      return;
    }
    const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
    const emailContent = {
      to: managerEmail,
      subject: `Storage Checkout Request - ${booking.storageName}`,
      html: `
        <h2>Storage Checkout Request</h2>
        <p>A chef has requested checkout for their storage booking.</p>
        <table style="border-collapse: collapse; margin: 20px 0;">
          <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Chef:</strong></td><td style="padding: 8px; border: 1px solid #ddd;">${chefEmail}</td></tr>
          <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Storage:</strong></td><td style="padding: 8px; border: 1px solid #ddd;">${booking.storageName}</td></tr>
          <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Kitchen:</strong></td><td style="padding: 8px; border: 1px solid #ddd;">${booking.kitchenName}</td></tr>
          <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>End Date:</strong></td><td style="padding: 8px; border: 1px solid #ddd;">${new Date(booking.endDate).toLocaleDateString()}</td></tr>
        </table>
        <p>Please review the checkout request and verify the storage unit is empty before approving.</p>
        <p><a href="${process.env.VITE_APP_URL || "https://localcooks.ca"}/manager/dashboard?tab=checkouts" style="background-color: #4CAF50; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">Review Checkout Request</a></p>
      `,
      text: `Storage Checkout Request

A chef has requested checkout for their storage booking.

Chef: ${chefEmail}
Storage: ${booking.storageName}
Kitchen: ${booking.kitchenName}
End Date: ${new Date(booking.endDate).toLocaleDateString()}

Please review the checkout request in your dashboard.`
    };
    await sendEmail2(emailContent);
    logger.info(`[StorageCheckout] Sent checkout request notification to manager ${managerEmail}`);
  } catch (error) {
    logger.error(`[StorageCheckout] Error sending checkout request notification:`, error);
  }
}
async function sendCheckoutClearedNotification(storageBookingId, chefId, isAutoClear = false) {
  try {
    if (!chefId) return;
    const [chef] = await db.select({ username: users.username }).from(users).where(eq28(users.id, chefId)).limit(1);
    if (!chef?.username) return;
    const [booking] = await db.select({
      storageName: storageListings.name,
      kitchenName: kitchens.name
    }).from(storageBookings).innerJoin(storageListings, eq28(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq28(storageListings.kitchenId, kitchens.id)).where(eq28(storageBookings.id, storageBookingId)).limit(1);
    if (!booking) return;
    const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
    const clearedBy = isAutoClear ? "automatically (review window expired with no issues reported)" : "by the kitchen manager";
    const emailContent = {
      to: chef.username,
      subject: `Storage Cleared \u2014 No Issues - ${booking.storageName}`,
      html: `
        <h2>Storage Checkout Complete</h2>
        <p>Your storage checkout has been cleared ${clearedBy}.</p>
        <table style="border-collapse: collapse; margin: 20px 0;">
          <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Storage:</strong></td><td style="padding: 8px; border: 1px solid #ddd;">${booking.storageName}</td></tr>
          <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Kitchen:</strong></td><td style="padding: 8px; border: 1px solid #ddd;">${booking.kitchenName}</td></tr>
          <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Status:</strong></td><td style="padding: 8px; border: 1px solid #ddd; color: #16a34a; font-weight: 600;">Storage Cleared \u2014 No Issues</td></tr>
        </table>
        <p>Your storage booking has been successfully completed. Thank you for using Local Cooks!</p>
      `,
      text: `Storage Checkout Complete

Your storage checkout has been cleared ${clearedBy}.

Storage: ${booking.storageName}
Kitchen: ${booking.kitchenName}
Status: Storage Cleared \u2014 No Issues

Thank you for using Local Cooks!`
    };
    await sendEmail2(emailContent);
    logger.info(`[StorageCheckout] Sent cleared notification to chef ${chef.username} (autoClear: ${isAutoClear})`);
  } catch (error) {
    logger.error(`[StorageCheckout] Error sending cleared notification:`, error);
  }
}
async function sendCheckoutClaimNotification(storageBookingId, chefId, claimId, claimTitle) {
  try {
    if (!chefId) return;
    const [chef] = await db.select({ username: users.username }).from(users).where(eq28(users.id, chefId)).limit(1);
    if (!chef?.username) return;
    const [booking] = await db.select({
      storageName: storageListings.name,
      kitchenName: kitchens.name
    }).from(storageBookings).innerJoin(storageListings, eq28(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq28(storageListings.kitchenId, kitchens.id)).where(eq28(storageBookings.id, storageBookingId)).limit(1);
    if (!booking) return;
    const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
    const emailContent = {
      to: chef.username,
      subject: `Storage Checkout \u2014 Claim Filed - ${booking.storageName}`,
      html: `
        <h2>Storage Checkout Complete \u2014 Claim Filed</h2>
        <p>Your storage checkout has been processed. The kitchen has filed a damage/cleaning claim that requires your attention.</p>
        <table style="border-collapse: collapse; margin: 20px 0;">
          <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Storage:</strong></td><td style="padding: 8px; border: 1px solid #ddd;">${booking.storageName}</td></tr>
          <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Kitchen:</strong></td><td style="padding: 8px; border: 1px solid #ddd;">${booking.kitchenName}</td></tr>
          <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Claim:</strong></td><td style="padding: 8px; border: 1px solid #ddd;">${claimTitle}</td></tr>
        </table>
        <p>You will receive a separate notification with the full claim details. You can accept or dispute the claim from your dashboard.</p>
        <p><a href="${process.env.VITE_APP_URL || "https://localcooks.ca"}/dashboard?view=damage-claims" style="background-color: #f59e0b; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">View Claim Details</a></p>
      `,
      text: `Storage Checkout Complete \u2014 Claim Filed

Your storage checkout has been processed. The kitchen has filed a damage/cleaning claim "${claimTitle}".

Storage: ${booking.storageName}
Kitchen: ${booking.kitchenName}

Please review the claim in your dashboard.`
    };
    await sendEmail2(emailContent);
    logger.info(`[StorageCheckout] Sent claim notification to chef ${chef.username} for claim #${claimId}`);
  } catch (error) {
    logger.error(`[StorageCheckout] Error sending claim notification:`, error);
  }
}
async function processCheckoutApproval(storageBookingId, managerId, action, managerNotes, denialReasonOrClaimData) {
  try {
    if (!storageBookingId || storageBookingId <= 0) {
      return { success: false, error: "Invalid storage booking ID" };
    }
    if (!managerId || managerId <= 0) {
      return { success: false, error: "Invalid manager ID" };
    }
    const normalizedAction = action === "approve" ? "clear" : action;
    if (normalizedAction === "deny") {
      logger.warn(`[StorageCheckout] Legacy 'deny' action called for booking ${storageBookingId}. Deny is deprecated \u2014 treating as clear.`);
      return processCheckoutClear(storageBookingId, managerId, managerNotes);
    }
    if (normalizedAction === "start_claim") {
      if (!denialReasonOrClaimData || typeof denialReasonOrClaimData === "string") {
        return { success: false, error: "Claim data is required when starting a damage/cleaning claim" };
      }
      return processCheckoutStartClaim(storageBookingId, managerId, denialReasonOrClaimData, managerNotes);
    }
    return processCheckoutClear(storageBookingId, managerId, managerNotes);
  } catch (error) {
    logger.error(`[StorageCheckout] Error processing checkout review:`, error);
    return { success: false, error: "Failed to process checkout review" };
  }
}
async function processCheckoutClear(storageBookingId, managerId, managerNotes) {
  const [booking] = await db.select({
    id: storageBookings.id,
    chefId: storageBookings.chefId,
    checkoutStatus: storageBookings.checkoutStatus
  }).from(storageBookings).where(eq28(storageBookings.id, storageBookingId)).limit(1);
  if (!booking) {
    return { success: false, error: "Storage booking not found" };
  }
  const hasPermission = await verifyManagerPermission(storageBookingId, managerId);
  if (!hasPermission) {
    return { success: false, error: "You do not have permission to review this checkout" };
  }
  const currentCheckoutStatus = booking.checkoutStatus;
  if (currentCheckoutStatus !== "checkout_requested") {
    return { success: false, error: `Cannot process checkout in status: ${currentCheckoutStatus || "active"}` };
  }
  await db.update(storageBookings).set({
    checkoutStatus: "completed",
    checkoutApprovedAt: /* @__PURE__ */ new Date(),
    checkoutApprovedBy: managerId,
    checkoutNotes: managerNotes ? `Manager: ${managerNotes}` : "Storage cleared \u2014 no issues found",
    status: "completed",
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq28(storageBookings.id, storageBookingId));
  logger.info(`[StorageCheckout] Manager ${managerId} cleared storage for booking ${storageBookingId} \u2014 no issues`);
  try {
    await sendCheckoutClearedNotification(storageBookingId, booking.chefId);
  } catch (notifyError) {
    logger.error(`[StorageCheckout] Error sending cleared notification:`, notifyError);
  }
  return {
    success: true,
    storageBookingId,
    checkoutStatus: "completed",
    bookingCompleted: true
  };
}
async function processCheckoutStartClaim(storageBookingId, managerId, claimData, managerNotes) {
  const [booking] = await db.select({
    id: storageBookings.id,
    chefId: storageBookings.chefId,
    checkoutStatus: storageBookings.checkoutStatus,
    checkoutRequestedAt: storageBookings.checkoutRequestedAt
  }).from(storageBookings).where(eq28(storageBookings.id, storageBookingId)).limit(1);
  if (!booking) {
    return { success: false, error: "Storage booking not found" };
  }
  const hasPermission = await verifyManagerPermission(storageBookingId, managerId);
  if (!hasPermission) {
    return { success: false, error: "You do not have permission to review this checkout" };
  }
  const currentCheckoutStatus = booking.checkoutStatus;
  if (currentCheckoutStatus !== "checkout_requested" && currentCheckoutStatus !== "completed") {
    return { success: false, error: `Cannot start claim from checkout status: ${currentCheckoutStatus || "active"}` };
  }
  if (currentCheckoutStatus === "completed") {
    const { getStorageCheckoutSettings: getStorageCheckoutSettings2 } = await Promise.resolve().then(() => (init_damage_claim_limits_service(), damage_claim_limits_service_exports));
    const settings = await getStorageCheckoutSettings2();
    const checkoutTime = booking.checkoutRequestedAt;
    if (checkoutTime) {
      const extendedDeadline = new Date(checkoutTime.getTime() + settings.extendedClaimWindowHours * 60 * 60 * 1e3);
      if (/* @__PURE__ */ new Date() > extendedDeadline) {
        return {
          success: false,
          error: `Extended claim window has expired. Claims must be filed within ${settings.extendedClaimWindowHours} hours of checkout.`
        };
      }
    }
  }
  if (!claimData.claimTitle || claimData.claimTitle.trim().length < 5) {
    return { success: false, error: "Claim title must be at least 5 characters" };
  }
  if (!claimData.claimDescription || claimData.claimDescription.trim().length < 50) {
    return { success: false, error: "Claim description must be at least 50 characters" };
  }
  if (!claimData.claimedAmountCents || claimData.claimedAmountCents <= 0) {
    return { success: false, error: "Claimed amount must be greater than zero" };
  }
  const { createDamageClaim: createDamageClaim2 } = await Promise.resolve().then(() => (init_damage_claim_service(), damage_claim_service_exports));
  const claimResult = await createDamageClaim2({
    bookingType: "storage",
    storageBookingId,
    managerId,
    claimTitle: claimData.claimTitle.trim(),
    claimDescription: claimData.claimDescription.trim(),
    claimedAmountCents: claimData.claimedAmountCents,
    damageDate: claimData.damageDate || (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
    submitImmediately: true
  });
  if (!claimResult.success || !claimResult.claim) {
    return {
      success: false,
      error: claimResult.error || "Failed to create damage claim"
    };
  }
  const claimId = claimResult.claim.id;
  try {
    const [bookingWithPhotos] = await db.select({ checkoutPhotoUrls: storageBookings.checkoutPhotoUrls }).from(storageBookings).where(eq28(storageBookings.id, storageBookingId)).limit(1);
    const photoUrls = bookingWithPhotos?.checkoutPhotoUrls;
    if (photoUrls && photoUrls.length > 0) {
      const { damageEvidence: damageEvidence2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      for (let i = 0; i < photoUrls.length; i++) {
        await db.insert(damageEvidence2).values({
          damageClaimId: claimId,
          evidenceType: "photo_after",
          fileUrl: photoUrls[i],
          fileName: `checkout-photo-${i + 1}.jpg`,
          description: `Chef checkout photo ${i + 1} of ${photoUrls.length} (auto-attached from checkout)`,
          uploadedBy: managerId
        });
      }
      logger.info(`[StorageCheckout] Auto-attached ${photoUrls.length} checkout photos as evidence for claim #${claimId}`);
    }
  } catch (evidenceError) {
    logger.error(`[StorageCheckout] Error auto-attaching checkout photos to claim #${claimId}:`, evidenceError);
  }
  await db.update(storageBookings).set({
    checkoutStatus: "checkout_claim_filed",
    checkoutApprovedAt: /* @__PURE__ */ new Date(),
    checkoutApprovedBy: managerId,
    checkoutNotes: managerNotes ? `Manager: ${managerNotes} | Claim #${claimId} filed` : `Damage/cleaning claim #${claimId} filed during checkout review`,
    // Mark booking as completed â€” storage is released, but claim is tracked separately
    status: "completed",
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq28(storageBookings.id, storageBookingId));
  logger.info(`[StorageCheckout] Manager ${managerId} started claim #${claimId} for storage booking ${storageBookingId}`);
  try {
    await sendCheckoutClaimNotification(storageBookingId, booking.chefId, claimId, claimData.claimTitle);
  } catch (notifyError) {
    logger.error(`[StorageCheckout] Error sending claim notification:`, notifyError);
  }
  return {
    success: true,
    storageBookingId,
    checkoutStatus: "checkout_claim_filed",
    bookingCompleted: true,
    damageClaimId: claimId
  };
}
async function autoCleanExpiredCheckout(bookingId, chefId, checkoutRequestedAt, reviewWindowHours) {
  if (!checkoutRequestedAt) return false;
  const reviewWindowMs = reviewWindowHours * 60 * 60 * 1e3;
  const deadline = new Date(checkoutRequestedAt.getTime() + reviewWindowMs);
  if (/* @__PURE__ */ new Date() <= deadline) return false;
  try {
    await db.update(storageBookings).set({
      checkoutStatus: "completed",
      checkoutApprovedAt: /* @__PURE__ */ new Date(),
      checkoutNotes: `Auto-cleared by system \u2014 review window (${reviewWindowHours}h) expired with no issues reported`,
      status: "completed",
      updatedAt: /* @__PURE__ */ new Date()
    }).where(
      and16(
        eq28(storageBookings.id, bookingId),
        eq28(storageBookings.checkoutStatus, "checkout_requested")
      )
    );
    logger.info(`[StorageCheckout] Lazy auto-cleared booking ${bookingId} \u2014 review window expired`);
    try {
      await sendCheckoutClearedNotification(bookingId, chefId, true);
    } catch (notifyError) {
      logger.error(`[StorageCheckout] Error sending auto-clear notification for booking ${bookingId}:`, notifyError);
    }
    return true;
  } catch (error) {
    logger.error(`[StorageCheckout] Error lazy auto-clearing booking ${bookingId}:`, error);
    return false;
  }
}
async function processExpiredCheckoutReviews() {
  const result = { processed: 0, cleared: 0, errors: 0 };
  try {
    const { getStorageCheckoutSettings: getStorageCheckoutSettings2 } = await Promise.resolve().then(() => (init_damage_claim_limits_service(), damage_claim_limits_service_exports));
    const settings = await getStorageCheckoutSettings2();
    const reviewWindowMs = settings.reviewWindowHours * 60 * 60 * 1e3;
    const cutoffTime = new Date(Date.now() - reviewWindowMs);
    const expiredCheckouts = await db.select({
      id: storageBookings.id,
      chefId: storageBookings.chefId,
      checkoutRequestedAt: storageBookings.checkoutRequestedAt
    }).from(storageBookings).where(
      and16(
        eq28(storageBookings.checkoutStatus, "checkout_requested"),
        lt4(storageBookings.checkoutRequestedAt, cutoffTime)
      )
    );
    result.processed = expiredCheckouts.length;
    if (expiredCheckouts.length === 0) {
      logger.info(`[StorageCheckout] No expired checkout reviews to process`);
      return result;
    }
    logger.info(`[StorageCheckout] Processing ${expiredCheckouts.length} expired checkout reviews (window: ${settings.reviewWindowHours}h)`);
    for (const checkout of expiredCheckouts) {
      try {
        await db.update(storageBookings).set({
          checkoutStatus: "completed",
          checkoutApprovedAt: /* @__PURE__ */ new Date(),
          checkoutNotes: `Auto-cleared by system \u2014 review window (${settings.reviewWindowHours}h) expired with no issues reported`,
          status: "completed",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq28(storageBookings.id, checkout.id));
        result.cleared++;
        logger.info(`[StorageCheckout] Auto-cleared booking ${checkout.id} \u2014 review window expired`);
        try {
          await sendCheckoutClearedNotification(checkout.id, checkout.chefId, true);
        } catch (notifyError) {
          logger.error(`[StorageCheckout] Error sending auto-clear notification for booking ${checkout.id}:`, notifyError);
        }
      } catch (bookingError) {
        result.errors++;
        logger.error(`[StorageCheckout] Error auto-clearing booking ${checkout.id}:`, bookingError);
      }
    }
    logger.info(`[StorageCheckout] Auto-clear results: ${result.cleared} cleared, ${result.errors} errors out of ${result.processed} processed`);
    return result;
  } catch (error) {
    logger.error(`[StorageCheckout] Error processing expired checkout reviews:`, error);
    return result;
  }
}
async function getPendingCheckoutReviews(locationId) {
  try {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const { getStorageCheckoutSettings: getStorageCheckoutSettings2 } = await Promise.resolve().then(() => (init_damage_claim_limits_service(), damage_claim_limits_service_exports));
    const settings = await getStorageCheckoutSettings2();
    const reviewWindowMs = settings.reviewWindowHours * 60 * 60 * 1e3;
    const query = db.select({
      storageBookingId: storageBookings.id,
      storageListingId: storageBookings.storageListingId,
      storageName: storageListings.name,
      storageType: storageListings.storageType,
      kitchenId: kitchens.id,
      kitchenName: kitchens.name,
      locationId: locations.id,
      locationName: locations.name,
      chefId: storageBookings.chefId,
      chefEmail: users.username,
      startDate: storageBookings.startDate,
      endDate: storageBookings.endDate,
      totalPrice: storageBookings.totalPrice,
      checkoutStatus: storageBookings.checkoutStatus,
      checkoutRequestedAt: storageBookings.checkoutRequestedAt,
      checkoutNotes: storageBookings.checkoutNotes,
      checkoutPhotoUrls: storageBookings.checkoutPhotoUrls
    }).from(storageBookings).innerJoin(storageListings, eq28(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq28(storageListings.kitchenId, kitchens.id)).innerJoin(locations, eq28(kitchens.locationId, locations.id)).leftJoin(users, eq28(storageBookings.chefId, users.id)).where(eq28(storageBookings.checkoutStatus, "checkout_requested")).orderBy(desc13(storageBookings.checkoutRequestedAt));
    const results = await query;
    const filtered = locationId ? results.filter((r) => r.locationId === locationId) : results;
    const now = /* @__PURE__ */ new Date();
    const stillPending = [];
    for (const r of filtered) {
      const reviewDeadline = r.checkoutRequestedAt ? new Date(r.checkoutRequestedAt.getTime() + reviewWindowMs) : null;
      const isExpired = reviewDeadline ? now > reviewDeadline : false;
      if (isExpired) {
        const wasCleared = await autoCleanExpiredCheckout(
          r.storageBookingId,
          r.chefId,
          r.checkoutRequestedAt,
          settings.reviewWindowHours
        );
        if (wasCleared) {
          logger.info(`[StorageCheckout] Lazy-cleared booking ${r.storageBookingId} during getPendingCheckoutReviews`);
          continue;
        }
      }
      stillPending.push(r);
    }
    return stillPending.map((r) => {
      const endDate = new Date(r.endDate);
      const daysUntilEnd = Math.ceil((endDate.getTime() - today.getTime()) / (1e3 * 60 * 60 * 24));
      const reviewDeadline = r.checkoutRequestedAt ? new Date(r.checkoutRequestedAt.getTime() + reviewWindowMs) : null;
      const isReviewExpired = reviewDeadline ? now > reviewDeadline : false;
      return {
        storageBookingId: r.storageBookingId,
        storageListingId: r.storageListingId,
        storageName: r.storageName || "Storage",
        storageType: r.storageType || "dry",
        kitchenId: r.kitchenId,
        kitchenName: r.kitchenName || "Kitchen",
        locationId: r.locationId,
        locationName: r.locationName || "Location",
        chefId: r.chefId,
        chefEmail: r.chefEmail,
        chefName: r.chefEmail,
        // Using email as name for now
        startDate: r.startDate,
        endDate: r.endDate,
        totalPrice: r.totalPrice,
        checkoutStatus: r.checkoutStatus,
        checkoutRequestedAt: r.checkoutRequestedAt,
        checkoutNotes: r.checkoutNotes,
        checkoutPhotoUrls: r.checkoutPhotoUrls || [],
        daysUntilEnd,
        isOverdue: daysUntilEnd < 0,
        reviewDeadline,
        isReviewExpired
      };
    });
  } catch (error) {
    logger.error(`[StorageCheckout] Error getting pending checkout reviews:`, error);
    return [];
  }
}
async function getCheckoutHistory(locationIds, limit = 20) {
  try {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const results = await db.select({
      storageBookingId: storageBookings.id,
      storageListingId: storageBookings.storageListingId,
      storageName: storageListings.name,
      storageType: storageListings.storageType,
      kitchenId: kitchens.id,
      kitchenName: kitchens.name,
      locationId: locations.id,
      locationName: locations.name,
      chefId: storageBookings.chefId,
      chefEmail: users.username,
      startDate: storageBookings.startDate,
      endDate: storageBookings.endDate,
      totalPrice: storageBookings.totalPrice,
      checkoutStatus: storageBookings.checkoutStatus,
      checkoutRequestedAt: storageBookings.checkoutRequestedAt,
      checkoutApprovedAt: storageBookings.checkoutApprovedAt,
      checkoutNotes: storageBookings.checkoutNotes,
      checkoutPhotoUrls: storageBookings.checkoutPhotoUrls
    }).from(storageBookings).innerJoin(storageListings, eq28(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq28(storageListings.kitchenId, kitchens.id)).innerJoin(locations, eq28(kitchens.locationId, locations.id)).leftJoin(users, eq28(storageBookings.chefId, users.id)).where(
      and16(
        inArray6(locations.id, locationIds),
        or3(
          eq28(storageBookings.checkoutStatus, "completed"),
          eq28(storageBookings.checkoutStatus, "checkout_claim_filed")
        )
      )
    ).orderBy(desc13(storageBookings.checkoutApprovedAt)).limit(limit);
    return results.map((r) => {
      const endDate = new Date(r.endDate);
      const daysUntilEnd = Math.ceil((endDate.getTime() - today.getTime()) / (1e3 * 60 * 60 * 24));
      return {
        storageBookingId: r.storageBookingId,
        storageListingId: r.storageListingId,
        storageName: r.storageName || "Storage",
        storageType: r.storageType || "dry",
        kitchenId: r.kitchenId,
        kitchenName: r.kitchenName || "Kitchen",
        locationId: r.locationId,
        locationName: r.locationName || "Location",
        chefId: r.chefId,
        chefEmail: r.chefEmail,
        chefName: r.chefEmail,
        startDate: r.startDate,
        endDate: r.endDate,
        totalPrice: r.totalPrice,
        checkoutStatus: r.checkoutStatus,
        checkoutRequestedAt: r.checkoutRequestedAt,
        checkoutApprovedAt: r.checkoutApprovedAt,
        checkoutNotes: r.checkoutNotes,
        checkoutPhotoUrls: r.checkoutPhotoUrls || [],
        daysUntilEnd,
        isOverdue: daysUntilEnd < 0,
        reviewDeadline: null,
        isReviewExpired: false
      };
    });
  } catch (error) {
    logger.error(`[StorageCheckout] Error getting checkout history:`, error);
    return [];
  }
}
async function getCheckoutStatus(storageBookingId) {
  try {
    const [booking] = await db.select({
      checkoutStatus: storageBookings.checkoutStatus,
      checkoutRequestedAt: storageBookings.checkoutRequestedAt,
      checkoutApprovedAt: storageBookings.checkoutApprovedAt,
      checkoutPhotoUrls: storageBookings.checkoutPhotoUrls,
      checkoutNotes: storageBookings.checkoutNotes
    }).from(storageBookings).where(eq28(storageBookings.id, storageBookingId)).limit(1);
    if (!booking) {
      return null;
    }
    const { getStorageCheckoutSettings: getStorageCheckoutSettings2 } = await Promise.resolve().then(() => (init_damage_claim_limits_service(), damage_claim_limits_service_exports));
    const settings = await getStorageCheckoutSettings2();
    const now = /* @__PURE__ */ new Date();
    const reviewDeadline = booking.checkoutRequestedAt ? new Date(booking.checkoutRequestedAt.getTime() + settings.reviewWindowHours * 60 * 60 * 1e3) : null;
    const isReviewExpired = reviewDeadline ? now > reviewDeadline : false;
    if (isReviewExpired && booking.checkoutStatus === "checkout_requested") {
      const [bookingFull] = await db.select({ chefId: storageBookings.chefId }).from(storageBookings).where(eq28(storageBookings.id, storageBookingId)).limit(1);
      const wasCleared = await autoCleanExpiredCheckout(
        storageBookingId,
        bookingFull?.chefId ?? null,
        booking.checkoutRequestedAt,
        settings.reviewWindowHours
      );
      if (wasCleared) {
        logger.info(`[StorageCheckout] Lazy-cleared booking ${storageBookingId} during getCheckoutStatus`);
        return {
          checkoutStatus: "completed",
          checkoutRequestedAt: booking.checkoutRequestedAt,
          checkoutApprovedAt: /* @__PURE__ */ new Date(),
          checkoutPhotoUrls: booking.checkoutPhotoUrls || [],
          checkoutNotes: `Auto-cleared by system \u2014 review window (${settings.reviewWindowHours}h) expired with no issues reported`,
          reviewDeadline,
          isReviewExpired: true,
          extendedClaimDeadline: booking.checkoutRequestedAt ? new Date(booking.checkoutRequestedAt.getTime() + settings.extendedClaimWindowHours * 60 * 60 * 1e3) : null,
          canFileExtendedClaim: booking.checkoutRequestedAt ? now <= new Date(booking.checkoutRequestedAt.getTime() + settings.extendedClaimWindowHours * 60 * 60 * 1e3) : false
        };
      }
    }
    const extendedClaimDeadline = booking.checkoutRequestedAt ? new Date(booking.checkoutRequestedAt.getTime() + settings.extendedClaimWindowHours * 60 * 60 * 1e3) : null;
    const canFileExtendedClaim = extendedClaimDeadline ? now <= extendedClaimDeadline : false;
    return {
      checkoutStatus: booking.checkoutStatus,
      checkoutRequestedAt: booking.checkoutRequestedAt,
      checkoutApprovedAt: booking.checkoutApprovedAt,
      checkoutPhotoUrls: booking.checkoutPhotoUrls || [],
      checkoutNotes: booking.checkoutNotes,
      reviewDeadline,
      isReviewExpired,
      extendedClaimDeadline,
      canFileExtendedClaim
    };
  } catch (error) {
    logger.error(`[StorageCheckout] Error getting checkout status:`, error);
    return null;
  }
}
async function isCheckoutInProgress(storageBookingId) {
  try {
    const [booking] = await db.select({ checkoutStatus: storageBookings.checkoutStatus }).from(storageBookings).where(eq28(storageBookings.id, storageBookingId)).limit(1);
    if (!booking) {
      return false;
    }
    const status = booking.checkoutStatus;
    return status === "checkout_requested" || status === "checkout_approved" || status === "completed" || status === "checkout_claim_filed";
  } catch (error) {
    logger.error(`[StorageCheckout] Error checking checkout status:`, error);
    return false;
  }
}
var init_storage_checkout_service = __esm({
  "server/services/storage-checkout-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_logger();
  }
});

// server/date-utils.ts
var date_utils_exports = {};
__export(date_utils_exports, {
  getHoursUntilBooking: () => getHoursUntilBooking,
  isBookingTimePast: () => isBookingTimePast
});
import { isAfter as isAfter2, differenceInHours } from "date-fns";
import { TZDate as TZDate2 } from "@date-fns/tz";
function isBookingTimePast(dateStr, timeStr, timezone = "America/St_Johns") {
  const bookingDateTime = createBookingDateTime2(dateStr, timeStr, timezone);
  const now = new TZDate2(/* @__PURE__ */ new Date(), timezone);
  return isAfter2(now, bookingDateTime);
}
function getHoursUntilBooking(dateStr, timeStr, timezone = "America/St_Johns") {
  const bookingDateTime = createBookingDateTime2(dateStr, timeStr, timezone);
  const now = new TZDate2(/* @__PURE__ */ new Date(), timezone);
  return differenceInHours(bookingDateTime, now);
}
function createBookingDateTime2(dateStr, timeStr, timezone) {
  const [year, month, day] = dateStr.split("-").map(Number);
  const [hours, minutes] = timeStr.split(":").map(Number);
  const tzDate = new TZDate2(year, month - 1, day, hours, minutes, 0, 0, timezone);
  return tzDate;
}
var init_date_utils = __esm({
  "server/date-utils.ts"() {
    "use strict";
  }
});

// server/routes/bookings.ts
var bookings_exports = {};
__export(bookings_exports, {
  default: () => bookings_default,
  syncStorageItemStatusInKitchenBooking: () => syncStorageItemStatusInKitchenBooking
});
import { Router as Router14 } from "express";
import { eq as eq29, and as and17, or as or4, desc as desc14, inArray as inArray7 } from "drizzle-orm";
function getBaseUrl(req) {
  const host = req.get("x-forwarded-host") || req.get("host") || "localhost:5001";
  const isLocalhost = host.includes("localhost") || host.includes("127.0.0.1");
  const protocol = isLocalhost ? "http" : req.get("x-forwarded-proto") || "https";
  return `${protocol}://${host}`;
}
async function sendStorageCancellationNotification(booking, bookingId, action) {
  try {
    const chef = booking.chefId ? await userService.getUser(booking.chefId) : null;
    if (!chef) return;
    const isCancellationRequest = action === "cancellation_requested";
    const storageName = booking.storageName || "Storage";
    if (booking.managerId) {
      const title = isCancellationRequest ? "Storage Cancellation Request" : "Storage Booking Cancelled";
      const message = isCancellationRequest ? `${chef.username || "A chef"} has requested to cancel their storage booking for ${storageName}.` : `${chef.username || "A chef"} has cancelled their storage booking for ${storageName}.`;
      await notificationService.create({
        userId: booking.managerId,
        target: "manager",
        type: isCancellationRequest ? "booking_cancellation_request" : "booking_cancelled",
        title,
        message,
        metadata: { storageBookingId: bookingId, chefId: booking.chefId }
      });
    }
    if (booking.chefId) {
      const title = isCancellationRequest ? "Cancellation Request Submitted" : "Storage Booking Cancelled";
      const message = isCancellationRequest ? `Your cancellation request for ${storageName} has been sent to the kitchen manager for review.` : `Your storage booking for ${storageName} has been cancelled.`;
      await notificationService.create({
        userId: booking.chefId,
        target: "chef",
        type: isCancellationRequest ? "booking_cancellation_request" : "booking_cancelled",
        title,
        message,
        metadata: { storageBookingId: bookingId }
      });
    }
  } catch (error) {
    logger.error(`[sendStorageCancellationNotification] Error for storage booking ${bookingId}:`, error);
  }
}
async function syncStorageItemStatusInKitchenBooking(storageBookingId, newStatus) {
  try {
    const { storageBookings: sbTable, kitchenBookings: kbTable } = await Promise.resolve().then(() => (init_schema(), schema_exports));
    const [sb] = await db.select({ kitchenBookingId: sbTable.kitchenBookingId }).from(sbTable).where(eq29(sbTable.id, storageBookingId)).limit(1);
    if (!sb?.kitchenBookingId) return;
    const [kb] = await db.select({ storageItems: kbTable.storageItems }).from(kbTable).where(eq29(kbTable.id, sb.kitchenBookingId)).limit(1);
    if (!kb) return;
    const items = Array.isArray(kb.storageItems) ? [...kb.storageItems] : [];
    let updated = false;
    for (const item of items) {
      const itemId = item.storageBookingId || item.id;
      if (itemId === storageBookingId) {
        item.cancellationRequested = newStatus === "cancellation_requested";
        item.status = newStatus;
        if (newStatus === "cancelled") {
          item.rejected = true;
        }
        updated = true;
        break;
      }
    }
    if (updated) {
      await db.update(kbTable).set({ storageItems: items, updatedAt: /* @__PURE__ */ new Date() }).where(eq29(kbTable.id, sb.kitchenBookingId));
      logger.info(`[syncStorageItemStatus] Updated JSONB for storage ${storageBookingId} \u2192 ${newStatus} on kb ${sb.kitchenBookingId}`);
    }
  } catch (err) {
    logger.error(`[syncStorageItemStatus] Error syncing storage ${storageBookingId}:`, err);
  }
}
async function processExpiredCancellationRequests() {
  const results = { processed: 0, accepted: 0, errors: 0 };
  try {
    const [setting] = await db.select({ value: platformSettings.value }).from(platformSettings).where(eq29(platformSettings.key, "cancellation_request_auto_accept_hours")).limit(1);
    const autoAcceptHours = setting ? parseInt(setting.value || "24", 10) : 24;
    if (autoAcceptHours <= 0) {
      logger.info("[Cron] Cancellation request auto-accept is disabled (hours=0)");
      return results;
    }
    const cutoffDate = new Date(Date.now() - autoAcceptHours * 60 * 60 * 1e3);
    const { lte: lte5, isNotNull: isNotNull2 } = await import("drizzle-orm");
    const expiredRequests = await db.select({ id: kitchenBookings.id, chefId: kitchenBookings.chefId }).from(kitchenBookings).where(
      and17(
        eq29(kitchenBookings.status, "cancellation_requested"),
        isNotNull2(kitchenBookings.cancellationRequestedAt),
        lte5(kitchenBookings.cancellationRequestedAt, cutoffDate)
      )
    );
    results.processed = expiredRequests.length;
    for (const booking of expiredRequests) {
      try {
        await db.update(kitchenBookings).set({ status: "cancelled", updatedAt: /* @__PURE__ */ new Date() }).where(eq29(kitchenBookings.id, booking.id));
        try {
          const { storageBookings: sbT, equipmentBookings: ebT } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const { ne: neOp } = await import("drizzle-orm");
          await db.update(sbT).set({ status: "cancelled", updatedAt: /* @__PURE__ */ new Date() }).where(and17(eq29(sbT.kitchenBookingId, booking.id), neOp(sbT.status, "cancelled")));
          await db.update(ebT).set({ status: "cancelled", updatedAt: /* @__PURE__ */ new Date() }).where(and17(eq29(ebT.kitchenBookingId, booking.id), neOp(ebT.status, "cancelled")));
        } catch (cascadeErr) {
          logger.warn(`[Cron] Cascade cancel failed for auto-accepted booking ${booking.id}:`, cascadeErr);
        }
        try {
          const [currentKb] = await db.select({ storageItems: kitchenBookings.storageItems, equipmentItems: kitchenBookings.equipmentItems }).from(kitchenBookings).where(eq29(kitchenBookings.id, booking.id));
          if (currentKb) {
            const updatedStorage = (Array.isArray(currentKb.storageItems) ? currentKb.storageItems : []).map((item) => ({ ...item, rejected: true, status: "cancelled", cancellationRequested: false }));
            const updatedEquip = (Array.isArray(currentKb.equipmentItems) ? currentKb.equipmentItems : []).map((item) => ({ ...item, rejected: true }));
            await db.update(kitchenBookings).set({ storageItems: updatedStorage, equipmentItems: updatedEquip, updatedAt: /* @__PURE__ */ new Date() }).where(eq29(kitchenBookings.id, booking.id));
          }
        } catch (jsonbErr) {
          logger.warn(`[Cron] JSONB sync failed for auto-accepted booking ${booking.id}:`, jsonbErr);
        }
        if (booking.chefId) {
          try {
            await notificationService.create({
              userId: booking.chefId,
              target: "chef",
              type: "booking_cancellation_accepted",
              title: "Cancellation Auto-Accepted",
              message: "Your cancellation request was automatically accepted. A refund may be processed by the kitchen manager.",
              metadata: { bookingId: booking.id }
            });
          } catch (notifErr) {
            logger.error(`[Cron] Notification error for auto-accepted booking ${booking.id}:`, notifErr);
          }
        }
        results.accepted++;
        logger.info(`[Cron] Auto-accepted cancellation request for kitchen booking ${booking.id}`);
      } catch (err) {
        results.errors++;
        logger.error(`[Cron] Error auto-accepting cancellation for kitchen booking ${booking.id}:`, err);
      }
    }
    const { storageBookings: storageBookingsTable } = await Promise.resolve().then(() => (init_schema(), schema_exports));
    const expiredStorageRequests = await db.select({ id: storageBookingsTable.id, chefId: storageBookingsTable.chefId }).from(storageBookingsTable).where(
      and17(
        eq29(storageBookingsTable.status, "cancellation_requested"),
        isNotNull2(storageBookingsTable.cancellationRequestedAt),
        lte5(storageBookingsTable.cancellationRequestedAt, cutoffDate)
      )
    );
    results.processed += expiredStorageRequests.length;
    for (const sb of expiredStorageRequests) {
      try {
        await db.update(storageBookingsTable).set({ status: "cancelled", updatedAt: /* @__PURE__ */ new Date() }).where(eq29(storageBookingsTable.id, sb.id));
        try {
          await syncStorageItemStatusInKitchenBooking(sb.id, "cancelled");
        } catch (syncErr) {
          logger.warn(`[Cron] JSONB sync failed for auto-accepted storage booking ${sb.id}:`, syncErr);
        }
        if (sb.chefId) {
          try {
            await notificationService.create({
              userId: sb.chefId,
              target: "chef",
              type: "booking_cancellation_accepted",
              title: "Storage Cancellation Auto-Accepted",
              message: "Your storage cancellation request was automatically accepted. A refund may be processed by the kitchen manager.",
              metadata: { storageBookingId: sb.id }
            });
          } catch (notifErr) {
            logger.error(`[Cron] Notification error for auto-accepted storage booking ${sb.id}:`, notifErr);
          }
        }
        results.accepted++;
        logger.info(`[Cron] Auto-accepted cancellation request for storage booking ${sb.id}`);
      } catch (err) {
        results.errors++;
        logger.error(`[Cron] Error auto-accepting cancellation for storage booking ${sb.id}:`, err);
      }
    }
  } catch (err) {
    logger.error("[Cron] Error in processExpiredCancellationRequests:", err);
    results.errors++;
  }
  return results;
}
async function sendCancellationNotifications(booking, bookingId, action) {
  try {
    const kitchen = await kitchenService.getKitchenById(booking.kitchenId);
    if (!kitchen) return;
    const chef = booking.chefId ? await userService.getUser(booking.chefId) : null;
    if (!chef) return;
    let manager = null;
    if (booking.managerId) {
      const [managerResult] = await db.select({ id: users.id, username: users.username }).from(users).where(eq29(users.id, booking.managerId));
      if (managerResult) manager = managerResult;
    }
    const chefPhone = booking.chefId ? await getChefPhone(booking.chefId, pool) : null;
    const { sendEmail: sendEmail2, generateBookingCancellationEmail: generateBookingCancellationEmail3, generateBookingCancellationNotificationEmail: generateBookingCancellationNotificationEmail3 } = await Promise.resolve().then(() => (init_email(), email_exports));
    const isCancellationRequest = action === "cancellation_requested";
    const cancellationReason = isCancellationRequest ? "You submitted a cancellation request. The kitchen manager will review it shortly." : "You cancelled this booking";
    const managerReason = isCancellationRequest ? "Chef requested cancellation \u2014 please review and process refund" : "Cancelled by chef";
    try {
      const chefEmail = generateBookingCancellationEmail3({
        chefEmail: chef.username || "",
        chefName: chef.username || "Chef",
        kitchenName: kitchen.name || "Kitchen",
        bookingDate: booking.bookingDate?.toISOString() || "",
        startTime: booking.startTime,
        endTime: booking.endTime,
        cancellationReason
      });
      await sendEmail2(chefEmail);
      logger.info(`\u2705 Booking ${action} email sent to chef: ${chef.username}`);
    } catch (e) {
      logger.error("Error sending chef cancellation email:", e);
    }
    if (chefPhone) {
      try {
        const smsMessage = generateChefSelfCancellationSMS({
          kitchenName: kitchen.name || "Kitchen",
          bookingDate: booking.bookingDate?.toISOString() || "",
          startTime: booking.startTime,
          endTime: booking.endTime || ""
        });
        await sendSMS(chefPhone, smsMessage, { trackingId: `booking_${bookingId}_chef_${action}` });
      } catch (e) {
        logger.error("Error sending chef cancellation SMS:", e);
      }
    }
    const notificationEmailAddress = booking.notificationEmail || (manager ? manager.username || null : null);
    if (notificationEmailAddress) {
      try {
        const managerEmail = generateBookingCancellationNotificationEmail3({
          managerEmail: notificationEmailAddress,
          chefName: chef.username || "Chef",
          kitchenName: kitchen.name || "Kitchen",
          bookingDate: booking.bookingDate?.toISOString() || "",
          startTime: booking.startTime,
          endTime: booking.endTime,
          cancellationReason: managerReason
        });
        await sendEmail2(managerEmail);
        logger.info(`\u2705 Booking ${action} notification email sent to manager: ${notificationEmailAddress}`);
      } catch (e) {
        logger.error("Error sending manager cancellation email:", e);
      }
    }
    if (booking.managerId) {
      try {
        const managerPhone = await getManagerPhone({ managerId: booking.managerId, managerPhone: null }, booking.managerId, pool);
        if (managerPhone) {
          const smsMessage = generateManagerBookingCancellationSMS({
            chefName: chef.username || "Chef",
            kitchenName: kitchen.name || "Kitchen",
            bookingDate: booking.bookingDate?.toISOString() || "",
            startTime: booking.startTime,
            endTime: booking.endTime
          });
          await sendSMS(managerPhone, smsMessage, { trackingId: `booking_${bookingId}_manager_${action}` });
        }
      } catch (e) {
        logger.error("Error sending manager cancellation SMS:", e);
      }
    }
    if (isCancellationRequest && booking.managerId) {
      try {
        await notificationService.create({
          userId: booking.managerId,
          target: "manager",
          type: "booking_cancellation_request",
          title: "Cancellation Request",
          message: `${chef.username || "A chef"} has requested to cancel their booking at ${kitchen.name || "your kitchen"}.`,
          metadata: { bookingId, chefId: booking.chefId }
        });
      } catch (e) {
        logger.error("Error creating in-app notification:", e);
      }
    }
  } catch (error) {
    logger.error(`[sendCancellationNotifications] Error for booking ${bookingId}:`, error);
  }
}
var router14, bookings_default;
var init_bookings = __esm({
  "server/routes/bookings.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_logger();
    init_middleware();
    init_firebase_auth_middleware();
    init_stripe_service();
    init_pricing_service();
    init_user_service();
    init_booking_service();
    init_inventory_service();
    init_kitchen_service();
    init_location_service();
    init_chef_service();
    init_phone_utils();
    init_sms();
    init_notification_service();
    init_invoice_service();
    init_overstay_penalty_service();
    init_damage_claim_service();
    init_auth_expiry_service();
    init_schema();
    router14 = Router14();
    router14.post("/bookings/checkout", async (req, res) => {
      try {
        const { bookingId, managerStripeAccountId, bookingPrice, customerEmail } = req.body;
        if (!bookingId || !managerStripeAccountId || !bookingPrice || !customerEmail) {
          return res.status(400).json({
            error: "Missing required fields: bookingId, managerStripeAccountId, bookingPrice, and customerEmail are required"
          });
        }
        const bookingPriceNum = parseFloat(bookingPrice);
        if (isNaN(bookingPriceNum) || bookingPriceNum <= 0) {
          return res.status(400).json({
            error: "bookingPrice must be a positive number"
          });
        }
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(customerEmail)) {
          return res.status(400).json({
            error: "Invalid email format"
          });
        }
        if (!pool) {
          return res.status(500).json({ error: "Database connection not available" });
        }
        const [booking] = await db.select({ id: kitchenBookings.id, kitchenId: kitchenBookings.kitchenId }).from(kitchenBookings).where(eq29(kitchenBookings.id, bookingId)).limit(1);
        if (!booking) {
          return res.status(404).json({ error: "Booking not found" });
        }
        const { calculateCheckoutFeesAsync: calculateCheckoutFeesAsync2 } = await Promise.resolve().then(() => (init_stripe_checkout_fee_service(), stripe_checkout_fee_service_exports));
        const feeCalculation = await calculateCheckoutFeesAsync2(Math.round(bookingPriceNum * 100));
        const baseUrl = getBaseUrl(req);
        const { createCheckoutSession: createCheckoutSession2 } = await Promise.resolve().then(() => (init_stripe_checkout_service(), stripe_checkout_service_exports));
        const checkoutSession = await createCheckoutSession2({
          bookingPriceInCents: feeCalculation.bookingPriceInCents,
          platformFeeInCents: feeCalculation.totalPlatformFeeInCents,
          managerStripeAccountId,
          customerEmail,
          bookingId,
          currency: "cad",
          successUrl: `${baseUrl}/booking-success?session_id={CHECKOUT_SESSION_ID}`,
          cancelUrl: `${baseUrl}/booking-cancel?booking_id=${bookingId}`,
          metadata: {
            booking_id: bookingId.toString(),
            kitchen_id: (booking.kitchenId || "").toString()
          }
        });
        logger.warn(`[DEPRECATED] Legacy /bookings/checkout endpoint used for booking ${bookingId}`);
        res.json({
          sessionUrl: checkoutSession.sessionUrl,
          sessionId: checkoutSession.sessionId,
          booking: {
            price: bookingPriceNum,
            platformFee: feeCalculation.totalPlatformFeeInCents / 100,
            total: feeCalculation.totalChargeInCents / 100
          }
        });
      } catch (error) {
        logger.error("Error creating checkout session:", error);
        res.status(500).json({
          error: error.message || "Failed to create checkout session"
        });
      }
    });
    router14.get("/bookings/by-reference/:code", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        const { code } = req.params;
        if (!code || code.length < 4) {
          return res.status(400).json({ error: "Invalid reference code" });
        }
        const prefix = code.split("-")[0];
        const user = req.neonUser;
        const role = user.role;
        const isAdmin = role === "admin";
        const isManager = role === "manager";
        const { storageBookings: sb, pendingStorageExtensions: pendingStorageExtensions2, storageOverstayRecords: storageOverstayRecords2, damageClaims: damageClaims2, storageListings: sl } = await Promise.resolve().then(() => (init_schema(), schema_exports));
        if (prefix === "KB") {
          let query = db.select({
            id: kitchenBookings.id,
            referenceCode: kitchenBookings.referenceCode,
            status: kitchenBookings.status,
            kitchenId: kitchenBookings.kitchenId
          }).from(kitchenBookings).innerJoin(kitchens, eq29(kitchenBookings.kitchenId, kitchens.id)).innerJoin(locations, eq29(kitchens.locationId, locations.id)).where(
            isAdmin ? eq29(kitchenBookings.referenceCode, code) : isManager ? and17(eq29(kitchenBookings.referenceCode, code), eq29(locations.managerId, user.id)) : and17(eq29(kitchenBookings.referenceCode, code), eq29(kitchenBookings.chefId, user.id))
          ).limit(1);
          const [booking] = await query;
          if (booking) {
            const url = isAdmin ? `/admin?section=transactions&search=${booking.referenceCode}` : isManager ? `/manager/booking/${booking.id}` : `/booking/${booking.id}`;
            return res.json({ type: "kitchen_booking", id: booking.id, referenceCode: booking.referenceCode, url });
          }
        } else if (prefix === "SB") {
          const [booking] = await db.select({
            id: sb.id,
            referenceCode: sb.referenceCode,
            status: sb.status
          }).from(sb).innerJoin(sl, eq29(sb.storageListingId, sl.id)).innerJoin(kitchens, eq29(sl.kitchenId, kitchens.id)).innerJoin(locations, eq29(kitchens.locationId, locations.id)).where(
            isAdmin ? eq29(sb.referenceCode, code) : isManager ? and17(eq29(sb.referenceCode, code), eq29(locations.managerId, user.id)) : and17(eq29(sb.referenceCode, code), eq29(sb.chefId, user.id))
          ).limit(1);
          if (booking) return res.json({ type: "storage_booking", id: booking.id, referenceCode: booking.referenceCode, url: isAdmin ? `/admin?section=transactions&search=${booking.referenceCode}` : `/dashboard` });
        } else if (prefix === "EXT") {
          const [ext] = await db.select({ id: pendingStorageExtensions2.id, referenceCode: pendingStorageExtensions2.referenceCode }).from(pendingStorageExtensions2).innerJoin(sb, eq29(pendingStorageExtensions2.storageBookingId, sb.id)).innerJoin(sl, eq29(sb.storageListingId, sl.id)).innerJoin(kitchens, eq29(sl.kitchenId, kitchens.id)).innerJoin(locations, eq29(kitchens.locationId, locations.id)).where(
            isAdmin ? eq29(pendingStorageExtensions2.referenceCode, code) : isManager ? and17(eq29(pendingStorageExtensions2.referenceCode, code), eq29(locations.managerId, user.id)) : and17(eq29(pendingStorageExtensions2.referenceCode, code), eq29(sb.chefId, user.id))
          ).limit(1);
          if (ext) return res.json({ type: "storage_extension", id: ext.id, referenceCode: ext.referenceCode, url: isAdmin ? `/admin?section=transactions&search=${ext.referenceCode}` : `/dashboard` });
        } else if (prefix === "OP") {
          const [record] = await db.select({ id: storageOverstayRecords2.id, referenceCode: storageOverstayRecords2.referenceCode }).from(storageOverstayRecords2).innerJoin(sb, eq29(storageOverstayRecords2.storageBookingId, sb.id)).innerJoin(sl, eq29(sb.storageListingId, sl.id)).innerJoin(kitchens, eq29(sl.kitchenId, kitchens.id)).innerJoin(locations, eq29(kitchens.locationId, locations.id)).where(
            isAdmin ? eq29(storageOverstayRecords2.referenceCode, code) : isManager ? and17(eq29(storageOverstayRecords2.referenceCode, code), eq29(locations.managerId, user.id)) : and17(eq29(storageOverstayRecords2.referenceCode, code), eq29(sb.chefId, user.id))
          ).limit(1);
          if (record) return res.json({ type: "overstay_penalty", id: record.id, referenceCode: record.referenceCode, url: isAdmin ? `/admin?section=overstay-penalties-history&search=${record.referenceCode}` : `/dashboard` });
        } else if (prefix === "DC") {
          const [claim] = await db.select({ id: damageClaims2.id, referenceCode: damageClaims2.referenceCode }).from(damageClaims2).where(
            isAdmin ? eq29(damageClaims2.referenceCode, code) : isManager ? and17(eq29(damageClaims2.referenceCode, code), eq29(damageClaims2.managerId, user.id)) : and17(eq29(damageClaims2.referenceCode, code), eq29(damageClaims2.chefId, user.id))
          ).limit(1);
          if (claim) return res.json({ type: "damage_claim", id: claim.id, referenceCode: claim.referenceCode, url: isAdmin ? `/admin?section=damage-claims&search=${claim.referenceCode}` : `/dashboard` });
        }
        return res.status(404).json({ error: "Reference not found" });
      } catch (error) {
        logger.error("Error looking up reference code:", error);
        res.status(500).json({ error: "Failed to look up reference" });
      }
    });
    router14.get("/chef/storage-bookings", requireChef, async (req, res) => {
      try {
        const storageBookings2 = await bookingService.getStorageBookingsByChef(req.neonUser.id);
        res.json(storageBookings2);
      } catch (error) {
        logger.error("Error fetching storage bookings:", error);
        res.status(500).json({ error: "Failed to fetch storage bookings" });
      }
    });
    router14.get("/chef/equipment-bookings", requireChef, async (req, res) => {
      try {
        const equipmentBookings2 = await bookingService.getEquipmentBookingsByChef(req.neonUser.id);
        res.json(equipmentBookings2);
      } catch (error) {
        logger.error("Error fetching equipment bookings:", error);
        res.status(500).json({ error: "Failed to fetch equipment bookings" });
      }
    });
    router14.get("/chef/storage-bookings/expiring", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const daysAhead = parseInt(req.query.days) || 3;
        const storageBookings2 = await bookingService.getStorageBookingsByChef(chefId);
        const today = /* @__PURE__ */ new Date();
        today.setHours(0, 0, 0, 0);
        const expiringBookings = storageBookings2.filter((booking) => {
          if (booking.status !== "confirmed") return false;
          const endDate = new Date(booking.endDate);
          endDate.setHours(0, 0, 0, 0);
          const daysUntilExpiry = Math.ceil((endDate.getTime() - today.getTime()) / (1e3 * 60 * 60 * 24));
          return daysUntilExpiry <= daysAhead && daysUntilExpiry >= -7;
        }).map((booking) => {
          const endDate = new Date(booking.endDate);
          endDate.setHours(0, 0, 0, 0);
          const daysUntilExpiry = Math.ceil((endDate.getTime() - today.getTime()) / (1e3 * 60 * 60 * 24));
          return {
            ...booking,
            daysUntilExpiry,
            isExpired: daysUntilExpiry < 0,
            isExpiringSoon: daysUntilExpiry >= 0 && daysUntilExpiry <= 2
          };
        });
        res.json(expiringBookings);
      } catch (error) {
        logger.error("Error fetching expiring storage bookings:", error);
        res.status(500).json({ error: error.message || "Failed to fetch expiring storage bookings" });
      }
    });
    router14.get("/chef/storage-bookings/:id", requireChef, async (req, res) => {
      try {
        const id = parseInt(req.params.id);
        if (isNaN(id) || id <= 0) {
          return res.status(400).json({ error: "Invalid storage booking ID" });
        }
        const booking = await bookingService.getStorageBookingById(id);
        if (!booking) {
          return res.status(404).json({ error: "Storage booking not found" });
        }
        if (booking.chefId !== req.neonUser.id) {
          return res.status(403).json({ error: "You don't have permission to view this booking" });
        }
        res.json(booking);
      } catch (error) {
        logger.error("Error fetching storage booking:", error);
        res.status(500).json({ error: error.message || "Failed to fetch storage booking" });
      }
    });
    router14.put("/chef/storage-bookings/:id/cancel", requireChef, async (req, res) => {
      try {
        const id = parseInt(req.params.id);
        const { reason } = req.body || {};
        if (isNaN(id) || id <= 0) {
          return res.status(400).json({ error: "Invalid storage booking ID" });
        }
        const { storageBookings: storageBookings2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
        const rows = await db.select({
          id: storageBookings2.id,
          status: storageBookings2.status,
          chefId: storageBookings2.chefId,
          storageListingId: storageBookings2.storageListingId,
          paymentStatus: storageBookings2.paymentStatus,
          paymentIntentId: storageBookings2.paymentIntentId,
          startDate: storageBookings2.startDate,
          endDate: storageBookings2.endDate,
          locationId: locations.id,
          locationName: locations.name,
          managerId: locations.managerId,
          notificationEmail: locations.notificationEmail,
          storageName: storageListings.name
        }).from(storageBookings2).innerJoin(storageListings, eq29(storageBookings2.storageListingId, storageListings.id)).innerJoin(kitchens, eq29(storageListings.kitchenId, kitchens.id)).innerJoin(locations, eq29(kitchens.locationId, locations.id)).where(
          and17(
            eq29(storageBookings2.id, id),
            eq29(storageBookings2.chefId, req.neonUser.id)
          )
        ).limit(1);
        if (rows.length === 0) {
          return res.status(404).json({ error: "Storage booking not found" });
        }
        const booking = rows[0];
        if (booking.status === "cancelled") {
          return res.status(400).json({ error: "Storage booking is already cancelled" });
        }
        if (booking.status === "cancellation_requested") {
          return res.status(400).json({ error: "A cancellation request is already pending for this storage booking" });
        }
        if (booking.status === "completed") {
          return res.status(400).json({ error: "Cannot cancel a completed storage booking" });
        }
        if (booking.status === "pending" || booking.paymentStatus === "authorized") {
          if (booking.paymentIntentId && booking.paymentStatus === "authorized") {
            try {
              const { cancelPaymentIntent: cancelPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
              await cancelPaymentIntent2(booking.paymentIntentId);
              logger.info(`[Cancel Storage] Voided authorization for storage booking ${id} (PI: ${booking.paymentIntentId})`);
              await db.update(storageBookings2).set({ paymentStatus: "failed", updatedAt: /* @__PURE__ */ new Date() }).where(eq29(storageBookings2.id, id));
            } catch (voidError) {
              logger.error(`[Cancel Storage] Error voiding auth for storage booking ${id}:`, voidError);
            }
          }
          await db.update(storageBookings2).set({ status: "cancelled", updatedAt: /* @__PURE__ */ new Date() }).where(eq29(storageBookings2.id, id));
          sendStorageCancellationNotification(booking, id, "cancelled").catch(
            (err) => logger.error(`[Cancel Storage] Notification error for storage booking ${id}:`, err)
          );
          return res.json({ success: true, action: "cancelled", message: "Storage booking cancelled successfully." });
        }
        if (booking.status === "confirmed" && (booking.paymentStatus === "paid" || booking.paymentStatus === "partially_refunded")) {
          await db.update(storageBookings2).set({
            status: "cancellation_requested",
            cancellationRequestedAt: /* @__PURE__ */ new Date(),
            cancellationRequestReason: reason || null,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq29(storageBookings2.id, id));
          syncStorageItemStatusInKitchenBooking(id, "cancellation_requested").catch(
            (err) => logger.error(`[Cancel Storage] JSONB sync error for storage booking ${id}:`, err)
          );
          sendStorageCancellationNotification(booking, id, "cancellation_requested").catch(
            (err) => logger.error(`[Cancel Storage] Notification error for storage booking ${id}:`, err)
          );
          return res.json({
            success: true,
            action: "cancellation_requested",
            message: "Your cancellation request has been submitted to the kitchen manager for review."
          });
        }
        await db.update(storageBookings2).set({ status: "cancelled", updatedAt: /* @__PURE__ */ new Date() }).where(eq29(storageBookings2.id, id));
        sendStorageCancellationNotification(booking, id, "cancelled").catch(
          (err) => logger.error(`[Cancel Storage] Notification error for storage booking ${id}:`, err)
        );
        res.json({ success: true, action: "cancelled", message: "Storage booking cancelled." });
      } catch (error) {
        logger.error("Error cancelling storage booking:", error);
        res.status(500).json({ error: error instanceof Error ? error.message : "Failed to cancel storage booking" });
      }
    });
    router14.post("/detect-overstays", async (req, res) => {
      try {
        const cronSecret = process.env.CRON_SECRET;
        const authHeader = req.headers.authorization;
        if (!cronSecret || authHeader !== `Bearer ${cronSecret}`) {
          logger.warn("[Cron] Unauthorized cron job attempt");
          return res.status(401).json({ error: "Unauthorized" });
        }
        logger.info("[Cron] Starting daily scheduled tasks...");
        logger.info("[Cron] Task 1: Detecting overstays...");
        const overstayResults = await overstayPenaltyService.detectOverstays();
        const overstaySummary = {
          total: overstayResults.length,
          inGracePeriod: overstayResults.filter((r) => r.isInGracePeriod).length,
          pendingReview: overstayResults.filter((r) => r.status === "pending_review").length,
          totalCalculatedPenalty: overstayResults.reduce((sum, r) => sum + r.calculatedPenaltyCents, 0)
        };
        logger.info("[Cron] Overstay detection complete:", overstaySummary);
        logger.info("[Cron] Task 2: Processing expired damage claims...");
        const expiredClaimResults = await damageClaimService.processExpiredClaims();
        const claimSummary = {
          total: expiredClaimResults.length,
          autoApproved: expiredClaimResults.filter((r) => r.action === "auto_approved").length
        };
        logger.info("[Cron] Expired claims processing complete:", claimSummary);
        logger.info("[Cron] Task 3: Cancelling expired payment authorizations...");
        const authExpiryResults = await processExpiredAuthorizations();
        const authExpirySummary = {
          total: authExpiryResults.length,
          canceled: authExpiryResults.filter((r) => r.action === "canceled").length,
          errors: authExpiryResults.filter((r) => r.action === "error").length,
          kitchenBookings: authExpiryResults.filter((r) => r.type === "kitchen_booking").length,
          storageExtensions: authExpiryResults.filter((r) => r.type === "storage_extension").length
        };
        logger.info("[Cron] Expired authorizations processing complete:", authExpirySummary);
        logger.info("[Cron] Task 4: Auto-clearing expired storage checkout reviews...");
        const { processExpiredCheckoutReviews: processExpiredCheckoutReviews2 } = await Promise.resolve().then(() => (init_storage_checkout_service(), storage_checkout_service_exports));
        const checkoutAutoClearResults = await processExpiredCheckoutReviews2();
        const checkoutAutoClearSummary = {
          processed: checkoutAutoClearResults.processed,
          cleared: checkoutAutoClearResults.cleared,
          errors: checkoutAutoClearResults.errors
        };
        logger.info("[Cron] Storage checkout auto-clear complete:", checkoutAutoClearSummary);
        logger.info("[Cron] Task 5: Auto-accepting expired cancellation requests...");
        const cancellationAutoAcceptResults = await processExpiredCancellationRequests();
        logger.info("[Cron] Cancellation request auto-accept complete:", cancellationAutoAcceptResults);
        logger.info("[Cron] All daily scheduled tasks complete");
        res.json({
          success: true,
          message: `Daily tasks complete: ${overstayResults.length} overstays detected, ${expiredClaimResults.length} expired claims processed, ${authExpiryResults.length} expired authorizations cancelled, ${checkoutAutoClearResults.cleared} checkout reviews auto-cleared, ${cancellationAutoAcceptResults.accepted} cancellation requests auto-accepted`,
          overstays: {
            summary: overstaySummary,
            results: overstayResults.map((r) => ({
              bookingId: r.bookingId,
              daysOverdue: r.daysOverdue,
              status: r.status,
              calculatedPenaltyCents: r.calculatedPenaltyCents
            }))
          },
          expiredClaims: {
            summary: claimSummary,
            results: expiredClaimResults.map((r) => ({
              claimId: r.claimId,
              action: r.action
            }))
          },
          expiredAuthorizations: {
            summary: authExpirySummary,
            results: authExpiryResults.map((r) => ({
              type: r.type,
              id: r.id,
              action: r.action,
              error: r.error
            }))
          },
          checkoutAutoClear: {
            summary: checkoutAutoClearSummary
          },
          cancellationAutoAccept: {
            summary: cancellationAutoAcceptResults
          }
        });
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Failed to run daily tasks";
        logger.error("[Cron] Error running daily tasks:", error);
        res.status(500).json({ error: errorMessage });
      }
    });
    router14.post("/admin/storage-bookings/process-overstayer-penalties", async (req, res) => {
      try {
        const cronSecret = process.env.CRON_SECRET;
        const authHeader = req.headers.authorization;
        const isAdmin = req.neonUser?.role === "admin";
        if (!isAdmin && (!cronSecret || authHeader !== `Bearer ${cronSecret}`)) {
          return res.status(401).json({ error: "Unauthorized" });
        }
        logger.warn("[DEPRECATED] Old penalty endpoint called - use /detect-overstays instead");
        const results = await overstayPenaltyService.detectOverstays();
        res.json({
          success: true,
          processed: results.length,
          bookings: results,
          message: `Detected ${results.length} overstay situations. Use manager dashboard to approve charges.`,
          deprecationWarning: "This endpoint is deprecated. Use POST /api/detect-overstays instead."
        });
      } catch (error) {
        logger.error("Error processing overstayer penalties:", error);
        res.status(500).json({ error: error.message || "Failed to process overstayer penalties" });
      }
    });
    router14.post("/chef/storage-bookings/:id/extension-preview", requireChef, requireNoUnpaidPenalties, async (req, res) => {
      try {
        const id = parseInt(req.params.id);
        if (isNaN(id) || id <= 0) {
          return res.status(400).json({ error: "Invalid storage booking ID" });
        }
        const { newEndDate } = req.body;
        if (!newEndDate) {
          return res.status(400).json({ error: "newEndDate is required" });
        }
        const booking = await bookingService.getStorageBookingById(id);
        if (!booking) {
          return res.status(404).json({ error: "Storage booking not found" });
        }
        if (booking.chefId !== req.neonUser.id) {
          return res.status(403).json({ error: "You don't have permission to extend this booking" });
        }
        if (booking.status === "pending") {
          return res.status(400).json({ error: "Cannot extend a booking that hasn't been approved yet. Please wait for manager approval." });
        }
        if (booking.status === "cancelled") {
          return res.status(400).json({ error: "Cannot extend a cancelled booking" });
        }
        if (booking.status === "completed") {
          return res.status(400).json({ error: "Cannot extend a completed booking. Storage has already been cleared." });
        }
        {
          const { storageOverstayRecords: storageOverstayRecords2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const [activeOverstay] = await db.select({ id: storageOverstayRecords2.id, status: storageOverstayRecords2.status }).from(storageOverstayRecords2).where(and17(
            eq29(storageOverstayRecords2.storageBookingId, id),
            inArray7(storageOverstayRecords2.status, ["detected", "grace_period", "pending_review", "penalty_approved", "charge_pending", "charge_failed", "escalated"])
          )).limit(1);
          if (activeOverstay) {
            return res.status(400).json({
              error: "Cannot extend this booking. There is an active overstay penalty that must be resolved first.",
              code: "ACTIVE_OVERSTAY",
              overstayStatus: activeOverstay.status
            });
          }
        }
        const newEndDateObj = new Date(newEndDate);
        if (isNaN(newEndDateObj.getTime())) {
          return res.status(400).json({ error: "Invalid date format for newEndDate" });
        }
        const currentEndDate = new Date(booking.endDate);
        if (newEndDateObj <= currentEndDate) {
          return res.status(400).json({ error: "New end date must be after current end date" });
        }
        const extensionDays = Math.ceil((newEndDateObj.getTime() - currentEndDate.getTime()) / (1e3 * 60 * 60 * 24));
        const minDays = booking.minimumBookingDuration || 1;
        if (extensionDays < minDays) {
          return res.status(400).json({
            error: `Extension must be at least ${minDays} day${minDays > 1 ? "s" : ""}`
          });
        }
        const basePricePerDayCents = booking.basePrice ? parseFloat(booking.basePrice.toString()) : 0;
        const basePricePerDayDollars = basePricePerDayCents / 100;
        const extensionBasePriceDollars = basePricePerDayDollars * extensionDays;
        const extensionBasePriceCents = Math.round(basePricePerDayCents * extensionDays);
        const storageListing = await inventoryService.getStorageListingById(booking.storageListingId);
        let taxRatePercent = 0;
        if (storageListing) {
          const kitchen = await kitchenService.getKitchenById(storageListing.kitchenId);
          if (kitchen && kitchen.taxRatePercent) {
            taxRatePercent = parseFloat(String(kitchen.taxRatePercent));
          }
        }
        const extensionTaxCents = Math.round(extensionBasePriceCents * taxRatePercent / 100);
        const extensionTaxDollars = extensionTaxCents / 100;
        const extensionTotalPriceDollars = extensionBasePriceDollars + extensionTaxDollars;
        res.json({
          storageBookingId: id,
          currentEndDate: currentEndDate.toISOString(),
          newEndDate: newEndDateObj.toISOString(),
          extensionDays,
          basePricePerDay: basePricePerDayDollars,
          extensionBasePrice: extensionBasePriceDollars,
          taxRatePercent,
          extensionTax: extensionTaxDollars,
          extensionTotalPrice: extensionTotalPriceDollars,
          currency: "CAD"
        });
      } catch (error) {
        logger.error("Error calculating extension preview:", error);
        res.status(500).json({ error: error.message || "Failed to calculate extension preview" });
      }
    });
    router14.post("/chef/storage-bookings/:id/extension-checkout", requireChef, requireNoUnpaidPenalties, async (req, res) => {
      try {
        const id = parseInt(req.params.id);
        if (isNaN(id) || id <= 0) {
          return res.status(400).json({ error: "Invalid storage booking ID" });
        }
        const { newEndDate } = req.body;
        if (!newEndDate) {
          return res.status(400).json({ error: "newEndDate is required" });
        }
        const booking = await bookingService.getStorageBookingById(id);
        if (!booking) {
          return res.status(404).json({ error: "Storage booking not found" });
        }
        if (booking.chefId !== req.neonUser.id) {
          return res.status(403).json({ error: "You don't have permission to extend this booking" });
        }
        if (booking.status === "pending") {
          return res.status(400).json({ error: "Cannot extend a booking that hasn't been approved yet. Please wait for manager approval." });
        }
        if (booking.status === "cancelled") {
          return res.status(400).json({ error: "Cannot extend a cancelled booking" });
        }
        if (booking.status === "completed") {
          return res.status(400).json({ error: "Cannot extend a completed booking. Storage has already been cleared." });
        }
        {
          const { storageOverstayRecords: storageOverstayRecords2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const [activeOverstay] = await db.select({ id: storageOverstayRecords2.id, status: storageOverstayRecords2.status }).from(storageOverstayRecords2).where(and17(
            eq29(storageOverstayRecords2.storageBookingId, id),
            inArray7(storageOverstayRecords2.status, ["detected", "grace_period", "pending_review", "penalty_approved", "charge_pending", "charge_failed", "escalated"])
          )).limit(1);
          if (activeOverstay) {
            return res.status(400).json({
              error: "Cannot extend this booking. There is an active overstay penalty that must be resolved first.",
              code: "ACTIVE_OVERSTAY",
              overstayStatus: activeOverstay.status
            });
          }
        }
        const newEndDateObj = new Date(newEndDate);
        if (isNaN(newEndDateObj.getTime())) {
          return res.status(400).json({ error: "Invalid date format for newEndDate" });
        }
        const currentEndDate = new Date(booking.endDate);
        if (newEndDateObj <= currentEndDate) {
          return res.status(400).json({ error: "New end date must be after current end date" });
        }
        const extensionDays = Math.ceil((newEndDateObj.getTime() - currentEndDate.getTime()) / (1e3 * 60 * 60 * 24));
        const minDays = booking.minimumBookingDuration || 1;
        if (extensionDays < minDays) {
          return res.status(400).json({
            error: `Extension must be at least ${minDays} day${minDays > 1 ? "s" : ""}`
          });
        }
        const basePricePerDayCents = booking.basePrice ? parseFloat(booking.basePrice.toString()) : 0;
        const extensionBasePriceCents = Math.round(basePricePerDayCents * extensionDays);
        const storageListing = await inventoryService.getStorageListingById(booking.storageListingId);
        if (!storageListing) {
          return res.status(404).json({ error: "Storage listing not found" });
        }
        const kitchen = await kitchenService.getKitchenById(storageListing.kitchenId);
        if (!kitchen) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const taxRatePercent = kitchen.taxRatePercent ? parseFloat(String(kitchen.taxRatePercent)) : 0;
        const extensionTaxCents = Math.round(extensionBasePriceCents * taxRatePercent / 100);
        const totalWithTaxCents = extensionBasePriceCents + extensionTaxCents;
        const { calculateCheckoutFeesAsync: calculateCheckoutFeesAsync2 } = await Promise.resolve().then(() => (init_stripe_checkout_fee_service(), stripe_checkout_fee_service_exports));
        const feeCalculation = await calculateCheckoutFeesAsync2(totalWithTaxCents);
        const location = await locationService.getLocationById(kitchen.locationId);
        if (!location) {
          return res.status(404).json({ error: "Location not found" });
        }
        const manager = await userService.getUser(location.managerId);
        if (!manager) {
          return res.status(404).json({ error: "Manager not found" });
        }
        const managerStripeAccountId = manager.stripeConnectAccountId;
        if (!managerStripeAccountId) {
          return res.status(400).json({
            error: "Manager has not set up Stripe payments. Please contact the kitchen manager."
          });
        }
        const chef = await userService.getUser(req.neonUser.id);
        if (!chef || !chef.username) {
          return res.status(400).json({ error: "Chef email not found" });
        }
        const chefEmail = chef.username;
        const baseUrl = getBaseUrl(req);
        const { createCheckoutSession: createCheckoutSession2 } = await Promise.resolve().then(() => (init_stripe_checkout_service(), stripe_checkout_service_exports));
        const checkoutSession = await createCheckoutSession2({
          bookingPriceInCents: totalWithTaxCents,
          platformFeeInCents: feeCalculation.totalPlatformFeeInCents,
          managerStripeAccountId,
          customerEmail: chefEmail,
          bookingId: id,
          // Using storage booking ID for legacy compatibility
          currency: "cad",
          successUrl: `${baseUrl}/dashboard?storage_extended=true&storage_booking_id=${id}`,
          cancelUrl: `${baseUrl}/dashboard?storage_extension_cancelled=true&storage_booking_id=${id}`,
          lineItemName: "Storage Extension",
          metadata: {
            type: "storage_extension",
            storage_booking_id: id.toString(),
            extension_days: extensionDays.toString(),
            new_end_date: newEndDateObj.toISOString(),
            current_end_date: currentEndDate.toISOString(),
            chef_id: req.neonUser.id.toString(),
            kitchen_id: kitchen.id.toString(),
            location_id: location.id.toString(),
            manager_id: location.managerId.toString(),
            extension_base_price_cents: extensionBasePriceCents.toString(),
            extension_service_fee_cents: feeCalculation.totalPlatformFeeInCents.toString(),
            extension_total_price_cents: totalWithTaxCents.toString(),
            manager_receives_cents: feeCalculation.managerReceivesInCents.toString(),
            tax_cents: extensionTaxCents.toString(),
            tax_rate_percent: taxRatePercent.toString()
          }
        });
        logger.info(`[Storage Extension Checkout] Created pending checkout session ${checkoutSession.sessionId} - extension will be created in webhook`);
        res.json({
          sessionUrl: checkoutSession.sessionUrl,
          sessionId: checkoutSession.sessionId,
          extension: {
            storageBookingId: id,
            extensionDays,
            extensionBasePrice: extensionBasePriceCents / 100,
            taxRatePercent,
            extensionTax: extensionTaxCents / 100,
            extensionTotalPrice: totalWithTaxCents / 100,
            newEndDate: newEndDateObj.toISOString()
          },
          booking: {
            price: extensionBasePriceCents / 100,
            tax: extensionTaxCents / 100,
            total: totalWithTaxCents / 100
          }
        });
      } catch (error) {
        logger.error("Error creating storage extension checkout:", error);
        res.status(500).json({ error: error.message || "Failed to create storage extension checkout" });
      }
    });
    router14.get("/chef/storage-extensions/pending", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const { pendingStorageExtensions: pendingStorageExtensions2, storageBookings: storageBookings2, storageListings: storageListings3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
        const extensions = await db.select({
          id: pendingStorageExtensions2.id,
          storageBookingId: pendingStorageExtensions2.storageBookingId,
          newEndDate: pendingStorageExtensions2.newEndDate,
          extensionDays: pendingStorageExtensions2.extensionDays,
          extensionBasePriceCents: pendingStorageExtensions2.extensionBasePriceCents,
          extensionTotalPriceCents: pendingStorageExtensions2.extensionTotalPriceCents,
          status: pendingStorageExtensions2.status,
          createdAt: pendingStorageExtensions2.createdAt,
          approvedAt: pendingStorageExtensions2.approvedAt,
          rejectedAt: pendingStorageExtensions2.rejectedAt,
          rejectionReason: pendingStorageExtensions2.rejectionReason,
          stripePaymentIntentId: pendingStorageExtensions2.stripePaymentIntentId,
          // Storage booking details
          currentEndDate: storageBookings2.endDate,
          storageName: storageListings3.name,
          storageType: storageListings3.storageType,
          kitchenName: kitchens.name
        }).from(pendingStorageExtensions2).innerJoin(storageBookings2, eq29(pendingStorageExtensions2.storageBookingId, storageBookings2.id)).innerJoin(storageListings3, eq29(storageBookings2.storageListingId, storageListings3.id)).innerJoin(kitchens, eq29(storageListings3.kitchenId, kitchens.id)).where(eq29(storageBookings2.chefId, chefId)).orderBy(desc14(pendingStorageExtensions2.createdAt));
        const { lazyExpireStorageExtensionAuth: lazyExpireStorageExtensionAuth2 } = await Promise.resolve().then(() => (init_auth_expiry_service(), auth_expiry_service_exports));
        for (const ext of extensions) {
          if (ext.status === "authorized") {
            const wasExpired = await lazyExpireStorageExtensionAuth2({
              id: ext.id,
              status: ext.status,
              stripePaymentIntentId: ext.stripePaymentIntentId,
              createdAt: ext.createdAt ? new Date(ext.createdAt) : null,
              storageBookingId: ext.storageBookingId
            });
            if (wasExpired) {
              ext.status = "expired";
            }
          }
        }
        res.json(extensions);
      } catch (error) {
        logger.error("Error fetching chef's pending storage extensions:", error);
        res.status(500).json({ error: error.message || "Failed to fetch pending extensions" });
      }
    });
    router14.post("/storage-extensions/:id/sync", requireChef, async (req, res) => {
      try {
        const extensionId = parseInt(req.params.id);
        const chefId = req.neonUser.id;
        if (isNaN(extensionId) || extensionId <= 0) {
          return res.status(400).json({ error: "Invalid extension ID" });
        }
        const { pendingStorageExtensions: pendingStorageExtensions2, storageBookings: storageBookings2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
        const [extension] = await db.select({
          id: pendingStorageExtensions2.id,
          storageBookingId: pendingStorageExtensions2.storageBookingId,
          stripeSessionId: pendingStorageExtensions2.stripeSessionId,
          status: pendingStorageExtensions2.status,
          chefId: storageBookings2.chefId
        }).from(pendingStorageExtensions2).innerJoin(storageBookings2, eq29(pendingStorageExtensions2.storageBookingId, storageBookings2.id)).where(eq29(pendingStorageExtensions2.id, extensionId)).limit(1);
        if (!extension) {
          return res.status(404).json({ error: "Extension not found" });
        }
        if (extension.chefId !== chefId) {
          return res.status(403).json({ error: "Not authorized" });
        }
        if (extension.status !== "pending") {
          return res.json({
            message: "Extension already processed",
            status: extension.status
          });
        }
        const Stripe7 = (await import("stripe")).default;
        const stripeSecretKey6 = process.env.STRIPE_SECRET_KEY;
        if (!stripeSecretKey6) {
          return res.status(500).json({ error: "Stripe not configured" });
        }
        const stripe6 = new Stripe7(stripeSecretKey6, { apiVersion: "2025-12-15.clover" });
        const session = await stripe6.checkout.sessions.retrieve(extension.stripeSessionId, {
          expand: ["payment_intent"]
        });
        if (session.payment_status === "paid") {
          let paymentIntentId;
          if (typeof session.payment_intent === "object" && session.payment_intent !== null) {
            paymentIntentId = session.payment_intent.id;
          } else if (typeof session.payment_intent === "string") {
            paymentIntentId = session.payment_intent;
          }
          await db.update(pendingStorageExtensions2).set({
            status: "paid",
            stripePaymentIntentId: paymentIntentId,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq29(pendingStorageExtensions2.id, extensionId));
          logger.info(`[Storage Extension Sync] Updated extension ${extensionId} to 'paid' status`);
          return res.json({
            success: true,
            message: "Extension status synced - now awaiting manager approval",
            status: "paid"
          });
        } else if (session.status === "expired") {
          await db.update(pendingStorageExtensions2).set({
            status: "expired",
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq29(pendingStorageExtensions2.id, extensionId));
          return res.json({
            success: true,
            message: "Session expired",
            status: "expired"
          });
        }
        return res.json({
          message: "Payment not yet completed",
          stripeStatus: session.payment_status,
          sessionStatus: session.status
        });
      } catch (error) {
        logger.error("Error syncing storage extension:", error);
        res.status(500).json({ error: error.message || "Failed to sync extension" });
      }
    });
    router14.put("/chef/storage-bookings/:id/extend", requireChef, async (req, res) => {
      try {
        const id = parseInt(req.params.id);
        if (isNaN(id) || id <= 0) {
          return res.status(400).json({ error: "Invalid storage booking ID" });
        }
        const { newEndDate, paymentConfirmed, stripeSessionId } = req.body;
        if (!newEndDate) {
          return res.status(400).json({ error: "newEndDate is required" });
        }
        const booking = await bookingService.getStorageBookingById(id);
        if (!booking) {
          return res.status(404).json({ error: "Storage booking not found" });
        }
        if (booking.chefId !== req.neonUser.id) {
          return res.status(403).json({ error: "You don't have permission to extend this booking" });
        }
        if (booking.status === "cancelled") {
          return res.status(400).json({ error: "Cannot extend a cancelled booking" });
        }
        const newEndDateObj = new Date(newEndDate);
        if (isNaN(newEndDateObj.getTime())) {
          return res.status(400).json({ error: "Invalid date format for newEndDate" });
        }
        if (!paymentConfirmed) {
          return res.status(402).json({
            error: "Payment required",
            message: "Please use the /extension-checkout endpoint to create a payment session",
            checkoutEndpoint: `/api/chef/storage-bookings/${id}/extension-checkout`
          });
        }
        if (stripeSessionId) {
          const pendingExtension = await bookingService.getPendingStorageExtension(id, stripeSessionId);
          if (!pendingExtension || pendingExtension.status !== "completed") {
            return res.status(402).json({
              error: "Payment not completed",
              message: "Payment must be completed before extending the booking"
            });
          }
        }
        const extendedBooking = await bookingService.extendStorageBooking(id, newEndDateObj);
        res.json({
          success: true,
          booking: extendedBooking,
          message: `Storage booking extended successfully to ${newEndDateObj.toLocaleDateString()}`
        });
      } catch (error) {
        logger.error("Error extending storage booking:", error);
        res.status(500).json({ error: error.message || "Failed to extend storage booking" });
      }
    });
    router14.post("/chef/storage-bookings/:id/request-checkout", requireChef, async (req, res) => {
      try {
        const id = parseInt(req.params.id);
        if (isNaN(id) || id <= 0) {
          return res.status(400).json({ error: "Invalid storage booking ID" });
        }
        const { checkoutNotes, checkoutPhotoUrls } = req.body;
        const chefId = req.neonUser.id;
        const { requestStorageCheckout: requestStorageCheckout2 } = await Promise.resolve().then(() => (init_storage_checkout_service(), storage_checkout_service_exports));
        const result = await requestStorageCheckout2(
          id,
          chefId,
          checkoutNotes,
          checkoutPhotoUrls
        );
        if (!result.success) {
          return res.status(400).json({ error: result.error });
        }
        res.json({
          success: true,
          storageBookingId: result.storageBookingId,
          checkoutStatus: result.checkoutStatus,
          message: "Checkout request submitted successfully. The manager will verify and approve your checkout."
        });
      } catch (error) {
        logger.error("Error requesting storage checkout:", error);
        res.status(500).json({ error: error.message || "Failed to request checkout" });
      }
    });
    router14.post("/chef/storage-bookings/:id/checkout-photos", requireChef, async (req, res) => {
      try {
        const id = parseInt(req.params.id);
        if (isNaN(id) || id <= 0) {
          return res.status(400).json({ error: "Invalid storage booking ID" });
        }
        const { photoUrls } = req.body;
        if (!photoUrls || !Array.isArray(photoUrls) || photoUrls.length === 0) {
          return res.status(400).json({ error: "photoUrls array is required" });
        }
        const chefId = req.neonUser.id;
        const { addCheckoutPhotos: addCheckoutPhotos2 } = await Promise.resolve().then(() => (init_storage_checkout_service(), storage_checkout_service_exports));
        const result = await addCheckoutPhotos2(id, chefId, photoUrls);
        if (!result.success) {
          return res.status(400).json({ error: result.error });
        }
        res.json({
          success: true,
          storageBookingId: result.storageBookingId,
          message: "Photos added to checkout request successfully."
        });
      } catch (error) {
        logger.error("Error adding checkout photos:", error);
        res.status(500).json({ error: error.message || "Failed to add checkout photos" });
      }
    });
    router14.get("/chef/storage-bookings/:id/checkout-status", requireChef, async (req, res) => {
      try {
        const id = parseInt(req.params.id);
        if (isNaN(id) || id <= 0) {
          return res.status(400).json({ error: "Invalid storage booking ID" });
        }
        const booking = await bookingService.getStorageBookingById(id);
        if (!booking) {
          return res.status(404).json({ error: "Storage booking not found" });
        }
        if (booking.chefId !== req.neonUser.id) {
          return res.status(403).json({ error: "You don't have permission to view this booking" });
        }
        const { getCheckoutStatus: getCheckoutStatus2 } = await Promise.resolve().then(() => (init_storage_checkout_service(), storage_checkout_service_exports));
        const status = await getCheckoutStatus2(id);
        if (!status) {
          return res.status(404).json({ error: "Checkout status not found" });
        }
        res.json(status);
      } catch (error) {
        logger.error("Error getting checkout status:", error);
        res.status(500).json({ error: error.message || "Failed to get checkout status" });
      }
    });
    router14.get("/chef/bookings/:id", requireChef, async (req, res) => {
      try {
        const id = parseInt(req.params.id);
        if (isNaN(id) || id <= 0) {
          return res.status(400).json({ error: "Invalid booking ID" });
        }
        const booking = await bookingService.getBookingById(id);
        if (!booking) {
          return res.status(404).json({ error: "Booking not found" });
        }
        if (booking.chefId !== req.neonUser.id) {
          return res.status(403).json({ error: "You don't have permission to view this booking" });
        }
        const storageBookings2 = await bookingService.getStorageBookingsByKitchenBooking(id);
        const equipmentBookings2 = await bookingService.getEquipmentBookingsByKitchenBooking(id);
        const kitchen = await kitchenService.getKitchenById(booking.kitchenId);
        res.json({
          ...booking,
          kitchen,
          storageBookings: storageBookings2,
          equipmentBookings: equipmentBookings2
        });
      } catch (error) {
        logger.error("Error fetching booking details:", error);
        res.status(500).json({ error: error.message || "Failed to fetch booking details" });
      }
    });
    router14.get("/chef/bookings/:id/details", requireChef, async (req, res) => {
      try {
        const id = parseInt(req.params.id);
        if (isNaN(id) || id <= 0) {
          return res.status(400).json({ error: "Invalid booking ID" });
        }
        const booking = await bookingService.getBookingById(id);
        if (!booking) {
          return res.status(404).json({ error: "Booking not found" });
        }
        if (booking.chefId !== req.neonUser.id) {
          return res.status(403).json({ error: "You don't have permission to view this booking" });
        }
        const kitchen = await kitchenService.getKitchenById(booking.kitchenId);
        let location = null;
        if (kitchen && kitchen.locationId) {
          const locationId = kitchen.locationId;
          const [locationData] = await db.select({
            id: locations.id,
            name: locations.name,
            address: locations.address,
            timezone: locations.timezone
          }).from(locations).where(eq29(locations.id, locationId)).limit(1);
          if (locationData) {
            location = locationData;
          }
        }
        const storageBookingsRaw = await bookingService.getStorageBookingsByKitchenBooking(id);
        let originalStorageIds = /* @__PURE__ */ new Set();
        const originalStorageDates = {};
        try {
          const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
          const kitchenTransaction = await findPaymentTransactionByIntentId2(booking.paymentIntentId || "", db);
          if (kitchenTransaction?.metadata) {
            const metadata = typeof kitchenTransaction.metadata === "string" ? JSON.parse(kitchenTransaction.metadata) : kitchenTransaction.metadata;
            if (metadata?.storage_items && Array.isArray(metadata.storage_items)) {
              for (const item of metadata.storage_items) {
                if (item.storageBookingId || item.id) {
                  const storageId = item.storageBookingId || item.id;
                  originalStorageIds.add(storageId);
                  const startDate = new Date(item.startDate);
                  const endDate = new Date(item.endDate);
                  const days = Math.max(1, Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24)));
                  originalStorageDates[storageId] = { startDate, endDate, days };
                }
              }
            }
          }
          if (originalStorageIds.size === 0 && booking.storageItems) {
            const storageItems = booking.storageItems;
            if (Array.isArray(storageItems) && storageItems.length > 0) {
              for (const item of storageItems) {
                if (item.id) {
                  originalStorageIds.add(item.id);
                  if (item.startDate && item.endDate) {
                    const startDate = new Date(item.startDate);
                    const endDate = new Date(item.endDate);
                    const days = Math.max(1, Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24)));
                    originalStorageDates[item.id] = { startDate, endDate, days };
                  }
                }
              }
            }
          }
        } catch {
        }
        if (originalStorageIds.size === 0 && storageBookingsRaw.length > 0) {
          originalStorageIds = new Set(storageBookingsRaw.map((sb) => sb.id));
        }
        const originalStorageBookings = storageBookingsRaw.filter((sb) => originalStorageIds.has(sb.id));
        const storageBookingsWithDetails = await Promise.all(
          originalStorageBookings.map(async (sb) => {
            const [listing] = await db.select({
              name: storageListings.name,
              storageType: storageListings.storageType,
              photos: storageListings.photos,
              basePrice: storageListings.basePrice
            }).from(storageListings).where(eq29(storageListings.id, sb.storageListingId)).limit(1);
            const originalDates = originalStorageDates[sb.id];
            let originalPrice = sb.totalPrice;
            let displayStartDate = sb.startDate;
            let displayEndDate = sb.endDate;
            if (originalDates && listing?.basePrice) {
              const dailyRate = parseFloat(listing.basePrice.toString());
              originalPrice = dailyRate * originalDates.days;
              displayStartDate = originalDates.startDate.toISOString();
              displayEndDate = originalDates.endDate.toISOString();
            }
            return {
              ...sb,
              totalPrice: originalPrice,
              startDate: displayStartDate,
              endDate: displayEndDate,
              storageListing: listing || null
            };
          })
        );
        const equipmentBookingsRaw = await bookingService.getEquipmentBookingsByKitchenBooking(id);
        const equipmentBookingsWithDetails = await Promise.all(
          equipmentBookingsRaw.map(async (eb) => {
            const [listing] = await db.select({
              equipmentType: equipmentListings.equipmentType,
              brand: equipmentListings.brand
            }).from(equipmentListings).where(eq29(equipmentListings.id, eb.equipmentListingId)).limit(1);
            return {
              ...eb,
              equipmentListing: listing || null
            };
          })
        );
        let paymentTransaction = null;
        try {
          const [txn] = await db.select({
            amount: paymentTransactions.amount,
            serviceFee: paymentTransactions.serviceFee,
            managerRevenue: paymentTransactions.managerRevenue,
            status: paymentTransactions.status,
            stripeProcessingFee: paymentTransactions.stripeProcessingFee,
            paidAt: paymentTransactions.paidAt,
            refundAmount: paymentTransactions.refundAmount,
            netAmount: paymentTransactions.netAmount,
            refundedAt: paymentTransactions.refundedAt,
            refundReason: paymentTransactions.refundReason
          }).from(paymentTransactions).where(
            and17(
              eq29(paymentTransactions.bookingId, id),
              or4(
                eq29(paymentTransactions.bookingType, "kitchen"),
                eq29(paymentTransactions.bookingType, "bundle")
              )
            )
          ).limit(1);
          if (txn) {
            paymentTransaction = {
              ...txn,
              amount: txn.amount ? parseFloat(txn.amount) : null,
              serviceFee: txn.serviceFee ? parseFloat(txn.serviceFee) : null,
              managerRevenue: txn.managerRevenue ? parseFloat(txn.managerRevenue) : null,
              stripeProcessingFee: txn.stripeProcessingFee ? parseFloat(txn.stripeProcessingFee) : null,
              refundAmount: txn.refundAmount ? parseFloat(txn.refundAmount) : 0,
              netAmount: txn.netAmount ? parseFloat(txn.netAmount) : null,
              refundedAt: txn.refundedAt || null,
              refundReason: txn.refundReason || null
            };
          }
        } catch (err) {
          logger.error("Error fetching payment transaction:", err);
        }
        const hourlyRate = booking.hourlyRate ? parseFloat(booking.hourlyRate.toString()) : 0;
        const durationHours = booking.durationHours ? parseFloat(booking.durationHours.toString()) : 0;
        const calculatedKitchenPrice = Math.round(hourlyRate * durationHours);
        const kitchenOnlyPrice = calculatedKitchenPrice > 0 ? calculatedKitchenPrice : booking.totalPrice || 0;
        res.json({
          ...booking,
          totalPrice: kitchenOnlyPrice,
          // Override with calculated kitchen-only price
          kitchen: kitchen ? {
            id: kitchen.id,
            name: kitchen.name,
            description: kitchen.description,
            photos: kitchen.galleryImages || (kitchen.imageUrl ? [kitchen.imageUrl] : []),
            locationId: kitchen.locationId,
            taxRatePercent: kitchen.taxRatePercent || 0
          } : null,
          location,
          storageBookings: storageBookingsWithDetails,
          equipmentBookings: equipmentBookingsWithDetails,
          paymentTransaction
        });
      } catch (error) {
        logger.error("Error fetching booking details:", error);
        res.status(500).json({ error: error.message || "Failed to fetch booking details" });
      }
    });
    router14.get("/bookings/:id/invoice", requireChef, async (req, res) => {
      try {
        const id = parseInt(req.params.id);
        if (isNaN(id) || id <= 0) {
          return res.status(400).json({ error: "Invalid booking ID" });
        }
        const booking = await bookingService.getBookingById(id);
        if (!booking) {
          return res.status(404).json({ error: "Booking not found" });
        }
        if (booking.chefId !== req.neonUser.id) {
          return res.status(403).json({ error: "You don't have permission to view this invoice" });
        }
        const bookingPaymentStatus = booking.paymentStatus || booking.payment_status;
        if (bookingPaymentStatus === "authorized" || bookingPaymentStatus === "pending") {
          return res.status(400).json({
            error: "Invoice not available yet. Payment must be captured (approved by manager) before an invoice can be generated."
          });
        }
        const chef = await userService.getUser(booking.chefId);
        const kitchen = await kitchenService.getKitchenById(booking.kitchenId);
        const allStorageBookings = await bookingService.getStorageBookingsByKitchenBooking(id);
        const allEquipmentBookings = await bookingService.getEquipmentBookingsByKitchenBooking(id);
        const storageBookings2 = (allStorageBookings || []).filter((sb) => {
          const payStatus = sb.paymentStatus || sb.payment_status;
          const bookingStatus = sb.status;
          return payStatus !== "failed" && bookingStatus !== "cancelled";
        });
        const equipmentBookings2 = (allEquipmentBookings || []).filter((eb) => {
          const payStatus = eb.paymentStatus || eb.payment_status;
          const bookingStatus = eb.status;
          return payStatus !== "failed" && bookingStatus !== "cancelled";
        });
        let location = null;
        if (kitchen && kitchen.locationId) {
          const locationId = kitchen.locationId || kitchen.location_id;
          const [locationData] = await db.select({ id: locations.id, name: locations.name, address: locations.address }).from(locations).where(eq29(locations.id, locationId)).limit(1);
          if (locationData) {
            location = locationData;
          }
        }
        const paymentIntentId = booking.paymentIntentId || booking.payment_intent_id || null;
        const originalStorageDates = {};
        if (paymentIntentId) {
          try {
            const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
            const kitchenTransaction = await findPaymentTransactionByIntentId2(paymentIntentId, db);
            if (kitchenTransaction?.metadata) {
              const metadata = typeof kitchenTransaction.metadata === "string" ? JSON.parse(kitchenTransaction.metadata) : kitchenTransaction.metadata;
              if (metadata?.storage_items) {
                const storageItems = Array.isArray(metadata.storage_items) ? metadata.storage_items : JSON.parse(metadata.storage_items);
                for (const item of storageItems) {
                  if (item.storageListingId || item.id) {
                    const storageId = item.storageBookingId || item.id;
                    const startDate = new Date(item.startDate);
                    const endDate = new Date(item.endDate);
                    const days = Math.max(1, Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24)));
                    originalStorageDates[storageId] = { startDate, endDate, days };
                  }
                }
              }
            }
          } catch {
            logger.info("[Invoice] Could not fetch original storage dates from transaction, using current dates");
          }
        }
        const storageBookingsForInvoice = storageBookings2.map((sb) => {
          const originalDates = originalStorageDates[sb.id];
          if (originalDates) {
            return {
              ...sb,
              startDate: originalDates.startDate,
              endDate: originalDates.endDate,
              // Calculate base price from original days Ã— daily rate
              totalPrice: (sb.listingBasePrice || sb.basePrice || 0) * originalDates.days,
              _originalDays: originalDates.days
            };
          }
          return sb;
        });
        const { generateInvoicePDF: generateInvoicePDF2 } = await Promise.resolve().then(() => (init_invoice_service(), invoice_service_exports));
        const pdfBuffer = await generateInvoicePDF2(
          booking,
          chef,
          kitchen,
          location,
          storageBookingsForInvoice,
          equipmentBookings2,
          paymentIntentId
        );
        res.setHeader("Content-Type", "application/pdf");
        const bookingDate = booking.bookingDate ? new Date(booking.bookingDate).toISOString().split("T")[0] : "unknown";
        res.setHeader("Content-Disposition", `attachment; filename="LocalCooks-Invoice-${id}-${bookingDate}.pdf"`);
        res.setHeader("Content-Length", pdfBuffer.length);
        res.send(pdfBuffer);
      } catch (error) {
        logger.error("Error generating invoice:", error);
        res.status(500).json({ error: error.message || "Failed to generate invoice" });
      }
    });
    router14.get("/chef/invoices/storage/:id", requireChef, async (req, res) => {
      try {
        const id = parseInt(req.params.id);
        if (isNaN(id) || id <= 0) {
          return res.status(400).json({ error: "Invalid storage booking ID" });
        }
        const storageBooking = await bookingService.getStorageBookingById(id);
        if (!storageBooking) {
          return res.status(404).json({ error: "Storage booking not found" });
        }
        if (storageBooking.chefId !== req.neonUser.id) {
          return res.status(403).json({ error: "You don't have permission to view this invoice" });
        }
        const chef = await userService.getUser(storageBooking.chefId);
        let chefFullName = null;
        try {
          const appResult = await pool.query(
            "SELECT full_name FROM applications WHERE user_id = $1 LIMIT 1",
            [storageBooking.chefId]
          );
          if (appResult.rows[0]?.full_name) chefFullName = appResult.rows[0].full_name;
        } catch {
        }
        const kitchen = await kitchenService.getKitchenById(storageBooking.kitchenId);
        let locationName = "";
        let locationAddress = "";
        if (kitchen?.locationId) {
          const [loc] = await db.select({ name: locations.name, address: locations.address }).from(locations).where(eq29(locations.id, kitchen.locationId)).limit(1);
          if (loc) {
            locationName = loc.name || "";
            locationAddress = loc.address || "";
          }
        }
        const kitchenBookingId = storageBooking.kitchenBookingId;
        let transaction = null;
        if (kitchenBookingId) {
          try {
            const { findPaymentTransactionByBooking: findPaymentTransactionByBooking2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
            transaction = await findPaymentTransactionByBooking2(kitchenBookingId, "kitchen", db);
          } catch {
          }
        }
        const dailyRateCents = storageBooking.basePrice || storageBooking.listingBasePrice || 0;
        const startDate = new Date(storageBooking.startDate);
        const endDate = new Date(storageBooking.endDate);
        const days = Math.max(1, Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24)));
        const basePriceCents = dailyRateCents * days;
        const taxRatePercent = kitchen?.taxRatePercent ? Number(kitchen.taxRatePercent) : 0;
        const taxCents = Math.round(basePriceCents * taxRatePercent / 100);
        const totalCents = basePriceCents + taxCents;
        const invoiceTransaction = transaction || {
          amount: totalCents.toString(),
          baseAmount: basePriceCents.toString(),
          paidAt: storageBooking.createdAt,
          createdAt: storageBooking.createdAt
        };
        const storageBookingForInvoice = {
          ...storageBooking,
          kitchenName: kitchen?.name || storageBooking.kitchenName || "Kitchen",
          locationName: locationName || "Location",
          locationAddress,
          taxRatePercent
        };
        const chefForInvoice = {
          ...chef || {},
          full_name: chefFullName || chef?.username || "Chef"
        };
        const { generateStorageInvoicePDF: generateStorageInvoicePDF2 } = await Promise.resolve().then(() => (init_invoice_service(), invoice_service_exports));
        const pdfBuffer = await generateStorageInvoicePDF2(
          invoiceTransaction,
          storageBookingForInvoice,
          chefForInvoice,
          {
            // Pass original booking details (not extension)
            extension_days: days,
            extension_base_price_cents: basePriceCents,
            extension_total_price_cents: totalCents,
            daily_rate_cents: dailyRateCents,
            is_overstay_penalty: false
          },
          { viewer: "chef" }
        );
        res.setHeader("Content-Type", "application/pdf");
        res.setHeader("Content-Disposition", `attachment; filename="LocalCooks-Storage-Invoice-${id}.pdf"`);
        res.setHeader("Content-Length", pdfBuffer.length);
        res.send(pdfBuffer);
      } catch (error) {
        logger.error("Error generating storage invoice:", error);
        res.status(500).json({ error: error.message || "Failed to generate storage invoice" });
      }
    });
    router14.put("/chef/bookings/:id/cancel", requireChef, async (req, res) => {
      try {
        const id = parseInt(req.params.id);
        const { reason } = req.body || {};
        if (!pool) {
          return res.status(500).json({ error: "Database not available" });
        }
        const rows = await db.select({
          id: kitchenBookings.id,
          bookingDate: kitchenBookings.bookingDate,
          startTime: kitchenBookings.startTime,
          endTime: kitchenBookings.endTime,
          status: kitchenBookings.status,
          kitchenId: kitchenBookings.kitchenId,
          chefId: kitchenBookings.chefId,
          paymentIntentId: kitchenBookings.paymentIntentId,
          paymentStatus: kitchenBookings.paymentStatus,
          cancellationPolicyHours: locations.cancellationPolicyHours,
          cancellationPolicyMessage: locations.cancellationPolicyMessage,
          locationId: locations.id,
          locationName: locations.name,
          managerId: locations.managerId,
          notificationEmail: locations.notificationEmail
        }).from(kitchenBookings).innerJoin(kitchens, eq29(kitchenBookings.kitchenId, kitchens.id)).innerJoin(locations, eq29(kitchens.locationId, locations.id)).where(
          and17(
            eq29(kitchenBookings.id, id),
            eq29(kitchenBookings.chefId, req.neonUser.id)
          )
        ).limit(1);
        if (rows.length === 0) {
          return res.status(404).json({ error: "Booking not found" });
        }
        const booking = rows[0];
        if (booking.status === "cancelled") {
          return res.status(400).json({ error: "Booking is already cancelled" });
        }
        if (booking.status === "cancellation_requested") {
          return res.status(400).json({ error: "A cancellation request is already pending for this booking" });
        }
        if (booking.status === "completed") {
          return res.status(400).json({ error: "Cannot cancel a completed booking" });
        }
        const bookingDateTime = /* @__PURE__ */ new Date(`${booking.bookingDate?.toISOString().split("T")[0]}T${booking.startTime}`);
        const now = /* @__PURE__ */ new Date();
        const hoursUntilBooking = (bookingDateTime.getTime() - now.getTime()) / (1e3 * 60 * 60);
        const cancellationHours = booking.cancellationPolicyHours || 24;
        if (hoursUntilBooking < cancellationHours) {
          const policyMessage = (booking.cancellationPolicyMessage || "Bookings cannot be cancelled within {hours} hours of the scheduled time.").replace("{hours}", String(cancellationHours));
          return res.status(400).json({ error: policyMessage });
        }
        if (booking.status === "pending" || booking.paymentStatus === "authorized") {
          if (booking.paymentIntentId && booking.paymentStatus === "authorized") {
            try {
              const { cancelPaymentIntent: cancelPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
              await cancelPaymentIntent2(booking.paymentIntentId);
              logger.info(`[Cancel Booking] Voided authorization for booking ${id} (PI: ${booking.paymentIntentId})`);
              await db.update(kitchenBookings).set({ paymentStatus: "failed", updatedAt: /* @__PURE__ */ new Date() }).where(eq29(kitchenBookings.id, id));
            } catch (voidError) {
              logger.error(`[Cancel Booking] Error voiding auth for booking ${id}:`, voidError);
            }
          }
          await db.update(kitchenBookings).set({ status: "cancelled", updatedAt: /* @__PURE__ */ new Date() }).where(eq29(kitchenBookings.id, id));
          sendCancellationNotifications(booking, id, "cancelled").catch(
            (err) => logger.error(`[Cancel Booking] Notification error for booking ${id}:`, err)
          );
          return res.json({ success: true, action: "cancelled", message: "Booking cancelled successfully." });
        }
        if (booking.status === "confirmed" && (booking.paymentStatus === "paid" || booking.paymentStatus === "partially_refunded")) {
          await db.update(kitchenBookings).set({
            status: "cancellation_requested",
            cancellationRequestedAt: /* @__PURE__ */ new Date(),
            cancellationRequestReason: reason || null,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq29(kitchenBookings.id, id));
          sendCancellationNotifications(booking, id, "cancellation_requested").catch(
            (err) => logger.error(`[Cancel Booking] Notification error for booking ${id}:`, err)
          );
          return res.json({
            success: true,
            action: "cancellation_requested",
            message: "Your cancellation request has been submitted to the kitchen manager for review."
          });
        }
        await db.update(kitchenBookings).set({ status: "cancelled", updatedAt: /* @__PURE__ */ new Date() }).where(eq29(kitchenBookings.id, id));
        sendCancellationNotifications(booking, id, "cancelled").catch(
          (err) => logger.error(`[Cancel Booking] Notification error for booking ${id}:`, err)
        );
        res.json({ success: true, action: "cancelled", message: "Booking cancelled." });
      } catch (error) {
        logger.error("Error cancelling booking:", error);
        res.status(500).json({ error: error instanceof Error ? error.message : "Failed to cancel booking" });
      }
    });
    router14.post("/payments/create-intent", requireChef, async (req, res) => {
      try {
        const { kitchenId, bookingDate, startTime, endTime, selectedStorage, selectedEquipmentIds, expectedAmountCents } = req.body;
        const chefId = req.neonUser.id;
        if (!kitchenId || !bookingDate || !startTime || !endTime) {
          return res.status(400).json({ error: "Missing required booking fields" });
        }
        const kitchenPricing = await calculateKitchenBookingPrice(kitchenId, startTime, endTime);
        let totalPriceCents = kitchenPricing.totalPriceCents;
        if (selectedStorage && Array.isArray(selectedStorage) && selectedStorage.length > 0 && pool) {
          for (const storage of selectedStorage) {
            try {
              const storageListing = await inventoryService.getStorageListingById(storage.storageListingId);
              if (storageListing) {
                const basePriceCents = storageListing.basePrice ? Math.round(parseFloat(String(storageListing.basePrice))) : 0;
                const minDays = storageListing.minimumBookingDuration || 1;
                const startDate = new Date(storage.startDate);
                const endDate = new Date(storage.endDate);
                const days = Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24));
                const effectiveDays = Math.max(days, minDays);
                let storagePrice = basePriceCents * effectiveDays;
                if (storageListing.pricingModel === "hourly") {
                  const durationHours = Math.max(1, Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60)));
                  storagePrice = basePriceCents * durationHours;
                } else if (storageListing.pricingModel === "monthly-flat") {
                  storagePrice = basePriceCents;
                }
                totalPriceCents += storagePrice;
              }
            } catch (error) {
              logger.error("Error calculating storage price:", error);
            }
          }
        }
        if (selectedEquipmentIds && Array.isArray(selectedEquipmentIds) && selectedEquipmentIds.length > 0) {
          for (const equipmentListingId of selectedEquipmentIds) {
            try {
              const equipmentListing = await inventoryService.getEquipmentListingById(equipmentListingId);
              if (equipmentListing && equipmentListing.availabilityType === "included") {
                continue;
              }
              if (equipmentListing) {
                const sessionRateCents = equipmentListing.sessionRate ? Math.round(parseFloat(String(equipmentListing.sessionRate))) : 0;
                const damageDepositCents = equipmentListing.damageDeposit ? Math.round(parseFloat(String(equipmentListing.damageDeposit))) : 0;
                totalPriceCents += sessionRateCents + damageDepositCents;
              }
            } catch (error) {
              logger.error(`Error calculating equipment price for listing ${equipmentListingId}:`, error);
            }
          }
        }
        let managerConnectAccountId;
        let taxRatePercent = 0;
        try {
          const rows = await db.select({
            stripeConnectAccountId: users.stripeConnectAccountId,
            taxRatePercent: kitchens.taxRatePercent
          }).from(kitchens).leftJoin(locations, eq29(kitchens.locationId, locations.id)).leftJoin(users, eq29(locations.managerId, users.id)).where(eq29(kitchens.id, kitchenId)).limit(1);
          if (rows.length > 0) {
            if (rows[0].stripeConnectAccountId) {
              managerConnectAccountId = rows[0].stripeConnectAccountId;
            }
            if (rows[0].taxRatePercent) {
              taxRatePercent = parseFloat(rows[0].taxRatePercent);
            }
          }
        } catch (error) {
          logger.error(`Error fetching kitchen/manager details for payment ${kitchenId}:`, error);
        }
        const taxCents = Math.round(totalPriceCents * taxRatePercent / 100);
        const totalWithTaxCents = totalPriceCents + taxCents;
        const { calculateCheckoutFeesAsync: calculateCheckoutFeesAsync2 } = await Promise.resolve().then(() => (init_stripe_checkout_fee_service(), stripe_checkout_fee_service_exports));
        const feeCalculation = await calculateCheckoutFeesAsync2(totalWithTaxCents);
        const applicationFeeAmountCents = feeCalculation.useStripePlatformPricing ? void 0 : feeCalculation.totalPlatformFeeInCents;
        logger.info(`[Payment] Creating intent: Subtotal=${totalPriceCents}, Tax=${taxCents} (${taxRatePercent}%), Total=${totalWithTaxCents}, Expected=${expectedAmountCents}, PlatformFee=${applicationFeeAmountCents ?? "Stripe Platform Pricing"}, ManagerReceives=${feeCalculation.managerReceivesInCents}, UseStripePricing=${feeCalculation.useStripePlatformPricing}`);
        const metadata = {
          kitchenId: String(kitchenId),
          chefId: String(chefId),
          bookingDate: String(bookingDate),
          startTime: String(startTime),
          endTime: String(endTime),
          hasStorage: selectedStorage && selectedStorage.length > 0 ? "true" : "false",
          hasEquipment: selectedEquipmentIds && selectedEquipmentIds.length > 0 ? "true" : "false",
          taxCents: String(taxCents),
          taxRatePercent: String(taxRatePercent)
        };
        const paymentIntent = await createPaymentIntent({
          amount: totalWithTaxCents,
          currency: kitchenPricing.currency.toLowerCase(),
          chefId,
          kitchenId,
          managerConnectAccountId,
          // Platform fee covers Stripe processing fees + platform commission
          // Deducted from manager's payout, not charged to customer
          applicationFeeAmount: managerConnectAccountId ? applicationFeeAmountCents : void 0,
          enableACSS: false,
          // Disable ACSS - only use card payments with automatic capture
          enableCards: true,
          // Enable card payments only
          metadata: {
            booking_date: bookingDate,
            start_time: startTime,
            end_time: endTime,
            expected_amount: totalWithTaxCents.toString(),
            tax_cents: String(taxCents),
            tax_rate_percent: String(taxRatePercent),
            has_storage: selectedStorage && selectedStorage.length > 0 ? "true" : "false",
            has_equipment: selectedEquipmentIds && selectedEquipmentIds.length > 0 ? "true" : "false",
            kitchen_id: String(kitchenId),
            chef_id: String(chefId)
          }
        });
        res.json({
          clientSecret: paymentIntent.clientSecret || paymentIntent.client_secret,
          paymentIntentId: paymentIntent.id,
          id: paymentIntent.id,
          amount: totalWithTaxCents,
          currency: kitchenPricing.currency.toUpperCase(),
          breakdown: {
            subtotal: totalPriceCents,
            tax: taxCents,
            taxRatePercent,
            total: totalWithTaxCents
          }
        });
      } catch (error) {
        logger.error("Error creating payment intent:", error);
        res.status(500).json({ error: error.message || "Failed to create payment intent" });
      }
    });
    router14.post("/payments/confirm", requireChef, async (req, res) => {
      try {
        const { paymentIntentId, paymentMethodId } = req.body;
        const chefId = req.neonUser.id;
        if (!paymentIntentId || !paymentMethodId) {
          return res.status(400).json({ error: "Missing paymentIntentId or paymentMethodId" });
        }
        const { confirmPaymentIntent: confirmPaymentIntent2, getPaymentIntent: getPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
        const paymentIntent = await getPaymentIntent2(paymentIntentId);
        if (!paymentIntent) {
          return res.status(404).json({ error: "Payment intent not found" });
        }
        const confirmed = await confirmPaymentIntent2(paymentIntentId, paymentMethodId);
        res.json({
          paymentIntentId: confirmed.id,
          status: confirmed.status
        });
      } catch (error) {
        logger.error("Error confirming payment:", error);
        res.status(500).json({
          error: "Failed to confirm payment",
          message: error.message
        });
      }
    });
    router14.get("/payments/intent/:id/status", requireChef, async (req, res) => {
      try {
        const { id } = req.params;
        const chefId = req.neonUser.id;
        const { getPaymentIntent: getPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
        const paymentIntent = await getPaymentIntent2(id);
        if (!paymentIntent) {
          return res.status(404).json({ error: "Payment intent not found" });
        }
        res.json({
          paymentIntentId: paymentIntent.id,
          status: paymentIntent.status
        });
      } catch (error) {
        logger.error("Error getting payment intent status:", error);
        res.status(500).json({
          error: "Failed to get payment intent status",
          message: error.message
        });
      }
    });
    router14.post("/payments/capture", requireChef, async (req, res) => {
      res.status(410).json({
        error: "This endpoint is deprecated. Payments are now automatically captured when confirmed.",
        message: "With automatic capture enabled, payments are processed immediately. No manual capture is needed."
      });
    });
    router14.post("/payments/cancel", requireChef, async (req, res) => {
      try {
        const { paymentIntentId } = req.body;
        const chefId = req.neonUser.id;
        if (!paymentIntentId) {
          return res.status(400).json({ error: "Missing paymentIntentId" });
        }
        const { cancelPaymentIntent: cancelPaymentIntent2, getPaymentIntent: getPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
        const paymentIntent = await getPaymentIntent2(paymentIntentId);
        if (!paymentIntent) {
          return res.status(404).json({ error: "Payment intent not found" });
        }
        const cancellableStatuses = ["requires_payment_method", "requires_capture", "requires_confirmation"];
        if (!cancellableStatuses.includes(paymentIntent.status)) {
          return res.status(400).json({
            error: `Payment intent cannot be cancelled. Current status: ${paymentIntent.status}`
          });
        }
        const canceled = await cancelPaymentIntent2(paymentIntentId);
        res.json({
          success: true,
          paymentIntentId: canceled.id,
          status: canceled.status,
          message: "Payment intent cancelled. Note: For captured payments, use refunds instead."
        });
      } catch (error) {
        logger.error("Error canceling payment intent:", error);
        res.status(500).json({
          error: "Failed to cancel payment intent",
          message: error.message
        });
      }
    });
    router14.post("/chef/bookings/checkout", requireChef, requireNoUnpaidPenalties, async (req, res) => {
      try {
        const { kitchenId, bookingDate, startTime, endTime, selectedSlots, specialNotes, selectedStorage, selectedEquipmentIds } = req.body;
        const chefId = req.neonUser.id;
        if (!kitchenId || !bookingDate || !startTime || !endTime) {
          return res.status(400).json({ error: "Missing required booking fields" });
        }
        const kitchenDetails = await kitchenService.getKitchenById(kitchenId);
        if (!kitchenDetails) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const kitchenLocationId = kitchenDetails.locationId;
        if (!kitchenLocationId) {
          return res.status(400).json({ error: "Kitchen location not found" });
        }
        const applicationStatus = await chefService.getApplicationStatusForBooking(chefId, kitchenLocationId);
        if (!applicationStatus.canBook) {
          return res.status(403).json({
            error: applicationStatus.message,
            hasApplication: applicationStatus.hasApplication,
            applicationStatus: applicationStatus.status
          });
        }
        const bookingDateObj = new Date(bookingDate);
        const availabilityCheck = await bookingService.validateBookingAvailability(
          kitchenId,
          bookingDateObj,
          startTime,
          endTime
        );
        if (!availabilityCheck.valid) {
          return res.status(400).json({ error: availabilityCheck.error || "Booking is not within manager-set available hours" });
        }
        const location = await locationService.getLocationById(kitchenLocationId);
        if (!location) {
          return res.status(404).json({ error: "Location not found" });
        }
        const timezone = location.timezone || "America/St_Johns";
        const minimumBookingWindowHours = location.minimumBookingWindowHours ?? 1;
        const bookingDateStr = typeof bookingDate === "string" ? bookingDate.split("T")[0] : bookingDateObj.toISOString().split("T")[0];
        const { isBookingTimePast: isBookingTimePast2, getHoursUntilBooking: getHoursUntilBooking2 } = await Promise.resolve().then(() => (init_date_utils(), date_utils_exports));
        if (isBookingTimePast2(bookingDateStr, startTime, timezone)) {
          return res.status(400).json({ error: "Cannot book a time slot that has already passed" });
        }
        const hoursUntilBooking = getHoursUntilBooking2(bookingDateStr, startTime, timezone);
        if (hoursUntilBooking < minimumBookingWindowHours) {
          return res.status(400).json({
            error: `Bookings must be made at least ${minimumBookingWindowHours} hour${minimumBookingWindowHours !== 1 ? "s" : ""} in advance`
          });
        }
        const manager = await userService.getUser(location.managerId);
        if (!manager) {
          return res.status(404).json({ error: "Manager not found" });
        }
        const managerStripeAccountId = manager.stripeConnectAccountId;
        if (!managerStripeAccountId) {
          return res.status(400).json({
            error: "Manager has not set up Stripe payments. Please contact the kitchen manager."
          });
        }
        const chef = await userService.getUser(chefId);
        if (!chef || !chef.username) {
          return res.status(400).json({ error: "Chef email not found" });
        }
        const chefEmail = chef.username;
        const minimumBookingHours = kitchenDetails.minimumBookingHours ?? 0;
        if (minimumBookingHours > 0 && selectedSlots && Array.isArray(selectedSlots) && selectedSlots.length > 0 && selectedSlots.length < minimumBookingHours) {
          return res.status(400).json({
            error: `This kitchen requires a minimum of ${minimumBookingHours} hour${minimumBookingHours > 1 ? "s" : ""} per booking. You selected ${selectedSlots.length}.`
          });
        }
        const kitchenPricing = await calculateKitchenBookingPrice(kitchenId, startTime, endTime);
        let totalPriceCents;
        let effectiveDurationHours;
        if (selectedSlots && Array.isArray(selectedSlots) && selectedSlots.length > 0) {
          effectiveDurationHours = Math.max(selectedSlots.length, minimumBookingHours);
          totalPriceCents = Math.round(kitchenPricing.hourlyRateCents * effectiveDurationHours);
          logger.info(`[Checkout] Staggered slots pricing: ${selectedSlots.length} slots, effective ${effectiveDurationHours} hours, $${(totalPriceCents / 100).toFixed(2)}`);
        } else {
          effectiveDurationHours = kitchenPricing.durationHours;
          totalPriceCents = kitchenPricing.totalPriceCents;
        }
        const storageIds = [];
        const storageLineItems = [];
        if (selectedStorage && Array.isArray(selectedStorage) && selectedStorage.length > 0) {
          for (const storage of selectedStorage) {
            try {
              const storageListing = await inventoryService.getStorageListingById(storage.storageListingId);
              if (storageListing) {
                storageIds.push(storage.storageListingId);
                const basePriceCents = storageListing.basePrice ? Math.round(parseFloat(String(storageListing.basePrice))) : 0;
                const minDays = storageListing.minimumBookingDuration || 1;
                const startDate = new Date(storage.startDate);
                const endDate = new Date(storage.endDate);
                const days = Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24));
                const effectiveDays = Math.max(days, minDays);
                let storagePrice = basePriceCents * effectiveDays;
                if (storageListing.pricingModel === "hourly") {
                  const durationHours = Math.max(1, Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60)));
                  storagePrice = basePriceCents * durationHours;
                } else if (storageListing.pricingModel === "monthly-flat") {
                  storagePrice = basePriceCents;
                }
                totalPriceCents += storagePrice;
                storageLineItems.push({
                  name: `Storage: ${storageListing.name || storageListing.storageType || "Storage Unit"}`,
                  priceCents: storagePrice
                });
              }
            } catch (error) {
              logger.error("Error calculating storage price:", error);
            }
          }
        }
        const equipmentLineItems = [];
        if (selectedEquipmentIds && Array.isArray(selectedEquipmentIds) && selectedEquipmentIds.length > 0) {
          for (const equipmentListingId of selectedEquipmentIds) {
            try {
              const equipmentListing = await inventoryService.getEquipmentListingById(equipmentListingId);
              if (equipmentListing && equipmentListing.availabilityType !== "included") {
                const sessionRateCents = equipmentListing.sessionRate ? Math.round(parseFloat(String(equipmentListing.sessionRate))) : 0;
                totalPriceCents += sessionRateCents;
                equipmentLineItems.push({
                  name: `Equipment: ${equipmentListing.brand ? equipmentListing.brand + " " : ""}${equipmentListing.equipmentType || "Equipment"}`,
                  priceCents: sessionRateCents
                });
              }
            } catch (error) {
              logger.error(`Error calculating equipment price for listing ${equipmentListingId}:`, error);
            }
          }
        }
        const taxRatePercent = kitchenDetails.taxRatePercent ? parseFloat(String(kitchenDetails.taxRatePercent)) : 0;
        const taxCents = Math.round(totalPriceCents * taxRatePercent / 100);
        const totalWithTaxCents = totalPriceCents + taxCents;
        const { calculateCheckoutFeesAsync: calculateCheckoutFeesAsync2 } = await Promise.resolve().then(() => (init_stripe_checkout_fee_service(), stripe_checkout_fee_service_exports));
        const feeCalculation = await calculateCheckoutFeesAsync2(totalWithTaxCents);
        const baseUrl = getBaseUrl(req);
        const { createPendingCheckoutSession: createPendingCheckoutSession2 } = await Promise.resolve().then(() => (init_stripe_checkout_service(), stripe_checkout_service_exports));
        const kitchenOnlyPriceCents = Math.round(kitchenPricing.hourlyRateCents * effectiveDurationHours);
        const kitchenLabel = `Kitchen Session (${effectiveDurationHours} hr${effectiveDurationHours !== 1 ? "s" : ""})`;
        const taxLabel = taxRatePercent > 0 ? `Tax (${taxRatePercent}%)` : "Tax";
        const checkoutSession = await createPendingCheckoutSession2({
          bookingPriceInCents: totalWithTaxCents,
          platformFeeInCents: feeCalculation.totalPlatformFeeInCents,
          managerStripeAccountId,
          customerEmail: chefEmail,
          currency: "cad",
          successUrl: `${baseUrl}/payment-success?session_id={CHECKOUT_SESSION_ID}`,
          cancelUrl: `${baseUrl}/dashboard?tab=kitchens`,
          bookingData: {
            kitchenId,
            chefId,
            bookingDate: bookingDateObj.toISOString(),
            startTime,
            endTime,
            selectedSlots: selectedSlots || [],
            specialNotes,
            selectedStorage: selectedStorage || [],
            selectedEquipmentIds: selectedEquipmentIds || [],
            totalPriceCents,
            taxCents,
            hourlyRateCents: kitchenPricing.hourlyRateCents,
            durationHours: effectiveDurationHours
          },
          // Separate line items for Stripe Dashboard & receipt visibility
          lineItemBreakdown: {
            kitchenPriceCents: kitchenOnlyPriceCents,
            kitchenLabel,
            storageItems: storageLineItems,
            equipmentItems: equipmentLineItems,
            taxCents,
            taxLabel
          }
        });
        logger.info(`[Checkout] Created pending checkout session ${checkoutSession.sessionId} - booking will be created in webhook`);
        res.json({
          sessionUrl: checkoutSession.sessionUrl,
          sessionId: checkoutSession.sessionId,
          booking: {
            price: totalWithTaxCents / 100,
            platformFee: feeCalculation.totalPlatformFeeInCents / 100,
            total: feeCalculation.totalChargeInCents / 100
          }
        });
      } catch (error) {
        logger.error("Error creating booking checkout:", error);
        res.status(500).json({ error: error.message || "Failed to create booking checkout" });
      }
    });
    router14.post("/chef/bookings", requireChef, requireNoUnpaidPenalties, async (req, res) => {
      try {
        const { kitchenId, bookingDate, startTime, endTime, selectedSlots, specialNotes, selectedStorageIds, selectedStorage, selectedEquipmentIds, paymentIntentId } = req.body;
        const chefId = req.neonUser.id;
        logger.info(`[Booking Route] Received booking request with selectedEquipmentIds: ${JSON.stringify(selectedEquipmentIds)}`);
        const kitchenDetails = await kitchenService.getKitchenById(kitchenId);
        const kitchenLocationId1 = kitchenDetails.locationId;
        if (!kitchenLocationId1) {
          return res.status(400).json({ error: "Kitchen location not found" });
        }
        const minimumBookingHours = kitchenDetails.minimumBookingHours ?? 0;
        if (minimumBookingHours > 0 && selectedSlots && Array.isArray(selectedSlots) && selectedSlots.length > 0 && selectedSlots.length < minimumBookingHours) {
          return res.status(400).json({
            error: `This kitchen requires a minimum of ${minimumBookingHours} hour${minimumBookingHours > 1 ? "s" : ""} per booking. You selected ${selectedSlots.length}.`
          });
        }
        const applicationStatus = await chefService.getApplicationStatusForBooking(chefId, kitchenLocationId1);
        if (!applicationStatus.canBook) {
          return res.status(403).json({
            error: applicationStatus.message,
            hasApplication: applicationStatus.hasApplication,
            applicationStatus: applicationStatus.status
          });
        }
        const bookingDateObj = new Date(bookingDate);
        const availabilityCheck = await bookingService.validateBookingAvailability(
          kitchenId,
          bookingDateObj,
          startTime,
          endTime
        );
        if (!availabilityCheck.valid) {
          return res.status(400).json({ error: availabilityCheck.error || "Booking is not within manager-set available hours" });
        }
        const kitchenLocationId2 = kitchenDetails.locationId;
        let location = null;
        let timezone = "America/St_Johns";
        let minimumBookingWindowHours = 1;
        if (kitchenLocationId2) {
          location = await locationService.getLocationById(kitchenLocationId2);
          if (location) {
            timezone = location.timezone || "America/St_Johns";
            const minWindow = location.minimumBookingWindowHours ?? location.minimum_booking_window_hours;
            if (minWindow !== null && minWindow !== void 0) {
              minimumBookingWindowHours = Number(minWindow);
              logger.info(`[Booking Window] Using location minimum booking window: ${minimumBookingWindowHours} hours for kitchen ${kitchenId}`);
            } else {
              logger.info(`[Booking Window] Location has no minimum booking window set, using default: 1 hour`);
            }
          }
        }
        const bookingDateStr = typeof bookingDate === "string" ? bookingDate.split("T")[0] : bookingDateObj.toISOString().split("T")[0];
        const { isBookingTimePast: isBookingTimePast2, getHoursUntilBooking: getHoursUntilBooking2 } = await Promise.resolve().then(() => (init_date_utils(), date_utils_exports));
        if (isBookingTimePast2(bookingDateStr, startTime, timezone)) {
          return res.status(400).json({ error: "Cannot book a time slot that has already passed" });
        }
        const hoursUntilBooking = getHoursUntilBooking2(bookingDateStr, startTime, timezone);
        if (hoursUntilBooking < minimumBookingWindowHours) {
          return res.status(400).json({
            error: `Bookings must be made at least ${minimumBookingWindowHours} hour${minimumBookingWindowHours !== 1 ? "s" : ""} in advance`
          });
        }
        let paymentIntentStatus;
        if (paymentIntentId) {
          const { getPaymentIntent: getPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
          const paymentIntent = await getPaymentIntent2(paymentIntentId);
          if (!paymentIntent) {
            return res.status(400).json({ error: "Invalid payment intent" });
          }
          if (paymentIntent.status !== "succeeded" && paymentIntent.status !== "processing") {
            return res.status(400).json({
              error: `Payment not completed. Status: ${paymentIntent.status}`
            });
          }
          paymentIntentStatus = paymentIntent.status;
        }
        const storageIds = selectedStorageIds && selectedStorageIds.length > 0 ? selectedStorageIds : selectedStorage && Array.isArray(selectedStorage) ? selectedStorage.map((s) => s.storageListingId).filter(Boolean) : [];
        logger.info(`[Booking Route] Received booking request with selectedStorage: ${JSON.stringify(selectedStorage)}, extracted storageIds: ${JSON.stringify(storageIds)}`);
        const booking = await bookingService.createKitchenBooking({
          kitchenId,
          chefId,
          bookingDate: bookingDateObj,
          startTime,
          endTime,
          selectedSlots: selectedSlots || [],
          // Pass discrete time slots
          status: "pending",
          // Requires manager approval before confirmation
          paymentStatus: paymentIntentId ? "paid" : "pending",
          paymentIntentId,
          specialNotes,
          selectedStorage: selectedStorage || [],
          // Pass storage with explicit dates
          selectedEquipmentIds: selectedEquipmentIds || []
        });
        if (paymentIntentId) {
          try {
            const { createPaymentTransaction: createPaymentTransaction2, findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
            const existingTransaction = await findPaymentTransactionByIntentId2(paymentIntentId, db);
            if (!existingTransaction) {
              const subtotalCents = booking?.totalPrice != null ? parseInt(String(booking.totalPrice)) : 0;
              const serviceFeeCents = booking?.serviceFee != null ? parseInt(String(booking.serviceFee)) : 0;
              const taxRatePercent = kitchenDetails?.taxRatePercent != null ? Number(kitchenDetails.taxRatePercent) : 0;
              const taxCents = Math.round(subtotalCents * taxRatePercent / 100);
              const totalAmountCents = subtotalCents + taxCents;
              const managerRevenueCents = Math.max(0, subtotalCents - serviceFeeCents);
              const managerId = location?.managerId || location?.manager_id || null;
              const normalizedStatus = paymentIntentStatus === "succeeded" ? "succeeded" : "processing";
              await createPaymentTransaction2({
                bookingId: booking.id,
                bookingType: "kitchen",
                chefId,
                managerId,
                amount: totalAmountCents,
                baseAmount: subtotalCents,
                serviceFee: serviceFeeCents,
                managerRevenue: managerRevenueCents,
                currency: (booking.currency || "CAD").toUpperCase(),
                paymentIntentId,
                status: normalizedStatus,
                stripeStatus: paymentIntentStatus,
                metadata: {
                  createdFrom: "chef_booking",
                  taxRatePercent,
                  taxCents
                }
              }, db);
            }
          } catch (ptError) {
            logger.warn(`[Booking Route] Could not create payment_transactions record for booking ${booking.id}:`, ptError);
          }
        }
        try {
          if (!pool) throw new Error("Database pool not available");
          const kitchen = await kitchenService.getKitchenById(kitchenId);
          const chef = await userService.getUser(chefId);
          if (chef && kitchen) {
            const { sendEmail: sendEmail2, generateBookingRequestEmail: generateBookingRequestEmail3 } = await Promise.resolve().then(() => (init_email(), email_exports));
            const chefEmail = generateBookingRequestEmail3({
              chefEmail: chef.username,
              chefName: chef.username,
              kitchenName: kitchen.name,
              bookingDate: bookingDateObj,
              startTime,
              endTime,
              specialNotes,
              timezone: location?.timezone || "America/St_Johns",
              locationName: location?.name
            });
            await sendEmail2(chefEmail, { trackingId: `booking_${booking.id}_chef` });
          }
        } catch (emailError) {
          logger.error("Error sending booking emails:", emailError);
        }
        res.status(201).json(booking);
      } catch (error) {
        logger.error("Error creating booking:", error);
        res.status(500).json({ error: error.message || "Failed to create booking" });
      }
    });
    router14.get("/chef/bookings/by-session/:sessionId", requireChef, async (req, res) => {
      try {
        const { sessionId } = req.params;
        const chefId = req.neonUser.id;
        logger.info(`[by-session] Request received for session ${sessionId}, chefId=${chefId}`);
        if (!sessionId) {
          return res.status(400).json({ error: "Session ID is required" });
        }
        const stripeSecretKey6 = process.env.STRIPE_SECRET_KEY;
        if (!stripeSecretKey6) {
          return res.status(500).json({ error: "Stripe configuration error" });
        }
        const Stripe7 = (await import("stripe")).default;
        const stripe6 = new Stripe7(stripeSecretKey6, { apiVersion: "2025-12-15.clover" });
        let session;
        try {
          session = await stripe6.checkout.sessions.retrieve(sessionId, {
            expand: ["payment_intent"]
          });
          logger.info(`[by-session] Retrieved Stripe session: payment_status=${session.payment_status}, metadata_type=${session.metadata?.type}`);
        } catch (stripeError) {
          logger.error(`[by-session] Failed to retrieve Stripe session ${sessionId}:`, stripeError.message);
          return res.status(404).json({ error: "Invalid or expired session ID" });
        }
        let paymentIntentId;
        if (typeof session.payment_intent === "object" && session.payment_intent !== null) {
          paymentIntentId = session.payment_intent.id;
        } else if (typeof session.payment_intent === "string") {
          paymentIntentId = session.payment_intent;
        }
        if (!paymentIntentId) {
          return res.status(404).json({ error: "Payment intent not found for session" });
        }
        logger.info(`[by-session] Looking for booking with paymentIntentId=${paymentIntentId}, chefId=${chefId}`);
        const [bookingByIntent] = await db.select().from(kitchenBookings).where(eq29(kitchenBookings.paymentIntentId, paymentIntentId)).limit(1);
        let booking = bookingByIntent;
        if (bookingByIntent) {
          logger.info(`[by-session] Found booking ${bookingByIntent.id} with chef_id=${bookingByIntent.chefId}, requested chefId=${chefId}`);
          if (bookingByIntent.chefId !== chefId) {
            logger.info(`[by-session] Chef mismatch - booking belongs to chef ${bookingByIntent.chefId}, not ${chefId}`);
            return res.status(403).json({ error: "This booking does not belong to you" });
          }
          const [kitchen2] = await db.select({ name: kitchens.name, locationId: kitchens.locationId }).from(kitchens).where(eq29(kitchens.id, bookingByIntent.kitchenId)).limit(1);
          return res.json({
            ...bookingByIntent,
            kitchenName: kitchen2?.name || "Kitchen"
          });
        } else {
          logger.info(`[by-session] No booking found with paymentIntentId=${paymentIntentId}`);
        }
        const piObj = typeof session.payment_intent === "object" ? session.payment_intent : null;
        const fallbackIsManualCapture = piObj?.status === "requires_capture";
        const fallbackPaymentStatus = fallbackIsManualCapture ? "authorized" : "paid";
        if (!booking && (session.payment_status === "paid" || fallbackIsManualCapture) && session.metadata?.type === "kitchen_booking") {
          logger.info(`[Fallback] Webhook may have failed - creating booking from session ${sessionId}`);
          const metadata = session.metadata;
          const kitchenIdFromMeta = parseInt(metadata.kitchen_id);
          const chefIdFromMeta = parseInt(metadata.chef_id);
          if (chefIdFromMeta !== chefId) {
            return res.status(403).json({ error: "Session does not belong to this chef" });
          }
          const bookingDate = new Date(metadata.booking_date);
          const startTime = metadata.start_time;
          const endTime = metadata.end_time;
          const specialNotes = metadata.special_notes || null;
          const selectedSlots = metadata.selected_slots ? JSON.parse(metadata.selected_slots) : [];
          const selectedStorage = metadata.selected_storage ? JSON.parse(metadata.selected_storage) : [];
          const selectedEquipmentIds = metadata.selected_equipment_ids ? JSON.parse(metadata.selected_equipment_ids) : [];
          logger.info(`[Fallback] Creating booking for kitchen ${kitchenIdFromMeta}, chef ${chefIdFromMeta}`);
          const totalPriceCents = parseInt(metadata.total_price_cents || "0");
          const hourlyRateCents = parseInt(metadata.hourly_rate_cents || "0");
          const durationHours = parseFloat(metadata.duration_hours || "1");
          const [directBooking] = await db.insert(kitchenBookings).values({
            kitchenId: kitchenIdFromMeta,
            chefId: chefIdFromMeta,
            bookingDate,
            startTime,
            endTime,
            status: "pending",
            // Awaiting manager approval
            paymentStatus: fallbackPaymentStatus,
            // 'authorized' for manual capture, 'paid' for auto capture
            paymentIntentId,
            specialNotes,
            totalPrice: totalPriceCents.toString(),
            hourlyRate: hourlyRateCents.toString(),
            durationHours: durationHours.toString(),
            serviceFee: parseInt(metadata.platform_fee_cents || "0").toString(),
            currency: "CAD",
            selectedSlots,
            storageItems: [],
            equipmentItems: []
          }).returning();
          if (!directBooking) {
            throw new Error("Failed to create booking");
          }
          const newBooking = directBooking;
          logger.info(`[Fallback] Created booking ${newBooking.id} from session ${sessionId}`);
          try {
            const { createPaymentTransaction: createPaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
            const [kitchen2] = await db.select({ locationId: kitchens.locationId }).from(kitchens).where(eq29(kitchens.id, kitchenIdFromMeta)).limit(1);
            if (kitchen2) {
              const [location] = await db.select({ managerId: locations.managerId }).from(locations).where(eq29(locations.id, kitchen2.locationId)).limit(1);
              if (location && location.managerId) {
                const chargeId = session.payment_intent && typeof session.payment_intent === "object" ? typeof session.payment_intent.latest_charge === "string" ? session.payment_intent.latest_charge : session.payment_intent.latest_charge?.id : void 0;
                await createPaymentTransaction2({
                  bookingId: newBooking.id,
                  bookingType: "kitchen",
                  chefId: chefIdFromMeta,
                  managerId: location.managerId,
                  amount: parseInt(metadata.booking_price_cents || "0"),
                  baseAmount: parseInt(metadata.total_price_cents || "0") + parseInt(metadata.tax_cents || "0"),
                  serviceFee: parseInt(metadata.platform_fee_cents || "0"),
                  managerRevenue: parseInt(metadata.booking_price_cents || "0") - parseInt(metadata.platform_fee_cents || "0"),
                  currency: "CAD",
                  paymentIntentId,
                  status: "succeeded",
                  stripeStatus: "succeeded",
                  metadata: {
                    checkout_session_id: sessionId,
                    booking_id: newBooking.id.toString(),
                    created_via: "fallback_endpoint"
                  }
                }, db);
                logger.info(`[Fallback] Created payment_transactions for booking ${newBooking.id}`);
              }
            }
          } catch (ptError) {
            logger.warn(`[Fallback] Could not create payment_transactions:`, ptError);
          }
          try {
            const [kitchen2] = await db.select({ name: kitchens.name, locationId: kitchens.locationId }).from(kitchens).where(eq29(kitchens.id, kitchenIdFromMeta)).limit(1);
            if (kitchen2) {
              const [location] = await db.select({
                name: locations.name,
                managerId: locations.managerId,
                notificationEmail: locations.notificationEmail,
                timezone: locations.timezone
              }).from(locations).where(eq29(locations.id, kitchen2.locationId)).limit(1);
              if (location && location.managerId) {
                const [chef] = await db.select({ username: users.username }).from(users).where(eq29(users.id, chefIdFromMeta)).limit(1);
                const chefName = chef?.username || "Chef";
                let managerEmailAddress = location.notificationEmail;
                if (!managerEmailAddress) {
                  const [manager] = await db.select({ username: users.username }).from(users).where(eq29(users.id, location.managerId)).limit(1);
                  managerEmailAddress = manager?.username;
                }
                if (managerEmailAddress) {
                  const { sendEmail: sendEmail2, generateBookingNotificationEmail: generateBookingNotificationEmail3 } = await Promise.resolve().then(() => (init_email(), email_exports));
                  const managerEmail = generateBookingNotificationEmail3({
                    managerEmail: managerEmailAddress,
                    chefName,
                    kitchenName: kitchen2.name,
                    bookingDate,
                    startTime,
                    endTime,
                    specialNotes: specialNotes || void 0,
                    timezone: location.timezone || "America/St_Johns",
                    locationName: location.name,
                    bookingId: newBooking.id
                  });
                  await sendEmail2(managerEmail);
                  logger.info(`[Fallback] Sent manager notification for booking ${newBooking.id}`);
                }
                const { notificationService: notificationService2 } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
                await notificationService2.notifyNewBooking({
                  managerId: location.managerId,
                  locationId: kitchen2.locationId,
                  bookingId: newBooking.id,
                  chefName,
                  kitchenName: kitchen2.name,
                  bookingDate: bookingDate.toISOString().split("T")[0],
                  startTime,
                  endTime
                });
              }
            }
          } catch (notifyError) {
            logger.error(`[Fallback] Error sending notifications:`, notifyError);
          }
          [booking] = await db.select().from(kitchenBookings).where(eq29(kitchenBookings.id, newBooking.id)).limit(1);
        }
        if (!booking) {
          logger.error(`[by-session] CRITICAL: No booking created for session ${sessionId}`, {
            paymentStatus: session.payment_status,
            metadataType: session.metadata?.type,
            hasMetadata: !!session.metadata,
            paymentIntentId,
            chefId
          });
          return res.status(404).json({
            error: "Booking not found for this session",
            debug: {
              paymentStatus: session.payment_status,
              metadataType: session.metadata?.type
            }
          });
        }
        const [kitchen] = await db.select({ name: kitchens.name }).from(kitchens).where(eq29(kitchens.id, booking.kitchenId)).limit(1);
        res.json({
          ...booking,
          kitchenName: kitchen?.name || "Kitchen"
        });
      } catch (error) {
        logger.error("Error fetching booking by session:", error);
        res.status(500).json({ error: error.message || "Failed to fetch booking" });
      }
    });
    router14.get("/chef/bookings", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        logger.info(`[CHEF BOOKINGS] Fetching bookings for chef ID: ${chefId}`);
        const bookings = await bookingService.getKitchenBookingsByChef(chefId);
        const { lazyExpireKitchenBookingAuth: lazyExpireKitchenBookingAuth2 } = await Promise.resolve().then(() => (init_auth_expiry_service(), auth_expiry_service_exports));
        for (const b of bookings) {
          if (b.paymentStatus === "authorized" && b.status === "pending") {
            const wasExpired = await lazyExpireKitchenBookingAuth2({
              id: b.id,
              paymentStatus: b.paymentStatus,
              paymentIntentId: b.paymentIntentId ?? null,
              chefId: b.chefId ?? null,
              kitchenId: b.kitchenId,
              createdAt: b.createdAt ? new Date(b.createdAt) : null,
              status: b.status
            });
            if (wasExpired) {
              b.status = "cancelled";
              b.paymentStatus = "failed";
            }
          }
        }
        res.json(bookings);
      } catch (error) {
        logger.error("Error fetching bookings:", error);
        res.status(500).json({ error: "Failed to fetch bookings" });
      }
    });
    router14.get("/chef/outstanding-dues", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const { getChefUnpaidPenalties: getChefUnpaidPenalties2 } = await Promise.resolve().then(() => (init_overstay_penalty_service(), overstay_penalty_service_exports));
        const { getChefUnpaidDamageClaims: getChefUnpaidDamageClaims2 } = await Promise.resolve().then(() => (init_damage_claim_service(), damage_claim_service_exports));
        const [penalties, claims] = await Promise.all([
          getChefUnpaidPenalties2(chefId),
          getChefUnpaidDamageClaims2(chefId)
        ]);
        const overstayItems = penalties.filter((p) => p.requiresImmediatePayment).map((p) => ({
          id: p.overstayId,
          type: "overstay_penalty",
          title: `Overstay Penalty \u2014 ${p.storageName}`,
          description: `${p.daysOverdue} days overdue at ${p.kitchenName}${p.kitchenTaxRatePercent > 0 ? ` (incl. ${p.kitchenTaxRatePercent}% tax)` : ""}`,
          amountCents: p.penaltyTotalCents,
          status: p.status,
          createdAt: p.detectedAt,
          payEndpoint: `/api/chef/overstay-penalties/${p.overstayId}/pay`
        }));
        const claimItems = claims.filter((c) => c.requiresImmediatePayment).map((c) => ({
          id: c.claimId,
          type: "damage_claim",
          title: `Damage Claim \u2014 ${c.claimTitle}`,
          description: c.kitchenName ? `${c.bookingType} booking at ${c.kitchenName}` : `${c.bookingType} booking`,
          amountCents: c.finalAmountCents,
          status: c.status,
          createdAt: c.createdAt,
          payEndpoint: `/api/chef/damage-claims/${c.claimId}/pay`
        }));
        const allItems = [...overstayItems, ...claimItems];
        const totalOwedCents = allItems.reduce((sum, item) => sum + item.amountCents, 0);
        res.json({
          hasOutstandingDues: allItems.length > 0,
          totalCount: allItems.length,
          totalOwedCents,
          items: allItems
        });
      } catch (error) {
        logger.error("Error fetching chef outstanding dues:", error);
        res.status(500).json({ error: "Failed to fetch outstanding dues" });
      }
    });
    router14.get("/chef/overstay-penalties", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const { getChefAllPenalties: getChefAllPenalties2 } = await Promise.resolve().then(() => (init_overstay_penalty_service(), overstay_penalty_service_exports));
        const penalties = await getChefAllPenalties2(chefId);
        res.json(penalties);
      } catch (error) {
        logger.error("Error fetching chef overstay penalties:", error);
        res.status(500).json({ error: "Failed to fetch overstay penalties" });
      }
    });
    router14.post("/chef/overstay-penalties/:id/pay", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const overstayRecordId = parseInt(req.params.id);
        if (isNaN(overstayRecordId)) {
          return res.status(400).json({ error: "Invalid overstay record ID" });
        }
        const host = req.get("x-forwarded-host") || req.get("host") || "localhost:5001";
        const isLocalhost = host.includes("localhost") || host.includes("127.0.0.1");
        const protocol = isLocalhost ? "http" : req.get("x-forwarded-proto") || "https";
        const baseUrl = `${protocol}://${host}`;
        const successUrl = `${baseUrl}/dashboard?penalty_paid=success&overstay_id=${overstayRecordId}`;
        const cancelUrl = `${baseUrl}/dashboard?penalty_paid=cancelled&overstay_id=${overstayRecordId}`;
        const { createPenaltyPaymentCheckout: createPenaltyPaymentCheckout2 } = await Promise.resolve().then(() => (init_overstay_penalty_service(), overstay_penalty_service_exports));
        const result = await createPenaltyPaymentCheckout2(overstayRecordId, chefId, successUrl, cancelUrl);
        if ("error" in result) {
          return res.status(400).json({ error: result.error });
        }
        res.json({ checkoutUrl: result.checkoutUrl });
      } catch (error) {
        logger.error("Error creating penalty payment checkout:", error);
        res.status(500).json({ error: "Failed to create payment session" });
      }
    });
    router14.get("/chef/damage-claims", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const claims = await damageClaimService.getChefPendingClaims(chefId);
        res.json({ claims });
      } catch (error) {
        logger.error("Error fetching chef damage claims:", error);
        res.status(500).json({ error: "Failed to fetch damage claims" });
      }
    });
    router14.post("/chef/damage-claims/:id/pay", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const claimId = parseInt(req.params.id);
        if (isNaN(claimId)) {
          return res.status(400).json({ error: "Invalid claim ID" });
        }
        const host = req.get("x-forwarded-host") || req.get("host") || "localhost:5001";
        const isLocalhost = host.includes("localhost") || host.includes("127.0.0.1");
        const protocol = isLocalhost ? "http" : req.get("x-forwarded-proto") || "https";
        const baseUrl = `${protocol}://${host}`;
        const successUrl = `${baseUrl}/dashboard?claim_paid=success&claim_id=${claimId}`;
        const cancelUrl = `${baseUrl}/dashboard?claim_paid=cancelled&claim_id=${claimId}`;
        const { createDamageClaimPaymentCheckout: createDamageClaimPaymentCheckout2 } = await Promise.resolve().then(() => (init_damage_claim_service(), damage_claim_service_exports));
        const result = await createDamageClaimPaymentCheckout2(claimId, chefId, successUrl, cancelUrl);
        if ("error" in result) {
          return res.status(400).json({ error: result.error });
        }
        res.json({ checkoutUrl: result.checkoutUrl });
      } catch (error) {
        logger.error("Error creating damage claim payment checkout:", error);
        res.status(500).json({ error: "Failed to create payment session" });
      }
    });
    router14.get("/chef/damage-claims/:id/invoice", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const claimId = parseInt(req.params.id);
        if (isNaN(claimId)) {
          return res.status(400).json({ error: "Invalid claim ID" });
        }
        const claim = await damageClaimService.getClaimById(claimId);
        if (!claim) {
          return res.status(404).json({ error: "Claim not found" });
        }
        if (claim.chefId !== chefId) {
          return res.status(403).json({ error: "Not authorized to view this claim" });
        }
        if (claim.status !== "charge_succeeded") {
          return res.status(400).json({ error: "Invoice only available for charged claims" });
        }
        const pdfBuffer = await generateDamageClaimInvoicePDF(claim);
        res.setHeader("Content-Type", "application/pdf");
        res.setHeader("Content-Disposition", `attachment; filename="damage-claim-invoice-${claimId}.pdf"`);
        res.send(pdfBuffer);
      } catch (error) {
        logger.error("Error downloading damage claim invoice:", error);
        res.status(500).json({ error: "Failed to download invoice" });
      }
    });
    router14.get("/chef/damage-claims/:id", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const claimId = parseInt(req.params.id);
        if (isNaN(claimId)) {
          return res.status(400).json({ error: "Invalid claim ID" });
        }
        const claim = await damageClaimService.getClaimById(claimId);
        if (!claim) {
          return res.status(404).json({ error: "Claim not found" });
        }
        if (claim.chefId !== chefId) {
          return res.status(403).json({ error: "Not authorized to view this claim" });
        }
        const history = await damageClaimService.getClaimHistory(claimId);
        res.json({ claim, history });
      } catch (error) {
        logger.error("Error fetching damage claim:", error);
        res.status(500).json({ error: "Failed to fetch damage claim" });
      }
    });
    router14.post("/chef/damage-claims/:id/respond", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const claimId = parseInt(req.params.id);
        const { action, response } = req.body;
        if (isNaN(claimId)) {
          return res.status(400).json({ error: "Invalid claim ID" });
        }
        if (!action || !["accept", "dispute"].includes(action)) {
          return res.status(400).json({ error: "Action must be 'accept' or 'dispute'" });
        }
        if (!response || response.length < 10) {
          return res.status(400).json({ error: "Response must be at least 10 characters" });
        }
        const result = await damageClaimService.chefRespondToClaim(claimId, chefId, {
          action,
          response
        });
        if (!result.success) {
          return res.status(400).json({ error: result.error });
        }
        res.json({
          success: true,
          message: action === "accept" ? "You have accepted responsibility for this claim" : "Your dispute has been submitted for admin review"
        });
      } catch (error) {
        logger.error("Error responding to damage claim:", error);
        res.status(500).json({ error: "Failed to respond to damage claim" });
      }
    });
    bookings_default = router14;
  }
});

// server/services/payment-transactions-backfill.ts
var payment_transactions_backfill_exports = {};
__export(payment_transactions_backfill_exports, {
  backfillPaymentTransactionsFromBookings: () => backfillPaymentTransactionsFromBookings
});
import { sql as sql14 } from "drizzle-orm";
async function backfillPaymentTransactionsFromBookings(managerId, db2, options) {
  const limit = options?.limit || 100;
  const result = {
    created: 0,
    skipped: 0,
    errors: []
  };
  try {
    const kitchenBookingsResult = await db2.execute(sql14`
      SELECT 
        kb.id,
        kb.chef_id,
        kb.total_price,
        kb.service_fee,
        kb.payment_intent_id,
        kb.payment_status,
        kb.currency,
        l.manager_id,
        k.tax_rate_percent
      FROM kitchen_bookings kb
      JOIN kitchens k ON kb.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      LEFT JOIN payment_transactions pt ON pt.booking_id = kb.id AND pt.booking_type = 'kitchen'
      WHERE l.manager_id = ${managerId}
        AND kb.payment_status IN ('paid', 'processing')
        AND kb.payment_intent_id IS NOT NULL
        AND pt.id IS NULL
      ORDER BY kb.created_at DESC
      LIMIT ${limit}
    `);
    logger.info(`[Backfill] Found ${kitchenBookingsResult.rows.length} kitchen bookings to backfill`);
    for (const booking of kitchenBookingsResult.rows) {
      try {
        const totalPrice = parseInt(booking.total_price || "0");
        const serviceFee = parseInt(booking.service_fee || "0");
        const baseAmount = totalPrice - serviceFee;
        const managerRevenue = baseAmount;
        await createPaymentTransaction({
          bookingId: booking.id,
          bookingType: "kitchen",
          chefId: booking.chef_id,
          managerId: booking.manager_id,
          amount: totalPrice,
          baseAmount,
          serviceFee,
          managerRevenue,
          currency: booking.currency || "CAD",
          paymentIntentId: booking.payment_intent_id,
          status: booking.payment_status === "paid" ? "succeeded" : "processing",
          metadata: {
            backfilled: true,
            backfilledAt: (/* @__PURE__ */ new Date()).toISOString(),
            taxRatePercent: booking.tax_rate_percent
          }
        }, db2);
        result.created++;
      } catch (error) {
        logger.error(`[Backfill] Error creating payment_transaction for kitchen booking ${booking.id}:`, error);
        result.errors.push({
          bookingId: booking.id,
          bookingType: "kitchen",
          error: error.message || "Unknown error"
        });
      }
    }
    const storageBookingsResult = await db2.execute(sql14`
      SELECT 
        sb.id,
        sb.chef_id,
        sb.total_price,
        sb.service_fee,
        sb.payment_intent_id,
        sb.payment_status,
        sb.currency,
        l.manager_id
      FROM storage_bookings sb
      JOIN storage_listings sl ON sb.storage_listing_id = sl.id
      JOIN kitchens k ON sl.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      LEFT JOIN payment_transactions pt ON pt.booking_id = sb.id AND pt.booking_type = 'storage'
      WHERE l.manager_id = ${managerId}
        AND sb.payment_status IN ('paid', 'processing')
        AND sb.payment_intent_id IS NOT NULL
        AND pt.id IS NULL
      ORDER BY sb.created_at DESC
      LIMIT ${limit}
    `);
    logger.info(`[Backfill] Found ${storageBookingsResult.rows.length} storage bookings to backfill`);
    for (const booking of storageBookingsResult.rows) {
      try {
        const totalPrice = parseInt(booking.total_price || "0");
        const serviceFee = parseInt(booking.service_fee || "0");
        const baseAmount = totalPrice - serviceFee;
        const managerRevenue = baseAmount;
        await createPaymentTransaction({
          bookingId: booking.id,
          bookingType: "storage",
          chefId: booking.chef_id,
          managerId: booking.manager_id,
          amount: totalPrice,
          baseAmount,
          serviceFee,
          managerRevenue,
          currency: booking.currency || "CAD",
          paymentIntentId: booking.payment_intent_id,
          status: booking.payment_status === "paid" ? "succeeded" : "processing",
          metadata: {
            backfilled: true,
            backfilledAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        }, db2);
        result.created++;
      } catch (error) {
        logger.error(`[Backfill] Error creating payment_transaction for storage booking ${booking.id}:`, error);
        result.errors.push({
          bookingId: booking.id,
          bookingType: "storage",
          error: error.message || "Unknown error"
        });
      }
    }
    const equipmentBookingsResult = await db2.execute(sql14`
      SELECT 
        eb.id,
        eb.chef_id,
        eb.total_price,
        eb.service_fee,
        eb.payment_intent_id,
        eb.payment_status,
        eb.currency,
        l.manager_id
      FROM equipment_bookings eb
      JOIN equipment_listings el ON eb.equipment_listing_id = el.id
      JOIN kitchens k ON el.kitchen_id = k.id
      JOIN locations l ON k.location_id = l.id
      LEFT JOIN payment_transactions pt ON pt.booking_id = eb.id AND pt.booking_type = 'equipment'
      WHERE l.manager_id = ${managerId}
        AND eb.payment_status IN ('paid', 'processing')
        AND eb.payment_intent_id IS NOT NULL
        AND pt.id IS NULL
      ORDER BY eb.created_at DESC
      LIMIT ${limit}
    `);
    logger.info(`[Backfill] Found ${equipmentBookingsResult.rows.length} equipment bookings to backfill`);
    for (const booking of equipmentBookingsResult.rows) {
      try {
        const totalPrice = parseInt(booking.total_price || "0");
        const serviceFee = parseInt(booking.service_fee || "0");
        const baseAmount = totalPrice - serviceFee;
        const managerRevenue = baseAmount;
        await createPaymentTransaction({
          bookingId: booking.id,
          bookingType: "equipment",
          chefId: booking.chef_id,
          managerId: booking.manager_id,
          amount: totalPrice,
          baseAmount,
          serviceFee,
          managerRevenue,
          currency: booking.currency || "CAD",
          paymentIntentId: booking.payment_intent_id,
          status: booking.payment_status === "paid" ? "succeeded" : "processing",
          metadata: {
            backfilled: true,
            backfilledAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        }, db2);
        result.created++;
      } catch (error) {
        logger.error(`[Backfill] Error creating payment_transaction for equipment booking ${booking.id}:`, error);
        result.errors.push({
          bookingId: booking.id,
          bookingType: "equipment",
          error: error.message || "Unknown error"
        });
      }
    }
    logger.info(`[Backfill] Complete: ${result.created} created, ${result.errors.length} errors`);
    return result;
  } catch (error) {
    logger.error("[Backfill] Error backfilling payment transactions:", error);
    throw error;
  }
}
var init_payment_transactions_backfill = __esm({
  "server/services/payment-transactions-backfill.ts"() {
    "use strict";
    init_logger();
    init_payment_transactions_service();
  }
});

// server/services/payout-statement-service.ts
var payout_statement_service_exports = {};
__export(payout_statement_service_exports, {
  generatePayoutStatementPDF: () => generatePayoutStatementPDF
});
import PDFDocument2 from "pdfkit";
async function generatePayoutStatementPDF(managerId, managerName, managerEmail, payout, balanceTransactions, bookings) {
  let totalEarnings = 0;
  let totalPlatformFees = 0;
  const totalBookings = bookings.length;
  let serviceFeeRate = 0.05;
  try {
    const { getServiceFeeRate: getServiceFeeRate2 } = await Promise.resolve().then(() => (init_pricing_service(), pricing_service_exports));
    serviceFeeRate = await getServiceFeeRate2();
  } catch (error) {
    logger.error("Error getting service fee rate for payout statement:", error);
  }
  bookings.forEach((booking) => {
    const totalPrice = (booking.totalPrice || booking.total_price || 0) / 100;
    const serviceFee = (booking.serviceFee || booking.service_fee || 0) / 100;
    const managerRevenue = totalPrice * (1 - serviceFeeRate);
    totalEarnings += managerRevenue;
    totalPlatformFees += serviceFee;
  });
  const payoutAmount = payout.amount / 100;
  const payoutDate = new Date(payout.created * 1e3);
  const payoutStatus = payout.status;
  const periodStart = bookings.length > 0 ? new Date(Math.min(...bookings.map((b) => new Date(b.booking_date || b.created_at).getTime()))) : payoutDate;
  const periodEnd = payoutDate;
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument2({
        margin: 50,
        size: "LETTER"
      });
      const buffers = [];
      doc.on("data", buffers.push.bind(buffers));
      doc.on("end", () => {
        const pdfBuffer = Buffer.concat(buffers);
        resolve(pdfBuffer);
      });
      doc.on("error", reject);
      doc.fontSize(28).font("Helvetica-Bold").text("PAYOUT STATEMENT", 50, 50);
      doc.fontSize(10).font("Helvetica");
      const statementDate = (/* @__PURE__ */ new Date()).toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric"
      });
      const statementNumber = `PS-${payout.id.substring(3)}-${payoutDate.getFullYear()}`;
      const pageWidth = doc.page.width;
      const rightMargin = pageWidth - 50;
      const labelWidth = 100;
      const valueStartX = rightMargin - 200;
      let rightY = 50;
      doc.fontSize(10).font("Helvetica-Bold");
      doc.text("Statement #:", valueStartX, rightY, { width: labelWidth, align: "right" });
      doc.font("Helvetica");
      doc.text(statementNumber, valueStartX + labelWidth + 5, rightY);
      rightY += 15;
      doc.font("Helvetica-Bold");
      doc.text("Date:", valueStartX, rightY, { width: labelWidth, align: "right" });
      doc.font("Helvetica");
      doc.text(statementDate, valueStartX + labelWidth + 5, rightY);
      rightY += 15;
      doc.font("Helvetica-Bold");
      doc.text("Payout ID:", valueStartX, rightY, { width: labelWidth, align: "right" });
      doc.font("Helvetica");
      const payoutIdDisplay = payout.id.length > 20 ? payout.id.substring(0, 20) + "..." : payout.id;
      doc.text(payoutIdDisplay, valueStartX + labelWidth + 5, rightY);
      rightY += 15;
      doc.font("Helvetica-Bold");
      doc.text("Status:", valueStartX, rightY, { width: labelWidth, align: "right" });
      doc.font("Helvetica");
      doc.text(payoutStatus.charAt(0).toUpperCase() + payoutStatus.slice(1), valueStartX + labelWidth + 5, rightY);
      rightY += 15;
      doc.font("Helvetica-Bold");
      doc.text("Payout Date:", valueStartX, rightY, { width: labelWidth, align: "right" });
      doc.font("Helvetica");
      doc.text(payoutDate.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric"
      }), valueStartX + labelWidth + 5, rightY);
      let leftY = 120;
      doc.fontSize(14).font("Helvetica-Bold").text("Local Cooks Community", 50, leftY);
      leftY += 18;
      doc.fontSize(10).font("Helvetica").text("support@localcook.shop", 50, leftY);
      leftY += 30;
      doc.fontSize(12).font("Helvetica-Bold").text("Pay To:", 50, leftY);
      leftY += 18;
      doc.fontSize(10).font("Helvetica");
      doc.text(managerName || "Manager", 50, leftY);
      leftY += 15;
      if (managerEmail) {
        doc.text(managerEmail, 50, leftY);
        leftY += 15;
      }
      leftY += 20;
      doc.fontSize(12).font("Helvetica-Bold").text("Period:", 50, leftY);
      leftY += 18;
      doc.fontSize(10).font("Helvetica");
      doc.text(
        `${periodStart.toLocaleDateString("en-US", { month: "long", day: "numeric", year: "numeric" })} - ${periodEnd.toLocaleDateString("en-US", { month: "long", day: "numeric", year: "numeric" })}`,
        50,
        leftY
      );
      leftY += 40;
      doc.fontSize(14).font("Helvetica-Bold").text("Summary", 50, leftY);
      leftY += 25;
      const summaryItems = [
        { label: "Total Bookings", value: totalBookings.toString() },
        { label: "Total Revenue", value: `$${totalEarnings.toFixed(2)}` },
        { label: "Platform Fees", value: `-$${totalPlatformFees.toFixed(2)}` },
        { label: "Net Earnings", value: `$${totalEarnings.toFixed(2)}` },
        { label: "Payout Amount", value: `$${payoutAmount.toFixed(2)}` }
      ];
      summaryItems.forEach((item) => {
        doc.fontSize(10).font("Helvetica");
        doc.text(item.label + ":", 50, leftY, { width: 200 });
        doc.font("Helvetica-Bold");
        doc.text(item.value, 250, leftY);
        leftY += 20;
      });
      if (bookings.length > 0) {
        leftY += 20;
        doc.fontSize(14).font("Helvetica-Bold").text("Booking Details", 50, leftY);
        leftY += 25;
        doc.fontSize(9).font("Helvetica-Bold");
        doc.text("Date", 50, leftY);
        doc.text("Kitchen", 120, leftY);
        doc.text("Chef", 250, leftY);
        doc.text("Amount", 350, leftY, { width: 100, align: "right" });
        leftY += 15;
        doc.moveTo(50, leftY).lineTo(550, leftY).stroke();
        leftY += 10;
        doc.fontSize(8).font("Helvetica");
        bookings.slice(0, 30).forEach((booking) => {
          if (leftY > 700) {
            doc.addPage();
            leftY = 50;
          }
          const bookingDateRaw = booking.bookingDate || booking.booking_date || booking.createdAt || booking.created_at;
          const bookingDate = new Date(bookingDateRaw);
          const dateStr = bookingDate.toLocaleDateString("en-US", { month: "short", day: "numeric" });
          const kitchenName = (booking.kitchenName || booking.kitchen_name || "Kitchen").substring(0, 20);
          const chefName = (booking.chefName || booking.chef_name || "Guest").substring(0, 20);
          const amount = (booking.totalPrice || booking.total_price || 0) / 100 * (1 - serviceFeeRate);
          doc.text(dateStr, 50, leftY);
          doc.text(kitchenName, 120, leftY, { width: 120 });
          doc.text(chefName, 250, leftY, { width: 90 });
          doc.text(`$${amount.toFixed(2)}`, 350, leftY, { width: 100, align: "right" });
          leftY += 15;
        });
        if (bookings.length > 30) {
          leftY += 5;
          doc.fontSize(8).font("Helvetica").text(`... and ${bookings.length - 30} more bookings`, 50, leftY);
        }
      }
      const footerY = doc.page.height - 100;
      doc.fontSize(8).font("Helvetica");
      doc.text(
        "This is an automated payout statement from Local Cooks Community.",
        50,
        footerY,
        { align: "center", width: doc.page.width - 100 }
      );
      doc.text(
        "For questions, contact support@localcook.shop",
        50,
        footerY + 15,
        { align: "center", width: doc.page.width - 100 }
      );
      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}
var init_payout_statement_service = __esm({
  "server/services/payout-statement-service.ts"() {
    "use strict";
    init_logger();
  }
});

// server/routes/manager.ts
var manager_exports = {};
__export(manager_exports, {
  default: () => manager_default
});
import { Router as Router15 } from "express";
import {
  eq as eq30,
  inArray as inArray8,
  and as and18,
  desc as desc15,
  ne as ne4,
  sql as sql15,
  or as or5,
  gte as gte3,
  lte as lte3
} from "drizzle-orm";
import { format as format5 } from "date-fns";
import * as Sentry4 from "@sentry/node";
async function verifyManagerOwnsOverstay(overstayRecordId, managerId) {
  const [row] = await db.select({ managerId: locations.managerId }).from(storageOverstayRecords).innerJoin(storageBookings, eq30(storageOverstayRecords.storageBookingId, storageBookings.id)).innerJoin(storageListings, eq30(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq30(storageListings.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).where(eq30(storageOverstayRecords.id, overstayRecordId)).limit(1);
  return row?.managerId === managerId;
}
async function getManagerIdForBooking(bookingId, bookingType, db2) {
  if (bookingType === "kitchen" || bookingType === "bundle") {
    const [row] = await db2.select({ managerId: locations.managerId }).from(kitchenBookings).innerJoin(kitchens, eq30(kitchenBookings.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).where(eq30(kitchenBookings.id, bookingId)).limit(1);
    return row?.managerId ?? null;
  }
  if (bookingType === "storage") {
    const [row] = await db2.select({ managerId: locations.managerId }).from(storageBookings).innerJoin(
      storageListings,
      eq30(storageBookings.storageListingId, storageListings.id)
    ).innerJoin(kitchens, eq30(storageListings.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).where(eq30(storageBookings.id, bookingId)).limit(1);
    return row?.managerId ?? null;
  }
  if (bookingType === "equipment") {
    const [row] = await db2.select({ managerId: locations.managerId }).from(equipmentBookings).innerJoin(
      equipmentListings,
      eq30(equipmentBookings.equipmentListingId, equipmentListings.id)
    ).innerJoin(kitchens, eq30(equipmentListings.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).where(eq30(equipmentBookings.id, bookingId)).limit(1);
    return row?.managerId ?? null;
  }
  return null;
}
var router15, manager_default;
var init_manager = __esm({
  "server/routes/manager.ts"() {
    "use strict";
    init_db();
    init_firebase_auth_middleware();
    init_schema();
    init_user_service();
    init_email();
    init_sms();
    init_phone_utils();
    init_timezone_utils();
    init_logger();
    init_api_response();
    init_notification_service();
    init_config();
    init_schema();
    init_booking_service();
    init_kitchen_service();
    init_location_service();
    init_chef_service();
    init_manager_service();
    init_schema();
    init_overstay_penalty_service();
    init_damage_claim_service();
    init_damage_claim_limits_service();
    router15 = Router15();
    router15.get(
      "/revenue/overview",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const { startDate, endDate, locationId } = req.query;
          const metrics = await managerService.getRevenueOverview(managerId, {
            startDate,
            endDate,
            locationId: locationId ? parseInt(locationId) : void 0
          });
          res.json(metrics);
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/revenue/invoices",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const result = await managerService.getInvoices(
            managerId,
            req.query
          );
          res.json(result);
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/revenue/invoices/:bookingId",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const bookingId = parseInt(req.params.bookingId);
          if (isNaN(bookingId) || bookingId <= 0) {
            return res.status(400).json({ error: "Invalid booking ID" });
          }
          const [booking] = await db.select({
            id: kitchenBookings.id,
            chefId: kitchenBookings.chefId,
            kitchenId: kitchenBookings.kitchenId,
            bookingDate: kitchenBookings.bookingDate,
            startTime: kitchenBookings.startTime,
            endTime: kitchenBookings.endTime,
            status: kitchenBookings.status,
            totalPrice: kitchenBookings.totalPrice,
            hourlyRate: kitchenBookings.hourlyRate,
            durationHours: kitchenBookings.durationHours,
            serviceFee: kitchenBookings.serviceFee,
            paymentStatus: kitchenBookings.paymentStatus,
            paymentIntentId: kitchenBookings.paymentIntentId,
            currency: kitchenBookings.currency,
            createdAt: kitchenBookings.createdAt,
            updatedAt: kitchenBookings.updatedAt,
            kitchenName: kitchens.name,
            kitchenTaxRatePercent: kitchens.taxRatePercent,
            locationName: locations.name,
            managerId: locations.managerId
          }).from(kitchenBookings).innerJoin(kitchens, eq30(kitchenBookings.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).where(eq30(kitchenBookings.id, bookingId)).limit(1);
          if (!booking) {
            return res.status(404).json({ error: "Booking not found" });
          }
          if (booking.managerId !== managerId) {
            return res.status(403).json({ error: "Access denied to this booking" });
          }
          if (booking.paymentStatus === "authorized" || booking.paymentStatus === "pending") {
            return res.status(400).json({
              error: "Invoice not available yet. Payment must be captured before an invoice can be generated."
            });
          }
          if (booking.status === "cancelled" && !booking.paymentIntentId && !booking.totalPrice) {
            return res.status(400).json({
              error: "Invoice cannot be downloaded for cancelled bookings without payment information"
            });
          }
          let chef = null;
          if (booking.chefId) {
            const chefResult = await db.execute(sql15`
                SELECT u.id, u.username, cka.full_name
                FROM users u
                LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = u.id
                WHERE u.id = ${booking.chefId}
                LIMIT 1
            `);
            const chefRows = chefResult.rows || chefResult;
            if (Array.isArray(chefRows) && chefRows.length > 0) {
              chef = chefRows[0];
            }
          }
          const allStorageRows = await db.select({
            id: storageBookings.id,
            kitchenBookingId: storageBookings.kitchenBookingId,
            storageListingId: storageBookings.storageListingId,
            startDate: storageBookings.startDate,
            endDate: storageBookings.endDate,
            status: storageBookings.status,
            paymentStatus: storageBookings.paymentStatus,
            totalPrice: storageBookings.totalPrice,
            storageName: storageListings.name,
            storageType: storageListings.storageType,
            listingBasePrice: storageListings.basePrice
            // Daily rate in cents
          }).from(storageBookings).innerJoin(
            storageListings,
            eq30(storageBookings.storageListingId, storageListings.id)
          ).where(eq30(storageBookings.kitchenBookingId, bookingId));
          const storageRows = allStorageRows.filter((sr) => sr.paymentStatus !== "failed" && sr.status !== "cancelled");
          const allEquipmentRows = await db.select({
            id: equipmentBookings.id,
            kitchenBookingId: equipmentBookings.kitchenBookingId,
            equipmentListingId: equipmentBookings.equipmentListingId,
            status: equipmentBookings.status,
            paymentStatus: equipmentBookings.paymentStatus,
            totalPrice: equipmentBookings.totalPrice,
            equipmentType: equipmentListings.equipmentType,
            brand: equipmentListings.brand
          }).from(equipmentBookings).innerJoin(
            equipmentListings,
            eq30(equipmentBookings.equipmentListingId, equipmentListings.id)
          ).where(eq30(equipmentBookings.kitchenBookingId, bookingId));
          const equipmentRows = allEquipmentRows.filter((er) => er.paymentStatus !== "failed" && er.status !== "cancelled");
          const originalStorageDates = {};
          if (booking.paymentIntentId) {
            try {
              const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
              const kitchenTransaction = await findPaymentTransactionByIntentId2(
                booking.paymentIntentId,
                db
              );
              if (kitchenTransaction?.metadata) {
                const metadata = typeof kitchenTransaction.metadata === "string" ? JSON.parse(kitchenTransaction.metadata) : kitchenTransaction.metadata;
                if (metadata?.storage_items) {
                  const storageItems = Array.isArray(metadata.storage_items) ? metadata.storage_items : JSON.parse(metadata.storage_items);
                  for (const item of storageItems) {
                    if (item.storageListingId || item.id) {
                      const storageId = item.storageBookingId || item.id;
                      const startDate = new Date(item.startDate);
                      const endDate = new Date(item.endDate);
                      const days = Math.max(
                        1,
                        Math.ceil(
                          (endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24)
                        )
                      );
                      originalStorageDates[storageId] = {
                        startDate,
                        endDate,
                        days
                      };
                    }
                  }
                }
              }
            } catch {
              logger.info(
                "[Invoice] Could not fetch original storage dates from transaction, using current dates"
              );
            }
          }
          const storageRowsForInvoice = storageRows.map((sr) => {
            const originalDates = originalStorageDates[sr.id];
            if (originalDates) {
              return {
                ...sr,
                startDate: originalDates.startDate,
                endDate: originalDates.endDate,
                // Calculate base price from original days Ã— daily rate
                totalPrice: (sr.listingBasePrice || 0) * originalDates.days,
                _originalDays: originalDates.days
              };
            } else {
              logger.warn(
                `[Invoice] No original storage dates found in payment metadata for storage booking ${sr.id}, using current dates (may include extensions)`
              );
            }
            return sr;
          });
          const { generateInvoicePDF: generateInvoicePDF2 } = await Promise.resolve().then(() => (init_invoice_service(), invoice_service_exports));
          const pdfBuffer = await generateInvoicePDF2(
            booking,
            chef,
            {
              name: booking.kitchenName,
              taxRatePercent: booking.kitchenTaxRatePercent
            },
            { name: booking.locationName },
            storageRowsForInvoice,
            equipmentRows,
            booking.paymentIntentId,
            { viewer: "manager" }
          );
          res.setHeader("Content-Type", "application/pdf");
          res.setHeader(
            "Content-Disposition",
            `attachment; filename="invoice-${bookingId}.pdf"`
          );
          res.send(pdfBuffer);
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/revenue/invoices/storage/:storageBookingId",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const storageBookingId = parseInt(req.params.storageBookingId);
          if (isNaN(storageBookingId) || storageBookingId <= 0) {
            return res.status(400).json({ error: "Invalid storage booking ID" });
          }
          const [storageBooking] = await db.select({
            id: storageBookings.id,
            kitchenBookingId: storageBookings.kitchenBookingId,
            storageListingId: storageBookings.storageListingId,
            startDate: storageBookings.startDate,
            endDate: storageBookings.endDate,
            status: storageBookings.status,
            totalPrice: storageBookings.totalPrice,
            paymentStatus: storageBookings.paymentStatus,
            paymentIntentId: storageBookings.paymentIntentId,
            chefId: storageBookings.chefId,
            storageName: storageListings.name,
            storageType: storageListings.storageType,
            kitchenId: storageListings.kitchenId,
            kitchenName: kitchens.name,
            locationName: locations.name,
            locationId: locations.id,
            taxRatePercent: kitchens.taxRatePercent
          }).from(storageBookings).innerJoin(
            storageListings,
            eq30(storageBookings.storageListingId, storageListings.id)
          ).innerJoin(kitchens, eq30(storageListings.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).where(eq30(storageBookings.id, storageBookingId)).limit(1);
          if (!storageBooking) {
            return res.status(404).json({ error: "Storage booking not found" });
          }
          const managerOwnsLocation = await db.select({ id: locations.id }).from(locations).where(
            and18(
              eq30(locations.id, storageBooking.locationId),
              eq30(locations.managerId, managerId)
            )
          ).limit(1);
          if (managerOwnsLocation.length === 0) {
            return res.status(403).json({ error: "Access denied to this storage booking" });
          }
          const [transaction] = await db.select({
            id: paymentTransactions.id,
            amount: paymentTransactions.amount,
            baseAmount: paymentTransactions.baseAmount,
            paymentIntentId: paymentTransactions.paymentIntentId,
            paidAt: paymentTransactions.paidAt,
            createdAt: paymentTransactions.createdAt,
            metadata: paymentTransactions.metadata,
            stripeProcessingFee: paymentTransactions.stripeProcessingFee,
            managerRevenue: paymentTransactions.managerRevenue
          }).from(paymentTransactions).where(
            and18(
              eq30(paymentTransactions.bookingId, storageBookingId),
              eq30(paymentTransactions.bookingType, "storage"),
              eq30(paymentTransactions.status, "succeeded")
            )
          ).orderBy(desc15(paymentTransactions.createdAt)).limit(1);
          let extensionDetails = null;
          const metadata = transaction?.metadata;
          if (metadata?.storage_extension_id) {
            const extensionId = parseInt(String(metadata.storage_extension_id));
            if (!isNaN(extensionId)) {
              const extensionResult = await db.execute(sql15`
                    SELECT 
                        pse.id,
                        pse.extension_days,
                        pse.extension_base_price_cents,
                        pse.extension_total_price_cents,
                        pse.new_end_date,
                        sl.name as storage_name,
                        sl.base_price as daily_rate_cents,
                        sl.storage_type::text as storage_type
                    FROM pending_storage_extensions pse
                    JOIN storage_bookings sb ON pse.storage_booking_id = sb.id
                    JOIN storage_listings sl ON sb.storage_listing_id = sl.id
                    WHERE pse.id = ${extensionId}
                    LIMIT 1
                `);
              const extensionRows = extensionResult.rows || extensionResult;
              if (Array.isArray(extensionRows) && extensionRows.length > 0) {
                extensionDetails = extensionRows[0];
              }
            }
          }
          let chef = null;
          if (storageBooking.chefId) {
            const chefResult = await db.execute(sql15`
                SELECT u.id, u.username, cka.full_name
                FROM users u
                LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = u.id
                WHERE u.id = ${storageBooking.chefId}
                LIMIT 1
            `);
            const chefRows = chefResult.rows || chefResult;
            if (Array.isArray(chefRows) && chefRows.length > 0) {
              chef = chefRows[0];
            }
          }
          const { generateStorageInvoicePDF: generateStorageInvoicePDF2 } = await Promise.resolve().then(() => (init_invoice_service(), invoice_service_exports));
          const pdfBuffer = await generateStorageInvoicePDF2(
            transaction || {
              amount: storageBooking.totalPrice,
              baseAmount: storageBooking.totalPrice
            },
            storageBooking,
            chef,
            extensionDetails,
            { viewer: "manager" }
          );
          res.setHeader("Content-Type", "application/pdf");
          res.setHeader(
            "Content-Disposition",
            `attachment; filename="storage-invoice-${storageBookingId}.pdf"`
          );
          res.send(pdfBuffer);
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/revenue/invoices/overstay/:overstayRecordId",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const overstayRecordId = parseInt(req.params.overstayRecordId);
          if (isNaN(overstayRecordId) || overstayRecordId <= 0) {
            return res.status(400).json({ error: "Invalid overstay record ID" });
          }
          const {
            storageOverstayRecords: storageOverstayRecords2,
            storageBookings: storageBookings2,
            storageListings: storageListings3,
            kitchens: kitchens3,
            locations: locations5
          } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const [overstayRecord] = await db.select({
            id: storageOverstayRecords2.id,
            storageBookingId: storageOverstayRecords2.storageBookingId,
            finalPenaltyCents: storageOverstayRecords2.finalPenaltyCents,
            calculatedPenaltyCents: storageOverstayRecords2.calculatedPenaltyCents,
            daysOverdue: storageOverstayRecords2.daysOverdue,
            chargeSucceededAt: storageOverstayRecords2.chargeSucceededAt,
            stripePaymentIntentId: storageOverstayRecords2.stripePaymentIntentId,
            stripeChargeId: storageOverstayRecords2.stripeChargeId
          }).from(storageOverstayRecords2).where(eq30(storageOverstayRecords2.id, overstayRecordId)).limit(1);
          if (!overstayRecord) {
            return res.status(404).json({ error: "Overstay record not found" });
          }
          const [storageBooking] = await db.select({
            id: storageBookings2.id,
            chefId: storageBookings2.chefId,
            startDate: storageBookings2.startDate,
            endDate: storageBookings2.endDate,
            storageListingId: storageBookings2.storageListingId
          }).from(storageBookings2).where(eq30(storageBookings2.id, overstayRecord.storageBookingId)).limit(1);
          if (!storageBooking) {
            return res.status(404).json({ error: "Storage booking not found" });
          }
          const [listing] = await db.select({
            id: storageListings3.id,
            name: storageListings3.name,
            storageType: storageListings3.storageType,
            kitchenId: storageListings3.kitchenId
          }).from(storageListings3).where(eq30(storageListings3.id, storageBooking.storageListingId)).limit(1);
          if (!listing) {
            return res.status(404).json({ error: "Storage listing not found" });
          }
          const [kitchen] = await db.select({
            id: kitchens3.id,
            name: kitchens3.name,
            locationId: kitchens3.locationId,
            taxRatePercent: kitchens3.taxRatePercent
          }).from(kitchens3).where(eq30(kitchens3.id, listing.kitchenId)).limit(1);
          if (!kitchen) {
            return res.status(404).json({ error: "Kitchen not found" });
          }
          const [location] = await db.select({
            id: locations5.id,
            managerId: locations5.managerId,
            name: locations5.name
          }).from(locations5).where(
            and18(
              eq30(locations5.id, kitchen.locationId),
              eq30(locations5.managerId, managerId)
            )
          ).limit(1);
          if (!location) {
            return res.status(403).json({ error: "Access denied to this overstay record" });
          }
          const [transaction] = await db.select({
            id: paymentTransactions.id,
            amount: paymentTransactions.amount,
            baseAmount: paymentTransactions.baseAmount,
            paymentIntentId: paymentTransactions.paymentIntentId,
            paidAt: paymentTransactions.paidAt,
            createdAt: paymentTransactions.createdAt,
            metadata: paymentTransactions.metadata,
            stripeProcessingFee: paymentTransactions.stripeProcessingFee,
            managerRevenue: paymentTransactions.managerRevenue
          }).from(paymentTransactions).where(
            and18(
              eq30(paymentTransactions.bookingId, overstayRecord.storageBookingId),
              eq30(paymentTransactions.bookingType, "storage"),
              eq30(paymentTransactions.status, "succeeded")
            )
          ).orderBy(desc15(paymentTransactions.createdAt)).limit(1);
          const metadata = transaction?.metadata;
          if (!metadata || metadata.type !== "overstay_penalty") {
            return res.status(404).json({
              error: "No payment transaction found for this overstay penalty"
            });
          }
          let chef = null;
          if (storageBooking.chefId) {
            const chefResult = await db.execute(sql15`
                SELECT u.id, u.username, cka.full_name
                FROM users u
                LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = u.id
                WHERE u.id = ${storageBooking.chefId}
                LIMIT 1
            `);
            const chefRows = chefResult.rows || chefResult;
            if (Array.isArray(chefRows) && chefRows.length > 0) {
              chef = chefRows[0];
            }
          }
          const taxRatePercent = parseFloat(String(metadata.tax_rate_percent || "0")) || 0;
          const penaltyBaseCents = parseInt(String(metadata.penalty_base_cents || "0")) || 0;
          const penaltyTaxCents = parseInt(String(metadata.penalty_tax_cents || "0")) || 0;
          const baseAmount = penaltyBaseCents || parseInt(String(transaction?.baseAmount || "0"));
          const totalAmount = parseInt(String(transaction?.amount || "0"));
          const displayTaxAmount = penaltyTaxCents || totalAmount - baseAmount;
          const { generateStorageInvoicePDF: generateStorageInvoicePDF2 } = await Promise.resolve().then(() => (init_invoice_service(), invoice_service_exports));
          const overstayDetails = {
            is_overstay_penalty: true,
            days_overdue: overstayRecord.daysOverdue,
            penalty_base_cents: baseAmount,
            penalty_total_cents: totalAmount,
            penalty_tax_cents: displayTaxAmount,
            tax_rate_percent: taxRatePercent
          };
          const pdfBuffer = await generateStorageInvoicePDF2(
            transaction || {
              amount: totalAmount || overstayRecord.finalPenaltyCents,
              baseAmount,
              paidAt: overstayRecord.chargeSucceededAt
            },
            {
              id: storageBooking.id,
              kitchenName: kitchen.name,
              locationName: location.name,
              storageName: listing.name,
              taxRatePercent
            },
            chef,
            overstayDetails,
            { viewer: "manager" }
          );
          res.setHeader("Content-Type", "application/pdf");
          res.setHeader(
            "Content-Disposition",
            `attachment; filename="overstay-invoice-${overstayRecordId}.pdf"`
          );
          res.send(pdfBuffer);
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/revenue/by-location",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const { startDate, endDate } = req.query;
          const { getRevenueByLocation: getRevenueByLocation2 } = await Promise.resolve().then(() => (init_revenue_service(), revenue_service_exports));
          const result = await getRevenueByLocation2(
            managerId,
            db,
            startDate,
            endDate
          );
          res.json(result);
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/revenue/charts",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const { startDate, endDate, period } = req.query;
          logger.info("[Revenue Charts] Request params:", {
            managerId,
            startDate,
            endDate,
            period
          });
          let data;
          try {
            const { getRevenueByDateFromTransactions: getRevenueByDateFromTransactions2 } = await Promise.resolve().then(() => (init_revenue_service_v2(), revenue_service_v2_exports));
            data = await getRevenueByDateFromTransactions2(
              managerId,
              db,
              startDate,
              endDate
            );
            if (!data || data.length === 0) {
              logger.info(
                "[Revenue Charts] payment_transactions empty, falling back to booking tables"
              );
              const { getRevenueByDate: getRevenueByDate2 } = await Promise.resolve().then(() => (init_revenue_service(), revenue_service_exports));
              data = await getRevenueByDate2(
                managerId,
                db,
                startDate,
                endDate
              );
            } else {
              logger.info(
                "[Revenue Charts] Using payment_transactions data (Stripe source)"
              );
            }
          } catch (v2Error) {
            logger.warn(
              "[Revenue Charts] Falling back to booking tables:",
              v2Error
            );
            const { getRevenueByDate: getRevenueByDate2 } = await Promise.resolve().then(() => (init_revenue_service(), revenue_service_exports));
            data = await getRevenueByDate2(
              managerId,
              db,
              startDate,
              endDate
            );
          }
          logger.info("[Revenue Charts] Returning data:", {
            count: data?.length || 0,
            data
          });
          res.json({ data, period: period || "daily" });
        } catch (error) {
          logger.error("[Revenue Charts] Error:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/revenue/transactions",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const {
            startDate,
            endDate,
            locationId,
            paymentStatus,
            limit = "50",
            offset = "0"
          } = req.query;
          const { getTransactionHistory: getTransactionHistory2 } = await Promise.resolve().then(() => (init_revenue_service(), revenue_service_exports));
          const { transactions, total } = await getTransactionHistory2(
            managerId,
            db,
            startDate,
            endDate,
            locationId ? parseInt(locationId) : void 0,
            parseInt(limit),
            parseInt(offset),
            paymentStatus
          );
          res.json({ transactions, total });
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.put(
      "/bookings/:id/cancellation-request",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const bookingId = parseInt(req.params.id);
          const { action } = req.body || {};
          if (isNaN(bookingId) || bookingId <= 0) {
            return res.status(400).json({ error: "Invalid booking ID" });
          }
          if (!action || !["accept", "decline"].includes(action)) {
            return res.status(400).json({ error: 'Action must be "accept" or "decline"' });
          }
          const { kitchenBookings: kitchenBookings3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const [booking] = await db.select({
            id: kitchenBookings3.id,
            status: kitchenBookings3.status,
            kitchenId: kitchenBookings3.kitchenId,
            chefId: kitchenBookings3.chefId,
            paymentStatus: kitchenBookings3.paymentStatus,
            cancellationRequestReason: kitchenBookings3.cancellationRequestReason
          }).from(kitchenBookings3).innerJoin(kitchens, eq30(kitchenBookings3.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).where(
            and18(
              eq30(kitchenBookings3.id, bookingId),
              eq30(locations.managerId, managerId)
            )
          ).limit(1);
          if (!booking) {
            return res.status(404).json({ error: "Booking not found" });
          }
          if (booking.status !== "cancellation_requested") {
            return res.status(400).json({
              error: `Booking is not in cancellation_requested status. Current: ${booking.status}`
            });
          }
          if (action === "accept") {
            await db.update(kitchenBookings3).set({ status: "cancelled", updatedAt: /* @__PURE__ */ new Date() }).where(eq30(kitchenBookings3.id, bookingId));
            try {
              const { storageBookings: sbTable, equipmentBookings: ebTable } = await Promise.resolve().then(() => (init_schema(), schema_exports));
              await db.update(sbTable).set({ status: "cancelled", updatedAt: /* @__PURE__ */ new Date() }).where(and18(eq30(sbTable.kitchenBookingId, bookingId), ne4(sbTable.status, "cancelled")));
              await db.update(ebTable).set({ status: "cancelled", updatedAt: /* @__PURE__ */ new Date() }).where(and18(eq30(ebTable.kitchenBookingId, bookingId), ne4(ebTable.status, "cancelled")));
            } catch (cascadeErr) {
              logger.warn(`[Cancellation Request] Cascade cancel failed for booking ${bookingId}:`, cascadeErr);
            }
            try {
              const [currentKb] = await db.select({ storageItems: kitchenBookings3.storageItems, equipmentItems: kitchenBookings3.equipmentItems }).from(kitchenBookings3).where(eq30(kitchenBookings3.id, bookingId));
              if (currentKb) {
                const updatedStorage = (Array.isArray(currentKb.storageItems) ? currentKb.storageItems : []).map((item) => ({ ...item, rejected: true, status: "cancelled", cancellationRequested: false }));
                const updatedEquip = (Array.isArray(currentKb.equipmentItems) ? currentKb.equipmentItems : []).map((item) => ({ ...item, rejected: true }));
                await db.update(kitchenBookings3).set({ storageItems: updatedStorage, equipmentItems: updatedEquip, updatedAt: /* @__PURE__ */ new Date() }).where(eq30(kitchenBookings3.id, bookingId));
              }
            } catch (jsonbErr) {
              logger.warn(`[Cancellation Request] JSONB sync failed for booking ${bookingId}:`, jsonbErr);
            }
            try {
              const chef = booking.chefId ? await userService.getUser(booking.chefId) : null;
              if (chef) {
                const { notificationService: notificationService2 } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
                await notificationService2.create({
                  userId: booking.chefId,
                  target: "chef",
                  type: "booking_cancellation_accepted",
                  title: "Cancellation Accepted",
                  message: "Your booking cancellation request has been accepted. A refund will be processed shortly.",
                  metadata: { bookingId }
                });
              }
            } catch (notifError) {
              logger.error(
                "[Cancellation Request] Notification error:",
                notifError
              );
            }
            return res.json({
              success: true,
              action: "accepted",
              message: 'Cancellation accepted. Use "Issue Refund" to process the refund.',
              requiresRefund: true
            });
          }
          if (action === "decline") {
            await db.update(kitchenBookings3).set({
              status: "confirmed",
              cancellationRequestDeclinedAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq30(kitchenBookings3.id, bookingId));
            try {
              if (booking.chefId) {
                const { notificationService: notificationService2 } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
                await notificationService2.create({
                  userId: booking.chefId,
                  target: "chef",
                  type: "booking_cancellation_declined",
                  title: "Cancellation Declined",
                  message: "Your booking cancellation request was declined by the kitchen manager. Your booking remains confirmed.",
                  metadata: { bookingId }
                });
              }
            } catch (notifError) {
              logger.error(
                "[Cancellation Request] Notification error:",
                notifError
              );
            }
            return res.json({
              success: true,
              action: "declined",
              message: "Cancellation request declined. Booking remains confirmed."
            });
          }
        } catch (error) {
          logger.error("[Cancellation Request] Error:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.put(
      "/storage-bookings/:id/cancellation-request",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const storageBookingId = parseInt(req.params.id);
          const { action } = req.body;
          if (isNaN(storageBookingId) || storageBookingId <= 0) {
            return res.status(400).json({ error: "Invalid storage booking ID" });
          }
          if (!action || !["accept", "decline"].includes(action)) {
            return res.status(400).json({ error: 'Invalid action. Must be "accept" or "decline".' });
          }
          const {
            storageBookings: storageBookingsTable,
            storageListings: storageListings3
          } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const rows = await db.select({
            id: storageBookingsTable.id,
            status: storageBookingsTable.status,
            chefId: storageBookingsTable.chefId,
            kitchenBookingId: storageBookingsTable.kitchenBookingId,
            cancellationRequestReason: storageBookingsTable.cancellationRequestReason,
            locationId: locations.id,
            managerId: locations.managerId
          }).from(storageBookingsTable).innerJoin(
            storageListings3,
            eq30(storageBookingsTable.storageListingId, storageListings3.id)
          ).innerJoin(kitchens, eq30(storageListings3.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).where(eq30(storageBookingsTable.id, storageBookingId)).limit(1);
          if (rows.length === 0) {
            return res.status(404).json({ error: "Storage booking not found" });
          }
          const booking = rows[0];
          if (booking.managerId !== req.neonUser.id) {
            return res.status(403).json({ error: "You don't have permission to manage this storage booking" });
          }
          if (booking.status !== "cancellation_requested") {
            return res.status(400).json({
              error: `Cannot process cancellation request \u2014 booking status is "${booking.status}", not "cancellation_requested".`
            });
          }
          if (action === "accept") {
            await db.update(storageBookingsTable).set({
              status: "cancelled",
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq30(storageBookingsTable.id, storageBookingId));
            try {
              const { syncStorageItemStatusInKitchenBooking: syncStorageItemStatusInKitchenBooking2 } = await Promise.resolve().then(() => (init_bookings(), bookings_exports));
              await syncStorageItemStatusInKitchenBooking2(storageBookingId, "cancelled");
            } catch (syncErr) {
              logger.error("[Storage Cancellation] JSONB sync error:", syncErr);
            }
            try {
              if (booking.chefId) {
                const { notificationService: notificationService2 } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
                await notificationService2.create({
                  userId: booking.chefId,
                  target: "chef",
                  type: "booking_cancellation_accepted",
                  title: "Storage Cancellation Accepted",
                  message: "Your storage cancellation request has been accepted. A refund will be processed shortly.",
                  metadata: { storageBookingId }
                });
              }
            } catch (notifError) {
              logger.error(
                "[Storage Cancellation Request] Notification error:",
                notifError
              );
            }
            return res.json({
              success: true,
              action: "accepted",
              message: 'Storage cancellation accepted. Use "Issue Refund" to process the refund.',
              requiresRefund: true
            });
          }
          if (action === "decline") {
            await db.update(storageBookingsTable).set({
              status: "confirmed",
              cancellationRequestDeclinedAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq30(storageBookingsTable.id, storageBookingId));
            try {
              const { syncStorageItemStatusInKitchenBooking: syncStorageItemStatusInKitchenBooking2 } = await Promise.resolve().then(() => (init_bookings(), bookings_exports));
              await syncStorageItemStatusInKitchenBooking2(storageBookingId, "confirmed");
            } catch (syncErr) {
              logger.error("[Storage Cancellation] JSONB sync error:", syncErr);
            }
            try {
              if (booking.chefId) {
                const { notificationService: notificationService2 } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
                await notificationService2.create({
                  userId: booking.chefId,
                  target: "chef",
                  type: "booking_cancellation_declined",
                  title: "Storage Cancellation Declined",
                  message: "Your storage cancellation request was declined by the kitchen manager. Your storage booking remains confirmed.",
                  metadata: { storageBookingId }
                });
              }
            } catch (notifError) {
              logger.error(
                "[Storage Cancellation Request] Notification error:",
                notifError
              );
            }
            return res.json({
              success: true,
              action: "declined",
              message: "Storage cancellation request declined. Booking remains confirmed."
            });
          }
        } catch (error) {
          logger.error("[Storage Cancellation Request] Error:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/revenue/transactions/:transactionId/refund",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const transactionId = parseInt(req.params.transactionId);
          const { amount, reason } = req.body || {};
          const refundReason = typeof reason === "string" ? reason.trim() : void 0;
          if (isNaN(transactionId) || transactionId <= 0) {
            return res.status(400).json({ error: "Invalid transaction ID" });
          }
          const amountCents = Math.round(Number(amount));
          if (!Number.isFinite(amountCents) || amountCents <= 0) {
            return res.status(400).json({ error: "Refund amount must be a positive number of cents" });
          }
          const { findPaymentTransactionById: findPaymentTransactionById2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
          const transaction = await findPaymentTransactionById2(transactionId, db);
          if (!transaction) {
            return res.status(404).json({ error: "Transaction not found" });
          }
          const transactionManagerId = transaction.manager_id ?? await getManagerIdForBooking(
            transaction.booking_id,
            transaction.booking_type,
            db
          );
          if (!transactionManagerId || transactionManagerId !== managerId) {
            return res.status(403).json({ error: "Access denied to this transaction" });
          }
          if (!transaction.payment_intent_id) {
            return res.status(400).json({ error: "No payment intent linked to this transaction" });
          }
          if (!["succeeded", "partially_refunded"].includes(transaction.status)) {
            return res.status(400).json({
              error: `Refunds are only allowed for paid transactions. Current status: ${transaction.status}`
            });
          }
          const totalAmount = parseInt(String(transaction.amount || "0")) || 0;
          const currentRefundAmount = parseInt(String(transaction.refund_amount || "0")) || 0;
          const managerRevenue = parseInt(String(transaction.manager_revenue || "0")) || 0;
          const stripeProcessingFee = parseInt(String(transaction.stripe_processing_fee || "0")) || 0;
          const { calculateRefundBreakdown: calculateRefundBreakdown2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
          const refundBreakdown = calculateRefundBreakdown2(
            totalAmount,
            managerRevenue,
            currentRefundAmount,
            stripeProcessingFee
          );
          if (amountCents > refundBreakdown.maxRefundableToCustomer) {
            return res.status(400).json({
              error: `Refund amount exceeds maximum. Max refundable: $${(refundBreakdown.maxRefundableToCustomer / 100).toFixed(2)}`,
              maxRefundable: refundBreakdown.maxRefundableToCustomer,
              managerBalance: refundBreakdown.remainingManagerBalance,
              explanation: refundBreakdown.explanation
            });
          }
          const [manager] = await db.select({ stripeConnectAccountId: users.stripeConnectAccountId }).from(users).where(eq30(users.id, managerId)).limit(1);
          if (!manager?.stripeConnectAccountId) {
            return res.status(400).json({ error: "Manager Stripe Connect account not found" });
          }
          const refundToCustomer = amountCents;
          const deductFromManager = amountCents;
          const { reverseTransferAndRefund: reverseTransferAndRefund2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
          const allowedStripeReasons = [
            "duplicate",
            "fraudulent",
            "requested_by_customer"
          ];
          const stripeReason = refundReason && allowedStripeReasons.includes(refundReason) ? refundReason : "requested_by_customer";
          const refund = await reverseTransferAndRefund2(
            transaction.payment_intent_id,
            refundToCustomer,
            // Customer receives this amount
            stripeReason,
            {
              reverseTransferAmount: deductFromManager,
              // Manager is debited this exact same amount
              refundApplicationFee: false,
              metadata: {
                transaction_id: String(transaction.id),
                booking_id: String(transaction.booking_id),
                booking_type: String(transaction.booking_type),
                manager_id: String(managerId),
                refund_reason: refundReason ? String(refundReason) : "",
                refund_model: "unified",
                // Track that we used unified model
                customer_receives: String(refundToCustomer),
                manager_debited: String(deductFromManager)
              },
              transferMetadata: {
                transaction_id: String(transaction.id),
                booking_id: String(transaction.booking_id),
                booking_type: String(transaction.booking_type),
                manager_id: String(managerId),
                refund_reason: refundReason ? String(refundReason) : ""
              }
            }
          );
          const newRefundTotal = currentRefundAmount + amountCents;
          const newStatus = newRefundTotal >= managerRevenue ? "refunded" : "partially_refunded";
          let currentMetadata = {};
          if (transaction.metadata) {
            if (typeof transaction.metadata === "string") {
              try {
                currentMetadata = JSON.parse(transaction.metadata);
              } catch {
                currentMetadata = {};
              }
            } else {
              currentMetadata = transaction.metadata;
            }
          }
          const existingRefunds = Array.isArray(currentMetadata.refunds) ? currentMetadata.refunds : [];
          const updatedMetadata = {
            ...currentMetadata,
            refunds: [
              ...existingRefunds,
              {
                id: refund.refundId,
                customerReceived: refundToCustomer,
                managerDebited: deductFromManager,
                reason: refundReason || null,
                createdAt: (/* @__PURE__ */ new Date()).toISOString(),
                createdBy: managerId,
                transferReversalId: refund.transferReversalId,
                model: "unified"
              }
            ],
            lastRefund: {
              id: refund.refundId,
              customerReceived: refundToCustomer,
              managerDebited: deductFromManager,
              reason: refundReason || null,
              createdAt: (/* @__PURE__ */ new Date()).toISOString(),
              createdBy: managerId,
              transferReversalId: refund.transferReversalId
            }
          };
          await updatePaymentTransaction2(
            transaction.id,
            {
              status: newStatus,
              stripeStatus: newStatus,
              refundAmount: newRefundTotal,
              refundId: refund.refundId,
              refundReason,
              refundedAt: /* @__PURE__ */ new Date(),
              lastSyncedAt: /* @__PURE__ */ new Date(),
              metadata: updatedMetadata
            },
            db
          );
          const paymentStatus = newStatus === "refunded" ? "refunded" : "partially_refunded";
          if (transaction.booking_type === "kitchen" || transaction.booking_type === "bundle") {
            await db.update(kitchenBookings).set({ paymentStatus, updatedAt: /* @__PURE__ */ new Date() }).where(eq30(kitchenBookings.id, transaction.booking_id));
          } else if (transaction.booking_type === "storage") {
            await db.update(storageBookings).set({ paymentStatus, updatedAt: /* @__PURE__ */ new Date() }).where(eq30(storageBookings.id, transaction.booking_id));
          } else if (transaction.booking_type === "equipment") {
            await db.update(equipmentBookings).set({ paymentStatus, updatedAt: /* @__PURE__ */ new Date() }).where(eq30(equipmentBookings.id, transaction.booking_id));
          }
          const newBreakdown = calculateRefundBreakdown2(
            totalAmount,
            managerRevenue,
            newRefundTotal,
            stripeProcessingFee
          );
          res.json({
            success: true,
            refundId: refund.refundId,
            status: newStatus,
            // UNIFIED: Both values are the same - no discrepancy!
            customerReceived: refundToCustomer,
            managerDebited: deductFromManager,
            // Total refunded so far
            totalRefunded: newRefundTotal,
            // Remaining amounts (using unified model)
            remainingCharged: totalAmount - newRefundTotal,
            maxRefundable: newBreakdown.maxRefundableToCustomer,
            managerRemainingBalance: newBreakdown.remainingManagerBalance,
            // Fee info for transparency
            originalStripeFee: stripeProcessingFee,
            transferReversalId: refund.transferReversalId
          });
        } catch (error) {
          logger.error("[Refund] Error processing refund:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/stripe-connect/create",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        logger.info(
          "[Stripe Connect] Create request received for manager:",
          req.neonUser?.id
        );
        try {
          const managerId = req.neonUser.id;
          const fromSetup = req.body?.from === "setup" || req.query.from === "setup";
          const userResult = await db.execute(sql15`
            SELECT id, username as email, stripe_connect_account_id 
            FROM users 
            WHERE id = ${managerId} 
            LIMIT 1
        `);
          const userRow = userResult.rows ? userResult.rows[0] : userResult[0];
          if (!userRow) {
            logger.error("[Stripe Connect] User not found for ID:", managerId);
            return res.status(404).json({ error: "User not found" });
          }
          const user = {
            id: userRow.id,
            email: userRow.email,
            stripeConnectAccountId: userRow.stripe_connect_account_id
          };
          const {
            createConnectAccount: createConnectAccount2,
            createAccountLink: createAccountLink2,
            isAccountReady: isAccountReady2,
            createDashboardLoginLink: createDashboardLoginLink2
          } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
          const baseUrl = getAppBaseUrl("kitchen");
          const fromParam = fromSetup ? "&from=setup" : "";
          const refreshUrl = `${baseUrl}/manager/stripe-connect/refresh?role=manager${fromParam}`;
          const returnUrl = `${baseUrl}/manager/stripe-connect/return?success=true&role=manager${fromParam}`;
          if (user.stripeConnectAccountId) {
            const isReady = await isAccountReady2(user.stripeConnectAccountId);
            if (isReady) {
              return res.json({
                alreadyExists: true,
                accountId: user.stripeConnectAccountId
              });
            } else {
              const link2 = await createAccountLink2(
                user.stripeConnectAccountId,
                refreshUrl,
                returnUrl
              );
              return res.json({ url: link2.url });
            }
          }
          logger.info(
            "[Stripe Connect] Creating new account for email:",
            user.email
          );
          const { accountId } = await createConnectAccount2({
            managerId,
            email: user.email,
            country: "CA"
          });
          await userService.updateUser(managerId, {
            stripeConnectAccountId: accountId
          });
          const link = await createAccountLink2(accountId, refreshUrl, returnUrl);
          return res.json({ url: link.url });
        } catch (error) {
          logger.error("[Stripe Connect] Error in create route:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/stripe-connect/onboarding-link",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const userResult = await db.execute(sql15`
            SELECT stripe_connect_account_id 
            FROM users 
            WHERE id = ${managerId} 
            LIMIT 1
        `);
          const userRow = userResult.rows ? userResult.rows[0] : userResult[0];
          if (!userRow?.stripe_connect_account_id) {
            return res.status(400).json({ error: "No Stripe Connect account found" });
          }
          const { createAccountLink: createAccountLink2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
          const baseUrl = getAppBaseUrl("kitchen");
          const fromSetup = req.query.from === "setup" ? "&from=setup" : "";
          const refreshUrl = `${baseUrl}/manager/stripe-connect/refresh?role=manager${fromSetup}`;
          const returnUrl = `${baseUrl}/manager/stripe-connect/return?success=true&role=manager${fromSetup}`;
          const link = await createAccountLink2(
            userRow.stripe_connect_account_id,
            refreshUrl,
            returnUrl
          );
          return res.json({ url: link.url });
        } catch (error) {
          logger.error("[Stripe Connect] Error in onboarding-link route:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/stripe-connect/dashboard-link",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const userResult = await db.execute(sql15`
            SELECT stripe_connect_account_id 
            FROM users 
            WHERE id = ${managerId} 
            LIMIT 1
        `);
          const userRow = userResult.rows ? userResult.rows[0] : userResult[0];
          if (!userRow?.stripe_connect_account_id) {
            return res.status(400).json({ error: "No Stripe Connect account found" });
          }
          const { createDashboardLoginLink: createDashboardLoginLink2, isAccountReady: isAccountReady2, createAccountLink: createAccountLink2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
          const isReady = await isAccountReady2(userRow.stripe_connect_account_id);
          if (isReady) {
            const link = await createDashboardLoginLink2(
              userRow.stripe_connect_account_id
            );
            return res.json({ url: link.url });
          } else {
            const baseUrl = getAppBaseUrl("kitchen");
            const fromSetup = req.query.from === "setup" ? "&from=setup" : "";
            const refreshUrl = `${baseUrl}/manager/stripe-connect/refresh?role=manager${fromSetup}`;
            const returnUrl = `${baseUrl}/manager/stripe-connect/return?success=true&role=manager${fromSetup}`;
            const link = await createAccountLink2(
              userRow.stripe_connect_account_id,
              refreshUrl,
              returnUrl
            );
            return res.json({ url: link.url, requiresOnboarding: true });
          }
        } catch (error) {
          logger.error("[Stripe Connect] Error in dashboard-link route:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/stripe-connect/status",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const [manager] = await db.select({
            stripeConnectAccountId: users.stripeConnectAccountId,
            stripeConnectOnboardingStatus: users.stripeConnectOnboardingStatus
          }).from(users).where(eq30(users.id, managerId)).limit(1);
          if (!manager?.stripeConnectAccountId) {
            return res.json({
              connected: false,
              hasAccount: false,
              accountId: null,
              payoutsEnabled: false,
              chargesEnabled: false,
              detailsSubmitted: false,
              status: "not_started"
            });
          }
          try {
            const { getAccountStatus: getAccountStatus2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
            const stripeStatus = await getAccountStatus2(
              manager.stripeConnectAccountId
            );
            let status = "incomplete";
            if (stripeStatus.chargesEnabled && stripeStatus.payoutsEnabled) {
              status = "complete";
            } else if (stripeStatus.detailsSubmitted) {
              status = "pending";
            }
            const reqs = stripeStatus.requirements;
            let verificationStage = "incomplete";
            if (stripeStatus.chargesEnabled && stripeStatus.payoutsEnabled) {
              verificationStage = "complete";
            } else if (reqs.disabledReason?.includes("rejected")) {
              verificationStage = "rejected";
            } else if (reqs.pastDue.length > 0) {
              verificationStage = "past_due";
            } else if (reqs.pendingVerification.length > 0 && stripeStatus.detailsSubmitted) {
              verificationStage = "pending_verification";
            } else if (stripeStatus.detailsSubmitted && reqs.currentlyDue.length > 0) {
              verificationStage = "requires_additional_info";
            } else if (stripeStatus.chargesEnabled && !stripeStatus.payoutsEnabled) {
              verificationStage = "payouts_disabled";
            } else if (!stripeStatus.chargesEnabled && stripeStatus.payoutsEnabled) {
              verificationStage = "charges_disabled";
            } else if (!stripeStatus.detailsSubmitted && reqs.currentlyDue.length > 0) {
              verificationStage = "details_needed";
            } else if (stripeStatus.detailsSubmitted) {
              verificationStage = "pending_verification";
            }
            const dbStatus = manager.stripeConnectOnboardingStatus;
            if (status === "complete" && dbStatus !== "complete" || status !== "complete" && dbStatus === "complete") {
              await db.update(users).set({
                stripeConnectOnboardingStatus: status === "complete" ? "complete" : "in_progress"
              }).where(eq30(users.id, managerId));
            }
            res.json({
              connected: true,
              hasAccount: true,
              accountId: manager.stripeConnectAccountId,
              payoutsEnabled: stripeStatus.payoutsEnabled,
              chargesEnabled: stripeStatus.chargesEnabled,
              detailsSubmitted: stripeStatus.detailsSubmitted,
              status,
              verificationStage,
              requirements: {
                currentlyDue: reqs.currentlyDue,
                pastDue: reqs.pastDue,
                pendingVerification: reqs.pendingVerification,
                currentDeadline: reqs.currentDeadline
              }
            });
          } catch (stripeError) {
            logger.error("Error fetching Stripe account status:", stripeError);
            res.json({
              connected: true,
              hasAccount: true,
              accountId: manager.stripeConnectAccountId,
              payoutsEnabled: manager.stripeConnectOnboardingStatus === "complete",
              chargesEnabled: manager.stripeConnectOnboardingStatus === "complete",
              detailsSubmitted: manager.stripeConnectOnboardingStatus === "complete",
              status: manager.stripeConnectOnboardingStatus === "complete" ? "complete" : "incomplete"
            });
          }
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/stripe-connect/sync",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const [manager] = await db.select().from(users).where(eq30(users.id, managerId)).limit(1);
          if (!manager?.stripeConnectAccountId) {
            return res.status(400).json({ error: "No Stripe account connected" });
          }
          const { getAccountStatus: getAccountStatus2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
          const status = await getAccountStatus2(manager.stripeConnectAccountId);
          const onboardingStatus = status.detailsSubmitted ? "complete" : "in_progress";
          await db.update(users).set({
            stripeConnectOnboardingStatus: onboardingStatus
            // If they are fully ready, ensure manager onboarding is arguably complete for payments part
            // keeping it simple for now, just updating stripe status
          }).where(eq30(users.id, managerId));
          res.json({
            connected: true,
            accountId: manager.stripeConnectAccountId,
            status: onboardingStatus,
            details: status
          });
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/revenue/sync-stripe",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const { limit = 100, onlyUnsynced = true } = req.body;
          logger.info(`[Stripe Sync] Starting sync for manager ${managerId}...`);
          const { backfillPaymentTransactionsFromBookings: backfillPaymentTransactionsFromBookings2 } = await Promise.resolve().then(() => (init_payment_transactions_backfill(), payment_transactions_backfill_exports));
          const backfillResult = await backfillPaymentTransactionsFromBookings2(
            managerId,
            db,
            { limit }
          );
          logger.info(`[Stripe Sync] Backfill complete:`, backfillResult);
          const { syncExistingPaymentTransactionsFromStripe: syncExistingPaymentTransactionsFromStripe2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
          const syncResult = await syncExistingPaymentTransactionsFromStripe2(
            managerId,
            db,
            {
              limit,
              onlyUnsynced
            }
          );
          logger.info(`[Stripe Sync] Stripe sync complete:`, syncResult);
          res.json({
            success: true,
            backfill: backfillResult,
            stripeSync: syncResult,
            message: `Backfilled ${backfillResult.created} transactions, synced ${syncResult.synced} with Stripe`
          });
        } catch (error) {
          logger.error("[Stripe Sync] Error:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/revenue/stripe-balance",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const [userResult] = await db.select({ stripeConnectAccountId: users.stripeConnectAccountId }).from(users).where(eq30(users.id, managerId)).limit(1);
          if (!userResult?.stripeConnectAccountId) {
            return res.json({
              available: 0,
              pending: 0,
              inTransit: 0,
              currency: "cad",
              hasStripeAccount: false
            });
          }
          const accountId = userResult.stripeConnectAccountId;
          const { getAccountBalance: getAccountBalance2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
          const balance = await getAccountBalance2(accountId);
          const availableBalance = balance.available?.reduce((sum, b) => sum + b.amount, 0) || 0;
          const pendingBalance = balance.pending?.reduce((sum, b) => sum + b.amount, 0) || 0;
          const connectReserved = balance.connect_reserved?.reduce(
            (sum, b) => sum + b.amount,
            0
          ) || 0;
          const currency = balance.available?.[0]?.currency || "cad";
          res.json({
            available: availableBalance,
            pending: pendingBalance,
            inTransit: connectReserved,
            currency,
            hasStripeAccount: true,
            // Include raw balance for debugging if needed
            _raw: process.env.NODE_ENV === "development" ? balance : void 0
          });
        } catch (error) {
          logger.error("[Stripe Balance] Error fetching balance:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/revenue/payouts",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const { limit = "50" } = req.query;
          const result = await managerService.getPayouts(
            managerId,
            parseInt(limit)
          );
          res.json(result);
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/revenue/payouts/:payoutId",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const payoutId = req.params.payoutId;
          const [userResult] = await db.select({ stripeConnectAccountId: users.stripeConnectAccountId }).from(users).where(eq30(users.id, managerId)).limit(1);
          if (!userResult?.stripeConnectAccountId) {
            return res.status(404).json({ error: "No Stripe Connect account linked" });
          }
          const accountId = userResult.stripeConnectAccountId;
          const { getPayout: getPayout2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
          const payout = await getPayout2(accountId, payoutId);
          if (!payout) {
            return res.status(404).json({ error: "Payout not found" });
          }
          const payoutDate = new Date(payout.created * 1e3);
          const periodStart = new Date(payoutDate);
          periodStart.setDate(periodStart.getDate() - 7);
          const { getBalanceTransactions: getBalanceTransactions2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
          const transactions = await getBalanceTransactions2(
            accountId,
            periodStart,
            payoutDate,
            100
          );
          const bookingRows = await db.select({
            id: kitchenBookings.id,
            bookingDate: kitchenBookings.bookingDate,
            startTime: kitchenBookings.startTime,
            endTime: kitchenBookings.endTime,
            totalPrice: kitchenBookings.totalPrice,
            serviceFee: kitchenBookings.serviceFee,
            paymentStatus: kitchenBookings.paymentStatus,
            paymentIntentId: kitchenBookings.paymentIntentId,
            kitchenName: kitchens.name,
            locationName: locations.name,
            chefName: users.username,
            chefEmail: users.username
          }).from(kitchenBookings).innerJoin(kitchens, eq30(kitchenBookings.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).leftJoin(users, eq30(kitchenBookings.chefId, users.id)).where(
            and18(
              eq30(locations.managerId, managerId),
              eq30(kitchenBookings.paymentStatus, "paid"),
              sql15`DATE(${kitchenBookings.bookingDate}) >= ${periodStart.toISOString().split("T")[0]}::date`,
              sql15`DATE(${kitchenBookings.bookingDate}) <= ${payoutDate.toISOString().split("T")[0]}::date`
            )
          ).orderBy(desc15(kitchenBookings.bookingDate));
          res.json({
            payout: {
              id: payout.id,
              amount: payout.amount / 100,
              currency: payout.currency,
              status: payout.status,
              arrivalDate: new Date(payout.arrival_date * 1e3).toISOString(),
              created: new Date(payout.created * 1e3).toISOString(),
              description: payout.description,
              method: payout.method,
              type: payout.type
            },
            transactions: transactions.map((t) => ({
              id: t.id,
              amount: t.amount / 100,
              currency: t.currency,
              description: t.description,
              fee: t.fee / 100,
              net: t.net / 100,
              status: t.status,
              type: t.type,
              created: new Date(t.created * 1e3).toISOString()
            })),
            bookings: bookingRows.map((row) => ({
              id: row.id,
              bookingDate: row.bookingDate,
              startTime: row.startTime,
              endTime: row.endTime,
              totalPrice: (parseInt(String(row.totalPrice)) || 0) / 100,
              serviceFee: (parseInt(String(row.serviceFee)) || 0) / 100,
              paymentStatus: row.paymentStatus,
              paymentIntentId: row.paymentIntentId,
              kitchenName: row.kitchenName,
              locationName: row.locationName,
              chefName: row.chefName || "Guest",
              chefEmail: row.chefEmail
            }))
          });
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/revenue/payouts/:payoutId/statement",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const payoutId = req.params.payoutId;
          const [manager] = await db.select({
            id: users.id,
            username: users.username,
            stripeConnectAccountId: users.stripeConnectAccountId
          }).from(users).where(eq30(users.id, managerId)).limit(1);
          if (!manager?.stripeConnectAccountId) {
            return res.status(404).json({ error: "No Stripe Connect account linked" });
          }
          const accountId = manager.stripeConnectAccountId;
          const { getPayout: getPayout2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
          const payout = await getPayout2(accountId, payoutId);
          if (!payout) {
            return res.status(404).json({ error: "Payout not found" });
          }
          const payoutDate = new Date(payout.created * 1e3);
          const periodStart = new Date(payoutDate);
          periodStart.setDate(periodStart.getDate() - 7);
          const bookingRows = await db.select({
            id: kitchenBookings.id,
            bookingDate: kitchenBookings.bookingDate,
            startTime: kitchenBookings.startTime,
            endTime: kitchenBookings.endTime,
            totalPrice: kitchenBookings.totalPrice,
            serviceFee: kitchenBookings.serviceFee,
            paymentStatus: kitchenBookings.paymentStatus,
            paymentIntentId: kitchenBookings.paymentIntentId,
            kitchenName: kitchens.name,
            locationName: locations.name,
            chefName: users.username,
            chefEmail: users.username
          }).from(kitchenBookings).innerJoin(kitchens, eq30(kitchenBookings.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).leftJoin(users, eq30(kitchenBookings.chefId, users.id)).where(
            and18(
              eq30(locations.managerId, managerId),
              eq30(kitchenBookings.paymentStatus, "paid"),
              sql15`DATE(${kitchenBookings.bookingDate}) >= ${periodStart.toISOString().split("T")[0]}::date`,
              sql15`DATE(${kitchenBookings.bookingDate}) <= ${payoutDate.toISOString().split("T")[0]}::date`
            )
          ).orderBy(desc15(kitchenBookings.bookingDate));
          const { getBalanceTransactions: getBalanceTransactions2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
          const transactions = await getBalanceTransactions2(
            accountId,
            periodStart,
            payoutDate,
            100
          );
          const { generatePayoutStatementPDF: generatePayoutStatementPDF2 } = await Promise.resolve().then(() => (init_payout_statement_service(), payout_statement_service_exports));
          const pdfBuffer = await generatePayoutStatementPDF2(
            managerId,
            manager.username || "Manager",
            manager.username || "",
            payout,
            transactions,
            bookingRows
          );
          res.setHeader("Content-Type", "application/pdf");
          res.setHeader(
            "Content-Disposition",
            `attachment; filename="payout-statement-${payoutId.substring(3)}.pdf"`
          );
          res.send(pdfBuffer);
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/kitchens/:locationId",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const locationId = parseInt(req.params.locationId);
          const location = await locationService.getLocationById(locationId);
          if (!location) {
            return res.status(404).json({ error: "Location not found" });
          }
          if (location.managerId !== user.id) {
            return res.status(403).json({ error: "Access denied to this location" });
          }
          const kitchens3 = await kitchenService.getKitchensByLocationId(locationId);
          res.json(kitchens3);
        } catch (error) {
          logger.error("Error fetching kitchen settings:", error);
          res.status(500).json({ error: error.message || "Failed to fetch kitchen settings" });
        }
      }
    );
    router15.post(
      "/kitchens",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const { locationId, name, description, features, imageUrl } = req.body;
          const location = await locationService.getLocationById(locationId);
          if (!location) {
            return res.status(404).json({ error: "Location not found" });
          }
          if (location.managerId !== user.id) {
            return res.status(403).json({ error: "Access denied to this location" });
          }
          const created = await kitchenService.createKitchen({
            locationId,
            name,
            description,
            imageUrl,
            amenities: features || [],
            isActive: true,
            // Auto-activate
            hourlyRate: void 0,
            // Manager sets pricing later
            minimumBookingHours: 1,
            pricingModel: "hourly"
          });
          res.status(201).json(created);
        } catch (error) {
          logger.error("Error creating kitchen:", error);
          res.status(500).json({ error: error.message || "Failed to create kitchen" });
        }
      }
    );
    router15.put(
      "/kitchens/:kitchenId/image",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const kitchenId = parseInt(req.params.kitchenId);
          const { imageUrl } = req.body;
          const kitchen = await kitchenService.getKitchenById(kitchenId);
          if (!kitchen) {
            return res.status(404).json({ error: "Kitchen not found" });
          }
          const location = await locationService.getLocationById(
            kitchen.locationId
          );
          if (!location || location.managerId !== user.id) {
            return res.status(403).json({ error: "Access denied" });
          }
          if (imageUrl && kitchen.imageUrl) {
            const { deleteFromR2: deleteFromR22 } = await Promise.resolve().then(() => (init_r2_storage(), r2_storage_exports));
            try {
              if (kitchen.imageUrl !== imageUrl) {
                await deleteFromR22(kitchen.imageUrl);
              }
            } catch (e) {
              logger.error("Failed to delete old image:", e);
            }
          }
          const updated = await kitchenService.updateKitchenImage(
            kitchenId,
            imageUrl
          );
          res.json(updated);
        } catch (error) {
          logger.error("Error updating kitchen image:", error);
          res.status(500).json({ error: error.message || "Failed to update kitchen image" });
        }
      }
    );
    router15.put(
      "/kitchens/:kitchenId/gallery",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const kitchenId = parseInt(req.params.kitchenId);
          const { method, imageUrl, index } = req.body;
          const kitchen = await kitchenService.getKitchenById(kitchenId);
          if (!kitchen) {
            return res.status(404).json({ error: "Kitchen not found" });
          }
          const location = await locationService.getLocationById(
            kitchen.locationId
          );
          if (!location || location.managerId !== user.id) {
            return res.status(403).json({ error: "Access denied" });
          }
          let updatedImages = [...kitchen.galleryImages || []];
          const { deleteFromR2: deleteFromR22 } = await Promise.resolve().then(() => (init_r2_storage(), r2_storage_exports));
          if (method === "add") {
            if (imageUrl) updatedImages.push(imageUrl);
          } else if (method === "remove" && typeof index === "number") {
            if (index >= 0 && index < updatedImages.length) {
              const removedUrl = updatedImages[index];
              updatedImages.splice(index, 1);
              try {
                await deleteFromR22(removedUrl);
              } catch (e) {
                logger.error("Failed to delete removed gallery image:", e);
              }
            }
          } else if (method === "reorder" && Array.isArray(imageUrl)) {
            updatedImages = imageUrl;
          }
          await kitchenService.updateKitchenGallery(kitchenId, updatedImages);
          const updated = await kitchenService.getKitchenById(kitchenId);
          res.json(updated);
        } catch (error) {
          logger.error("Error updating gallery:", error);
          res.status(500).json({ error: error.message || "Failed to update gallery" });
        }
      }
    );
    router15.put(
      "/kitchens/:kitchenId/details",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const kitchenId = parseInt(req.params.kitchenId);
          const { name, description, features } = req.body;
          const kitchen = await kitchenService.getKitchenById(kitchenId);
          if (!kitchen) {
            return res.status(404).json({ error: "Kitchen not found" });
          }
          const location = await locationService.getLocationById(
            kitchen.locationId
          );
          if (!location || location.managerId !== user.id) {
            return res.status(403).json({ error: "Access denied" });
          }
          const updated = await kitchenService.updateKitchen({
            id: kitchenId,
            name,
            description,
            amenities: features
          });
          res.json(updated);
        } catch (error) {
          logger.error("Error updating kitchen details:", error);
          res.status(500).json({ error: error.message || "Failed to update kitchen details" });
        }
      }
    );
    router15.delete(
      "/kitchens/:kitchenId",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const kitchenId = parseInt(req.params.kitchenId);
          const kitchen = await kitchenService.getKitchenById(kitchenId);
          if (!kitchen) {
            return res.status(404).json({ error: "Kitchen not found" });
          }
          const location = await locationService.getLocationById(
            kitchen.locationId
          );
          if (!location || location.managerId !== user.id) {
            return res.status(403).json({ error: "Access denied" });
          }
          const imageUrl = kitchen.imageUrl;
          const galleryImages = kitchen.galleryImages || [];
          await kitchenService.deleteKitchen(kitchenId);
          const { deleteFromR2: deleteFromR22 } = await Promise.resolve().then(() => (init_r2_storage(), r2_storage_exports));
          if (imageUrl) {
            try {
              await deleteFromR22(imageUrl);
            } catch (e) {
              logger.error(`Failed to delete kitchen image ${imageUrl}:`, e);
            }
          }
          if (galleryImages.length > 0) {
            await Promise.all(
              galleryImages.map(async (img) => {
                try {
                  await deleteFromR22(img);
                } catch (e) {
                  logger.error(`Failed to delete gallery image ${img}:`, e);
                }
              })
            );
          }
          res.json({ success: true });
        } catch (error) {
          logger.error("Error deleting kitchen:", error);
          res.status(500).json({ error: error.message || "Failed to delete kitchen" });
        }
      }
    );
    router15.get(
      "/kitchens/:kitchenId/pricing",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const kitchenId = parseInt(req.params.kitchenId);
          const kitchen = await kitchenService.getKitchenById(kitchenId);
          if (!kitchen) {
            return res.status(404).json({ error: "Kitchen not found" });
          }
          const location = await locationService.getLocationById(
            kitchen.locationId
          );
          if (!location || location.managerId !== user.id) {
            return res.status(403).json({ error: "Access denied" });
          }
          res.json({
            hourlyRate: kitchen.hourlyRate,
            // In dollars if getKitchenById handled it, or cents?
            // routes.ts typically converted it?
            // Wait, updateKitchenPricing converts dollars to cents.
            // getKitchenById likely returns cents?
            // Let's check updateKitchenPricing in storage-firebase.ts if needed.
            // But for now, returning raw db value or whatever getKitchenById returns.
            // Typically frontend expects dollars if input was dollars?
            // routes.ts 4350 just sends `res.json(pricing)`.
            // Let's assume getKitchenById returns it as is.
            currency: kitchen.currency,
            minimumBookingHours: kitchen.minimumBookingHours,
            pricingModel: kitchen.pricingModel,
            taxRatePercent: kitchen.taxRatePercent !== void 0 && kitchen.taxRatePercent !== null ? Number(kitchen.taxRatePercent) : null
          });
        } catch (error) {
          logger.error("Error getting kitchen pricing:", error);
          res.status(500).json({ error: error.message || "Failed to get kitchen pricing" });
        }
      }
    );
    router15.put(
      "/kitchens/:kitchenId/pricing",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const kitchenId = parseInt(req.params.kitchenId);
          if (isNaN(kitchenId) || kitchenId <= 0) {
            return res.status(400).json({ error: "Invalid kitchen ID" });
          }
          const kitchen = await kitchenService.getKitchenById(kitchenId);
          if (!kitchen) {
            return res.status(404).json({ error: "Kitchen not found" });
          }
          const locations5 = await locationService.getLocationsByManagerId(user.id);
          const hasAccess = locations5.some((loc) => loc.id === kitchen.locationId);
          if (!hasAccess) {
            return res.status(403).json({ error: "Access denied to this kitchen" });
          }
          const {
            hourlyRate,
            currency,
            minimumBookingHours,
            pricingModel,
            taxRatePercent
          } = req.body;
          if (hourlyRate !== void 0 && hourlyRate !== null && (typeof hourlyRate !== "number" || hourlyRate < 0)) {
            return res.status(400).json({ error: "Hourly rate must be a positive number or null" });
          }
          if (currency !== void 0 && typeof currency !== "string") {
            return res.status(400).json({ error: "Currency must be a string" });
          }
          if (minimumBookingHours !== void 0 && (typeof minimumBookingHours !== "number" || minimumBookingHours < 0 || minimumBookingHours > 24 || !Number.isInteger(minimumBookingHours))) {
            return res.status(400).json({ error: "Minimum booking hours must be a whole number between 0 and 24" });
          }
          if (minimumBookingHours !== void 0 && minimumBookingHours > 0) {
            const locationId = kitchen.locationId;
            if (locationId) {
              const location = await locationService.getLocationById(locationId);
              const dailyLimit = location?.defaultDailyBookingLimit ?? 24;
              if (minimumBookingHours > dailyLimit) {
                return res.status(400).json({
                  error: `Minimum booking hours (${minimumBookingHours}) cannot exceed the location's maximum daily booking limit (${dailyLimit} hours). Please increase the daily limit first or reduce the minimum.`
                });
              }
            }
          }
          if (pricingModel !== void 0 && !["hourly", "daily", "weekly"].includes(pricingModel)) {
            return res.status(400).json({
              error: "Pricing model must be 'hourly', 'daily', or 'weekly'"
            });
          }
          const pricing = {};
          if (hourlyRate !== void 0) {
            pricing.hourlyRate = hourlyRate === null ? null : hourlyRate;
          }
          if (currency !== void 0) pricing.currency = currency;
          if (minimumBookingHours !== void 0)
            pricing.minimumBookingHours = minimumBookingHours;
          if (pricingModel !== void 0) pricing.pricingModel = pricingModel;
          if (taxRatePercent !== void 0) {
            pricing.taxRatePercent = taxRatePercent ? parseFloat(taxRatePercent) : null;
          }
          const updated = await kitchenService.updateKitchen({
            id: kitchenId,
            ...pricing
          });
          logger.info(
            `\u2705 Kitchen ${kitchenId} pricing updated by manager ${user.id}`
          );
          res.json(updated);
        } catch (error) {
          logger.error("Error updating kitchen pricing:", error);
          res.status(500).json({ error: error.message || "Failed to update kitchen pricing" });
        }
      }
    );
    router15.put(
      "/kitchens/:kitchenId/availability",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const kitchenId = parseInt(req.params.kitchenId);
          const { isAvailable, reason } = req.body;
          const kitchen = await kitchenService.getKitchenById(kitchenId);
          if (!kitchen) {
            return res.status(404).json({ error: "Kitchen not found" });
          }
          const locations5 = await locationService.getLocationsByManagerId(user.id);
          const hasAccess = locations5.some((loc) => loc.id === kitchen.locationId);
          if (!hasAccess) {
            return res.status(403).json({ error: "Access denied" });
          }
          if (isAvailable === false) {
          }
          const updated = await kitchenService.updateKitchen({
            id: kitchenId,
            isActive: isAvailable
          });
          res.json(updated);
        } catch (error) {
          logger.error("Error setting availability:", error);
          res.status(500).json({ error: error.message || "Failed to set availability" });
        }
      }
    );
    router15.get(
      "/bookings",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const bookings = await bookingService.getBookingsByManager(user.id);
          const { lazyExpireKitchenBookingAuth: lazyExpireKitchenBookingAuth2 } = await Promise.resolve().then(() => (init_auth_expiry_service(), auth_expiry_service_exports));
          for (const b of bookings) {
            if (b.paymentStatus === "authorized" && b.status === "pending") {
              const wasExpired = await lazyExpireKitchenBookingAuth2({
                id: b.id,
                paymentStatus: b.paymentStatus,
                paymentIntentId: b.paymentIntentId ?? null,
                chefId: b.chefId ?? null,
                kitchenId: b.kitchenId,
                createdAt: b.createdAt ? new Date(b.createdAt) : null,
                status: b.status
              });
              if (wasExpired) {
                b.status = "cancelled";
                b.paymentStatus = "failed";
              }
            }
          }
          res.json(bookings);
        } catch (error) {
          logger.error("Error fetching bookings:", error);
          res.status(500).json({ error: error.message || "Failed to fetch bookings" });
        }
      }
    );
    router15.get(
      "/profile",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const userResults = await db.select().from(users).where(eq30(users.id, managerId)).limit(1);
          const userData = userResults[0];
          if (!userData) {
            return res.status(404).json({ error: "Manager profile not found" });
          }
          const managerLocations = await db.select().from(locations).where(eq30(locations.managerId, managerId));
          let profile = {};
          try {
            const profileData = userData.managerProfileData;
            if (profileData && typeof profileData === "object" && !Array.isArray(profileData)) {
              profile = profileData;
            }
          } catch {
          }
          const stripeStatus = userData.stripeConnectOnboardingStatus || "not_started";
          res.json({
            profileImageUrl: profile.profileImageUrl || null,
            phone: profile.phone || null,
            displayName: profile.displayName || null,
            stripeConnectStatus: stripeStatus,
            locations: managerLocations.map((loc) => ({
              id: loc.id,
              name: loc.name,
              address: loc.address,
              timezone: loc.timezone,
              logoUrl: loc.logoUrl,
              // Primary contact fields
              contactEmail: loc.contactEmail,
              contactPhone: loc.contactPhone,
              preferredContactMethod: loc.preferredContactMethod || "email",
              // Notification fields
              notificationEmail: loc.notificationEmail,
              notificationPhone: loc.notificationPhone
            }))
          });
        } catch (error) {
          logger.error(`[Manager Profile v2] Error:`, error);
          return errorResponse(res, error);
        }
      }
    );
    router15.put(
      "/profile",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const { username, displayName, phone, profileImageUrl } = req.body;
          const profileUpdates = {};
          if (displayName !== void 0) profileUpdates.displayName = displayName;
          if (phone !== void 0) {
            if (phone && phone.trim() !== "") {
              const normalized = normalizePhoneForStorage(phone);
              if (!normalized)
                return res.status(400).json({ error: "Invalid phone" });
              profileUpdates.phone = normalized;
            } else {
              profileUpdates.phone = null;
            }
          }
          if (profileImageUrl !== void 0)
            profileUpdates.profileImageUrl = profileImageUrl;
          if (username !== void 0 && username !== user.username) {
            const existingUser = await userService.getUserByUsername(username);
            if (existingUser && existingUser.id !== user.id) {
              return res.status(400).json({ error: "Username already exists" });
            }
            await userService.updateUser(user.id, { username });
          }
          if (Object.keys(profileUpdates).length > 0) {
            const [currentUser] = await db.select({ managerProfileData: users.managerProfileData }).from(users).where(eq30(users.id, user.id)).limit(1);
            const currentData = currentUser?.managerProfileData || {};
            const newData = { ...currentData, ...profileUpdates };
            await db.update(users).set({ managerProfileData: newData }).where(eq30(users.id, user.id));
          }
          const [updatedUser] = await db.select({ managerProfileData: users.managerProfileData }).from(users).where(eq30(users.id, user.id)).limit(1);
          const finalProfile = updatedUser?.managerProfileData || {};
          res.json({
            profileImageUrl: finalProfile.profileImageUrl || null,
            phone: finalProfile.phone || null,
            displayName: finalProfile.displayName || null
          });
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/chef-profiles",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const profiles = await chefService.getChefProfilesForManager(user.id);
          res.json(profiles);
        } catch (error) {
          res.status(500).json({ error: error.message || "Failed to get profiles" });
        }
      }
    );
    router15.get(
      "/portal-applications",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const { users: users5 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const managedLocations = await db.select().from(locations).where(eq30(locations.managerId, user.id));
          if (managedLocations.length === 0) return res.json([]);
          const locationIds = managedLocations.map((loc) => loc.id);
          const applications4 = await db.select({
            application: portalUserApplications,
            location: locations,
            user: users5
          }).from(portalUserApplications).innerJoin(
            locations,
            eq30(portalUserApplications.locationId, locations.id)
          ).innerJoin(users5, eq30(portalUserApplications.userId, users5.id)).where(inArray8(portalUserApplications.locationId, locationIds));
          const formatted = applications4.map((app2) => ({
            ...app2.application,
            location: {
              id: app2.location.id,
              name: app2.location.name,
              address: app2.location.address
            },
            user: { id: app2.user.id, username: app2.user.username },
            // fields mapped from joins
            id: app2.application.id
            // Ensure ID is correct
          }));
          const accessRecords = await db.select().from(portalUserLocationAccess).where(inArray8(portalUserLocationAccess.locationId, locationIds));
          res.json({ applications: formatted, accessCount: accessRecords.length });
        } catch (error) {
          logger.error("Error getting apps:", error);
          res.status(500).json({ error: error.message });
        }
      }
    );
    router15.put(
      "/portal-applications/:id/status",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        res.status(501).json({ error: "Not fully implemented in refactor yet" });
      }
    );
    router15.put(
      "/chef-profiles/:id/status",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const profileId = parseInt(req.params.id);
          const { status, reviewFeedback } = req.body;
          if (!["approved", "rejected"].includes(status))
            return res.status(400).json({ error: "Invalid status" });
          const updated = await chefService.updateProfileStatus(
            profileId,
            status,
            user.id,
            reviewFeedback
          );
          if (status === "approved") {
          }
          res.json(updated);
        } catch (e) {
          res.status(500).json({ error: e.message });
        }
      }
    );
    router15.delete(
      "/chef-location-access",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const { chefId, locationId } = req.body;
          await chefService.revokeLocationAccess(chefId, locationId);
          res.json({ success: true });
        } catch (e) {
          res.status(500).json({ error: e.message });
        }
      }
    );
    router15.get(
      "/kitchens/:kitchenId/bookings",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const kitchenId = parseInt(req.params.kitchenId);
          const bookings = await bookingService.getBookingsByKitchen(kitchenId);
          res.json(bookings);
        } catch (e) {
          res.status(500).json({ error: e.message });
        }
      }
    );
    router15.get(
      "/bookings/:id",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const id = parseInt(req.params.id);
          const booking = await bookingService.getBookingById(id);
          if (!booking) return res.status(404).json({ error: "Booking not found" });
          const kitchen = await kitchenService.getKitchenById(booking.kitchenId);
          if (!kitchen) return res.status(404).json({ error: "Kitchen not found" });
          const location = await locationService.getLocationById(
            kitchen.locationId
          );
          if (!location || location.managerId !== user.id)
            return res.status(403).json({ error: "Access denied" });
          res.json({ ...booking, kitchen, location });
        } catch (e) {
          res.status(500).json({ error: e.message });
        }
      }
    );
    router15.get(
      "/bookings/:id/details",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const id = parseInt(req.params.id);
          if (isNaN(id) || id <= 0) {
            return res.status(400).json({ error: "Invalid booking ID" });
          }
          const booking = await bookingService.getBookingById(id);
          if (!booking) {
            return res.status(404).json({ error: "Booking not found" });
          }
          const kitchen = await kitchenService.getKitchenById(booking.kitchenId);
          if (!kitchen) {
            return res.status(404).json({ error: "Kitchen not found" });
          }
          const location = await locationService.getLocationById(
            kitchen.locationId
          );
          if (!location || location.managerId !== user.id) {
            return res.status(403).json({ error: "Access denied" });
          }
          let chef = null;
          if (booking.chefId) {
            const chefUser = await userService.getUser(booking.chefId);
            if (chefUser) {
              const [chefApp] = await db.select({
                fullName: chefKitchenApplications.fullName,
                phone: chefKitchenApplications.phone
              }).from(chefKitchenApplications).where(
                and18(
                  eq30(chefKitchenApplications.chefId, booking.chefId),
                  eq30(chefKitchenApplications.locationId, location.id)
                )
              ).limit(1);
              chef = {
                id: chefUser.id,
                username: chefUser.username,
                fullName: chefApp?.fullName || chefUser.username,
                phone: chefApp?.phone || null
              };
            }
          }
          const storageBookingsRaw = await bookingService.getStorageBookingsByKitchenBooking(id);
          let originalStorageIds = /* @__PURE__ */ new Set();
          const originalStorageDates = {};
          try {
            const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
            const kitchenTransaction = await findPaymentTransactionByIntentId2(booking.paymentIntentId || "", db);
            if (kitchenTransaction?.metadata) {
              const metadata = typeof kitchenTransaction.metadata === "string" ? JSON.parse(kitchenTransaction.metadata) : kitchenTransaction.metadata;
              if (metadata?.storage_items && Array.isArray(metadata.storage_items)) {
                for (const item of metadata.storage_items) {
                  if (item.storageBookingId || item.id) {
                    const storageId = item.storageBookingId || item.id;
                    originalStorageIds.add(storageId);
                    const startDate = new Date(item.startDate);
                    const endDate = new Date(item.endDate);
                    const days = Math.max(1, Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24)));
                    originalStorageDates[storageId] = { startDate, endDate, days };
                  }
                }
              }
            }
          } catch {
            originalStorageIds = new Set(storageBookingsRaw.map((sb) => sb.id));
          }
          const originalStorageBookings = storageBookingsRaw.filter((sb) => originalStorageIds.has(sb.id));
          const storageBookingsWithDetails = await Promise.all(
            originalStorageBookings.map(async (sb) => {
              const [listing] = await db.select({
                name: storageListings.name,
                storageType: storageListings.storageType,
                photos: storageListings.photos,
                basePrice: storageListings.basePrice
              }).from(storageListings).where(eq30(storageListings.id, sb.storageListingId)).limit(1);
              const originalDates = originalStorageDates[sb.id];
              let originalPrice = sb.totalPrice;
              let displayStartDate = sb.startDate;
              let displayEndDate = sb.endDate;
              if (originalDates && listing?.basePrice) {
                const dailyRate = parseFloat(listing.basePrice.toString());
                originalPrice = dailyRate * originalDates.days;
                displayStartDate = originalDates.startDate.toISOString();
                displayEndDate = originalDates.endDate.toISOString();
              }
              return {
                ...sb,
                totalPrice: originalPrice,
                startDate: displayStartDate,
                endDate: displayEndDate,
                storageListing: listing || null
              };
            })
          );
          const equipmentBookingsRaw = await bookingService.getEquipmentBookingsByKitchenBooking(id);
          const equipmentBookingsWithDetails = await Promise.all(
            equipmentBookingsRaw.map(async (eb) => {
              const [listing] = await db.select({
                equipmentType: equipmentListings.equipmentType,
                brand: equipmentListings.brand
              }).from(equipmentListings).where(eq30(equipmentListings.id, eb.equipmentListingId)).limit(1);
              return {
                ...eb,
                equipmentListing: listing || null
              };
            })
          );
          let paymentTransaction = null;
          try {
            const [txn] = await db.select({
              amount: paymentTransactions.amount,
              baseAmount: paymentTransactions.baseAmount,
              // Base amount before tax
              serviceFee: paymentTransactions.serviceFee,
              managerRevenue: paymentTransactions.managerRevenue,
              status: paymentTransactions.status,
              stripeProcessingFee: paymentTransactions.stripeProcessingFee,
              paidAt: paymentTransactions.paidAt,
              refundAmount: paymentTransactions.refundAmount,
              netAmount: paymentTransactions.netAmount,
              refundedAt: paymentTransactions.refundedAt,
              refundReason: paymentTransactions.refundReason
            }).from(paymentTransactions).where(
              and18(
                eq30(paymentTransactions.bookingId, id),
                // Include both 'kitchen' and 'bundle' booking types for accurate payment data
                or5(
                  eq30(paymentTransactions.bookingType, "kitchen"),
                  eq30(paymentTransactions.bookingType, "bundle")
                )
              )
            ).limit(1);
            if (txn) {
              paymentTransaction = {
                ...txn,
                amount: txn.amount ? parseFloat(txn.amount) : null,
                baseAmount: txn.baseAmount ? parseFloat(txn.baseAmount) : null,
                // Base before tax
                serviceFee: txn.serviceFee ? parseFloat(txn.serviceFee) : null,
                managerRevenue: txn.managerRevenue ? parseFloat(txn.managerRevenue) : null,
                stripeProcessingFee: txn.stripeProcessingFee ? parseFloat(txn.stripeProcessingFee) : null,
                refundAmount: txn.refundAmount ? parseFloat(txn.refundAmount) : 0,
                netAmount: txn.netAmount ? parseFloat(txn.netAmount) : null,
                refundedAt: txn.refundedAt || null,
                refundReason: txn.refundReason || null
              };
            }
          } catch (err) {
            logger.error("Error fetching payment transaction:", err);
          }
          const hourlyRate = booking.hourlyRate ? parseFloat(booking.hourlyRate.toString()) : 0;
          const durationHours = booking.durationHours ? parseFloat(booking.durationHours.toString()) : 0;
          const calculatedKitchenPrice = Math.round(hourlyRate * durationHours);
          const kitchenOnlyPrice = calculatedKitchenPrice > 0 ? calculatedKitchenPrice : booking.totalPrice || 0;
          res.json({
            ...booking,
            totalPrice: kitchenOnlyPrice,
            // Override with calculated kitchen-only price
            kitchen: {
              id: kitchen.id,
              name: kitchen.name,
              description: kitchen.description,
              photos: kitchen.galleryImages || (kitchen.imageUrl ? [kitchen.imageUrl] : []),
              locationId: kitchen.locationId,
              taxRatePercent: kitchen.taxRatePercent || 0
              // Include tax rate for revenue calculation
            },
            location: {
              id: location.id,
              name: location.name,
              address: location.address,
              timezone: location.timezone
            },
            chef,
            storageBookings: storageBookingsWithDetails,
            equipmentBookings: equipmentBookingsWithDetails,
            paymentTransaction
          });
        } catch (e) {
          logger.error("Error fetching booking details:", e);
          res.status(500).json({ error: e.message || "Failed to fetch booking details" });
        }
      }
    );
    router15.put(
      "/bookings/:id/status",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const id = parseInt(req.params.id);
          const { status, storageActions, equipmentActions, refundOnCancel } = req.body;
          const bLog = logger.child({ bookingId: id, managerId: user.id, targetStatus: status });
          if (!["confirmed", "cancelled", "pending"].includes(status)) {
            return res.status(400).json({
              error: "Invalid status. Must be 'confirmed', 'cancelled', or 'pending'"
            });
          }
          const booking = await bookingService.getBookingById(id);
          if (!booking) {
            return res.status(404).json({ error: "Booking not found" });
          }
          const kitchen = await kitchenService.getKitchenById(booking.kitchenId);
          if (!kitchen) {
            return res.status(404).json({ error: "Kitchen not found" });
          }
          const location = await locationService.getLocationById(
            kitchen.locationId
          );
          if (!location || location.managerId !== user.id) {
            return res.status(403).json({ error: "Access denied to this booking" });
          }
          if (status === "confirmed") {
            const paymentStatus = booking.paymentStatus;
            if (paymentStatus === "pending") {
              return res.status(400).json({
                error: "Cannot confirm booking - payment has not been completed. The chef may have abandoned checkout.",
                paymentStatus
              });
            }
          }
          await bookingService.updateBookingStatus(id, status);
          const storageActionResults = [];
          try {
            const associatedStorageBookings = await bookingService.getStorageBookingsByKitchenBooking(id);
            if (associatedStorageBookings && associatedStorageBookings.length > 0) {
              if (Array.isArray(storageActions) && storageActions.length > 0) {
                const actionMap = /* @__PURE__ */ new Map();
                for (const sa of storageActions) {
                  if (sa.storageBookingId && ["confirmed", "cancelled"].includes(sa.action)) {
                    actionMap.set(sa.storageBookingId, sa.action);
                  }
                }
                for (const storageBooking of associatedStorageBookings) {
                  const action = actionMap.get(storageBooking.id) || status;
                  await bookingService.updateStorageBooking(storageBooking.id, {
                    status: action
                  });
                  storageActionResults.push({ storageBookingId: storageBooking.id, action, success: true });
                  logger.info(
                    `[Manager] Modular approval: storage booking ${storageBooking.id} \u2192 ${action} for kitchen booking ${id}`
                  );
                }
              } else {
                for (const storageBooking of associatedStorageBookings) {
                  await bookingService.updateStorageBooking(storageBooking.id, {
                    status
                  });
                  storageActionResults.push({ storageBookingId: storageBooking.id, action: status, success: true });
                  logger.info(
                    `[Manager] Updated storage booking ${storageBooking.id} to ${status} for kitchen booking ${id}`
                  );
                }
              }
            }
          } catch (storageUpdateError) {
            logger.error(
              `[Manager] Error updating storage bookings for kitchen booking ${id}:`,
              storageUpdateError
            );
          }
          const equipmentActionResults = [];
          try {
            const associatedEquipmentBookings = await bookingService.getEquipmentBookingsByKitchenBooking(id);
            if (associatedEquipmentBookings && associatedEquipmentBookings.length > 0) {
              if (Array.isArray(equipmentActions) && equipmentActions.length > 0) {
                const actionMap = /* @__PURE__ */ new Map();
                for (const ea of equipmentActions) {
                  if (ea.equipmentBookingId && ["confirmed", "cancelled"].includes(ea.action)) {
                    actionMap.set(ea.equipmentBookingId, ea.action);
                  }
                }
                for (const equipmentBooking of associatedEquipmentBookings) {
                  const action = actionMap.get(equipmentBooking.id) || status;
                  await bookingService.updateEquipmentBooking(equipmentBooking.id, {
                    status: action
                  });
                  equipmentActionResults.push({ equipmentBookingId: equipmentBooking.id, action, success: true });
                  logger.info(
                    `[Manager] Modular approval: equipment booking ${equipmentBooking.id} \u2192 ${action} for kitchen booking ${id}`
                  );
                }
              } else {
                for (const equipmentBooking of associatedEquipmentBookings) {
                  await bookingService.updateEquipmentBooking(equipmentBooking.id, {
                    status
                  });
                  equipmentActionResults.push({ equipmentBookingId: equipmentBooking.id, action: status, success: true });
                  logger.info(
                    `[Manager] Updated equipment booking ${equipmentBooking.id} to ${status} for kitchen booking ${id}`
                  );
                }
              }
            }
          } catch (equipmentUpdateError) {
            logger.error(
              `[Manager] Error updating equipment bookings for kitchen booking ${id}:`,
              equipmentUpdateError
            );
          }
          const previousStatus = booking.status;
          const isCancellation = previousStatus === "confirmed" && status === "cancelled";
          const isFromPending = previousStatus === "pending";
          const bookingPaymentIntentId = booking.paymentIntentId;
          const bookingPaymentStatus = booking.paymentStatus;
          const hasValidPayment = bookingPaymentIntentId && (bookingPaymentStatus === "paid" || bookingPaymentStatus === "processing");
          const isAuthorizedPayment = bookingPaymentIntentId && bookingPaymentStatus === "authorized";
          if (isFromPending && isAuthorizedPayment && status === "confirmed") {
            try {
              const { capturePaymentIntent: capturePaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
              const { calculateCheckoutFeesAsync: calculateCheckoutFeesAsync2 } = await Promise.resolve().then(() => (init_stripe_checkout_fee_service(), stripe_checkout_fee_service_exports));
              const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
              const bookingHourlyRate = parseFloat(String(booking.hourlyRate || "0"));
              const bookingDurationHours = parseFloat(String(booking.durationHours || "1"));
              const kitchenOnlyPriceCents = Math.round(bookingHourlyRate * bookingDurationHours);
              const approvedStorageIds = /* @__PURE__ */ new Set();
              const rejectedStorageIds = /* @__PURE__ */ new Set();
              for (const r of storageActionResults) {
                if (r.action === "confirmed") approvedStorageIds.add(r.storageBookingId);
                else if (r.action === "cancelled") rejectedStorageIds.add(r.storageBookingId);
              }
              const approvedEquipmentIds = /* @__PURE__ */ new Set();
              const rejectedEquipmentIds = /* @__PURE__ */ new Set();
              for (const r of equipmentActionResults) {
                if (r.action === "confirmed") approvedEquipmentIds.add(r.equipmentBookingId);
                else if (r.action === "cancelled") rejectedEquipmentIds.add(r.equipmentBookingId);
              }
              let approvedStorageCents = 0;
              let approvedEquipmentCents = 0;
              const assocStorage = await bookingService.getStorageBookingsByKitchenBooking(id);
              for (const sb of assocStorage || []) {
                const price = Math.round(parseFloat(String(sb.totalPrice || "0")));
                if (rejectedStorageIds.has(sb.id)) {
                } else {
                  approvedStorageCents += price;
                  approvedStorageIds.add(sb.id);
                }
              }
              const assocEquip = await bookingService.getEquipmentBookingsByKitchenBooking(id);
              for (const eb of assocEquip || []) {
                const price = Math.round(parseFloat(String(eb.totalPrice || "0")));
                if (rejectedEquipmentIds.has(eb.id)) {
                } else {
                  approvedEquipmentCents += price;
                  approvedEquipmentIds.add(eb.id);
                }
              }
              const approvedSubtotalCents = kitchenOnlyPriceCents + approvedStorageCents + approvedEquipmentCents;
              const taxRatePercent = kitchen?.taxRatePercent ? parseFloat(String(kitchen.taxRatePercent)) : 0;
              const approvedTaxCents = Math.round(approvedSubtotalCents * taxRatePercent / 100);
              const captureAmountCents = approvedSubtotalCents + approvedTaxCents;
              const feeCalc = await calculateCheckoutFeesAsync2(captureAmountCents);
              const newApplicationFeeCents = feeCalc.totalPlatformFeeInCents;
              const originalTotalPriceCents = Math.round(parseFloat(String(booking.totalPrice || "0")));
              const originalTaxCents = Math.round(originalTotalPriceCents * taxRatePercent / 100);
              const originalAuthorizedAmount = originalTotalPriceCents + originalTaxCents;
              const isPartialCapture = captureAmountCents < originalAuthorizedAmount;
              logger.info(`[Manager] PARTIAL CAPTURE ENGINE for booking ${id}:`, {
                kitchenOnlyPriceCents,
                approvedStorageCents,
                approvedEquipmentCents,
                approvedSubtotalCents,
                taxRatePercent,
                approvedTaxCents,
                captureAmountCents,
                originalAuthorizedAmount,
                isPartialCapture,
                newApplicationFeeCents,
                rejectedStorageIds: Array.from(rejectedStorageIds),
                rejectedEquipmentIds: Array.from(rejectedEquipmentIds)
              });
              if (isPartialCapture) {
                try {
                  const ptRecordPreCapture = await findPaymentTransactionByIntentId2(bookingPaymentIntentId, db);
                  if (ptRecordPreCapture) {
                    const existingMeta = ptRecordPreCapture.metadata ? typeof ptRecordPreCapture.metadata === "string" ? JSON.parse(ptRecordPreCapture.metadata) : ptRecordPreCapture.metadata : {};
                    await updatePaymentTransaction2(ptRecordPreCapture.id, {
                      metadata: {
                        ...existingMeta,
                        partialCapture: true,
                        approvedSubtotal: approvedSubtotalCents,
                        approvedTax: approvedTaxCents,
                        taxRatePercent
                      }
                    }, db);
                    logger.info(`[Manager] Pre-set partialCapture metadata on PT ${ptRecordPreCapture.id} BEFORE stripe.capture()`);
                  }
                } catch (preCapErr) {
                  logger.warn(`[Manager] Could not pre-set PT metadata (non-fatal, will retry in Step 9):`, preCapErr);
                }
              }
              const captureResult = isPartialCapture ? await capturePaymentIntent2(bookingPaymentIntentId, captureAmountCents, newApplicationFeeCents) : await capturePaymentIntent2(bookingPaymentIntentId);
              logger.info(`[Manager] AUTH-THEN-CAPTURE: ${isPartialCapture ? "Partial" : "Full"} capture for booking ${id}`, {
                paymentIntentId: bookingPaymentIntentId,
                capturedAmount: captureResult.amount,
                status: captureResult.status
              });
              const currentStorageItems = booking.storageItems || [];
              const currentEquipmentItems = booking.equipmentItems || [];
              const updatedStorageItems = currentStorageItems.map(
                (item) => rejectedStorageIds.has(item.id) ? { ...item, rejected: true } : item
              );
              const updatedEquipmentItems = currentEquipmentItems.map(
                (item) => rejectedEquipmentIds.has(item.id) ? { ...item, rejected: true } : item
              );
              await db.update(kitchenBookings).set({
                paymentStatus: "paid",
                totalPrice: approvedSubtotalCents.toString(),
                storageItems: updatedStorageItems,
                equipmentItems: updatedEquipmentItems,
                updatedAt: /* @__PURE__ */ new Date()
              }).where(eq30(kitchenBookings.id, id));
              logger.info(`[Manager] Updated kb: total_price=${approvedSubtotalCents} (approved subtotal), marked ${rejectedStorageIds.size} rejected storage + ${rejectedEquipmentIds.size} rejected equipment in JSONB`);
              for (const sb of assocStorage || []) {
                if (rejectedStorageIds.has(sb.id)) {
                  await db.update(storageBookings).set({ paymentStatus: "failed", updatedAt: /* @__PURE__ */ new Date() }).where(eq30(storageBookings.id, sb.id));
                } else {
                  await db.update(storageBookings).set({ paymentStatus: "paid", updatedAt: /* @__PURE__ */ new Date() }).where(eq30(storageBookings.id, sb.id));
                }
              }
              for (const eb of assocEquip || []) {
                if (rejectedEquipmentIds.has(eb.id)) {
                  await db.update(equipmentBookings).set({ paymentStatus: "failed", updatedAt: /* @__PURE__ */ new Date() }).where(eq30(equipmentBookings.id, eb.id));
                } else {
                  await db.update(equipmentBookings).set({ paymentStatus: "paid", updatedAt: /* @__PURE__ */ new Date() }).where(eq30(equipmentBookings.id, eb.id));
                }
              }
              try {
                const ptRecord = await findPaymentTransactionByIntentId2(bookingPaymentIntentId, db);
                if (ptRecord) {
                  const capturedBaseAmount = captureAmountCents - newApplicationFeeCents;
                  const capturedManagerRevenue = capturedBaseAmount;
                  const existingMetadata = ptRecord.metadata ? typeof ptRecord.metadata === "string" ? JSON.parse(ptRecord.metadata) : ptRecord.metadata : {};
                  const captureMetadata = {
                    ...existingMetadata,
                    partialCapture: isPartialCapture,
                    capturedAmount: captureAmountCents,
                    originalAuthorizedAmount,
                    approvedSubtotal: approvedSubtotalCents,
                    approvedTax: approvedTaxCents,
                    taxRatePercent,
                    applicationFee: newApplicationFeeCents,
                    approvedStorageIds: Array.from(approvedStorageIds),
                    approvedEquipmentIds: Array.from(approvedEquipmentIds),
                    rejectedStorageIds: Array.from(rejectedStorageIds),
                    rejectedEquipmentIds: Array.from(rejectedEquipmentIds),
                    capturedAt: (/* @__PURE__ */ new Date()).toISOString()
                  };
                  await updatePaymentTransaction2(ptRecord.id, {
                    status: "succeeded",
                    stripeStatus: "succeeded",
                    paidAt: /* @__PURE__ */ new Date(),
                    amount: captureAmountCents,
                    metadata: captureMetadata
                  }, db);
                  await db.execute(sql15`
                UPDATE payment_transactions
                SET base_amount = ${capturedBaseAmount.toString()},
                    service_fee = ${newApplicationFeeCents.toString()},
                    manager_revenue = ${capturedManagerRevenue.toString()},
                    net_amount = ${captureAmountCents.toString()}
                WHERE id = ${ptRecord.id}
              `);
                  logger.info(`[Manager] Updated payment_transactions ${ptRecord.id}: amount=${captureAmountCents}, base=${capturedBaseAmount}, fee=${newApplicationFeeCents}, revenue=${capturedManagerRevenue}`);
                }
              } catch (ptErr) {
                logger.warn(`[Manager] Could not update payment_transactions after capture:`, ptErr);
              }
            } catch (captureError) {
              bLog.error(`[Manager] PARTIAL CAPTURE ENGINE: Failed for booking ${id}:`, captureError);
              Sentry4.captureException(captureError, {
                tags: { component: "partial_capture_engine", bookingId: String(id) },
                extra: { managerId: user.id, paymentIntentId: bookingPaymentIntentId }
              });
              return res.status(500).json({
                error: "Failed to capture payment. The authorization may have expired. Please contact the chef to re-book.",
                details: captureError.message
              });
            }
          }
          let refundResult = null;
          if (isFromPending && isAuthorizedPayment && status === "cancelled") {
            try {
              const { cancelPaymentIntent: cancelPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
              const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
              const cancelResult = await cancelPaymentIntent2(bookingPaymentIntentId);
              logger.info(`[Manager] AUTH-THEN-CAPTURE: Cancelled authorization for booking ${id}`, {
                paymentIntentId: bookingPaymentIntentId,
                status: cancelResult.status
              });
              await db.update(kitchenBookings).set({ paymentStatus: "failed", updatedAt: /* @__PURE__ */ new Date() }).where(eq30(kitchenBookings.id, id));
              try {
                const assocStorage = await bookingService.getStorageBookingsByKitchenBooking(id);
                for (const sb of assocStorage || []) {
                  if (sb.paymentStatus === "authorized") {
                    await db.update(storageBookings).set({ paymentStatus: "failed", updatedAt: /* @__PURE__ */ new Date() }).where(eq30(storageBookings.id, sb.id));
                  }
                }
                const assocEquip = await bookingService.getEquipmentBookingsByKitchenBooking(id);
                for (const eb of assocEquip || []) {
                  if (eb.paymentStatus === "authorized") {
                    await db.update(equipmentBookings).set({ paymentStatus: "failed", updatedAt: /* @__PURE__ */ new Date() }).where(eq30(equipmentBookings.id, eb.id));
                  }
                }
              } catch (subBookErr) {
                logger.warn(`[Manager] Could not update sub-booking paymentStatus after auth cancel:`, subBookErr);
              }
              try {
                const ptRecord = await findPaymentTransactionByIntentId2(bookingPaymentIntentId, db);
                if (ptRecord) {
                  await updatePaymentTransaction2(ptRecord.id, {
                    status: "canceled",
                    stripeStatus: "canceled"
                  }, db);
                  logger.info(`[Manager] Updated payment_transactions ${ptRecord.id} to canceled after auth cancel`);
                }
              } catch (ptErr) {
                logger.warn(`[Manager] Could not update payment_transactions after auth cancel:`, ptErr);
              }
            } catch (cancelError) {
              logger.error(`[Manager] AUTH-THEN-CAPTURE: Failed to cancel authorization for booking ${id}:`, cancelError);
            }
          }
          const shouldAutoRefund = isFromPending && hasValidPayment && !isCancellation || isCancellation && refundOnCancel && hasValidPayment;
          if (shouldAutoRefund) {
            try {
              const { reverseTransferAndRefund: reverseTransferAndRefund2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
              const {
                findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2,
                updatePaymentTransaction: updatePaymentTransaction2
              } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
              const kitchenWasRejected = status === "cancelled";
              let rejectedStorageIds = [];
              if (Array.isArray(storageActions) && storageActions.length > 0) {
                rejectedStorageIds = storageActions.filter((sa) => sa.action === "cancelled").map((sa) => sa.storageBookingId);
              } else if (kitchenWasRejected) {
                rejectedStorageIds = storageActionResults.filter((r) => r.action === "cancelled").map((r) => r.storageBookingId);
              }
              let rejectedEquipmentIds = [];
              if (Array.isArray(equipmentActions) && equipmentActions.length > 0) {
                rejectedEquipmentIds = equipmentActions.filter((ea) => ea.action === "cancelled").map((ea) => ea.equipmentBookingId);
              } else if (kitchenWasRejected) {
                rejectedEquipmentIds = equipmentActionResults.filter((r) => r.action === "cancelled").map((r) => r.equipmentBookingId);
              }
              let rejectedKitchenCents = 0;
              if (kitchenWasRejected) {
                rejectedKitchenCents = parseInt(String(booking.totalPrice || "0")) || 0;
              }
              let rejectedStorageTotalCents = 0;
              if (rejectedStorageIds.length > 0) {
                const rejectedRows = await db.select({
                  id: storageBookings.id,
                  totalPrice: storageBookings.totalPrice
                }).from(storageBookings).where(
                  sql15`${storageBookings.id} IN (${sql15.join(
                    rejectedStorageIds.map((rid) => sql15`${rid}`),
                    sql15`, `
                  )})`
                );
                for (const row of rejectedRows) {
                  rejectedStorageTotalCents += parseInt(String(row.totalPrice || "0")) || 0;
                }
              }
              let rejectedEquipmentTotalCents = 0;
              if (rejectedEquipmentIds.length > 0) {
                const rejectedEqRows = await db.select({
                  id: equipmentBookings.id,
                  totalPrice: equipmentBookings.totalPrice
                }).from(equipmentBookings).where(
                  sql15`${equipmentBookings.id} IN (${sql15.join(
                    rejectedEquipmentIds.map((rid) => sql15`${rid}`),
                    sql15`, `
                  )})`
                );
                for (const row of rejectedEqRows) {
                  rejectedEquipmentTotalCents += parseInt(String(row.totalPrice || "0")) || 0;
                }
              }
              const totalRejectedSubtotalCents = rejectedKitchenCents + rejectedStorageTotalCents + rejectedEquipmentTotalCents;
              if (totalRejectedSubtotalCents > 0) {
                const paymentTransaction = await findPaymentTransactionByIntentId2(
                  bookingPaymentIntentId,
                  db
                );
                const transactionAmount = paymentTransaction ? parseInt(String(paymentTransaction.amount || "0")) || 0 : 0;
                const baseAmount = paymentTransaction ? parseInt(String(paymentTransaction.base_amount || "0")) || 0 : 0;
                const stripeProcessingFee = paymentTransaction ? parseInt(String(paymentTransaction.stripe_processing_fee || "0")) || 0 : 0;
                const managerRevenue = paymentTransaction ? parseInt(String(paymentTransaction.manager_revenue || "0")) || 0 : transactionAmount;
                const currentRefundAmount = paymentTransaction ? parseInt(String(paymentTransaction.refund_amount || "0")) || 0 : 0;
                const taxRatePercent = kitchen.taxRatePercent ? parseFloat(String(kitchen.taxRatePercent)) : 0;
                const proportionalTaxCents = Math.round(
                  totalRejectedSubtotalCents * taxRatePercent / 100
                );
                const grossRefundCents = totalRejectedSubtotalCents + proportionalTaxCents;
                const proportionalStripeFee = transactionAmount > 0 ? Math.round(stripeProcessingFee * (grossRefundCents / transactionAmount)) : 0;
                const netRefundCents = Math.max(0, grossRefundCents - proportionalStripeFee);
                const managerRemainingBalance = Math.max(0, managerRevenue - currentRefundAmount);
                const cappedRefundAmount = Math.min(netRefundCents, managerRemainingBalance);
                const rejectedItems = [];
                if (kitchenWasRejected) rejectedItems.push("kitchen_booking");
                if (rejectedStorageIds.length > 0) rejectedItems.push(...rejectedStorageIds.map((sid) => `storage_${sid}`));
                if (rejectedEquipmentIds.length > 0) rejectedItems.push(...rejectedEquipmentIds.map((eid) => `equipment_${eid}`));
                const isFullRefund = cappedRefundAmount >= managerRemainingBalance;
                const refundType = kitchenWasRejected ? rejectedStorageIds.length > 0 || rejectedEquipmentIds.length > 0 ? "kitchen_and_items" : "kitchen_only" : "items_only";
                if (cappedRefundAmount > 0) {
                  const stripeResult = await reverseTransferAndRefund2(
                    bookingPaymentIntentId,
                    cappedRefundAmount,
                    "requested_by_customer",
                    {
                      reverseTransferAmount: cappedRefundAmount,
                      refundApplicationFee: false,
                      metadata: {
                        booking_id: String(id),
                        booking_type: refundType,
                        cancellation_reason: kitchenWasRejected ? "Booking rejected by manager" : "Item(s) rejected by manager (partial approval)",
                        manager_id: String(user.id),
                        refund_model: "tax_inclusive_proportional_stripe_deducted",
                        rejected_kitchen: String(kitchenWasRejected),
                        rejected_kitchen_cents: String(rejectedKitchenCents),
                        rejected_storage_ids: JSON.stringify(rejectedStorageIds),
                        rejected_storage_cents: String(rejectedStorageTotalCents),
                        rejected_equipment_ids: JSON.stringify(rejectedEquipmentIds),
                        rejected_equipment_cents: String(rejectedEquipmentTotalCents),
                        total_rejected_subtotal_cents: String(totalRejectedSubtotalCents),
                        proportional_tax_cents: String(proportionalTaxCents),
                        tax_rate_percent: String(taxRatePercent),
                        gross_refund_cents: String(grossRefundCents),
                        proportional_stripe_fee_cents: String(proportionalStripeFee),
                        total_stripe_fee: String(stripeProcessingFee),
                        net_refund_cents: String(netRefundCents),
                        transaction_amount: String(transactionAmount),
                        base_amount: String(baseAmount),
                        manager_revenue: String(managerRevenue),
                        customer_receives: String(cappedRefundAmount),
                        manager_debited: String(cappedRefundAmount)
                      }
                    }
                  );
                  refundResult = {
                    refundId: stripeResult.refundId,
                    refundAmount: stripeResult.refundAmount,
                    transferReversalId: stripeResult.transferReversalId,
                    rejectedItems
                  };
                  logger.info(`[Manager] Unified refund processed for booking ${id}`, {
                    refundId: refundResult.refundId,
                    refundAmount: refundResult.refundAmount,
                    refundType,
                    kitchenRejected: kitchenWasRejected,
                    rejectedKitchenCents,
                    rejectedStorageIds,
                    rejectedStorageTotalCents,
                    rejectedEquipmentIds,
                    rejectedEquipmentTotalCents,
                    totalRejectedSubtotalCents,
                    proportionalTaxCents,
                    grossRefundCents,
                    proportionalStripeFee,
                    totalStripeFee: stripeProcessingFee,
                    netRefundCents,
                    cappedRefundAmount,
                    isFullRefund
                  });
                  if (paymentTransaction) {
                    const newTotalRefunded = currentRefundAmount + refundResult.refundAmount;
                    const newStatus = newTotalRefunded >= managerRevenue ? "refunded" : "partially_refunded";
                    await updatePaymentTransaction2(
                      paymentTransaction.id,
                      {
                        status: newStatus,
                        refundAmount: newTotalRefunded,
                        refundId: refundResult.refundId,
                        refundReason: kitchenWasRejected ? `Booking rejected by manager (${refundType})` : `Partial refund: rejected ${rejectedStorageIds.length} storage + ${rejectedEquipmentIds.length} equipment`,
                        refundedAt: /* @__PURE__ */ new Date()
                      },
                      db
                    );
                  }
                  if (kitchenWasRejected) {
                    await db.update(kitchenBookings).set({ paymentStatus: isFullRefund ? "refunded" : "partially_refunded", updatedAt: /* @__PURE__ */ new Date() }).where(eq30(kitchenBookings.id, id));
                  } else if (totalRejectedSubtotalCents > 0) {
                    await db.update(kitchenBookings).set({ paymentStatus: "partially_refunded", updatedAt: /* @__PURE__ */ new Date() }).where(eq30(kitchenBookings.id, id));
                  }
                  for (const rejectedId of rejectedStorageIds) {
                    await db.update(storageBookings).set({ paymentStatus: "refunded", updatedAt: /* @__PURE__ */ new Date() }).where(eq30(storageBookings.id, rejectedId));
                  }
                  for (const rejectedId of rejectedEquipmentIds) {
                    await db.update(equipmentBookings).set({ paymentStatus: "refunded", updatedAt: /* @__PURE__ */ new Date() }).where(eq30(equipmentBookings.id, rejectedId));
                  }
                  if (rejectedStorageIds.length > 0 || rejectedEquipmentIds.length > 0) {
                    const rejStorageSet = new Set(rejectedStorageIds);
                    const rejEquipSet = new Set(rejectedEquipmentIds);
                    const curStorage = booking.storageItems || [];
                    const curEquip = booking.equipmentItems || [];
                    const markedStorage = curStorage.map((item) => rejStorageSet.has(item.id) ? { ...item, rejected: true } : item);
                    const markedEquip = curEquip.map((item) => rejEquipSet.has(item.id) ? { ...item, rejected: true } : item);
                    await db.update(kitchenBookings).set({ storageItems: markedStorage, equipmentItems: markedEquip, updatedAt: /* @__PURE__ */ new Date() }).where(eq30(kitchenBookings.id, id));
                  }
                }
              }
            } catch (refundError) {
              bLog.error(
                `[Manager] Failed to process refund for booking ${id}:`,
                refundError
              );
              Sentry4.captureException(refundError, {
                tags: { component: "unified_refund_engine", bookingId: String(id) },
                extra: { managerId: user.id, paymentIntentId: bookingPaymentIntentId }
              });
            }
          }
          const cancelledStorageIdsFromActions = new Set(
            storageActionResults.filter((r) => r.action === "cancelled").map((r) => r.storageBookingId)
          );
          const cancelledEquipmentIdsFromActions = new Set(
            equipmentActionResults.filter((r) => r.action === "cancelled").map((r) => r.equipmentBookingId)
          );
          if (cancelledStorageIdsFromActions.size > 0 || cancelledEquipmentIdsFromActions.size > 0) {
            try {
              const [currentBookingJsonb] = await db.select({ storageItems: kitchenBookings.storageItems, equipmentItems: kitchenBookings.equipmentItems }).from(kitchenBookings).where(eq30(kitchenBookings.id, id));
              if (currentBookingJsonb) {
                const curStorage = Array.isArray(currentBookingJsonb.storageItems) ? currentBookingJsonb.storageItems : [];
                const curEquip = Array.isArray(currentBookingJsonb.equipmentItems) ? currentBookingJsonb.equipmentItems : [];
                const needsStorageUpdate = curStorage.some((item) => cancelledStorageIdsFromActions.has(item.id) && !item.rejected);
                const needsEquipmentUpdate = curEquip.some((item) => cancelledEquipmentIdsFromActions.has(item.id) && !item.rejected);
                if (needsStorageUpdate || needsEquipmentUpdate) {
                  const updatedStorage = curStorage.map(
                    (item) => cancelledStorageIdsFromActions.has(item.id) ? { ...item, rejected: true } : item
                  );
                  const updatedEquip = curEquip.map(
                    (item) => cancelledEquipmentIdsFromActions.has(item.id) ? { ...item, rejected: true } : item
                  );
                  await db.update(kitchenBookings).set({ storageItems: updatedStorage, equipmentItems: updatedEquip, updatedAt: /* @__PURE__ */ new Date() }).where(eq30(kitchenBookings.id, id));
                  logger.info(`[Manager] JSONB sync: marked ${cancelledStorageIdsFromActions.size} storage + ${cancelledEquipmentIdsFromActions.size} equipment as rejected in JSONB for booking ${id}`);
                }
              }
            } catch (jsonbSyncErr) {
              logger.warn(`[Manager] JSONB sync failed for booking ${id}:`, jsonbSyncErr);
            }
          }
          try {
            let chef = null;
            if (booking.chefId) {
              chef = await userService.getUser(booking.chefId);
            }
            const timezone = location.timezone || "America/St_Johns";
            const locationName = location.name;
            const locationAddress = location.address || void 0;
            const storageItems = Array.isArray(booking.storageItems) ? booking.storageItems : [];
            const equipmentItems = Array.isArray(booking.equipmentItems) ? booking.equipmentItems : [];
            const activeStorage = storageItems.filter((s) => !s.rejected);
            const activeEquipment = equipmentItems.filter((e) => !e.rejected);
            const addonParts = [];
            if (activeStorage.length > 0) addonParts.push(`${activeStorage.length} storage unit${activeStorage.length > 1 ? "s" : ""}`);
            if (activeEquipment.length > 0) addonParts.push(`${activeEquipment.length} equipment item${activeEquipment.length > 1 ? "s" : ""}`);
            const addons = addonParts.length > 0 ? addonParts.join(", ") : void 0;
            if (chef) {
              if (status === "confirmed") {
                const chefConfirmationEmail = generateBookingConfirmationEmail({
                  chefEmail: chef.username,
                  chefName: chef.username,
                  kitchenName: kitchen.name,
                  bookingDate: booking.bookingDate,
                  startTime: booking.startTime,
                  endTime: booking.endTime,
                  timezone,
                  locationName,
                  locationAddress,
                  addons
                });
                const emailSent = await sendEmail(chefConfirmationEmail, { trackingId: `booking_${id}_confirmed_chef` });
                if (emailSent) {
                  logger.info(
                    `[Manager] \u2705 Sent booking confirmation email to chef: ${chef.username}`
                  );
                } else {
                  logger.error(
                    `[Manager] \u274C Failed to send booking confirmation email to chef: ${chef.username}`
                  );
                }
                try {
                  const chefPhone = await getChefPhone(booking.chefId);
                  if (chefPhone) {
                    const smsContent = generateChefBookingConfirmationSMS({
                      kitchenName: kitchen.name,
                      bookingDate: booking.bookingDate instanceof Date ? booking.bookingDate.toISOString() : String(booking.bookingDate),
                      startTime: booking.startTime,
                      endTime: booking.endTime
                    });
                    await sendSMS(chefPhone, smsContent);
                  }
                } catch (smsError) {
                  logger.error(
                    "Error sending confirmation SMS to chef:",
                    smsError
                  );
                }
                if (location.notificationEmail) {
                  try {
                    const managerConfirmEmail = generateBookingStatusChangeNotificationEmail({
                      managerEmail: location.notificationEmail,
                      chefName: chef.username,
                      kitchenName: kitchen.name,
                      bookingDate: booking.bookingDate,
                      startTime: booking.startTime,
                      endTime: booking.endTime,
                      status: "confirmed",
                      timezone,
                      locationName,
                      addons
                    });
                    const managerEmailSent = await sendEmail(managerConfirmEmail, { trackingId: `booking_${id}_confirmed_manager` });
                    if (managerEmailSent) {
                      logger.info(`[Manager] \u2705 Sent booking confirmed email to manager: ${location.notificationEmail}`);
                    } else {
                      logger.error(`[Manager] \u274C Failed to send booking confirmed email to manager: ${location.notificationEmail}`);
                    }
                  } catch (managerEmailError) {
                    logger.error(`[Manager] Error sending booking confirmed email to manager:`, managerEmailError);
                  }
                }
                logger.info(
                  `[Manager] Booking ${id} confirmed by manager ${user.id}`
                );
                try {
                  await notificationService.notifyBookingConfirmed({
                    managerId: user.id,
                    locationId: location.id,
                    bookingId: id,
                    chefName: chef.username || "Chef",
                    kitchenName: kitchen.name,
                    bookingDate: booking.bookingDate instanceof Date ? booking.bookingDate.toISOString().split("T")[0] : String(booking.bookingDate).split("T")[0],
                    startTime: booking.startTime,
                    endTime: booking.endTime
                  });
                } catch (notifError) {
                  logger.error(
                    "Error creating confirmation notification:",
                    notifError
                  );
                }
              } else if (status === "cancelled") {
                const chefCancellationEmail = generateBookingCancellationEmail({
                  chefEmail: chef.username,
                  chefName: chef.username,
                  kitchenName: kitchen.name,
                  bookingDate: booking.bookingDate instanceof Date ? booking.bookingDate.toISOString() : String(booking.bookingDate),
                  startTime: booking.startTime,
                  endTime: booking.endTime,
                  cancellationReason: "Booking was declined by the kitchen manager"
                });
                const cancelEmailSent = await sendEmail(chefCancellationEmail, { trackingId: `booking_${id}_cancelled_chef` });
                if (cancelEmailSent) {
                  logger.info(
                    `[Manager] \u2705 Sent booking cancellation email to chef: ${chef.username}`
                  );
                } else {
                  logger.error(
                    `[Manager] \u274C Failed to send booking cancellation email to chef: ${chef.username}`
                  );
                }
                try {
                  const chefPhone = await getChefPhone(booking.chefId);
                  if (chefPhone) {
                    const smsContent = generateChefBookingCancellationSMS({
                      kitchenName: kitchen.name,
                      bookingDate: booking.bookingDate instanceof Date ? booking.bookingDate.toISOString() : String(booking.bookingDate),
                      startTime: booking.startTime,
                      endTime: booking.endTime,
                      reason: "Booking was declined by the kitchen manager"
                    });
                    await sendSMS(chefPhone, smsContent);
                  }
                } catch (smsError) {
                  logger.error(
                    "Error sending cancellation SMS to chef:",
                    smsError
                  );
                }
                logger.info(
                  `[Manager] Booking ${id} cancelled/declined by manager ${user.id}`
                );
                try {
                  await notificationService.notifyBookingCancelled({
                    managerId: user.id,
                    locationId: location.id,
                    bookingId: id,
                    chefName: chef.username || "Chef",
                    kitchenName: kitchen.name,
                    bookingDate: booking.bookingDate instanceof Date ? booking.bookingDate.toISOString().split("T")[0] : String(booking.bookingDate).split("T")[0],
                    startTime: booking.startTime,
                    endTime: booking.endTime,
                    cancelledBy: "manager"
                  });
                } catch (notifError) {
                  logger.error(
                    "Error creating cancellation notification:",
                    notifError
                  );
                }
              }
            }
          } catch (emailError) {
            logger.error(
              "Error sending booking status change emails:",
              emailError
            );
          }
          const responseData = {
            success: true,
            message: `Booking ${status === "confirmed" ? "approved" : status}`,
            storageActions: storageActionResults.length > 0 ? storageActionResults : void 0,
            equipmentActions: equipmentActionResults.length > 0 ? equipmentActionResults : void 0
          };
          if (refundResult) {
            const isFullRejection = status === "cancelled";
            responseData.refund = {
              refundId: refundResult.refundId,
              amount: refundResult.refundAmount,
              rejectedItems: refundResult.rejectedItems,
              message: isFullRejection ? "Refund processed for rejected items (customer absorbs proportional Stripe fee)" : "Partial refund processed for rejected items (customer absorbs proportional Stripe fee)"
            };
            responseData.message = isFullRejection ? "Booking rejected and refund processed" : "Booking approved with partial rejection. Refund processed for rejected items.";
          } else if (isFromPending && isAuthorizedPayment && status === "cancelled") {
            responseData.authorizationVoided = true;
            responseData.message = "Booking rejected \u2014 payment hold released. No charge was made.";
          } else if (isCancellation && !refundOnCancel) {
            responseData.requiresManualRefund = true;
            responseData.message = "Booking cancelled. Use 'Issue Refund' to process refund manually.";
          } else if (isCancellation && refundOnCancel && !refundResult) {
            responseData.requiresManualRefund = true;
            responseData.message = "Booking cancelled but refund could not be processed automatically. Use 'Issue Refund' to process manually.";
          }
          res.json(responseData);
        } catch (e) {
          logger.error("Error updating booking status:", e);
          Sentry4.captureException(e, {
            tags: { component: "manager_booking_status" },
            extra: { bookingId: req.params.id }
          });
          res.status(500).json({ error: e.message || "Failed to update booking status" });
        }
      }
    );
    router15.get(
      "/kitchens/:kitchenId/date-overrides",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const kitchenId = parseInt(req.params.kitchenId);
          const { startDate, endDate } = req.query;
          const start = startDate ? new Date(startDate) : /* @__PURE__ */ new Date();
          const end = endDate ? new Date(endDate) : new Date((/* @__PURE__ */ new Date()).setFullYear((/* @__PURE__ */ new Date()).getFullYear() + 1));
          const overrides = await kitchenService.getKitchenDateOverrides(
            kitchenId,
            start,
            end
          );
          res.json(overrides);
        } catch (e) {
          res.status(500).json({ error: e.message });
        }
      }
    );
    router15.post(
      "/kitchens/:kitchenId/date-overrides",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const kitchenId = parseInt(req.params.kitchenId);
          const { specificDate, startTime, endTime, isAvailable, reason } = req.body;
          const parseDateString = (dateStr) => {
            const [year, month, day] = dateStr.split("-").map(Number);
            return new Date(Date.UTC(year, month - 1, day, 12, 0, 0));
          };
          const parsedDate = parseDateString(specificDate);
          const override = await kitchenService.createKitchenDateOverride({
            kitchenId,
            specificDate: parsedDate,
            startTime,
            endTime,
            isAvailable: isAvailable !== void 0 ? isAvailable : false,
            reason
          });
          res.json(override);
        } catch (e) {
          res.status(500).json({ error: e.message });
        }
      }
    );
    router15.put(
      "/date-overrides/:id",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const id = parseInt(req.params.id);
          const { startTime, endTime, isAvailable, reason } = req.body;
          await kitchenService.updateKitchenDateOverride(id, {
            id,
            startTime,
            endTime,
            isAvailable,
            reason
          });
          res.json({ success: true });
        } catch (e) {
          res.status(500).json({ error: e.message });
        }
      }
    );
    router15.delete(
      "/date-overrides/:id",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const id = parseInt(req.params.id);
          await kitchenService.deleteKitchenDateOverride(id);
          res.json({ success: true });
        } catch (e) {
          res.status(500).json({ error: e.message });
        }
      }
    );
    router15.put(
      "/locations/:locationId/cancellation-policy",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        logger.info(
          "[PUT] /api/manager/locations/:locationId/cancellation-policy hit",
          {
            locationId: req.params.locationId,
            body: req.body
          }
        );
        try {
          const user = req.neonUser;
          const { locationId } = req.params;
          const locationIdNum = parseInt(locationId);
          if (isNaN(locationIdNum) || locationIdNum <= 0) {
            logger.error("[PUT] Invalid locationId:", locationId);
            return res.status(400).json({ error: "Invalid location ID" });
          }
          const {
            cancellationPolicyHours,
            cancellationPolicyMessage,
            defaultDailyBookingLimit,
            minimumBookingWindowHours,
            notificationEmail,
            notificationPhone,
            logoUrl,
            brandImageUrl,
            timezone,
            description,
            customOnboardingLink
          } = req.body;
          logger.info("[PUT] Request body:", {
            cancellationPolicyHours,
            cancellationPolicyMessage,
            defaultDailyBookingLimit,
            minimumBookingWindowHours,
            notificationEmail,
            logoUrl,
            brandImageUrl,
            timezone,
            locationId: locationIdNum
          });
          if (cancellationPolicyHours !== void 0 && (typeof cancellationPolicyHours !== "number" || cancellationPolicyHours < 0)) {
            return res.status(400).json({
              error: "Cancellation policy hours must be a non-negative number"
            });
          }
          if (defaultDailyBookingLimit !== void 0 && (typeof defaultDailyBookingLimit !== "number" || defaultDailyBookingLimit < 1 || defaultDailyBookingLimit > 24)) {
            return res.status(400).json({
              error: "Daily booking limit must be between 1 and 24 hours"
            });
          }
          if (defaultDailyBookingLimit !== void 0) {
            const locationKitchens = await db.select({ id: kitchens.id, name: kitchens.name, minimumBookingHours: kitchens.minimumBookingHours }).from(kitchens).where(eq30(kitchens.locationId, locationIdNum));
            const conflicting = locationKitchens.filter((k) => {
              const minHours = k.minimumBookingHours ? parseFloat(String(k.minimumBookingHours)) : 0;
              return minHours > defaultDailyBookingLimit;
            });
            if (conflicting.length > 0) {
              const names = conflicting.map((k) => k.name).join(", ");
              return res.status(400).json({
                error: `Cannot set daily limit to ${defaultDailyBookingLimit} hours. The following kitchen(s) have a minimum booking requirement that exceeds this limit: ${names}. Please reduce their minimum booking hours first.`
              });
            }
          }
          if (minimumBookingWindowHours !== void 0 && (typeof minimumBookingWindowHours !== "number" || !Number.isInteger(minimumBookingWindowHours) || minimumBookingWindowHours < 0 || minimumBookingWindowHours > 168)) {
            return res.status(400).json({
              error: "Minimum booking window hours must be a whole number between 0 and 168"
            });
          }
          const locationResults = await db.select().from(locations).where(
            and18(
              eq30(locations.id, locationIdNum),
              eq30(locations.managerId, user.id)
            )
          );
          const location = locationResults[0];
          if (!location) {
            logger.error("[PUT] Location not found or access denied:", {
              locationId: locationIdNum,
              managerId: user.id,
              userRole: user.role
            });
            return res.status(404).json({ error: "Location not found or access denied" });
          }
          logger.info("[PUT] Location verified:", {
            locationId: location.id,
            locationName: location.name,
            managerId: location.managerId
          });
          const oldNotificationEmail = location.notificationEmail || location.notification_email || null;
          const updates = {
            updatedAt: /* @__PURE__ */ new Date()
          };
          if (cancellationPolicyHours !== void 0) {
            updates.cancellationPolicyHours = cancellationPolicyHours;
          }
          if (cancellationPolicyMessage !== void 0) {
            updates.cancellationPolicyMessage = cancellationPolicyMessage;
          }
          if (defaultDailyBookingLimit !== void 0) {
            updates.defaultDailyBookingLimit = defaultDailyBookingLimit;
          }
          if (minimumBookingWindowHours !== void 0) {
            updates.minimumBookingWindowHours = minimumBookingWindowHours;
          }
          if (notificationEmail !== void 0) {
            if (notificationEmail && notificationEmail.trim() !== "" && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(notificationEmail)) {
              return res.status(400).json({ error: "Invalid email format" });
            }
            updates.notificationEmail = notificationEmail && notificationEmail.trim() !== "" ? notificationEmail.trim() : null;
            logger.info("[PUT] Setting notificationEmail:", {
              raw: notificationEmail,
              processed: updates.notificationEmail,
              oldEmail: oldNotificationEmail
            });
          }
          if (notificationPhone !== void 0) {
            if (notificationPhone && notificationPhone.trim() !== "") {
              const normalized = normalizePhoneForStorage(notificationPhone);
              if (!normalized) {
                return res.status(400).json({
                  error: "Invalid phone number format. Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
                });
              }
              updates.notificationPhone = normalized;
              logger.info("[PUT] Setting notificationPhone:", {
                raw: notificationPhone,
                normalized
              });
            } else {
              updates.notificationPhone = null;
            }
          }
          const { contactEmail, contactPhone, preferredContactMethod } = req.body;
          if (contactEmail !== void 0) {
            if (contactEmail && contactEmail.trim() !== "" && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(contactEmail)) {
              return res.status(400).json({ error: "Invalid contact email format" });
            }
            updates.contactEmail = contactEmail && contactEmail.trim() !== "" ? contactEmail.trim() : null;
          }
          if (contactPhone !== void 0) {
            if (contactPhone && contactPhone.trim() !== "") {
              const normalized = normalizePhoneForStorage(contactPhone);
              if (!normalized) {
                return res.status(400).json({
                  error: "Invalid contact phone number format. Please enter a valid phone number"
                });
              }
              updates.contactPhone = normalized;
            } else {
              updates.contactPhone = null;
            }
          }
          if (preferredContactMethod !== void 0) {
            if (!["email", "phone", "both"].includes(preferredContactMethod)) {
              return res.status(400).json({
                error: "Invalid preferred contact method. Must be 'email', 'phone', or 'both'"
              });
            }
            updates.preferredContactMethod = preferredContactMethod;
          }
          if (logoUrl !== void 0) {
            const processedLogoUrl = logoUrl && logoUrl.trim() !== "" ? logoUrl.trim() : null;
            updates.logoUrl = processedLogoUrl;
            updates.logo_url = processedLogoUrl;
            logger.info("[PUT] Setting logoUrl:", {
              raw: logoUrl,
              processed: processedLogoUrl,
              type: typeof processedLogoUrl,
              inUpdates: updates.logoUrl,
              alsoSetAsLogo_url: updates.logo_url
            });
          }
          if (brandImageUrl !== void 0) {
            const processedBrandImageUrl = brandImageUrl && brandImageUrl.trim() !== "" ? brandImageUrl.trim() : null;
            updates.brandImageUrl = processedBrandImageUrl;
            updates.brand_image_url = processedBrandImageUrl;
            logger.info("[PUT] Setting brandImageUrl:", {
              raw: brandImageUrl,
              processed: processedBrandImageUrl
            });
          }
          if (timezone !== void 0) {
            updates.timezone = DEFAULT_TIMEZONE;
            logger.info("[PUT] Setting timezone (locked to Newfoundland):", {
              raw: timezone,
              processed: DEFAULT_TIMEZONE,
              note: "Timezone is locked and cannot be changed"
            });
          }
          if (description !== void 0) {
            updates.description = description && description.trim() !== "" ? description.trim() : null;
            logger.info("[PUT] Setting description:", {
              raw: description,
              processed: updates.description
            });
          }
          if (customOnboardingLink !== void 0) {
            updates.customOnboardingLink = customOnboardingLink && customOnboardingLink.trim() !== "" ? customOnboardingLink.trim() : null;
            logger.info("[PUT] Setting customOnboardingLink:", {
              raw: customOnboardingLink,
              processed: updates.customOnboardingLink
            });
          }
          logger.info(
            "[PUT] Final updates object before DB update:",
            JSON.stringify(updates, null, 2)
          );
          logger.info("[PUT] Updates keys:", Object.keys(updates));
          logger.info("[PUT] Updates object has logoUrl?", "logoUrl" in updates);
          logger.info(
            "[PUT] Updates object logoUrl value:",
            updates.logoUrl
          );
          logger.info("[PUT] Updates object has logo_url?", "logo_url" in updates);
          logger.info(
            "[PUT] Updates object logo_url value:",
            updates.logo_url
          );
          const updatedResults = await db.update(locations).set(updates).where(eq30(locations.id, locationIdNum)).returning();
          logger.info(
            "[PUT] Updated location from DB (full object):",
            JSON.stringify(updatedResults[0], null, 2)
          );
          logger.info(
            "[PUT] Updated location logoUrl (camelCase):",
            updatedResults[0].logoUrl
          );
          logger.info(
            "[PUT] Updated location logo_url (snake_case):",
            updatedResults[0].logo_url
          );
          logger.info(
            "[PUT] Updated location all keys:",
            Object.keys(updatedResults[0] || {})
          );
          if (!updatedResults || updatedResults.length === 0) {
            logger.error(
              "[PUT] Cancellation policy update failed: No location returned from DB",
              {
                locationId: locationIdNum,
                updates
              }
            );
            return res.status(500).json({
              error: "Failed to update location settings - no rows updated"
            });
          }
          const updated = updatedResults[0];
          logger.info("[PUT] Location settings updated successfully:", {
            locationId: updated.id,
            cancellationPolicyHours: updated.cancellationPolicyHours,
            defaultDailyBookingLimit: updated.defaultDailyBookingLimit,
            defaultDailyBookingLimitRaw: updated.default_daily_booking_limit,
            notificationEmail: updated.notificationEmail || updated.notification_email || "not set",
            logoUrl: updated.logoUrl || updated.logo_url || "NOT SET"
          });
          if (defaultDailyBookingLimit !== void 0) {
            const savedValue = updated.defaultDailyBookingLimit ?? updated.default_daily_booking_limit;
            logger.info("[PUT] \u2705 Verified defaultDailyBookingLimit save:", {
              requested: defaultDailyBookingLimit,
              saved: savedValue,
              match: savedValue === defaultDailyBookingLimit
            });
            if (savedValue !== defaultDailyBookingLimit) {
              logger.error(
                "[PUT] \u274C WARNING: defaultDailyBookingLimit mismatch!",
                {
                  requested: defaultDailyBookingLimit,
                  saved: savedValue
                }
              );
            }
          }
          const response = {
            ...updated,
            logoUrl: updated.logoUrl || updated.logo_url || null,
            notificationEmail: updated.notificationEmail || updated.notification_email || null,
            notificationPhone: updated.notificationPhone || updated.notification_phone || null,
            cancellationPolicyHours: updated.cancellationPolicyHours || updated.cancellation_policy_hours,
            cancellationPolicyMessage: updated.cancellationPolicyMessage || updated.cancellation_policy_message,
            defaultDailyBookingLimit: updated.defaultDailyBookingLimit || updated.default_daily_booking_limit,
            minimumBookingWindowHours: updated.minimumBookingWindowHours || updated.minimum_booking_window_hours || 1,
            timezone: updated.timezone || DEFAULT_TIMEZONE,
            description: updated.description || null,
            customOnboardingLink: updated.customOnboardingLink || updated.custom_onboarding_link || null
          };
          if (notificationEmail !== void 0 && response.notificationEmail && response.notificationEmail !== oldNotificationEmail) {
            try {
              const emailContent = generateLocationEmailChangedEmail({
                email: response.notificationEmail,
                locationName: location.name || "Location",
                locationId: locationIdNum
              });
              await sendEmail(emailContent);
              logger.info(
                `\u2705 Location notification email change notification sent to: ${response.notificationEmail}`
              );
            } catch (emailError) {
              logger.error(
                "Error sending location email change notification:",
                emailError
              );
            }
          }
          logger.info(
            "[PUT] Sending response with notificationEmail:",
            response.notificationEmail
          );
          res.status(200).json(response);
        } catch (error) {
          logger.error("Error updating cancellation policy:", error);
          res.status(500).json({
            error: error.message || "Failed to update cancellation policy"
          });
        }
      }
    );
    router15.get(
      "/locations",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const locations5 = await locationService.getLocationsByManagerId(user.id);
          logger.info(
            "[GET] /api/manager/locations - Raw locations from DB:",
            locations5.map((loc) => ({
              id: loc.id,
              name: loc.name,
              logoUrl: loc.logoUrl,
              logo_url: loc.logo_url,
              allKeys: Object.keys(loc)
            }))
          );
          const mappedLocations = locations5.map((loc) => ({
            ...loc,
            notificationEmail: loc.notificationEmail || loc.notification_email || null,
            notificationPhone: loc.notificationPhone || loc.notification_phone || null,
            // Primary contact fields
            contactEmail: loc.contactEmail || loc.contact_email || null,
            contactPhone: loc.contactPhone || loc.contact_phone || null,
            preferredContactMethod: loc.preferredContactMethod || loc.preferred_contact_method || "email",
            cancellationPolicyHours: loc.cancellationPolicyHours || loc.cancellation_policy_hours,
            cancellationPolicyMessage: loc.cancellationPolicyMessage || loc.cancellation_policy_message,
            defaultDailyBookingLimit: loc.defaultDailyBookingLimit || loc.default_daily_booking_limit,
            minimumBookingWindowHours: loc.minimumBookingWindowHours || loc.minimum_booking_window_hours || 1,
            logoUrl: loc.logoUrl || loc.logo_url || null,
            timezone: loc.timezone || DEFAULT_TIMEZONE,
            description: loc.description || null,
            customOnboardingLink: loc.customOnboardingLink || loc.custom_onboarding_link || null,
            // Kitchen license status fields
            kitchenLicenseUrl: loc.kitchenLicenseUrl || loc.kitchen_license_url || null,
            kitchenLicenseStatus: loc.kitchenLicenseStatus || loc.kitchen_license_status || "pending",
            kitchenLicenseApprovedBy: loc.kitchenLicenseApprovedBy || loc.kitchen_license_approved_by || null,
            kitchenLicenseApprovedAt: loc.kitchenLicenseApprovedAt || loc.kitchen_license_approved_at || null,
            kitchenLicenseFeedback: loc.kitchenLicenseFeedback || loc.kitchen_license_feedback || null,
            kitchenLicenseExpiry: loc.kitchenLicenseExpiry || loc.kitchen_license_expiry || null,
            // Kitchen terms and policies fields
            kitchenTermsUrl: loc.kitchenTermsUrl || loc.kitchen_terms_url || null,
            kitchenTermsUploadedAt: loc.kitchenTermsUploadedAt || loc.kitchen_terms_uploaded_at || null
          }));
          logger.info(
            "[GET] /api/manager/locations - Mapped locations:",
            mappedLocations.map((loc) => ({
              id: loc.id,
              name: loc.name,
              logoUrl: loc.logoUrl,
              notificationEmail: loc.notificationEmail || "not set"
            }))
          );
          res.json(mappedLocations);
        } catch (error) {
          logger.error("Error fetching locations:", error);
          res.status(500).json({ error: error.message || "Failed to fetch locations" });
        }
      }
    );
    router15.post(
      "/locations",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const {
            name,
            address,
            notificationEmail,
            notificationPhone,
            contactEmail,
            contactPhone,
            preferredContactMethod,
            kitchenLicenseUrl,
            kitchenLicenseStatus,
            kitchenLicenseExpiry,
            kitchenTermsUrl
          } = req.body;
          logger.info(
            "[POST /locations] Request body:",
            JSON.stringify(req.body, null, 2)
          );
          logger.info("[POST /locations] kitchenTermsUrl:", kitchenTermsUrl);
          if (!name || !address) {
            return res.status(400).json({ error: "Name and address are required" });
          }
          let normalizedNotificationPhone = void 0;
          if (notificationPhone && notificationPhone.trim() !== "") {
            const normalized = normalizePhoneForStorage(notificationPhone);
            if (!normalized) {
              return res.status(400).json({
                error: "Invalid phone number format. Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
              });
            }
            normalizedNotificationPhone = normalized;
          }
          let normalizedContactPhone = void 0;
          if (contactPhone && contactPhone.trim() !== "") {
            const normalized = normalizePhoneForStorage(contactPhone);
            if (!normalized) {
              return res.status(400).json({
                error: "Invalid contact phone number format. Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
              });
            }
            normalizedContactPhone = normalized;
          }
          logger.info("Creating location for manager:", {
            managerId: user.id,
            name,
            address,
            notificationPhone: normalizedNotificationPhone,
            contactPhone: normalizedContactPhone,
            kitchenLicenseUrl: kitchenLicenseUrl ? "Provided" : "Not provided"
          });
          const location = await locationService.createLocation({
            name,
            address,
            managerId: user.id,
            notificationEmail: notificationEmail || void 0,
            notificationPhone: normalizedNotificationPhone,
            contactEmail: contactEmail || void 0,
            contactPhone: normalizedContactPhone,
            preferredContactMethod: preferredContactMethod || "email",
            kitchenLicenseUrl: kitchenLicenseUrl || void 0,
            kitchenLicenseStatus: kitchenLicenseStatus || "pending",
            kitchenLicenseExpiry: kitchenLicenseExpiry || void 0,
            kitchenTermsUrl: kitchenTermsUrl || void 0
          });
          const mappedLocation = {
            ...location,
            managerId: location.managerId || location.manager_id || null,
            notificationEmail: location.notificationEmail || location.notification_email || null,
            notificationPhone: location.notificationPhone || location.notification_phone || null,
            cancellationPolicyHours: location.cancellationPolicyHours || location.cancellation_policy_hours || 24,
            cancellationPolicyMessage: location.cancellationPolicyMessage || location.cancellation_policy_message || "Bookings cannot be cancelled within {hours} hours of the scheduled time.",
            defaultDailyBookingLimit: location.defaultDailyBookingLimit || location.default_daily_booking_limit || 2,
            createdAt: location.createdAt || location.created_at,
            updatedAt: location.updatedAt || location.updated_at
          };
          res.status(201).json(mappedLocation);
        } catch (error) {
          logger.error("Error creating location:", error);
          logger.error("Error details:", error);
          res.status(500).json({ error: error.message || "Failed to create location" });
        }
      }
    );
    router15.put(
      "/locations/:locationId",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const locationId = parseInt(req.params.locationId);
          if (isNaN(locationId) || locationId <= 0) {
            return res.status(400).json({ error: "Invalid location ID" });
          }
          const locations5 = await locationService.getLocationsByManagerId(user.id);
          const hasAccess = locations5.some((loc) => loc.id === locationId);
          if (!hasAccess) {
            return res.status(403).json({ error: "Access denied to this location" });
          }
          const {
            name,
            address,
            notificationEmail,
            notificationPhone,
            contactEmail,
            contactPhone,
            preferredContactMethod,
            kitchenLicenseUrl,
            kitchenLicenseStatus,
            kitchenLicenseExpiry,
            kitchenTermsUrl
          } = req.body;
          const updates = {};
          if (name !== void 0) updates.name = name;
          if (address !== void 0) updates.address = address;
          if (notificationEmail !== void 0)
            updates.notificationEmail = notificationEmail || null;
          if (notificationPhone !== void 0) {
            if (notificationPhone && notificationPhone.trim() !== "") {
              const normalized = normalizePhoneForStorage(notificationPhone);
              if (!normalized) {
                return res.status(400).json({
                  error: "Invalid phone number format. Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
                });
              }
              updates.notificationPhone = normalized;
            } else {
              updates.notificationPhone = null;
            }
          }
          if (contactEmail !== void 0) {
            if (contactEmail && contactEmail.trim() !== "" && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(contactEmail)) {
              return res.status(400).json({ error: "Invalid contact email format" });
            }
            updates.contactEmail = contactEmail && contactEmail.trim() !== "" ? contactEmail.trim() : null;
          }
          if (contactPhone !== void 0) {
            if (contactPhone && contactPhone.trim() !== "") {
              const normalized = normalizePhoneForStorage(contactPhone);
              if (!normalized) {
                return res.status(400).json({
                  error: "Invalid contact phone number format. Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
                });
              }
              updates.contactPhone = normalized;
            } else {
              updates.contactPhone = null;
            }
          }
          if (preferredContactMethod !== void 0) {
            if (!["email", "phone", "both"].includes(preferredContactMethod)) {
              return res.status(400).json({
                error: "Invalid preferred contact method. Must be 'email', 'phone', or 'both'"
              });
            }
            updates.preferredContactMethod = preferredContactMethod;
          }
          if (kitchenLicenseUrl !== void 0) {
            updates.kitchenLicenseUrl = kitchenLicenseUrl || null;
            if (kitchenLicenseUrl) {
              updates.kitchenLicenseUploadedAt = /* @__PURE__ */ new Date();
              if (kitchenLicenseStatus === void 0) {
                updates.kitchenLicenseStatus = "pending";
              }
            }
          }
          if (kitchenLicenseStatus !== void 0) {
            if (kitchenLicenseStatus && !["pending", "approved", "rejected"].includes(kitchenLicenseStatus)) {
              return res.status(400).json({
                error: "Invalid kitchenLicenseStatus. Must be 'pending', 'approved', or 'rejected'"
              });
            }
            updates.kitchenLicenseStatus = kitchenLicenseStatus || null;
          }
          if (kitchenLicenseExpiry !== void 0) {
            updates.kitchenLicenseExpiry = kitchenLicenseExpiry || null;
          }
          if (kitchenTermsUrl !== void 0) {
            updates.kitchenTermsUrl = kitchenTermsUrl || null;
            if (kitchenTermsUrl) {
              updates.kitchenTermsUploadedAt = /* @__PURE__ */ new Date();
            }
          }
          logger.info(`\u{1F4BE} Updating location ${locationId} with:`, updates);
          const updated = await locationService.updateLocation({
            id: locationId,
            ...updates
          });
          if (!updated) {
            logger.error(`\u274C Location ${locationId} not found in database`);
            return res.status(404).json({ error: "Location not found" });
          }
          logger.info(`\u2705 Location ${locationId} updated successfully`);
          if (kitchenLicenseUrl && updates.kitchenLicenseStatus === "pending") {
            try {
              const { generateKitchenLicenseSubmittedAdminEmail: generateKitchenLicenseSubmittedAdminEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
              const admins = await db.select({ username: users.username }).from(users).where(eq30(users.role, "admin"));
              for (const admin2 of admins) {
                if (admin2.username) {
                  const adminEmail = generateKitchenLicenseSubmittedAdminEmail2({
                    adminEmail: admin2.username,
                    managerName: user.username,
                    managerEmail: user.username,
                    locationName: updated.name || "Kitchen Location",
                    locationId,
                    submittedAt: /* @__PURE__ */ new Date()
                  });
                  await sendEmail(adminEmail, {
                    trackingId: `kitchen_license_submitted_${locationId}_${Date.now()}`
                  });
                }
              }
              logger.info(
                `[Manager] Sent kitchen license submission notification to admins for location ${locationId}`
              );
            } catch (emailError) {
              logger.error(
                "Error sending kitchen license submission email to admin:",
                emailError
              );
            }
          }
          const mappedLocation = {
            ...updated,
            managerId: updated.managerId || updated.manager_id || null,
            notificationEmail: updated.notificationEmail || updated.notification_email || null,
            notificationPhone: updated.notificationPhone || updated.notification_phone || null,
            cancellationPolicyHours: updated.cancellationPolicyHours || updated.cancellation_policy_hours || 24,
            cancellationPolicyMessage: updated.cancellationPolicyMessage || updated.cancellation_policy_message || "Bookings cannot be cancelled within {hours} hours of the scheduled time.",
            defaultDailyBookingLimit: updated.defaultDailyBookingLimit || updated.default_daily_booking_limit || 2,
            createdAt: updated.createdAt || updated.created_at,
            updatedAt: updated.updatedAt || updated.updated_at
          };
          return res.json(mappedLocation);
        } catch (error) {
          logger.error("\u274C Error updating location:", error);
          logger.error("Error stack:", error.stack);
          res.status(500).json({ error: error.message || "Failed to update location" });
        }
      }
    );
    router15.post(
      "/complete-onboarding",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const { skipped } = req.body;
          logger.info(
            `[POST] /api/manager/complete-onboarding - User: ${user.id}, skipped: ${skipped}`
          );
          const updatedUser = await managerService.updateOnboarding(user.id, {
            completed: true,
            skipped: !!skipped
          });
          if (!updatedUser) {
            return res.status(500).json({ error: "Failed to update onboarding status" });
          }
          res.json({ success: true, user: updatedUser });
        } catch (error) {
          logger.error("Error completing manager onboarding:", error);
          res.status(500).json({ error: error.message || "Failed to complete onboarding" });
        }
      }
    );
    router15.post(
      "/onboarding/step",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const { stepId, locationId } = req.body;
          if (stepId === void 0) {
            return res.status(400).json({ error: "stepId is required" });
          }
          logger.info(
            `[POST] /api/manager/onboarding/step - User: ${user.id}, stepId: ${stepId}, locationId: ${locationId}`
          );
          const currentSteps = user.managerOnboardingStepsCompleted || {};
          const stepKey = locationId ? `${stepId}_location_${locationId}` : `${stepId}`;
          const newSteps = {
            ...currentSteps,
            [stepKey]: true
          };
          const updatedUser = await managerService.updateOnboarding(user.id, {
            steps: newSteps
          });
          if (!updatedUser) {
            return res.status(500).json({ error: "Failed to update onboarding step" });
          }
          res.json({
            success: true,
            stepsCompleted: updatedUser.managerOnboardingStepsCompleted
          });
        } catch (error) {
          logger.error("Error tracking onboarding step:", error);
          res.status(500).json({ error: error.message || "Failed to track onboarding step" });
        }
      }
    );
    router15.get(
      "/availability/:kitchenId",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const kitchenId = parseInt(req.params.kitchenId);
          if (isNaN(kitchenId) || kitchenId <= 0) {
            return res.status(400).json({ error: "Invalid kitchen ID" });
          }
          const kitchen = await kitchenService.getKitchenById(kitchenId);
          if (!kitchen) {
            return res.status(404).json({ error: "Kitchen not found" });
          }
          const managerLocations = await locationService.getLocationsByManagerId(
            user.id
          );
          const hasAccess = managerLocations.some(
            (loc) => loc.id === kitchen.locationId
          );
          if (!hasAccess) {
            return res.status(403).json({ error: "Access denied to this kitchen" });
          }
          const availability = await kitchenService.getKitchenAvailability(kitchenId);
          res.json(availability);
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/availability",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const user = req.neonUser;
          const { kitchenId, dayOfWeek, startTime, endTime, isAvailable } = req.body;
          if (!kitchenId || dayOfWeek === void 0 || dayOfWeek < 0 || dayOfWeek > 6) {
            return res.status(400).json({ error: "kitchenId and valid dayOfWeek (0-6) are required" });
          }
          const kitchen = await kitchenService.getKitchenById(kitchenId);
          if (!kitchen) {
            return res.status(404).json({ error: "Kitchen not found" });
          }
          const managerLocations = await locationService.getLocationsByManagerId(
            user.id
          );
          const hasAccess = managerLocations.some(
            (loc) => loc.id === kitchen.locationId
          );
          if (!hasAccess) {
            return res.status(403).json({ error: "Access denied to this kitchen" });
          }
          const { kitchenAvailability: kitchenAvailability2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const [existing] = await db.select().from(kitchenAvailability2).where(
            and18(
              eq30(kitchenAvailability2.kitchenId, kitchenId),
              eq30(kitchenAvailability2.dayOfWeek, dayOfWeek)
            )
          ).limit(1);
          let result;
          if (existing) {
            [result] = await db.update(kitchenAvailability2).set({
              startTime: startTime || "00:00",
              endTime: endTime || "00:00",
              isAvailable: isAvailable ?? false
            }).where(eq30(kitchenAvailability2.id, existing.id)).returning();
          } else {
            [result] = await db.insert(kitchenAvailability2).values({
              kitchenId,
              dayOfWeek,
              startTime: startTime || "00:00",
              endTime: endTime || "00:00",
              isAvailable: isAvailable ?? false
            }).returning();
          }
          res.json(result);
        } catch (error) {
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/storage-extensions/pending",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const pendingExtensions = await db.select({
            id: pendingStorageExtensions.id,
            storageBookingId: pendingStorageExtensions.storageBookingId,
            newEndDate: pendingStorageExtensions.newEndDate,
            extensionDays: pendingStorageExtensions.extensionDays,
            extensionBasePriceCents: pendingStorageExtensions.extensionBasePriceCents,
            extensionServiceFeeCents: pendingStorageExtensions.extensionServiceFeeCents,
            extensionTotalPriceCents: pendingStorageExtensions.extensionTotalPriceCents,
            status: pendingStorageExtensions.status,
            createdAt: pendingStorageExtensions.createdAt,
            stripePaymentIntentId: pendingStorageExtensions.stripePaymentIntentId,
            // Storage booking details
            currentEndDate: storageBookings.endDate,
            storageName: storageListings.name,
            storageType: storageListings.storageType,
            // Chef details
            chefId: storageBookings.chefId,
            chefEmail: users.username,
            // Kitchen/Location details
            kitchenName: kitchens.name,
            locationId: locations.id
          }).from(pendingStorageExtensions).innerJoin(
            storageBookings,
            eq30(
              pendingStorageExtensions.storageBookingId,
              storageBookings.id
            )
          ).innerJoin(
            storageListings,
            eq30(storageBookings.storageListingId, storageListings.id)
          ).innerJoin(kitchens, eq30(storageListings.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).innerJoin(users, eq30(storageBookings.chefId, users.id)).where(
            and18(
              eq30(locations.managerId, managerId),
              or5(
                eq30(pendingStorageExtensions.status, "paid"),
                eq30(pendingStorageExtensions.status, "authorized")
              )
              // Show paid and authorized extensions awaiting manager approval
            )
          ).orderBy(desc15(pendingStorageExtensions.createdAt));
          const { lazyExpireStorageExtensionAuth: lazyExpireStorageExtensionAuth2 } = await Promise.resolve().then(() => (init_auth_expiry_service(), auth_expiry_service_exports));
          const stillPending = [];
          for (const ext of pendingExtensions) {
            if (ext.status === "authorized") {
              const wasExpired = await lazyExpireStorageExtensionAuth2({
                id: ext.id,
                status: ext.status,
                stripePaymentIntentId: ext.stripePaymentIntentId,
                createdAt: ext.createdAt ? new Date(ext.createdAt) : null,
                storageBookingId: ext.storageBookingId
              });
              if (wasExpired) continue;
            }
            stillPending.push(ext);
          }
          res.json(stillPending);
        } catch (error) {
          logger.error("Error fetching pending storage extensions:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/storage-extensions/:id/approve",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const extensionId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          if (isNaN(extensionId) || extensionId <= 0) {
            return res.status(400).json({ error: "Invalid extension ID" });
          }
          const [extension] = await db.select({
            id: pendingStorageExtensions.id,
            storageBookingId: pendingStorageExtensions.storageBookingId,
            newEndDate: pendingStorageExtensions.newEndDate,
            extensionDays: pendingStorageExtensions.extensionDays,
            status: pendingStorageExtensions.status,
            locationManagerId: locations.managerId,
            chefId: storageBookings.chefId,
            chefEmail: users.username,
            storageName: storageListings.name
          }).from(pendingStorageExtensions).innerJoin(
            storageBookings,
            eq30(
              pendingStorageExtensions.storageBookingId,
              storageBookings.id
            )
          ).innerJoin(
            storageListings,
            eq30(storageBookings.storageListingId, storageListings.id)
          ).innerJoin(kitchens, eq30(storageListings.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).innerJoin(users, eq30(storageBookings.chefId, users.id)).where(eq30(pendingStorageExtensions.id, extensionId)).limit(1);
          if (!extension) {
            return res.status(404).json({ error: "Extension request not found" });
          }
          if (extension.locationManagerId !== managerId) {
            return res.status(403).json({ error: "Not authorized to approve this extension" });
          }
          if (extension.status !== "paid" && extension.status !== "authorized") {
            return res.status(400).json({
              error: `Cannot approve extension with status '${extension.status}'`
            });
          }
          if (extension.status === "authorized") {
            try {
              const [extDetails] = await db.select({ stripePaymentIntentId: pendingStorageExtensions.stripePaymentIntentId }).from(pendingStorageExtensions).where(eq30(pendingStorageExtensions.id, extensionId)).limit(1);
              if (extDetails?.stripePaymentIntentId) {
                const { capturePaymentIntent: capturePaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
                const captureResult = await capturePaymentIntent2(extDetails.stripePaymentIntentId);
                logger.info(`[Manager] AUTH-THEN-CAPTURE: Captured storage extension payment ${extensionId}`, {
                  paymentIntentId: extDetails.stripePaymentIntentId,
                  capturedAmount: captureResult.amount,
                  status: captureResult.status
                });
                try {
                  const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
                  const ptRecord = await findPaymentTransactionByIntentId2(extDetails.stripePaymentIntentId, db);
                  if (ptRecord) {
                    await updatePaymentTransaction2(ptRecord.id, {
                      status: "succeeded",
                      stripeStatus: "succeeded",
                      paidAt: /* @__PURE__ */ new Date()
                    }, db);
                  }
                } catch (ptErr) {
                  logger.warn(`[Manager] Could not update PT after storage extension capture:`, ptErr);
                }
              }
            } catch (captureError) {
              logger.error(`[Manager] AUTH-THEN-CAPTURE: Failed to capture storage extension payment ${extensionId}:`, captureError);
              return res.status(500).json({
                error: "Failed to capture payment for storage extension. The authorization may have expired.",
                details: captureError.message
              });
            }
          }
          await db.update(pendingStorageExtensions).set({
            status: "approved",
            managerId,
            approvedAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq30(pendingStorageExtensions.id, extensionId));
          await bookingService.extendStorageBooking(
            extension.storageBookingId,
            extension.newEndDate
          );
          await db.update(pendingStorageExtensions).set({
            status: "completed",
            completedAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq30(pendingStorageExtensions.id, extensionId));
          logger.info(
            `[Manager] Storage extension ${extensionId} approved by manager ${managerId}`,
            {
              storageBookingId: extension.storageBookingId,
              newEndDate: extension.newEndDate,
              extensionDays: extension.extensionDays
            }
          );
          try {
            const { storageOverstayRecords: storageOverstayRecords2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
            const activeOverstays = await db.select({ id: storageOverstayRecords2.id }).from(storageOverstayRecords2).where(
              and18(
                eq30(storageOverstayRecords2.storageBookingId, extension.storageBookingId),
                inArray8(storageOverstayRecords2.status, ["detected", "grace_period", "pending_review"])
              )
            );
            if (activeOverstays.length > 0) {
              for (const overstay of activeOverstays) {
                await overstayPenaltyService.resolveOverstay(
                  overstay.id,
                  "extended",
                  `Auto-resolved: storage extension ${extensionId} approved by manager ${managerId}. New end date: ${extension.newEndDate.toISOString()}`,
                  managerId
                );
              }
              logger.info(
                `[Manager] Auto-resolved ${activeOverstays.length} overstay record(s) for storage booking ${extension.storageBookingId} after extension approval`
              );
            }
          } catch (overstayError) {
            logger.warn(
              `[Manager] Failed to auto-resolve overstay records after extension approval:`,
              overstayError
            );
          }
          try {
            const approvalEmail = generateStorageExtensionApprovedEmail({
              chefEmail: extension.chefEmail,
              chefName: extension.chefEmail,
              storageName: extension.storageName,
              extensionDays: extension.extensionDays,
              newEndDate: extension.newEndDate
            });
            await sendEmail(approvalEmail);
            logger.info(
              `[Manager] Sent storage extension approval email to chef: ${extension.chefEmail}`
            );
          } catch (emailError) {
            logger.error(
              "Error sending storage extension approval email:",
              emailError
            );
          }
          try {
            if (extension.chefId) {
              await notificationService.notifyChefStorageExtensionApproved({
                chefId: extension.chefId,
                storageBookingId: extension.storageBookingId,
                storageName: extension.storageName,
                extensionDays: extension.extensionDays,
                newEndDate: extension.newEndDate.toLocaleDateString("en-US", {
                  year: "numeric",
                  month: "long",
                  day: "numeric"
                })
              });
            }
          } catch (notifError) {
            logger.error(
              "Error sending storage extension approval in-app notification:",
              notifError
            );
          }
          res.json({
            success: true,
            message: "Storage extension approved successfully",
            extension: {
              id: extensionId,
              storageBookingId: extension.storageBookingId,
              newEndDate: extension.newEndDate,
              status: "completed"
            }
          });
        } catch (error) {
          logger.error("Error approving storage extension:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/storage-extensions/:id/reject",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const extensionId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          const { reason } = req.body;
          if (isNaN(extensionId) || extensionId <= 0) {
            return res.status(400).json({ error: "Invalid extension ID" });
          }
          const [extension] = await db.select({
            id: pendingStorageExtensions.id,
            storageBookingId: pendingStorageExtensions.storageBookingId,
            status: pendingStorageExtensions.status,
            stripePaymentIntentId: pendingStorageExtensions.stripePaymentIntentId,
            extensionTotalPriceCents: pendingStorageExtensions.extensionTotalPriceCents,
            locationManagerId: locations.managerId,
            chefId: storageBookings.chefId,
            chefEmail: users.username
          }).from(pendingStorageExtensions).innerJoin(
            storageBookings,
            eq30(
              pendingStorageExtensions.storageBookingId,
              storageBookings.id
            )
          ).innerJoin(
            storageListings,
            eq30(storageBookings.storageListingId, storageListings.id)
          ).innerJoin(kitchens, eq30(storageListings.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).innerJoin(users, eq30(storageBookings.chefId, users.id)).where(eq30(pendingStorageExtensions.id, extensionId)).limit(1);
          if (!extension) {
            return res.status(404).json({ error: "Extension request not found" });
          }
          if (extension.locationManagerId !== managerId) {
            return res.status(403).json({ error: "Not authorized to reject this extension" });
          }
          if (extension.status !== "paid" && extension.status !== "authorized") {
            return res.status(400).json({
              error: `Cannot reject extension with status '${extension.status}'`
            });
          }
          const wasAuthorizedExtension = extension.status === "authorized";
          await db.update(pendingStorageExtensions).set({
            status: "rejected",
            managerId,
            rejectedAt: /* @__PURE__ */ new Date(),
            rejectionReason: reason || "Extension request declined by manager",
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq30(pendingStorageExtensions.id, extensionId));
          logger.info(
            `[Manager] Storage extension ${extensionId} rejected by manager ${managerId}`,
            {
              storageBookingId: extension.storageBookingId,
              reason: reason || "No reason provided"
            }
          );
          let refundResult = null;
          if (extension.stripePaymentIntentId) {
            if (wasAuthorizedExtension) {
              try {
                const { cancelPaymentIntent: cancelPaymentIntent2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
                const { findPaymentTransactionByMetadata: findPaymentTransactionByMetadata2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
                await cancelPaymentIntent2(extension.stripePaymentIntentId);
                logger.info(`[Manager] AUTH-THEN-CAPTURE: Cancelled authorization for storage extension ${extensionId}`);
                const ptRecord = await findPaymentTransactionByMetadata2(
                  "storage_extension_id",
                  String(extensionId),
                  db
                );
                if (ptRecord) {
                  await updatePaymentTransaction2(ptRecord.id, {
                    status: "canceled",
                    stripeStatus: "canceled"
                  }, db);
                }
              } catch (cancelError) {
                logger.error(`[Manager] Failed to cancel auth for storage extension ${extensionId}:`, cancelError);
              }
            } else {
              try {
                const { reverseTransferAndRefund: reverseTransferAndRefund2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
                const { findPaymentTransactionByMetadata: findPaymentTransactionByMetadata2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
                const paymentTransaction = await findPaymentTransactionByMetadata2(
                  "storage_extension_id",
                  String(extensionId),
                  db
                );
                const extensionTotalPrice = extension.extensionTotalPriceCents || 0;
                const transactionAmount = paymentTransaction ? parseInt(String(paymentTransaction.amount || "0")) || extensionTotalPrice : extensionTotalPrice;
                if (transactionAmount > 0) {
                  const { calculateRefundBreakdown: calculateRefundBreakdown2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
                  const stripeProcessingFee = paymentTransaction ? parseInt(
                    String(paymentTransaction.stripe_processing_fee || "0")
                  ) || 0 : 0;
                  const currentRefundAmount = paymentTransaction ? parseInt(String(paymentTransaction.refund_amount || "0")) || 0 : 0;
                  const managerRevenue = paymentTransaction ? parseInt(String(paymentTransaction.manager_revenue || "0")) || transactionAmount : transactionAmount;
                  const refundBreakdown = calculateRefundBreakdown2(
                    transactionAmount,
                    managerRevenue,
                    currentRefundAmount,
                    stripeProcessingFee
                  );
                  const refundToCustomer = refundBreakdown.maxRefundableToCustomer;
                  const deductFromManager = refundBreakdown.maxDeductibleFromManager;
                  refundResult = await reverseTransferAndRefund2(
                    extension.stripePaymentIntentId,
                    refundToCustomer,
                    // Customer receives this amount
                    "requested_by_customer",
                    {
                      reverseTransferAmount: deductFromManager,
                      // Manager debited same amount
                      refundApplicationFee: false,
                      metadata: {
                        storage_extension_id: String(extensionId),
                        storage_booking_id: String(extension.storageBookingId),
                        rejection_reason: reason || "Extension declined by manager",
                        manager_id: String(managerId),
                        refund_model: "unified",
                        customer_receives: String(refundToCustomer),
                        manager_debited: String(deductFromManager)
                      }
                    }
                  );
                  logger.info(
                    `[Manager] Refund processed for storage extension ${extensionId}`,
                    {
                      refundId: refundResult.refundId,
                      refundAmount: refundResult.refundAmount,
                      transferReversalId: refundResult.transferReversalId
                    }
                  );
                  await db.update(pendingStorageExtensions).set({
                    status: "refunded",
                    updatedAt: /* @__PURE__ */ new Date()
                  }).where(eq30(pendingStorageExtensions.id, extensionId));
                  if (paymentTransaction) {
                    await updatePaymentTransaction2(
                      paymentTransaction.id,
                      {
                        status: "refunded",
                        refundAmount: refundResult.refundAmount,
                        refundId: refundResult.refundId,
                        refundedAt: /* @__PURE__ */ new Date()
                      },
                      db
                    );
                  }
                }
              } catch (refundError) {
                logger.error(
                  `[Manager] Failed to process refund for extension ${extensionId}:`,
                  refundError
                );
              }
            }
          }
          try {
            const rejectionEmail = generateStorageExtensionRejectedEmail({
              chefEmail: extension.chefEmail,
              chefName: extension.chefEmail,
              storageName: extension.storageName || "Storage",
              extensionDays: extension.extensionDays || 0,
              rejectionReason: reason || "Extension request declined by manager",
              refundAmount: refundResult?.refundAmount
            });
            await sendEmail(rejectionEmail);
            logger.info(
              `[Manager] Sent storage extension rejection email to chef: ${extension.chefEmail}`
            );
          } catch (emailError) {
            logger.error(
              "Error sending storage extension rejection email:",
              emailError
            );
          }
          try {
            if (extension.chefId) {
              await notificationService.notifyChefStorageExtensionRejected({
                chefId: extension.chefId,
                storageBookingId: extension.storageBookingId,
                storageName: extension.storageName || "Storage",
                extensionDays: extension.extensionDays || 0,
                newEndDate: "",
                reason: reason || "Extension request declined by manager"
              });
            }
          } catch (notifError) {
            logger.error(
              "Error sending storage extension rejection in-app notification:",
              notifError
            );
          }
          res.json({
            success: true,
            message: refundResult ? "Storage extension rejected and refund processed successfully." : "Storage extension rejected. Refund will be processed.",
            extension: {
              id: extensionId,
              storageBookingId: extension.storageBookingId,
              status: refundResult ? "refunded" : "rejected"
            },
            refund: refundResult ? {
              refundId: refundResult.refundId,
              amount: refundResult.refundAmount
            } : null
          });
        } catch (error) {
          logger.error("Error rejecting storage extension:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/overstays",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const includeAll = req.query.includeAll === "true";
          const managerLocations = await db.select({ id: locations.id }).from(locations).where(eq30(locations.managerId, managerId));
          const locationIds = managerLocations.map((l) => l.id);
          if (locationIds.length === 0) {
            return res.json({ overstays: [], pastOverstays: [], stats: null });
          }
          const pendingOverstays = await overstayPenaltyService.getPendingOverstayReviews();
          const filteredPending = pendingOverstays.filter(
            (o) => locationIds.includes(o.locationId)
          );
          let pastOverstays = [];
          if (includeAll) {
            const allOverstays = await overstayPenaltyService.getAllOverstayRecords();
            const filteredAll = allOverstays.filter(
              (o) => locationIds.includes(o.locationId)
            );
            const pendingStatuses = [
              "detected",
              "grace_period",
              "pending_review",
              "penalty_approved",
              "charge_pending",
              "charge_failed",
              "escalated"
            ];
            pastOverstays = filteredAll.filter(
              (o) => !pendingStatuses.includes(o.status)
            );
          }
          const stats = await overstayPenaltyService.getOverstayStats(locationIds);
          res.json({
            overstays: filteredPending,
            pastOverstays,
            stats
          });
        } catch (error) {
          logger.error("Error fetching overstays:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/overstays/:id",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const overstayId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          if (isNaN(overstayId)) {
            return res.status(400).json({ error: "Invalid overstay ID" });
          }
          const ownsRecord = await verifyManagerOwnsOverstay(overstayId, managerId);
          if (!ownsRecord) {
            return res.status(403).json({ error: "Access denied" });
          }
          const record = await overstayPenaltyService.getOverstayRecord(overstayId);
          if (!record) {
            return res.status(404).json({ error: "Overstay record not found" });
          }
          const history = await overstayPenaltyService.getOverstayHistory(overstayId);
          res.json({
            overstay: record,
            history
          });
        } catch (error) {
          logger.error("Error fetching overstay record:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/overstays/:id/approve",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const overstayId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          const { finalPenaltyCents, managerNotes } = req.body;
          if (isNaN(overstayId)) {
            return res.status(400).json({ error: "Invalid overstay ID" });
          }
          const ownsRecord = await verifyManagerOwnsOverstay(overstayId, managerId);
          if (!ownsRecord) {
            return res.status(403).json({ error: "Access denied" });
          }
          if (finalPenaltyCents !== void 0) {
            if (typeof finalPenaltyCents !== "number" || finalPenaltyCents < 0) {
              return res.status(400).json({ error: "Invalid penalty amount" });
            }
          }
          const decision = {
            overstayRecordId: overstayId,
            managerId,
            action: finalPenaltyCents !== void 0 ? "adjust" : "approve",
            finalPenaltyCents,
            managerNotes
          };
          const result = await overstayPenaltyService.processManagerDecision(decision);
          if (!result.success) {
            return res.status(400).json({ error: result.error });
          }
          logger.info(
            `[Manager] Auto-charging overstay penalty ${overstayId} after manager approval`
          );
          const chargeResult = await overstayPenaltyService.chargeApprovedPenalty(overstayId);
          if (!chargeResult.success) {
            logger.warn(
              `[Manager] Auto-charge failed for overstay ${overstayId}: ${chargeResult.error}`
            );
          }
          res.json({
            success: true,
            message: chargeResult.success ? "Penalty approved and charged successfully" : `Penalty approved but charge failed: ${chargeResult.error || "Unknown error"}`,
            chargeResult,
            autoCharged: true
          });
        } catch (error) {
          logger.error("Error approving penalty:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/overstays/:id/waive",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const overstayId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          const { waiveReason, managerNotes } = req.body;
          if (isNaN(overstayId)) {
            return res.status(400).json({ error: "Invalid overstay ID" });
          }
          const ownsRecord = await verifyManagerOwnsOverstay(overstayId, managerId);
          if (!ownsRecord) {
            return res.status(403).json({ error: "Access denied" });
          }
          if (!waiveReason || typeof waiveReason !== "string" || waiveReason.trim().length === 0) {
            return res.status(400).json({ error: "Waive reason is required" });
          }
          const decision = {
            overstayRecordId: overstayId,
            managerId,
            action: "waive",
            waiveReason: waiveReason.trim(),
            managerNotes
          };
          const result = await overstayPenaltyService.processManagerDecision(decision);
          if (!result.success) {
            return res.status(400).json({ error: result.error });
          }
          res.json({
            success: true,
            message: "Penalty waived successfully"
          });
        } catch (error) {
          logger.error("Error waiving penalty:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/overstays/:id/charge",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const overstayId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          if (isNaN(overstayId)) {
            return res.status(400).json({ error: "Invalid overstay ID" });
          }
          const ownsRecord = await verifyManagerOwnsOverstay(overstayId, managerId);
          if (!ownsRecord) {
            return res.status(403).json({ error: "Access denied" });
          }
          const result = await overstayPenaltyService.chargeApprovedPenalty(overstayId);
          if (!result.success) {
            return res.status(400).json({
              error: result.error,
              message: "Failed to charge penalty. The chef may need to update their payment method."
            });
          }
          res.json({
            success: true,
            message: "Penalty charged successfully",
            paymentIntentId: result.paymentIntentId,
            chargeId: result.chargeId
          });
        } catch (error) {
          logger.error("Error charging penalty:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/overstays/:id/resolve",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const overstayId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          const { resolutionType, resolutionNotes } = req.body;
          if (isNaN(overstayId)) {
            return res.status(400).json({ error: "Invalid overstay ID" });
          }
          const ownsRecord = await verifyManagerOwnsOverstay(overstayId, managerId);
          if (!ownsRecord) {
            return res.status(403).json({ error: "Access denied" });
          }
          const validTypes = ["extended", "removed", "escalated"];
          if (!resolutionType || !validTypes.includes(resolutionType)) {
            return res.status(400).json({
              error: "Invalid resolution type. Must be: extended, removed, or escalated"
            });
          }
          const result = await overstayPenaltyService.resolveOverstay(
            overstayId,
            resolutionType,
            resolutionNotes,
            managerId
          );
          if (!result.success) {
            return res.status(400).json({ error: result.error });
          }
          res.json({
            success: true,
            message: `Overstay marked as ${resolutionType}`
          });
        } catch (error) {
          logger.error("Error resolving overstay:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/overstays-stats",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const managerLocations = await db.select({ id: locations.id }).from(locations).where(eq30(locations.managerId, managerId));
          const locationIds = managerLocations.map((l) => l.id);
          if (locationIds.length === 0) {
            return res.json({ stats: null });
          }
          const stats = await overstayPenaltyService.getOverstayStats(locationIds);
          res.json({ stats });
        } catch (error) {
          logger.error("Error fetching overstay stats:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/storage-checkouts/pending",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const managerLocations = await db.select({ id: locations.id }).from(locations).where(eq30(locations.managerId, managerId));
          const locationIds = managerLocations.map((l) => l.id);
          if (locationIds.length === 0) {
            return res.json({ pendingCheckouts: [] });
          }
          const { getPendingCheckoutReviews: getPendingCheckoutReviews2 } = await Promise.resolve().then(() => (init_storage_checkout_service(), storage_checkout_service_exports));
          const allPending = await getPendingCheckoutReviews2();
          logger.info(
            `[StorageCheckouts] Manager ${managerId} locations: ${locationIds.join(", ")}`
          );
          logger.info(
            `[StorageCheckouts] All pending checkouts: ${allPending.length}`
          );
          const pendingCheckouts = allPending.filter(
            (c) => locationIds.includes(c.locationId)
          );
          logger.info(
            `[StorageCheckouts] Filtered pending checkouts for manager: ${pendingCheckouts.length}`
          );
          res.json({ pendingCheckouts });
        } catch (error) {
          logger.error("Error fetching pending checkouts:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/storage-checkouts/history",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const limit = parseInt(req.query.limit) || 20;
          const managerLocations = await db.select({ id: locations.id }).from(locations).where(eq30(locations.managerId, managerId));
          const locationIds = managerLocations.map((l) => l.id);
          if (locationIds.length === 0) {
            return res.json({ checkoutHistory: [] });
          }
          const { getCheckoutHistory: getCheckoutHistory2 } = await Promise.resolve().then(() => (init_storage_checkout_service(), storage_checkout_service_exports));
          const checkoutHistory = await getCheckoutHistory2(locationIds, limit);
          res.json({ checkoutHistory });
        } catch (error) {
          logger.error("Error fetching checkout history:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/storage-bookings/:id/approve-checkout",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const storageBookingId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          const { managerNotes } = req.body;
          if (isNaN(storageBookingId)) {
            return res.status(400).json({ error: "Invalid storage booking ID" });
          }
          const { processCheckoutApproval: processCheckoutApproval2 } = await Promise.resolve().then(() => (init_storage_checkout_service(), storage_checkout_service_exports));
          const result = await processCheckoutApproval2(
            storageBookingId,
            managerId,
            "clear",
            managerNotes
          );
          if (!result.success) {
            return res.status(400).json({ error: result.error });
          }
          res.json({
            success: true,
            message: "Storage cleared \u2014 no issues found. Booking completed.",
            storageBookingId: result.storageBookingId,
            checkoutStatus: result.checkoutStatus
          });
        } catch (error) {
          logger.error("Error clearing checkout:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/storage-bookings/:id/clear-checkout",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const storageBookingId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          const { managerNotes } = req.body;
          if (isNaN(storageBookingId)) {
            return res.status(400).json({ error: "Invalid storage booking ID" });
          }
          const { processCheckoutApproval: processCheckoutApproval2 } = await Promise.resolve().then(() => (init_storage_checkout_service(), storage_checkout_service_exports));
          const result = await processCheckoutApproval2(
            storageBookingId,
            managerId,
            "clear",
            managerNotes
          );
          if (!result.success) {
            return res.status(400).json({ error: result.error });
          }
          res.json({
            success: true,
            message: "Storage cleared \u2014 no issues found. Booking completed.",
            storageBookingId: result.storageBookingId,
            checkoutStatus: result.checkoutStatus
          });
        } catch (error) {
          logger.error("Error clearing checkout:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/storage-bookings/:id/start-claim",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const storageBookingId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          const { claimTitle, claimDescription, claimedAmountCents, damageDate, managerNotes } = req.body;
          if (isNaN(storageBookingId)) {
            return res.status(400).json({ error: "Invalid storage booking ID" });
          }
          if (!claimTitle || typeof claimTitle !== "string" || claimTitle.trim().length < 5) {
            return res.status(400).json({ error: "Claim title must be at least 5 characters" });
          }
          if (!claimDescription || typeof claimDescription !== "string" || claimDescription.trim().length < 50) {
            return res.status(400).json({ error: "Claim description must be at least 50 characters" });
          }
          if (!claimedAmountCents || typeof claimedAmountCents !== "number" || claimedAmountCents <= 0) {
            return res.status(400).json({ error: "Claimed amount must be a positive number (in cents)" });
          }
          const { processCheckoutApproval: processCheckoutApproval2 } = await Promise.resolve().then(() => (init_storage_checkout_service(), storage_checkout_service_exports));
          const result = await processCheckoutApproval2(
            storageBookingId,
            managerId,
            "start_claim",
            managerNotes,
            {
              claimTitle: claimTitle.trim(),
              claimDescription: claimDescription.trim(),
              claimedAmountCents,
              damageDate
            }
          );
          if (!result.success) {
            return res.status(400).json({ error: result.error });
          }
          res.json({
            success: true,
            message: "Damage/cleaning claim started. The chef will be notified.",
            storageBookingId: result.storageBookingId,
            checkoutStatus: result.checkoutStatus,
            damageClaimId: result.damageClaimId
          });
        } catch (error) {
          logger.error("Error starting checkout claim:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/storage-bookings/:id/deny-checkout",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const storageBookingId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          const { managerNotes } = req.body;
          if (isNaN(storageBookingId)) {
            return res.status(400).json({ error: "Invalid storage booking ID" });
          }
          logger.warn(`[StorageCheckout] Deprecated deny-checkout called for booking ${storageBookingId}. Use clear-checkout or start-claim instead.`);
          const { processCheckoutApproval: processCheckoutApproval2 } = await Promise.resolve().then(() => (init_storage_checkout_service(), storage_checkout_service_exports));
          const result = await processCheckoutApproval2(
            storageBookingId,
            managerId,
            "deny",
            managerNotes
          );
          if (!result.success) {
            return res.status(400).json({ error: result.error });
          }
          res.json({
            success: true,
            message: "DEPRECATED: Deny is no longer supported. Storage has been cleared instead. Use /clear-checkout or /start-claim.",
            storageBookingId: result.storageBookingId,
            checkoutStatus: result.checkoutStatus,
            deprecated: true
          });
        } catch (error) {
          logger.error("Error processing legacy deny-checkout:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.put(
      "/storage-listings/:id/penalty-config",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const listingId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          const {
            overstayGracePeriodDays,
            overstayPenaltyRate,
            overstayMaxPenaltyDays,
            overstayPolicyText
          } = req.body;
          if (isNaN(listingId)) {
            return res.status(400).json({ error: "Invalid listing ID" });
          }
          const [listing] = await db.select({
            id: storageListings.id,
            managerId: locations.managerId
          }).from(storageListings).innerJoin(kitchens, eq30(storageListings.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).where(eq30(storageListings.id, listingId)).limit(1);
          if (!listing) {
            return res.status(404).json({ error: "Storage listing not found" });
          }
          if (listing.managerId !== managerId) {
            return res.status(403).json({ error: "Not authorized to update this listing" });
          }
          const updates = { updatedAt: /* @__PURE__ */ new Date() };
          if (overstayGracePeriodDays !== void 0) {
            const days = parseInt(overstayGracePeriodDays);
            if (isNaN(days) || days < 0 || days > 14) {
              return res.status(400).json({ error: "Grace period must be between 0 and 14 days" });
            }
            updates.overstayGracePeriodDays = days;
          }
          if (overstayPenaltyRate !== void 0) {
            const rate = parseFloat(overstayPenaltyRate);
            if (isNaN(rate) || rate < 0 || rate > 0.5) {
              return res.status(400).json({ error: "Penalty rate must be between 0 and 0.50 (50%)" });
            }
            updates.overstayPenaltyRate = rate.toString();
          }
          if (overstayMaxPenaltyDays !== void 0) {
            const maxDays = parseInt(overstayMaxPenaltyDays);
            if (isNaN(maxDays) || maxDays < 1 || maxDays > 90) {
              return res.status(400).json({ error: "Max penalty days must be between 1 and 90" });
            }
            updates.overstayMaxPenaltyDays = maxDays;
          }
          if (overstayPolicyText !== void 0) {
            updates.overstayPolicyText = overstayPolicyText || null;
          }
          await db.update(storageListings).set(updates).where(eq30(storageListings.id, listingId));
          logger.info(
            `[Manager] Updated penalty config for storage listing ${listingId}`,
            {
              managerId,
              updates
            }
          );
          res.json({
            success: true,
            message: "Penalty configuration updated successfully"
          });
        } catch (error) {
          logger.error("Error updating penalty config:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/locations/:id/overstay-penalty-defaults",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const locationId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          if (isNaN(locationId)) {
            return res.status(400).json({ error: "Invalid location ID" });
          }
          const [location] = await db.select({
            id: locations.id,
            managerId: locations.managerId,
            overstayGracePeriodDays: locations.overstayGracePeriodDays,
            overstayPenaltyRate: locations.overstayPenaltyRate,
            overstayMaxPenaltyDays: locations.overstayMaxPenaltyDays,
            overstayPolicyText: locations.overstayPolicyText
          }).from(locations).where(eq30(locations.id, locationId)).limit(1);
          if (!location) {
            return res.status(404).json({ error: "Location not found" });
          }
          if (location.managerId !== managerId) {
            return res.status(403).json({ error: "Not authorized to access this location" });
          }
          const { getOverstayPlatformDefaults: getOverstayPlatformDefaults2 } = await Promise.resolve().then(() => (init_overstay_defaults_service(), overstay_defaults_service_exports));
          const platformDefaults = await getOverstayPlatformDefaults2();
          res.json({
            locationDefaults: {
              gracePeriodDays: location.overstayGracePeriodDays,
              penaltyRate: location.overstayPenaltyRate ? parseFloat(location.overstayPenaltyRate.toString()) : null,
              maxPenaltyDays: location.overstayMaxPenaltyDays,
              policyText: location.overstayPolicyText
            },
            platformDefaults,
            isUsingDefaults: location.overstayGracePeriodDays === null && location.overstayPenaltyRate === null && location.overstayMaxPenaltyDays === null
          });
        } catch (error) {
          logger.error("Error getting location overstay penalty defaults:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.put(
      "/locations/:id/overstay-penalty-defaults",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const locationId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          const { gracePeriodDays, penaltyRate, maxPenaltyDays, policyText } = req.body;
          if (isNaN(locationId)) {
            return res.status(400).json({ error: "Invalid location ID" });
          }
          const [location] = await db.select({ id: locations.id, managerId: locations.managerId }).from(locations).where(eq30(locations.id, locationId)).limit(1);
          if (!location) {
            return res.status(404).json({ error: "Location not found" });
          }
          if (location.managerId !== managerId) {
            return res.status(403).json({ error: "Not authorized to update this location" });
          }
          const updates = { updatedAt: /* @__PURE__ */ new Date() };
          if (gracePeriodDays !== void 0) {
            if (gracePeriodDays !== null) {
              const days = parseInt(gracePeriodDays);
              if (isNaN(days) || days < 0 || days > 14) {
                return res.status(400).json({ error: "Grace period must be between 0 and 14 days" });
              }
              updates.overstayGracePeriodDays = days;
            } else {
              updates.overstayGracePeriodDays = null;
            }
          }
          if (penaltyRate !== void 0) {
            if (penaltyRate !== null) {
              const rate = parseFloat(penaltyRate);
              if (isNaN(rate) || rate < 0 || rate > 0.5) {
                return res.status(400).json({ error: "Penalty rate must be between 0 and 0.50 (50%)" });
              }
              updates.overstayPenaltyRate = rate.toString();
            } else {
              updates.overstayPenaltyRate = null;
            }
          }
          if (maxPenaltyDays !== void 0) {
            if (maxPenaltyDays !== null) {
              const maxDays = parseInt(maxPenaltyDays);
              if (isNaN(maxDays) || maxDays < 1 || maxDays > 90) {
                return res.status(400).json({ error: "Max penalty days must be between 1 and 90" });
              }
              updates.overstayMaxPenaltyDays = maxDays;
            } else {
              updates.overstayMaxPenaltyDays = null;
            }
          }
          if (policyText !== void 0) {
            updates.overstayPolicyText = policyText || null;
          }
          await db.update(locations).set(updates).where(eq30(locations.id, locationId));
          logger.info(
            `[Manager] Updated location ${locationId} overstay penalty defaults`,
            {
              managerId,
              updates
            }
          );
          res.json({
            success: true,
            message: "Location overstay penalty defaults updated successfully"
          });
        } catch (error) {
          logger.error("Error updating location overstay penalty defaults:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/damage-claims/recent-bookings",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const limits = await getDamageClaimLimits();
          const deadlineDays = limits.claimSubmissionDeadlineDays;
          const cutoffDate = /* @__PURE__ */ new Date();
          cutoffDate.setDate(cutoffDate.getDate() - deadlineDays);
          const managerLocations = await db.select({ id: locations.id }).from(locations).where(eq30(locations.managerId, managerId));
          const locationIds = managerLocations.map((l) => l.id);
          if (locationIds.length === 0) {
            return res.json({ bookings: [], deadlineDays });
          }
          const now = /* @__PURE__ */ new Date();
          const recentKitchenBookings = await db.select({
            id: kitchenBookings.id,
            chefId: kitchenBookings.chefId,
            kitchenId: kitchenBookings.kitchenId,
            bookingDate: kitchenBookings.bookingDate,
            startTime: kitchenBookings.startTime,
            endTime: kitchenBookings.endTime,
            status: kitchenBookings.status,
            chefName: users.username,
            kitchenName: kitchens.name,
            locationName: locations.name
          }).from(kitchenBookings).innerJoin(kitchens, eq30(kitchenBookings.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).innerJoin(users, eq30(kitchenBookings.chefId, users.id)).where(
            and18(
              inArray8(locations.id, locationIds),
              gte3(kitchenBookings.bookingDate, cutoffDate),
              // Not older than deadline
              lte3(kitchenBookings.bookingDate, now),
              // Must be in the past (booking date <= now)
              eq30(kitchenBookings.status, "confirmed")
            )
          ).orderBy(desc15(kitchenBookings.bookingDate)).limit(50);
          const recentStorageBookings = await db.select({
            id: storageBookings.id,
            chefId: storageBookings.chefId,
            storageListingId: storageBookings.storageListingId,
            startDate: storageBookings.startDate,
            endDate: storageBookings.endDate,
            status: storageBookings.status,
            chefName: users.username,
            locationName: locations.name
          }).from(storageBookings).innerJoin(
            storageListings,
            eq30(storageBookings.storageListingId, storageListings.id)
          ).innerJoin(kitchens, eq30(storageListings.kitchenId, kitchens.id)).innerJoin(locations, eq30(kitchens.locationId, locations.id)).innerJoin(users, eq30(storageBookings.chefId, users.id)).where(
            and18(
              inArray8(locations.id, locationIds),
              gte3(storageBookings.endDate, cutoffDate),
              // Not older than deadline
              lte3(storageBookings.endDate, now),
              // Must be in the past (end date <= now)
              eq30(storageBookings.status, "confirmed")
            )
          ).orderBy(desc15(storageBookings.endDate)).limit(50);
          const kitchenBookingIds = recentKitchenBookings.map((b) => b.id);
          const equipmentMap = /* @__PURE__ */ new Map();
          if (kitchenBookingIds.length > 0) {
            const rentedEquipment = await db.select({
              kitchenBookingId: equipmentBookings.kitchenBookingId,
              equipmentBookingId: equipmentBookings.id,
              equipmentListingId: equipmentBookings.equipmentListingId,
              equipmentType: equipmentListings.equipmentType,
              brand: equipmentListings.brand,
              availabilityType: equipmentListings.availabilityType,
              status: equipmentBookings.status
            }).from(equipmentBookings).innerJoin(equipmentListings, eq30(equipmentBookings.equipmentListingId, equipmentListings.id)).where(
              sql15`${equipmentBookings.kitchenBookingId} IN (${sql15.join(kitchenBookingIds.map((id) => sql15`${id}`), sql15`, `)})`
            );
            for (const eq_item of rentedEquipment) {
              const list = equipmentMap.get(eq_item.kitchenBookingId) || [];
              list.push({
                equipmentBookingId: eq_item.equipmentBookingId,
                equipmentListingId: eq_item.equipmentListingId,
                equipmentType: eq_item.equipmentType,
                brand: eq_item.brand,
                availabilityType: eq_item.availabilityType,
                status: eq_item.status
              });
              equipmentMap.set(eq_item.kitchenBookingId, list);
            }
            const kitchenIds = Array.from(new Set(recentKitchenBookings.map((b) => b.kitchenId)));
            if (kitchenIds.length > 0) {
              const includedEquipment = await db.select({
                kitchenId: equipmentListings.kitchenId,
                equipmentListingId: equipmentListings.id,
                equipmentType: equipmentListings.equipmentType,
                brand: equipmentListings.brand,
                availabilityType: equipmentListings.availabilityType
              }).from(equipmentListings).where(
                and18(
                  sql15`${equipmentListings.kitchenId} IN (${sql15.join(kitchenIds.map((id) => sql15`${id}`), sql15`, `)})`,
                  eq30(equipmentListings.availabilityType, "included"),
                  eq30(equipmentListings.isActive, true)
                )
              );
              for (const kb of recentKitchenBookings) {
                const list = equipmentMap.get(kb.id) || [];
                const kitchenIncluded = includedEquipment.filter((ie) => ie.kitchenId === kb.kitchenId);
                for (const ie of kitchenIncluded) {
                  if (!list.some((e) => e.equipmentListingId === ie.equipmentListingId)) {
                    list.push({
                      equipmentBookingId: null,
                      equipmentListingId: ie.equipmentListingId,
                      equipmentType: ie.equipmentType,
                      brand: ie.brand,
                      availabilityType: ie.availabilityType,
                      status: "confirmed"
                    });
                  }
                }
                equipmentMap.set(kb.id, list);
              }
            }
          }
          const bookings = [
            ...recentKitchenBookings.map((b) => ({
              id: b.id,
              type: "kitchen",
              chefId: b.chefId,
              chefName: b.chefName,
              locationName: b.locationName,
              kitchenName: b.kitchenName,
              startDate: b.bookingDate,
              endDate: b.bookingDate,
              status: b.status,
              label: `Kitchen #${b.id} - ${b.chefName} @ ${b.kitchenName} (${format5(new Date(b.bookingDate), "MMM d")})`,
              equipment: equipmentMap.get(b.id) || []
            })),
            ...recentStorageBookings.map((b) => ({
              id: b.id,
              type: "storage",
              chefId: b.chefId,
              chefName: b.chefName,
              locationName: b.locationName,
              kitchenName: null,
              startDate: b.startDate,
              endDate: b.endDate,
              status: b.status,
              label: `Storage #${b.id} - ${b.chefName} @ ${b.locationName} (${format5(new Date(b.endDate), "MMM d")})`,
              equipment: []
            }))
          ].sort(
            (a, b) => new Date(b.endDate).getTime() - new Date(a.endDate).getTime()
          );
          res.json({ bookings, deadlineDays });
        } catch (error) {
          logger.error("Error fetching recent bookings for damage claims:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/damage-claims",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const includeAll = req.query.includeAll === "true";
          const claims = await damageClaimService.getManagerClaims(
            managerId,
            includeAll
          );
          res.json({ claims });
        } catch (error) {
          logger.error("Error fetching damage claims:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/damage-claims/:id",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const claimId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          if (isNaN(claimId)) {
            return res.status(400).json({ error: "Invalid claim ID" });
          }
          const claim = await damageClaimService.getClaimById(claimId);
          if (!claim) {
            return res.status(404).json({ error: "Claim not found" });
          }
          if (claim.managerId !== managerId) {
            return res.status(403).json({ error: "Access denied" });
          }
          const history = await damageClaimService.getClaimHistory(claimId);
          res.json({ claim, history });
        } catch (error) {
          logger.error("Error fetching damage claim:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/damage-claims",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const {
            bookingType,
            kitchenBookingId,
            storageBookingId,
            claimTitle,
            claimDescription,
            damageDate,
            claimedAmountCents,
            damagedItems,
            submitImmediately
          } = req.body;
          if (!bookingType || !["kitchen", "storage"].includes(bookingType)) {
            return res.status(400).json({ error: "Invalid booking type" });
          }
          if (!claimTitle || claimTitle.length < 5) {
            return res.status(400).json({ error: "Claim title must be at least 5 characters" });
          }
          if (!claimDescription || claimDescription.length < 50) {
            return res.status(400).json({ error: "Claim description must be at least 50 characters" });
          }
          if (!damageDate) {
            return res.status(400).json({ error: "Damage date is required" });
          }
          if (!claimedAmountCents || claimedAmountCents < 1e3) {
            return res.status(400).json({ error: "Claimed amount must be at least $10" });
          }
          const result = await damageClaimService.createDamageClaim({
            bookingType,
            kitchenBookingId,
            storageBookingId,
            managerId,
            claimTitle,
            claimDescription,
            damageDate,
            claimedAmountCents,
            damagedItems: Array.isArray(damagedItems) ? damagedItems : void 0,
            submitImmediately: submitImmediately === true
          });
          if (!result.success) {
            return res.status(400).json({ error: result.error });
          }
          res.status(201).json({
            success: true,
            claim: result.claim
          });
        } catch (error) {
          logger.error("Error creating damage claim:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.put(
      "/damage-claims/:id",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const claimId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          if (isNaN(claimId)) {
            return res.status(400).json({ error: "Invalid claim ID" });
          }
          const { claimTitle, claimDescription, claimedAmountCents, damageDate } = req.body;
          const result = await damageClaimService.updateDraftClaim(
            claimId,
            managerId,
            {
              claimTitle,
              claimDescription,
              claimedAmountCents,
              damageDate
            }
          );
          if (!result.success) {
            return res.status(400).json({ error: result.error });
          }
          res.json({ success: true });
        } catch (error) {
          logger.error("Error updating damage claim:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/damage-claims/:id/submit",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const claimId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          if (isNaN(claimId)) {
            return res.status(400).json({ error: "Invalid claim ID" });
          }
          const result = await damageClaimService.submitClaim(claimId, managerId);
          if (!result.success) {
            return res.status(400).json({ error: result.error });
          }
          res.json({
            success: true,
            message: "Claim submitted to chef for response"
          });
        } catch (error) {
          logger.error("Error submitting damage claim:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/damage-claims/:id/history",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const claimId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          if (isNaN(claimId)) {
            return res.status(400).json({ error: "Invalid claim ID" });
          }
          const claim = await damageClaimService.getClaimById(claimId);
          if (!claim || claim.managerId !== managerId) {
            return res.status(403).json({ error: "Access denied" });
          }
          const history = await damageClaimService.getClaimHistory(claimId);
          res.json({ history });
        } catch (error) {
          logger.error("Error fetching claim history:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.delete(
      "/damage-claims/:id",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const claimId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          if (isNaN(claimId)) {
            return res.status(400).json({ error: "Invalid claim ID" });
          }
          const result = await damageClaimService.deleteDraftClaim(
            claimId,
            managerId
          );
          if (!result.success) {
            return res.status(400).json({ error: result.error });
          }
          res.json({ success: true, message: "Draft claim deleted successfully" });
        } catch (error) {
          logger.error("Error deleting claim:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/damage-claims/:id/evidence",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const claimId = parseInt(req.params.id);
          const userId = req.neonUser.id;
          if (isNaN(claimId)) {
            return res.status(400).json({ error: "Invalid claim ID" });
          }
          const {
            evidenceType,
            fileUrl,
            fileName,
            fileSize,
            mimeType,
            description,
            amountCents,
            vendorName
          } = req.body;
          if (!evidenceType || !fileUrl) {
            return res.status(400).json({ error: "Evidence type and file URL are required" });
          }
          const result = await damageClaimService.addEvidence(claimId, userId, {
            evidenceType,
            fileUrl,
            fileName,
            fileSize,
            mimeType,
            description,
            amountCents,
            vendorName
          });
          if (!result.success) {
            return res.status(400).json({ error: result.error });
          }
          res.status(201).json({
            success: true,
            evidence: result.evidence
          });
        } catch (error) {
          logger.error("Error adding evidence:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.delete(
      "/damage-claims/:id/evidence/:evidenceId",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const evidenceId = parseInt(req.params.evidenceId);
          const userId = req.neonUser.id;
          if (isNaN(evidenceId)) {
            return res.status(400).json({ error: "Invalid evidence ID" });
          }
          const result = await damageClaimService.removeEvidence(
            evidenceId,
            userId
          );
          if (!result.success) {
            return res.status(400).json({ error: result.error });
          }
          res.json({ success: true });
        } catch (error) {
          logger.error("Error removing evidence:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.post(
      "/damage-claims/:id/charge",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const claimId = parseInt(req.params.id);
          const managerId = req.neonUser.id;
          if (isNaN(claimId)) {
            return res.status(400).json({ error: "Invalid claim ID" });
          }
          const claimCheck = await damageClaimService.getClaimById(claimId);
          if (!claimCheck || claimCheck.managerId !== managerId) {
            return res.status(403).json({ error: "Access denied" });
          }
          const result = await damageClaimService.chargeApprovedClaim(claimId);
          if (!result.success) {
            return res.status(400).json({
              error: result.error,
              message: "Failed to charge damage claim. The chef may need to update their payment method."
            });
          }
          res.json({
            success: true,
            message: "Damage claim charged successfully",
            paymentIntentId: result.paymentIntentId,
            chargeId: result.chargeId
          });
        } catch (error) {
          logger.error("Error charging damage claim:", error);
          return errorResponse(res, error);
        }
      }
    );
    router15.get(
      "/damage-claims/:id/invoice",
      requireFirebaseAuthWithUser,
      requireManager,
      async (req, res) => {
        try {
          const managerId = req.neonUser.id;
          const claimId = parseInt(req.params.id);
          if (isNaN(claimId)) {
            return res.status(400).json({ error: "Invalid claim ID" });
          }
          const claim = await damageClaimService.getClaimById(claimId);
          if (!claim) {
            return res.status(404).json({ error: "Claim not found" });
          }
          if (claim.managerId !== managerId) {
            return res.status(403).json({ error: "Not authorized to view this claim" });
          }
          if (claim.status !== "charge_succeeded") {
            return res.status(400).json({ error: "Invoice only available for charged claims" });
          }
          const { generateDamageClaimInvoicePDF: generateDamageClaimInvoicePDF2 } = await Promise.resolve().then(() => (init_invoice_service(), invoice_service_exports));
          const pdfBuffer = await generateDamageClaimInvoicePDF2(claim, {
            viewer: "manager"
          });
          res.setHeader("Content-Type", "application/pdf");
          res.setHeader(
            "Content-Disposition",
            `attachment; filename="damage-claim-invoice-${claimId}.pdf"`
          );
          res.send(pdfBuffer);
        } catch (error) {
          logger.error("Error downloading damage claim invoice:", error);
          return errorResponse(res, error);
        }
      }
    );
    manager_default = router15;
  }
});

// server/routes/notifications.ts
var notifications_exports = {};
__export(notifications_exports, {
  archiveNotifications: () => archiveNotifications,
  cleanupOldNotifications: () => cleanupOldNotifications,
  createNotification: () => createNotification2,
  default: () => notifications_default,
  getNotifications: () => getNotifications,
  getUnreadCount: () => getUnreadCount,
  markAllAsRead: () => markAllAsRead,
  markAsRead: () => markAsRead
});
import { Router as Router16 } from "express";
import { sql as sql16 } from "drizzle-orm";
async function createNotification2(params) {
  const {
    managerId,
    locationId,
    type,
    priority = "normal",
    title,
    message,
    metadata = {},
    actionUrl,
    actionLabel,
    expiresAt
  } = params;
  const result = await db.execute(sql16`
    INSERT INTO manager_notifications 
    (manager_id, location_id, type, priority, title, message, metadata, action_url, action_label, expires_at)
    VALUES (
      ${managerId}, 
      ${locationId || null}, 
      ${type}::notification_type, 
      ${priority}::notification_priority, 
      ${title}, 
      ${message}, 
      ${JSON.stringify(metadata)}::jsonb, 
      ${actionUrl || null}, 
      ${actionLabel || null}, 
      ${expiresAt ? expiresAt.toISOString() : null}
    )
    RETURNING *
  `);
  return result.rows[0];
}
async function getNotifications(managerId, options = {}) {
  const {
    page = 1,
    limit = 20,
    filter = "all",
    type,
    locationId
  } = options;
  const offset = (page - 1) * limit;
  let filterCondition = sql16`AND is_archived = false`;
  if (filter === "unread") {
    filterCondition = sql16`AND is_read = false AND is_archived = false`;
  } else if (filter === "read") {
    filterCondition = sql16`AND is_read = true AND is_archived = false`;
  } else if (filter === "archived") {
    filterCondition = sql16`AND is_archived = true`;
  }
  const typeCondition = type ? sql16`AND type = ${type}::notification_type` : sql16``;
  const locationCondition = locationId ? sql16`AND (location_id = ${locationId} OR location_id IS NULL)` : sql16``;
  const notificationsResult = await db.execute(sql16`
    SELECT 
      id, manager_id, location_id, type, priority, title, message, 
      metadata, is_read, read_at, is_archived, archived_at, 
      action_url, action_label, created_at, expires_at
    FROM manager_notifications
    WHERE manager_id = ${managerId}
      AND (expires_at IS NULL OR expires_at > NOW())
      ${filterCondition}
      ${typeCondition}
      ${locationCondition}
    ORDER BY 
      CASE WHEN priority = 'urgent' THEN 0
           WHEN priority = 'high' THEN 1
           WHEN priority = 'normal' THEN 2
           ELSE 3 END,
      created_at DESC
    LIMIT ${limit}
    OFFSET ${offset}
  `);
  const countResult = await db.execute(sql16`
    SELECT COUNT(*) as total
    FROM manager_notifications
    WHERE manager_id = ${managerId}
      AND (expires_at IS NULL OR expires_at > NOW())
      ${filterCondition}
      ${typeCondition}
      ${locationCondition}
  `);
  const total = parseInt(countResult.rows[0]?.total || "0", 10);
  return {
    notifications: notificationsResult.rows,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
      hasMore: page * limit < total
    }
  };
}
async function getUnreadCount(managerId, locationId) {
  const locationCondition = locationId ? sql16`AND (location_id = ${locationId} OR location_id IS NULL)` : sql16``;
  const result = await db.execute(sql16`
    SELECT COUNT(*) as count
    FROM manager_notifications
    WHERE manager_id = ${managerId}
      AND is_read = false
      AND is_archived = false
      AND (expires_at IS NULL OR expires_at > NOW())
      ${locationCondition}
  `);
  return parseInt(result.rows[0]?.count || "0", 10);
}
async function markAsRead(managerId, notificationIds) {
  if (notificationIds.length === 0) return { updated: 0 };
  const result = await db.execute(sql16`
    UPDATE manager_notifications
    SET is_read = true, read_at = NOW()
    WHERE manager_id = ${managerId}
      AND id IN (${sql16.join(notificationIds.map((id) => sql16`${id}`), sql16`, `)})
      AND is_read = false
  `);
  return { updated: result.rowCount || 0 };
}
async function markAllAsRead(managerId, locationId) {
  const locationCondition = locationId ? sql16`AND location_id = ${locationId}` : sql16``;
  const result = await db.execute(sql16`
    UPDATE manager_notifications
    SET is_read = true, read_at = NOW()
    WHERE manager_id = ${managerId}
      AND is_read = false
      ${locationCondition}
  `);
  return { updated: result.rowCount || 0 };
}
async function archiveNotifications(managerId, notificationIds) {
  if (notificationIds.length === 0) return { updated: 0 };
  const result = await db.execute(sql16`
    UPDATE manager_notifications
    SET is_archived = true, archived_at = NOW()
    WHERE manager_id = ${managerId}
      AND id IN (${sql16.join(notificationIds.map((id) => sql16`${id}`), sql16`, `)})
      AND is_archived = false
  `);
  return { updated: result.rowCount || 0 };
}
async function unarchiveNotifications(managerId, notificationIds) {
  if (notificationIds.length === 0) return { updated: 0 };
  const result = await db.execute(sql16`
    UPDATE manager_notifications
    SET is_archived = false, archived_at = NULL
    WHERE manager_id = ${managerId}
      AND id IN (${sql16.join(notificationIds.map((id) => sql16`${id}`), sql16`, `)})
      AND is_archived = true
  `);
  return { updated: result.rowCount || 0 };
}
async function cleanupOldNotifications(daysOld = 90) {
  const result = await db.execute(sql16`
    DELETE FROM manager_notifications
    WHERE is_archived = true
      AND archived_at < NOW() - INTERVAL '${sql16.raw(String(daysOld))} days'
  `);
  return { deleted: result.rowCount || 0 };
}
var router16, notifications_default;
var init_notifications = __esm({
  "server/routes/notifications.ts"() {
    "use strict";
    init_db();
    init_firebase_auth_middleware();
    init_logger();
    init_api_response();
    router16 = Router16();
    router16.get("/", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const managerId = req.neonUser.id;
        const { page, limit, filter, type, locationId } = req.query;
        const result = await getNotifications(managerId, {
          page: page ? parseInt(page) : void 0,
          limit: limit ? parseInt(limit) : void 0,
          filter,
          type,
          locationId: locationId ? parseInt(locationId) : void 0
        });
        res.json(result);
      } catch (error) {
        logger.error("Error fetching notifications:", error);
        return errorResponse(res, error);
      }
    });
    router16.get("/unread-count", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const managerId = req.neonUser.id;
        const { locationId } = req.query;
        const count3 = await getUnreadCount(
          managerId,
          locationId ? parseInt(locationId) : void 0
        );
        res.json({ count: count3 });
      } catch (error) {
        logger.error("Error fetching unread count:", error);
        return errorResponse(res, error);
      }
    });
    router16.post("/mark-read", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const managerId = req.neonUser.id;
        const { notificationIds } = req.body;
        if (!Array.isArray(notificationIds)) {
          return res.status(400).json({ error: "notificationIds must be an array" });
        }
        const result = await markAsRead(managerId, notificationIds);
        res.json(result);
      } catch (error) {
        logger.error("Error marking notifications as read:", error);
        return errorResponse(res, error);
      }
    });
    router16.post("/mark-all-read", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const managerId = req.neonUser.id;
        const { locationId } = req.body;
        const result = await markAllAsRead(
          managerId,
          locationId ? parseInt(locationId) : void 0
        );
        res.json(result);
      } catch (error) {
        logger.error("Error marking all as read:", error);
        return errorResponse(res, error);
      }
    });
    router16.post("/archive", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const managerId = req.neonUser.id;
        const { notificationIds } = req.body;
        if (!Array.isArray(notificationIds)) {
          return res.status(400).json({ error: "notificationIds must be an array" });
        }
        const result = await archiveNotifications(managerId, notificationIds);
        res.json(result);
      } catch (error) {
        logger.error("Error archiving notifications:", error);
        return errorResponse(res, error);
      }
    });
    router16.post("/unarchive", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const managerId = req.neonUser.id;
        const { notificationIds } = req.body;
        if (!Array.isArray(notificationIds)) {
          return res.status(400).json({ error: "notificationIds must be an array" });
        }
        const result = await unarchiveNotifications(managerId, notificationIds);
        res.json(result);
      } catch (error) {
        logger.error("Error unarchiving notifications:", error);
        return errorResponse(res, error);
      }
    });
    router16.post("/message-received", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        const { managerId, locationId, senderName, messagePreview, conversationId } = req.body;
        if (!managerId || !senderName || !conversationId) {
          return res.status(400).json({ error: "managerId, senderName, and conversationId are required" });
        }
        await createNotification2({
          managerId,
          locationId,
          type: "message_received",
          priority: "normal",
          title: `Message from ${senderName}`,
          message: messagePreview?.length > 100 ? `${messagePreview.substring(0, 100)}...` : messagePreview || "You have a new message",
          metadata: {
            senderName,
            conversationId
          },
          actionUrl: `/manager/booking/:id`,
          actionLabel: "View Message"
        });
        res.json({ success: true });
      } catch (error) {
        logger.error("Error creating message notification:", error);
        return errorResponse(res, error);
      }
    });
    router16.delete("/:id", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const managerId = req.neonUser.id;
        const notificationId = parseInt(req.params.id);
        const result = await db.execute(sql16`
      DELETE FROM manager_notifications
      WHERE id = ${notificationId}
        AND manager_id = ${managerId}
    `);
        if (result.rowCount === 0) {
          return res.status(404).json({ error: "Notification not found" });
        }
        res.json({ deleted: true });
      } catch (error) {
        logger.error("Error deleting notification:", error);
        return errorResponse(res, error);
      }
    });
    notifications_default = router16;
  }
});

// server/routes/chef-notifications.ts
var chef_notifications_exports = {};
__export(chef_notifications_exports, {
  archiveNotifications: () => archiveNotifications2,
  default: () => chef_notifications_default,
  getNotifications: () => getNotifications2,
  getUnreadCount: () => getUnreadCount2,
  markAllAsRead: () => markAllAsRead2,
  markAsRead: () => markAsRead2,
  notificationService: () => notificationService
});
import { Router as Router17 } from "express";
import { sql as sql17 } from "drizzle-orm";
async function getNotifications2(chefId, options = {}) {
  const {
    page = 1,
    limit = 20,
    filter = "all",
    type
  } = options;
  const offset = (page - 1) * limit;
  let filterCondition = sql17`AND is_archived = false`;
  if (filter === "unread") {
    filterCondition = sql17`AND is_read = false AND is_archived = false`;
  } else if (filter === "read") {
    filterCondition = sql17`AND is_read = true AND is_archived = false`;
  } else if (filter === "archived") {
    filterCondition = sql17`AND is_archived = true`;
  }
  const typeCondition = type ? sql17`AND type = ${type}::chef_notification_type` : sql17``;
  const notificationsResult = await db.execute(sql17`
    SELECT 
      id, chef_id, type, priority, title, message, 
      metadata, is_read, read_at, is_archived, archived_at, 
      action_url, action_label, created_at, expires_at
    FROM chef_notifications
    WHERE chef_id = ${chefId}
      AND (expires_at IS NULL OR expires_at > NOW())
      ${filterCondition}
      ${typeCondition}
    ORDER BY 
      CASE WHEN priority = 'urgent' THEN 0
           WHEN priority = 'high' THEN 1
           WHEN priority = 'normal' THEN 2
           ELSE 3 END,
      created_at DESC
    LIMIT ${limit}
    OFFSET ${offset}
  `);
  const countResult = await db.execute(sql17`
    SELECT COUNT(*) as total
    FROM chef_notifications
    WHERE chef_id = ${chefId}
      AND (expires_at IS NULL OR expires_at > NOW())
      ${filterCondition}
      ${typeCondition}
  `);
  const total = parseInt(countResult.rows[0]?.total || "0", 10);
  return {
    notifications: notificationsResult.rows,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
      hasMore: page * limit < total
    }
  };
}
async function getUnreadCount2(chefId) {
  const result = await db.execute(sql17`
    SELECT COUNT(*) as count
    FROM chef_notifications
    WHERE chef_id = ${chefId}
      AND is_read = false
      AND is_archived = false
      AND (expires_at IS NULL OR expires_at > NOW())
  `);
  return { count: parseInt(result.rows[0]?.count || "0", 10) };
}
async function markAsRead2(chefId, notificationIds) {
  if (notificationIds.length === 0) return { updated: 0 };
  const result = await db.execute(sql17`
    UPDATE chef_notifications
    SET is_read = true, read_at = NOW()
    WHERE chef_id = ${chefId}
      AND id IN (${sql17.join(notificationIds.map((id) => sql17`${id}`), sql17`, `)})
      AND is_read = false
  `);
  return { updated: result.rowCount || 0 };
}
async function markAllAsRead2(chefId) {
  const result = await db.execute(sql17`
    UPDATE chef_notifications
    SET is_read = true, read_at = NOW()
    WHERE chef_id = ${chefId}
      AND is_read = false
      AND is_archived = false
  `);
  return { updated: result.rowCount || 0 };
}
async function archiveNotifications2(chefId, notificationIds) {
  if (notificationIds.length === 0) return { updated: 0 };
  const result = await db.execute(sql17`
    UPDATE chef_notifications
    SET is_archived = true, archived_at = NOW()
    WHERE chef_id = ${chefId}
      AND id IN (${sql17.join(notificationIds.map((id) => sql17`${id}`), sql17`, `)})
      AND is_archived = false
  `);
  return { updated: result.rowCount || 0 };
}
var router17, chef_notifications_default;
var init_chef_notifications = __esm({
  "server/routes/chef-notifications.ts"() {
    "use strict";
    init_db();
    init_firebase_auth_middleware();
    init_logger();
    init_api_response();
    init_notification_service();
    router17 = Router17();
    router17.get("/", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const { page, limit, filter, type } = req.query;
        const result = await getNotifications2(chefId, {
          page: page ? parseInt(page, 10) : void 0,
          limit: limit ? parseInt(limit, 10) : void 0,
          filter,
          type
        });
        res.json(result);
      } catch (error) {
        logger.error("Error fetching chef notifications:", error);
        return errorResponse(res, "Failed to fetch notifications", 500);
      }
    });
    router17.get("/unread-count", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const result = await getUnreadCount2(chefId);
        res.json(result);
      } catch (error) {
        logger.error("Error fetching chef unread count:", error);
        return errorResponse(res, "Failed to fetch unread count", 500);
      }
    });
    router17.post("/mark-read", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const { notificationIds } = req.body;
        if (!Array.isArray(notificationIds)) {
          return res.status(400).json({ error: "notificationIds must be an array" });
        }
        const result = await markAsRead2(chefId, notificationIds);
        res.json(result);
      } catch (error) {
        logger.error("Error marking chef notifications as read:", error);
        return errorResponse(res, "Failed to mark as read", 500);
      }
    });
    router17.post("/mark-all-read", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const result = await markAllAsRead2(chefId);
        res.json(result);
      } catch (error) {
        logger.error("Error marking all chef notifications as read:", error);
        return errorResponse(res, "Failed to mark all as read", 500);
      }
    });
    router17.post("/archive", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const { notificationIds } = req.body;
        if (!Array.isArray(notificationIds)) {
          return res.status(400).json({ error: "notificationIds must be an array" });
        }
        const result = await archiveNotifications2(chefId, notificationIds);
        res.json(result);
      } catch (error) {
        logger.error("Error archiving chef notifications:", error);
        return errorResponse(res, "Failed to archive notifications", 500);
      }
    });
    router17.post("/message-received", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        const { chefId, senderName, messagePreview, conversationId } = req.body;
        if (!chefId || !senderName || !conversationId) {
          return res.status(400).json({ error: "chefId, senderName, and conversationId are required" });
        }
        await notificationService.notifyChefMessage({
          chefId,
          senderName,
          messagePreview: messagePreview || "You have a new message",
          conversationId
        });
        res.json({ success: true });
      } catch (error) {
        logger.error("Error creating message notification:", error);
        return errorResponse(res, "Failed to create notification", 500);
      }
    });
    router17.delete("/:id", requireFirebaseAuthWithUser, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const notificationId = parseInt(req.params.id);
        const result = await db.execute(sql17`
      DELETE FROM chef_notifications
      WHERE id = ${notificationId}
        AND chef_id = ${chefId}
    `);
        if (result.rowCount === 0) {
          return res.status(404).json({ error: "Notification not found" });
        }
        res.json({ deleted: true });
      } catch (error) {
        logger.error("Error deleting chef notification:", error);
        return errorResponse(res, "Failed to delete notification", 500);
      }
    });
    chef_notifications_default = router17;
  }
});

// server/routes/kitchens.ts
var kitchens_exports = {};
__export(kitchens_exports, {
  default: () => kitchens_default
});
import { Router as Router18 } from "express";
import { eq as eq32, inArray as inArray9, desc as desc17, and as and20 } from "drizzle-orm";
var router18, kitchens_default;
var init_kitchens = __esm({
  "server/routes/kitchens.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_middleware();
    init_utils();
    init_schema();
    init_email();
    init_phone_utils();
    init_kitchen_service();
    init_location_service();
    init_chef_service();
    init_booking_service();
    init_user_service();
    router18 = Router18();
    router18.get("/chef/kitchens", requireChef, async (req, res) => {
      try {
        const allKitchens = await kitchenService.getAllKitchensWithLocation();
        const activeKitchens = allKitchens.filter((kitchen) => kitchen.isActive);
        const normalizedKitchens = activeKitchens.map((kitchen) => {
          const normalizedImageUrl = normalizeImageUrl(kitchen.imageUrl || null, req);
          const normalizedGalleryImages = (kitchen.galleryImages || []).map(
            (img) => normalizeImageUrl(img, req)
          ).filter((url) => url !== null);
          const locationBrandImageUrl = kitchen.location?.brandImageUrl || null;
          const locationLogoUrl = kitchen.location?.logoUrl || null;
          const normalizedLocationBrandImageUrl = normalizeImageUrl(locationBrandImageUrl, req);
          const normalizedLocationLogoUrl = normalizeImageUrl(locationLogoUrl, req);
          return {
            ...kitchen,
            imageUrl: normalizedImageUrl,
            image_url: normalizedImageUrl,
            // Also set snake_case for compatibility
            galleryImages: normalizedGalleryImages,
            gallery_images: normalizedGalleryImages,
            // Also set snake_case for compatibility
            locationBrandImageUrl: normalizedLocationBrandImageUrl,
            location_brand_image_url: normalizedLocationBrandImageUrl,
            // Also set snake_case for compatibility
            locationLogoUrl: normalizedLocationLogoUrl,
            location_logo_url: normalizedLocationLogoUrl
            // Also set snake_case for compatibility
          };
        });
        logger.info(`[API] /api/chef/kitchens - Returning ${normalizedKitchens.length} active kitchens (all locations for marketing)`);
        res.json(normalizedKitchens);
      } catch (error) {
        logger.error("Error fetching kitchens:", error);
        res.status(500).json({ error: "Failed to fetch kitchens", details: error.message });
      }
    });
    router18.get("/chef/kitchens/:kitchenId/pricing", requireChef, async (req, res) => {
      try {
        const kitchenId = parseInt(req.params.kitchenId);
        if (isNaN(kitchenId) || kitchenId <= 0) {
          return res.status(400).json({ error: "Invalid kitchen ID" });
        }
        const kitchen = await kitchenService.getKitchenById(kitchenId);
        const pricing = {
          hourlyRate: kitchen.hourlyRate,
          currency: kitchen.currency,
          pricingModel: kitchen.pricingModel,
          minimumBookingHours: kitchen.minimumBookingHours
        };
        res.json(pricing);
      } catch (error) {
        if (error.statusCode === 404) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        logger.error("Error getting kitchen pricing:", error);
        res.status(500).json({ error: error.message || "Failed to get kitchen pricing" });
      }
    });
    router18.get("/chef/kitchens/:kitchenId/policy", requireChef, async (req, res) => {
      try {
        const kitchenId = parseInt(req.params.kitchenId);
        if (isNaN(kitchenId) || kitchenId <= 0) {
          return res.status(400).json({ error: "Invalid kitchen ID" });
        }
        const kitchen = await kitchenService.getKitchenById(kitchenId);
        const locationId = kitchen.locationId;
        if (!locationId) {
          return res.status(404).json({ error: "Location not found for this kitchen" });
        }
        const location = await locationService.getLocationById(locationId);
        const maxSlotsPerChef = location.defaultDailyBookingLimit ?? 2;
        res.json({ maxSlotsPerChef });
      } catch (error) {
        if (error.statusCode === 404) {
          return res.status(404).json({ error: error.message });
        }
        logger.error("Error getting kitchen policy:", error);
        res.status(500).json({ error: error.message || "Failed to get kitchen policy" });
      }
    });
    router18.post("/chef/share-profile", requireChef, async (req, res) => {
      try {
        const { locationId } = req.body;
        const chefId = req.user.id;
        if (!locationId) {
          return res.status(400).json({ error: "locationId is required" });
        }
        const hasLocationAccess = await chefService.hasLocationAccess(chefId, locationId);
        if (!hasLocationAccess) {
          return res.status(403).json({ error: "You don't have access to this location. Please contact an administrator." });
        }
        const chef = await userService.getUser(chefId);
        if (!chef) {
          return res.status(404).json({ error: "Chef not found" });
        }
        const location = await locationService.getLocationById(locationId);
        if (!location) {
          return res.status(404).json({ error: "Location not found" });
        }
        const chefApp = await db.select().from(applications).where(and20(
          eq32(applications.userId, chefId),
          eq32(applications.status, "approved")
        )).orderBy(desc17(applications.createdAt)).limit(1);
        const profile = await chefService.shareProfileWithLocation(chefId, locationId);
        if (profile && profile.status === "pending") {
          try {
            const managerEmail = location.notificationEmail || location.notification_email;
            if (managerEmail) {
              const chefName = chefApp.length > 0 && chefApp[0].fullName ? chefApp[0].fullName : chef.username || "Chef";
              const chefEmail = chefApp.length > 0 && chefApp[0].email ? chefApp[0].email : chef.email || chef.username || "chef@example.com";
              const emailContent = generateChefProfileRequestEmail({
                managerEmail,
                chefName,
                chefEmail,
                locationName: location.name || "Location",
                locationId
              });
              await sendEmail(emailContent);
              logger.info(`\u2705 Chef profile request notification sent to manager: ${managerEmail}`);
            }
          } catch (emailError) {
            logger.error("Error sending chef profile request notification:", emailError);
          }
        }
        res.status(201).json(profile);
      } catch (error) {
        logger.error("Error sharing chef profile:", error);
        res.status(500).json({ error: error.message || "Failed to share profile" });
      }
    });
    router18.get("/chef/profiles", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const locationAccessRecords = await db.select().from(chefLocationAccess).where(eq32(chefLocationAccess.chefId, chefId));
        const locationIds = locationAccessRecords.map((access) => access.locationId);
        if (locationIds.length === 0) {
          return res.json([]);
        }
        const allLocations = await db.select().from(locations).where(inArray9(locations.id, locationIds));
        const profiles = await Promise.all(
          locationIds.map(async (locationId) => {
            const profile = await chefService.getProfile(chefId, locationId);
            const location = allLocations.find((l) => l.id === locationId);
            return { locationId, location, profile };
          })
        );
        res.json(profiles);
      } catch (error) {
        logger.error("Error getting chef profiles:", error);
        res.status(500).json({ error: error.message || "Failed to get profiles" });
      }
    });
    router18.get("/chef/kitchens/:kitchenId/slots", requireChef, async (req, res) => {
      try {
        const kitchenId = parseInt(req.params.kitchenId);
        const { date: date2 } = req.query;
        if (!date2) {
          return res.status(400).json({ error: "Date parameter is required" });
        }
        const [year, month, day] = date2.split("-").map(Number);
        const bookingDate = new Date(Date.UTC(year, month - 1, day, 12, 0, 0));
        if (isNaN(bookingDate.getTime())) {
          return res.status(400).json({ error: "Invalid date format" });
        }
        const slotsInfo = await bookingService.getAllTimeSlotsWithBookingInfo(kitchenId, bookingDate);
        res.json(slotsInfo);
      } catch (error) {
        logger.error("Error fetching time slots:", error);
        res.status(500).json({
          error: "Failed to fetch time slots",
          message: error.message
        });
      }
    });
    router18.get("/chef/kitchens/:kitchenId/availability", requireChef, async (req, res) => {
      try {
        const kitchenId = parseInt(req.params.kitchenId);
        const { date: date2 } = req.query;
        if (!date2) {
          return res.status(400).json({ error: "Date parameter is required" });
        }
        const [year, month, day] = date2.split("-").map(Number);
        const bookingDate = new Date(Date.UTC(year, month - 1, day, 12, 0, 0));
        if (isNaN(bookingDate.getTime())) {
          return res.status(400).json({ error: "Invalid date format" });
        }
        logger.info(`\u{1F50D} Fetching available slots for kitchen ${kitchenId} on ${date2}`);
        const slots = await bookingService.getAvailableTimeSlots(kitchenId, bookingDate);
        logger.info(`\u2705 Returning ${slots.length} available slots`);
        res.json(slots);
      } catch (error) {
        logger.error("Error fetching available slots:", error);
        res.status(500).json({
          error: "Failed to fetch available slots",
          message: error.message
        });
      }
    });
    router18.get("/chef/my-profile", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const [userData] = await db.select().from(users).where(eq32(users.id, chefId)).limit(1);
        if (!userData) {
          return res.status(404).json({ error: "User not found" });
        }
        const [latestApp] = await db.select().from(applications).where(and20(
          eq32(applications.userId, chefId),
          eq32(applications.status, "approved")
        )).orderBy(desc17(applications.createdAt)).limit(1);
        let profileData = {};
        try {
          const raw = userData.managerProfileData;
          if (raw && typeof raw === "object" && !Array.isArray(raw)) {
            profileData = raw;
          }
        } catch {
        }
        res.json({
          phone: profileData.phone || latestApp?.phone || null,
          displayName: profileData.displayName || latestApp?.fullName || null,
          profileImageUrl: profileData.profileImageUrl || null,
          applicationStatus: latestApp?.status || null,
          applicationFullName: latestApp?.fullName || null,
          applicationEmail: latestApp?.email || null,
          applicationPhone: latestApp?.phone || null
        });
      } catch (error) {
        logger.error("[Chef Profile] GET error:", error);
        res.status(500).json({ error: error.message || "Failed to fetch chef profile" });
      }
    });
    router18.put("/chef/my-profile", requireChef, async (req, res) => {
      try {
        const user = req.neonUser;
        const { username, displayName, phone, profileImageUrl } = req.body;
        const profileUpdates = {};
        if (displayName !== void 0) profileUpdates.displayName = displayName;
        if (phone !== void 0) {
          if (phone && phone.trim() !== "") {
            const normalized = normalizePhoneForStorage(phone);
            if (!normalized) return res.status(400).json({ error: "Invalid phone number format" });
            profileUpdates.phone = normalized;
          } else {
            profileUpdates.phone = null;
          }
        }
        if (profileImageUrl !== void 0) profileUpdates.profileImageUrl = profileImageUrl;
        if (username !== void 0 && username !== user.username) {
          const existingUser = await userService.getUserByUsername(username);
          if (existingUser && existingUser.id !== user.id) {
            return res.status(400).json({ error: "Username already taken" });
          }
          await userService.updateUser(user.id, { username });
        }
        if (Object.keys(profileUpdates).length > 0) {
          const [currentUser] = await db.select({ managerProfileData: users.managerProfileData }).from(users).where(eq32(users.id, user.id)).limit(1);
          const currentData = currentUser?.managerProfileData || {};
          const newData = { ...currentData, ...profileUpdates };
          await db.update(users).set({ managerProfileData: newData }).where(eq32(users.id, user.id));
        }
        const [updatedUser] = await db.select({ managerProfileData: users.managerProfileData }).from(users).where(eq32(users.id, user.id)).limit(1);
        const finalProfile = updatedUser?.managerProfileData || {};
        res.json({
          profileImageUrl: finalProfile.profileImageUrl || null,
          phone: finalProfile.phone || null,
          displayName: finalProfile.displayName || null
        });
      } catch (error) {
        logger.error("[Chef Profile] PUT error:", error);
        res.status(500).json({ error: error.message || "Failed to update chef profile" });
      }
    });
    kitchens_default = router18;
  }
});

// server/routes/equipment.ts
var equipment_exports = {};
__export(equipment_exports, {
  default: () => equipment_default
});
import { Router as Router19 } from "express";
var router19, equipment_default;
var init_equipment = __esm({
  "server/routes/equipment.ts"() {
    "use strict";
    init_logger();
    init_firebase_auth_middleware();
    init_middleware();
    init_inventory_service();
    init_kitchen_service();
    init_location_service();
    router19 = Router19();
    router19.get("/manager/kitchens/:kitchenId/equipment-listings", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const user = req.neonUser;
        const kitchenId = parseInt(req.params.kitchenId);
        if (isNaN(kitchenId) || kitchenId <= 0) {
          return res.status(400).json({ error: "Invalid kitchen ID" });
        }
        const kitchen = await kitchenService.getKitchenById(kitchenId);
        if (!kitchen) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const locations5 = await locationService.getLocationsByManagerId(user.id);
        const hasAccess = locations5.some((loc) => loc.id === kitchen.locationId);
        if (!hasAccess) {
          return res.status(403).json({ error: "Access denied to this kitchen" });
        }
        const listings = await inventoryService.getEquipmentListingsByKitchen(kitchenId);
        res.json(listings);
      } catch (error) {
        logger.error("Error getting equipment listings:", error);
        res.status(500).json({ error: error.message || "Failed to get equipment listings" });
      }
    });
    router19.get("/manager/equipment-listings/:listingId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const user = req.neonUser;
        const listingId = parseInt(req.params.listingId);
        if (isNaN(listingId) || listingId <= 0) {
          return res.status(400).json({ error: "Invalid listing ID" });
        }
        const listing = await inventoryService.getEquipmentListingById(listingId);
        if (!listing) {
          return res.status(404).json({ error: "Equipment listing not found" });
        }
        const kitchen = await kitchenService.getKitchenById(listing.kitchenId);
        if (!kitchen) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const locations5 = await locationService.getLocationsByManagerId(user.id);
        const hasAccess = locations5.some((loc) => loc.id === kitchen.locationId);
        if (!hasAccess) {
          return res.status(403).json({ error: "Access denied to this listing" });
        }
        res.json(listing);
      } catch (error) {
        logger.error("Error getting equipment listing:", error);
        res.status(500).json({ error: error.message || "Failed to get equipment listing" });
      }
    });
    router19.post("/manager/equipment-listings", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const user = req.neonUser;
        const { kitchenId, ...listingData } = req.body;
        if (!kitchenId || isNaN(parseInt(kitchenId))) {
          return res.status(400).json({ error: "Valid kitchen ID is required" });
        }
        const kitchen = await kitchenService.getKitchenById(parseInt(kitchenId));
        if (!kitchen) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const locations5 = await locationService.getLocationsByManagerId(user.id);
        const hasAccess = locations5.some((loc) => loc.id === kitchen.locationId);
        if (!hasAccess) {
          return res.status(403).json({ error: "Access denied to this kitchen" });
        }
        if (!listingData.equipmentType || !listingData.category || !listingData.condition) {
          return res.status(400).json({ error: "Equipment type, category, and condition are required" });
        }
        if (!listingData.availabilityType || !["included", "rental"].includes(listingData.availabilityType)) {
          return res.status(400).json({ error: "Availability type must be 'included' or 'rental'" });
        }
        if (listingData.availabilityType === "rental") {
          if (!listingData.sessionRate || listingData.sessionRate <= 0) {
            return res.status(400).json({ error: "Session rate is required for rental equipment" });
          }
        }
        const created = await inventoryService.createEquipmentListing({
          kitchenId: parseInt(kitchenId),
          ...listingData
        });
        logger.info(`\u2705 Equipment listing created by manager ${user.id}`);
        res.status(201).json(created);
      } catch (error) {
        logger.error("Error creating equipment listing:", error);
        res.status(500).json({ error: error.message || "Failed to create equipment listing" });
      }
    });
    router19.put("/manager/equipment-listings/:listingId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const user = req.neonUser;
        const listingId = parseInt(req.params.listingId);
        if (isNaN(listingId) || listingId <= 0) {
          return res.status(400).json({ error: "Invalid listing ID" });
        }
        const existingListing = await inventoryService.getEquipmentListingById(listingId);
        if (!existingListing) {
          return res.status(404).json({ error: "Equipment listing not found" });
        }
        const kitchen = await kitchenService.getKitchenById(existingListing.kitchenId);
        if (!kitchen) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const locations5 = await locationService.getLocationsByManagerId(user.id);
        const hasAccess = locations5.some((loc) => loc.id === kitchen.locationId);
        if (!hasAccess) {
          return res.status(403).json({ error: "Access denied to this listing" });
        }
        const updated = await inventoryService.updateEquipmentListing(listingId, req.body);
        logger.info(`\u2705 Equipment listing ${listingId} updated by manager ${user.id}`);
        res.json(updated);
      } catch (error) {
        logger.error("Error updating equipment listing:", error);
        res.status(500).json({ error: error.message || "Failed to update equipment listing" });
      }
    });
    router19.delete("/manager/equipment-listings/:listingId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const user = req.neonUser;
        const listingId = parseInt(req.params.listingId);
        if (isNaN(listingId) || listingId <= 0) {
          return res.status(400).json({ error: "Invalid listing ID" });
        }
        const existingListing = await inventoryService.getEquipmentListingById(listingId);
        if (!existingListing) {
          return res.status(404).json({ error: "Equipment listing not found" });
        }
        const kitchen = await kitchenService.getKitchenById(existingListing.kitchenId);
        if (!kitchen) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const locations5 = await locationService.getLocationsByManagerId(user.id);
        const hasAccess = locations5.some((loc) => loc.id === kitchen.locationId);
        if (!hasAccess) {
          return res.status(403).json({ error: "Access denied to this listing" });
        }
        await inventoryService.deleteEquipmentListing(listingId);
        logger.info(`\u2705 Equipment listing ${listingId} deleted by manager ${user.id}`);
        res.json({ success: true });
      } catch (error) {
        logger.error("Error deleting equipment listing:", error);
        res.status(500).json({ error: error.message || "Failed to delete equipment listing" });
      }
    });
    router19.get("/chef/kitchens/:kitchenId/equipment-listings", requireChef, async (req, res) => {
      try {
        const kitchenId = parseInt(req.params.kitchenId);
        if (isNaN(kitchenId) || kitchenId <= 0) {
          return res.status(400).json({ error: "Invalid kitchen ID" });
        }
        const allListings = await inventoryService.getEquipmentListingsByKitchen(kitchenId);
        const visibleListings = allListings.filter(
          (listing) => listing.isActive === true
        );
        const includedEquipment = visibleListings.filter((l) => l.availabilityType === "included");
        const rentalEquipment = visibleListings.filter((l) => l.availabilityType === "rental");
        logger.info(`[API] /api/chef/kitchens/${kitchenId}/equipment-listings - Returning ${visibleListings.length} visible listings (${includedEquipment.length} included, ${rentalEquipment.length} rental)`);
        res.json({
          all: visibleListings,
          included: includedEquipment,
          rental: rentalEquipment
        });
      } catch (error) {
        logger.error("Error getting equipment listings for chef:", error);
        res.status(500).json({ error: error.message || "Failed to get equipment listings" });
      }
    });
    equipment_default = router19;
  }
});

// server/routes/storage-listings.ts
var storage_listings_exports = {};
__export(storage_listings_exports, {
  default: () => storage_listings_default
});
import { Router as Router20 } from "express";
var router20, storage_listings_default;
var init_storage_listings = __esm({
  "server/routes/storage-listings.ts"() {
    "use strict";
    init_logger();
    init_firebase_auth_middleware();
    init_middleware();
    init_inventory_service();
    init_kitchen_service();
    init_location_service();
    init_overstay_defaults_service();
    router20 = Router20();
    router20.get("/manager/kitchens/:kitchenId/storage-listings", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const user = req.neonUser;
        const kitchenId = parseInt(req.params.kitchenId);
        if (isNaN(kitchenId) || kitchenId <= 0) {
          return res.status(400).json({ error: "Invalid kitchen ID" });
        }
        const kitchen = await kitchenService.getKitchenById(kitchenId);
        if (!kitchen) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const locations5 = await locationService.getLocationsByManagerId(user.id);
        const hasAccess = locations5.some((loc) => loc.id === kitchen.locationId);
        if (!hasAccess) {
          return res.status(403).json({ error: "Access denied to this kitchen" });
        }
        const listings = await inventoryService.getStorageListingsByKitchen(kitchenId);
        res.json(listings);
      } catch (error) {
        logger.error("Error getting storage listings:", error);
        res.status(500).json({ error: error.message || "Failed to get storage listings" });
      }
    });
    router20.get("/manager/storage-listings/:listingId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const user = req.neonUser;
        const listingId = parseInt(req.params.listingId);
        if (isNaN(listingId) || listingId <= 0) {
          return res.status(400).json({ error: "Invalid listing ID" });
        }
        const listing = await inventoryService.getStorageListingById(listingId);
        if (!listing) {
          return res.status(404).json({ error: "Storage listing not found" });
        }
        const kitchen = await kitchenService.getKitchenById(listing.kitchenId);
        if (!kitchen) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const locations5 = await locationService.getLocationsByManagerId(user.id);
        const hasAccess = locations5.some((loc) => loc.id === kitchen.locationId);
        if (!hasAccess) {
          return res.status(403).json({ error: "Access denied to this listing" });
        }
        res.json(listing);
      } catch (error) {
        logger.error("Error getting storage listing:", error);
        res.status(500).json({ error: error.message || "Failed to get storage listing" });
      }
    });
    router20.post("/manager/storage-listings", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const user = req.neonUser;
        const { kitchenId, ...listingData } = req.body;
        if (!kitchenId || isNaN(parseInt(kitchenId))) {
          return res.status(400).json({ error: "Valid kitchen ID is required" });
        }
        const kitchen = await kitchenService.getKitchenById(parseInt(kitchenId));
        if (!kitchen) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const locations5 = await locationService.getLocationsByManagerId(user.id);
        const hasAccess = locations5.some((loc) => loc.id === kitchen.locationId);
        if (!hasAccess) {
          return res.status(403).json({ error: "Access denied to this kitchen" });
        }
        if (!listingData.name || !listingData.storageType || !listingData.pricingModel || !listingData.basePrice) {
          return res.status(400).json({ error: "Name, storage type, pricing model, and base price are required" });
        }
        const locationDefaults = await getOverstayLocationDefaults(kitchen.locationId);
        const listingDataWithDefaults = {
          ...listingData,
          // Only apply location defaults if listing data doesn't already include these values
          overstayGracePeriodDays: listingData.overstayGracePeriodDays !== void 0 ? listingData.overstayGracePeriodDays : locationDefaults.gracePeriodDays ?? 3,
          overstayPenaltyRate: listingData.overstayPenaltyRate !== void 0 ? listingData.overstayPenaltyRate : locationDefaults.penaltyRate ?? 0.1,
          overstayMaxPenaltyDays: listingData.overstayMaxPenaltyDays !== void 0 ? listingData.overstayMaxPenaltyDays : locationDefaults.maxPenaltyDays ?? 30,
          overstayPolicyText: listingData.overstayPolicyText !== void 0 ? listingData.overstayPolicyText : locationDefaults.policyText
        };
        const created = await inventoryService.createStorageListing({
          kitchenId: parseInt(kitchenId),
          ...listingDataWithDefaults,
          status: "active",
          // Auto-activate manager-created listings
          isActive: true
        });
        logger.info(`\u2705 Storage listing created by manager ${user.id}`);
        res.status(201).json(created);
      } catch (error) {
        logger.error("Error creating storage listing:", error);
        res.status(500).json({ error: error.message || "Failed to create storage listing" });
      }
    });
    router20.put("/manager/storage-listings/:listingId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const user = req.neonUser;
        const listingId = parseInt(req.params.listingId);
        if (isNaN(listingId) || listingId <= 0) {
          return res.status(400).json({ error: "Invalid listing ID" });
        }
        const existingListing = await inventoryService.getStorageListingById(listingId);
        if (!existingListing) {
          return res.status(404).json({ error: "Storage listing not found" });
        }
        const kitchen = await kitchenService.getKitchenById(existingListing.kitchenId);
        if (!kitchen) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const locations5 = await locationService.getLocationsByManagerId(user.id);
        const hasAccess = locations5.some((loc) => loc.id === kitchen.locationId);
        if (!hasAccess) {
          return res.status(403).json({ error: "Access denied to this listing" });
        }
        const updated = await inventoryService.updateStorageListing(listingId, req.body);
        logger.info(`\u2705 Storage listing ${listingId} updated by manager ${user.id}`);
        res.json(updated);
      } catch (error) {
        logger.error("Error updating storage listing:", error);
        res.status(500).json({ error: error.message || "Failed to update storage listing" });
      }
    });
    router20.delete("/manager/storage-listings/:listingId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
      try {
        const user = req.neonUser;
        const listingId = parseInt(req.params.listingId);
        if (isNaN(listingId) || listingId <= 0) {
          return res.status(400).json({ error: "Invalid listing ID" });
        }
        const existingListing = await inventoryService.getStorageListingById(listingId);
        if (!existingListing) {
          return res.status(404).json({ error: "Storage listing not found" });
        }
        const kitchen = await kitchenService.getKitchenById(existingListing.kitchenId);
        if (!kitchen) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const locations5 = await locationService.getLocationsByManagerId(user.id);
        const hasAccess = locations5.some((loc) => loc.id === kitchen.locationId);
        if (!hasAccess) {
          return res.status(403).json({ error: "Access denied to this listing" });
        }
        await inventoryService.deleteStorageListing(listingId);
        logger.info(`\u2705 Storage listing ${listingId} deleted by manager ${user.id}`);
        res.json({ success: true });
      } catch (error) {
        logger.error("Error deleting storage listing:", error);
        res.status(500).json({ error: error.message || "Failed to delete storage listing" });
      }
    });
    router20.get("/chef/kitchens/:kitchenId/storage-listings", requireChef, async (req, res) => {
      try {
        const kitchenId = parseInt(req.params.kitchenId);
        if (isNaN(kitchenId) || kitchenId <= 0) {
          return res.status(400).json({ error: "Invalid kitchen ID" });
        }
        const allListings = await inventoryService.getStorageListingsByKitchen(kitchenId);
        const visibleListings = allListings.filter(
          (listing) => (listing.status === "approved" || listing.status === "active") && listing.isActive === true
        );
        logger.info(`[API] /api/chef/kitchens/${kitchenId}/storage-listings - Returning ${visibleListings.length} visible listings (out of ${allListings.length} total)`);
        res.json(visibleListings);
      } catch (error) {
        logger.error("Error getting storage listings for chef:", error);
        res.status(500).json({ error: error.message || "Failed to get storage listings" });
      }
    });
    storage_listings_default = router20;
  }
});

// server/security.ts
var security_exports = {};
__export(security_exports, {
  escapeHtml: () => escapeHtml,
  getDefaultRateLimits: () => getDefaultRateLimits,
  getRateLimitConfig: () => getRateLimitConfig,
  invalidateRateLimitCache: () => invalidateRateLimitCache,
  registerSecurityMiddleware: () => registerSecurityMiddleware,
  sanitizeErrorForClient: () => sanitizeErrorForClient
});
import helmet from "helmet";
import cors from "cors";
import rateLimit from "express-rate-limit";
import { sql as sql18 } from "drizzle-orm";
async function loadRateLimitConfig() {
  const now = Date.now();
  if (now - lastConfigFetch < CONFIG_CACHE_TTL) {
    return cachedConfig;
  }
  try {
    const result = await db.execute(sql18`
      SELECT key, value FROM platform_settings 
      WHERE key LIKE 'rate_limit_%'
    `);
    const settings = {};
    for (const row of result.rows) {
      settings[row.key] = row.value;
    }
    cachedConfig = {
      globalWindowMs: parseInt(settings["rate_limit_global_window_ms"] || "") || DEFAULT_RATE_LIMITS.globalWindowMs,
      globalMaxRequests: parseInt(settings["rate_limit_global_max"] || "") || DEFAULT_RATE_LIMITS.globalMaxRequests,
      authWindowMs: parseInt(settings["rate_limit_auth_window_ms"] || "") || DEFAULT_RATE_LIMITS.authWindowMs,
      authMaxRequests: parseInt(settings["rate_limit_auth_max"] || "") || DEFAULT_RATE_LIMITS.authMaxRequests,
      apiWindowMs: parseInt(settings["rate_limit_api_window_ms"] || "") || DEFAULT_RATE_LIMITS.apiWindowMs,
      apiMaxRequests: parseInt(settings["rate_limit_api_max"] || "") || DEFAULT_RATE_LIMITS.apiMaxRequests,
      webhookWindowMs: parseInt(settings["rate_limit_webhook_window_ms"] || "") || DEFAULT_RATE_LIMITS.webhookWindowMs,
      webhookMaxRequests: parseInt(settings["rate_limit_webhook_max"] || "") || DEFAULT_RATE_LIMITS.webhookMaxRequests
    };
    lastConfigFetch = now;
  } catch (error) {
    logger.info("[Security] Using default rate limits (DB config not available)");
  }
  return cachedConfig;
}
function invalidateRateLimitCache() {
  lastConfigFetch = 0;
}
async function getRateLimitConfig() {
  return loadRateLimitConfig();
}
function getDefaultRateLimits() {
  return { ...DEFAULT_RATE_LIMITS };
}
function getCorsOrigins() {
  const origins = [
    "https://localcooks.ca",
    "https://www.localcooks.ca",
    "https://chef.localcooks.ca",
    "https://kitchen.localcooks.ca",
    "https://admin.localcooks.ca",
    // Dev environment subdomains (Vercel Preview deployment)
    "https://dev.localcooks.ca",
    "https://dev-chef.localcooks.ca",
    "https://dev-kitchen.localcooks.ca",
    "https://dev-admin.localcooks.ca",
    // Vercel preview deployments
    /^https:\/\/local-cooks-community.*\.vercel\.app$/
  ];
  if (process.env.NODE_ENV === "development" || !process.env.VERCEL) {
    origins.push("http://localhost:5001");
    origins.push("http://localhost:5173");
    origins.push("http://localhost:3000");
    origins.push(/^http:\/\/localhost:\d+$/);
    origins.push(/^http:\/\/[a-z]+\.localhost:\d+$/);
  }
  const customOrigins = process.env.CORS_ALLOWED_ORIGINS;
  if (customOrigins) {
    customOrigins.split(",").map((o) => o.trim()).filter(Boolean).forEach((o) => origins.push(o));
  }
  return origins;
}
function escapeHtml(str) {
  if (!str) return "";
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function sanitizeErrorForClient(error, fallbackMessage) {
  if (process.env.NODE_ENV === "development") {
    return error instanceof Error ? error.message : fallbackMessage;
  }
  return fallbackMessage;
}
function registerSecurityMiddleware(app2) {
  const isProduction2 = process.env.VERCEL_ENV === "production" || process.env.NODE_ENV === "production";
  app2.use(helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        scriptSrc: [
          "'self'",
          "'unsafe-inline'",
          // Required for Vite HMR in dev
          "'unsafe-eval'",
          // Required for Vite HMR in dev
          "https://js.stripe.com",
          "https://code.tidio.co",
          "https://widget-v4.tidiochat.com",
          "https://maps.googleapis.com",
          "https://apis.google.com",
          "https://accounts.google.com",
          "https://www.gstatic.com",
          ...isProduction2 ? [] : ["http://localhost:*"]
        ],
        styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
        fontSrc: ["'self'", "https://fonts.gstatic.com", "data:", "https://r2cdn.perplexity.ai"],
        workerSrc: ["'self'", "blob:"],
        // Required for Sentry tracing worker
        imgSrc: ["'self'", "data:", "blob:", "https:", "http:"],
        connectSrc: [
          "'self'",
          "https://api.stripe.com",
          "https://*.firebaseio.com",
          "https://*.googleapis.com",
          "https://*.cloudfunctions.net",
          "https://code.tidio.co",
          "https://widget-v4.tidiochat.com",
          "wss://*.tidiochat.com",
          "https://files.localcooks.ca",
          "https://*.ingest.us.sentry.io",
          ...isProduction2 ? ["https://*.localcooks.ca"] : ["http://localhost:*", "ws://localhost:*"]
        ],
        frameSrc: [
          "'self'",
          "https://js.stripe.com",
          "https://hooks.stripe.com",
          "https://widget-v4.tidiochat.com",
          "https://accounts.google.com",
          "https://*.firebaseapp.com"
        ],
        mediaSrc: [
          "'self'",
          "https://pub-dc8137b10b784e3e9f6c75b8d78ca468.r2.dev",
          "blob:"
        ],
        objectSrc: ["'none'"],
        baseUri: ["'self'"],
        formAction: ["'self'"],
        frameAncestors: ["'self'"]
      }
    },
    crossOriginEmbedderPolicy: false,
    // Required for Stripe/Tidio iframes
    crossOriginOpenerPolicy: { policy: "same-origin-allow-popups" },
    // Required for OAuth popups
    crossOriginResourcePolicy: { policy: "cross-origin" }
    // Allow cross-origin images
  }));
  app2.use(cors({
    origin: getCorsOrigins(),
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With"],
    maxAge: 86400
    // Cache preflight for 24 hours
  }));
  const globalLimiter = rateLimit({
    windowMs: DEFAULT_RATE_LIMITS.globalWindowMs,
    max: async () => {
      const config = await loadRateLimitConfig();
      return config.globalMaxRequests;
    },
    standardHeaders: true,
    legacyHeaders: false,
    message: { error: "Too many requests. Please try again later." },
    skip: (req) => {
      if (req.path === "/api/webhooks/stripe") return true;
      if (!isProduction2 && !req.path.startsWith("/api/")) return true;
      return false;
    },
    // In production (behind Vercel proxy), use X-Forwarded-For; in dev, use default
    ...isProduction2 ? {
      keyGenerator: (req) => {
        return req.headers["x-forwarded-for"]?.split(",")[0]?.trim() || req.ip || "unknown";
      }
    } : {},
    validate: false
  });
  app2.use(globalLimiter);
  const authLimiter = rateLimit({
    windowMs: DEFAULT_RATE_LIMITS.authWindowMs,
    max: async () => {
      const config = await loadRateLimitConfig();
      return config.authMaxRequests;
    },
    standardHeaders: true,
    legacyHeaders: false,
    message: { error: "Too many authentication attempts. Please wait before trying again." },
    ...isProduction2 ? {
      keyGenerator: (req) => {
        return req.headers["x-forwarded-for"]?.split(",")[0]?.trim() || req.ip || "unknown";
      }
    } : {},
    validate: false
  });
  app2.use("/api/portal-login", authLimiter);
  app2.use("/api/firebase-register-user", authLimiter);
  app2.use("/api/firebase-sync-user", authLimiter);
  app2.use("/api/user-exists", authLimiter);
  const webhookLimiter = rateLimit({
    windowMs: DEFAULT_RATE_LIMITS.webhookWindowMs,
    max: async () => {
      const config = await loadRateLimitConfig();
      return config.webhookMaxRequests;
    },
    standardHeaders: true,
    legacyHeaders: false,
    ...isProduction2 ? {
      keyGenerator: (req) => {
        return req.headers["x-forwarded-for"]?.split(",")[0]?.trim() || req.ip || "unknown";
      }
    } : {},
    validate: false
  });
  app2.use("/api/webhooks", webhookLimiter);
  logger.info(`[Security] Helmet, CORS, and Rate Limiting configured (env: ${isProduction2 ? "production" : "development"})`);
}
var DEFAULT_RATE_LIMITS, cachedConfig, lastConfigFetch, CONFIG_CACHE_TTL;
var init_security = __esm({
  "server/security.ts"() {
    "use strict";
    init_logger();
    init_db();
    DEFAULT_RATE_LIMITS = {
      globalWindowMs: 15 * 60 * 1e3,
      // 15 minutes
      globalMaxRequests: 300,
      // 300 requests per 15 min (dev-friendly)
      authWindowMs: 15 * 60 * 1e3,
      // 15 minutes
      authMaxRequests: 15,
      // 15 auth attempts per 15 min
      apiWindowMs: 1 * 60 * 1e3,
      // 1 minute
      apiMaxRequests: 60,
      // 60 API calls per minute
      webhookWindowMs: 1 * 60 * 1e3,
      // 1 minute
      webhookMaxRequests: 100
      // 100 webhook calls per minute (Stripe bursts)
    };
    cachedConfig = { ...DEFAULT_RATE_LIMITS };
    lastConfigFetch = 0;
    CONFIG_CACHE_TTL = 6e4;
  }
});

// server/routes/admin.ts
var admin_exports = {};
__export(admin_exports, {
  default: () => admin_default
});
import { Router as Router21 } from "express";
import { eq as eq33, sql as sql19, ilike } from "drizzle-orm";
import { getFirestore as getFirestore2 } from "firebase-admin/firestore";
async function getFirestoreDisplayNames(firebaseUids) {
  const nameMap = {};
  if (!firebaseUids.length) return nameMap;
  try {
    if (!firestoreDb) {
      const app2 = initializeFirebaseAdmin();
      if (!app2) return nameMap;
      firestoreDb = getFirestore2(app2);
      firestoreDb.settings({ ignoreUndefinedProperties: true });
    }
    const refs = firebaseUids.map((uid) => firestoreDb.collection("users").doc(uid));
    const docs = await firestoreDb.getAll(...refs);
    docs.forEach((doc) => {
      if (doc.exists) {
        const data = doc.data();
        if (data?.displayName) {
          nameMap[doc.id] = data.displayName;
        }
      }
    });
  } catch (error) {
    logger.error("Error fetching Firestore display names:", error);
  }
  return nameMap;
}
function emailPrefix(email) {
  return email.includes("@") ? email.split("@")[0] : email;
}
async function getAuthenticatedUser2(req) {
  if (req.neonUser) {
    return {
      id: req.neonUser.id,
      username: req.neonUser.username,
      role: req.neonUser.role || ""
    };
  }
  return null;
}
var firestoreDb, router21, handleAdminDamageClaimDecision, admin_default;
var init_admin = __esm({
  "server/routes/admin.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_user_service();
    init_firebase_auth_middleware();
    init_schema();
    init_email();
    init_phone_utils();
    init_passwordUtils();
    init_firebase_setup();
    init_location_service();
    init_kitchen_service();
    init_chef_service();
    init_booking_service();
    init_stripe_checkout_fee_service();
    init_damage_claim_service();
    init_damage_claim_limits_service();
    firestoreDb = null;
    router21 = Router21();
    router21.get("/users", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const search = req.query.search;
        let query = db.select({
          id: users.id,
          username: users.username,
          role: users.role,
          firebaseUid: users.firebaseUid
        }).from(users);
        if (search && search.trim()) {
          const searchPattern = `%${search.trim()}%`;
          query = query.where(
            ilike(users.username, searchPattern)
          );
        }
        const dbUsers = await query.limit(50);
        const firebaseUids = dbUsers.map((u) => u.firebaseUid).filter((uid) => !!uid);
        const displayNames = await getFirestoreDisplayNames(firebaseUids);
        const mappedUsers = dbUsers.map((u) => {
          const displayName = u.firebaseUid ? displayNames[u.firebaseUid] : null;
          return {
            id: u.id,
            username: u.username,
            email: u.username,
            fullName: displayName || u.username,
            role: u.role || "user",
            displayText: displayName ? `${displayName} (${u.username})` : u.username
          };
        });
        let filteredUsers = mappedUsers;
        if (search && search.trim()) {
          const lowerSearch = search.trim().toLowerCase();
          filteredUsers = mappedUsers.filter(
            (u) => u.username.toLowerCase().includes(lowerSearch) || u.fullName.toLowerCase().includes(lowerSearch)
          );
        }
        res.json({ users: filteredUsers });
      } catch (error) {
        logger.error("Error fetching users:", error);
        res.status(500).json({ error: "Failed to fetch users" });
      }
    });
    router21.get("/revenue/all-managers", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        if (res.headersSent) {
          return;
        }
        const { startDate, endDate } = req.query;
        const conditions = [sql19`pt.status = 'succeeded'`];
        if (startDate) {
          conditions.push(sql19`DATE(pt.paid_at) >= ${startDate}::date`);
        }
        if (endDate) {
          conditions.push(sql19`DATE(pt.paid_at) <= ${endDate}::date`);
        }
        const txnFilters = sql19.join(conditions, sql19` AND `);
        const managerRole = "manager";
        const result = await db.execute(sql19`
        SELECT 
          u.id as manager_id,
          u.username as manager_name,
          u.username as manager_email,
          COALESCE(SUM(pt.amount::numeric), 0)::bigint as total_revenue,
          COALESCE(SUM(pt.service_fee::numeric), 0)::bigint as platform_fee,
          COALESCE(SUM(pt.manager_revenue::numeric), 0)::bigint as manager_revenue,
          COUNT(pt.id)::int as booking_count,
          COALESCE(SUM(pt.refund_amount::numeric), 0)::bigint as total_refunds
        FROM users u
        LEFT JOIN payment_transactions pt ON pt.manager_id = u.id AND ${txnFilters}
        WHERE u.role = ${managerRole}
        GROUP BY u.id, u.username
        ORDER BY total_revenue DESC
      `);
        const managers = result.rows.map((row) => ({
          managerId: parseInt(row.manager_id),
          managerName: row.manager_name,
          managerEmail: row.manager_email,
          totalRevenue: (parseInt(row.total_revenue) || 0) / 100,
          platformFee: (parseInt(row.platform_fee) || 0) / 100,
          managerRevenue: (parseInt(row.manager_revenue) || 0) / 100,
          bookingCount: parseInt(row.booking_count) || 0,
          totalRefunds: (parseInt(row.total_refunds) || 0) / 100
        })).filter((m) => m.bookingCount > 0 || m.totalRevenue > 0);
        res.json({ managers, total: managers.length });
      } catch (error) {
        logger.error("Error getting all managers revenue:", error);
        res.status(500).json({ error: error.message || "Failed to get all managers revenue" });
      }
    });
    router21.get("/revenue/platform-overview", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        if (res.headersSent) {
          return;
        }
        const { startDate, endDate } = req.query;
        const managerCountResult = await db.select({ count: sql19`count(*)::int` }).from(users).where(eq33(users.role, "manager"));
        const totalManagers = managerCountResult[0]?.count || 0;
        const conditions = [sql19`kb.status != 'cancelled'`];
        if (startDate) {
          conditions.push(sql19`kb.booking_date >= ${startDate}::date`);
        }
        if (endDate) {
          conditions.push(sql19`kb.booking_date <= ${endDate}::date`);
        }
        const bookingFilters = sql19.join(conditions, sql19` AND `);
        const bookingResult = await db.execute(sql19`
        SELECT 
          COALESCE(SUM(kb.total_price), 0)::bigint as total_revenue,
          COALESCE(SUM(kb.service_fee), 0)::bigint as platform_fee,
          COUNT(*)::int as booking_count,
          COUNT(CASE WHEN kb.payment_status = 'paid' THEN 1 END)::int as paid_count,
          COUNT(CASE WHEN kb.payment_status = 'pending' THEN 1 END)::int as pending_count
        FROM kitchen_bookings kb
        JOIN kitchens k ON kb.kitchen_id = k.id
        JOIN locations l ON k.location_id = l.id
        WHERE ${bookingFilters}
      `);
        const row = bookingResult.rows[0] || {};
        res.json({
          totalPlatformRevenue: (parseInt(row.total_revenue) || 0) / 100,
          totalPlatformFees: (parseInt(row.platform_fee) || 0) / 100,
          activeManagers: totalManagers,
          // Use total managers count, not just those with bookings
          totalBookings: parseInt(row.booking_count) || 0,
          paidBookingCount: parseInt(row.paid_count) || 0,
          pendingBookingCount: parseInt(row.pending_count) || 0,
          _raw: {
            totalRevenue: parseInt(row.total_revenue) || 0,
            platformFee: parseInt(row.platform_fee) || 0
          }
        });
      } catch (error) {
        logger.error("Error getting platform overview:", error);
        res.status(500).json({ error: error.message || "Failed to get platform overview" });
      }
    });
    router21.get("/revenue/manager/:managerId", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        if (res.headersSent) {
          return;
        }
        const managerId = parseInt(req.params.managerId);
        if (isNaN(managerId) || managerId <= 0) {
          return res.status(400).json({ error: "Invalid manager ID" });
        }
        const { startDate, endDate } = req.query;
        const { pool: pool3 } = await Promise.resolve().then(() => (init_db(), db_exports));
        const { getCompleteRevenueMetrics: getCompleteRevenueMetrics2, getRevenueByLocation: getRevenueByLocation2 } = await Promise.resolve().then(() => (init_revenue_service(), revenue_service_exports));
        const metrics = await getCompleteRevenueMetrics2(
          managerId,
          db,
          startDate ? new Date(startDate) : void 0,
          endDate ? new Date(endDate) : void 0
        );
        const revenueByLocation = await getRevenueByLocation2(
          managerId,
          db,
          startDate ? new Date(startDate) : void 0,
          endDate ? new Date(endDate) : void 0
        );
        const [managerRecord] = await db.select({ id: users.id, username: users.username }).from(users).where(eq33(users.id, managerId)).limit(1);
        res.json({
          manager: managerRecord || null,
          metrics: {
            ...metrics,
            totalRevenue: metrics.totalRevenue / 100,
            platformFee: metrics.platformFee / 100,
            managerRevenue: metrics.managerRevenue / 100,
            pendingPayments: metrics.pendingPayments / 100,
            completedPayments: metrics.completedPayments / 100,
            averageBookingValue: metrics.averageBookingValue / 100,
            refundedAmount: metrics.refundedAmount / 100
          },
          revenueByLocation: revenueByLocation.map((loc) => ({
            ...loc,
            totalRevenue: loc.totalRevenue / 100,
            platformFee: loc.platformFee / 100,
            managerRevenue: loc.managerRevenue / 100
          }))
        });
      } catch (error) {
        logger.error("Error getting manager revenue details:", error);
        res.status(500).json({ error: error.message || "Failed to get manager revenue details" });
      }
    });
    router21.post("/chef-location-access", async (req, res) => {
      try {
        const sessionUser = await getAuthenticatedUser2(req);
        const isFirebaseAuth = req.neonUser;
        if (!sessionUser && !isFirebaseAuth) {
          return res.status(401).json({ error: "Not authenticated" });
        }
        const user = isFirebaseAuth ? req.neonUser : sessionUser;
        if (user.role !== "admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const { chefId, locationId } = req.body;
        if (!chefId || !locationId) {
          return res.status(400).json({ error: "chefId and locationId are required" });
        }
        const access = await chefService.grantLocationAccess(chefId, locationId, user.id);
        try {
          const location = await locationService.getLocationById(locationId);
          if (!location) {
            logger.warn(`\u26A0\uFE0F Location ${locationId} not found for email notification`);
          } else {
            const chef = await userService.getUser(chefId);
            if (!chef) {
              logger.warn(`\u26A0\uFE0F Chef ${chefId} not found for email notification`);
            } else {
              try {
                const chefEmail = generateChefLocationAccessApprovedEmail({
                  chefEmail: chef.username || "",
                  chefName: chef.username || "Chef",
                  locationName: location.name || "Location",
                  locationId
                });
                await sendEmail(chefEmail);
                logger.info(`\u2705 Chef location access granted email sent to chef: ${chef.username}`);
              } catch (emailError) {
                logger.error("Error sending chef access email:", emailError);
                logger.error("Chef email error details:", emailError instanceof Error ? emailError.message : emailError);
              }
            }
          }
        } catch (emailError) {
          logger.error("Error sending chef access emails:", emailError);
        }
        res.status(201).json(access);
      } catch (error) {
        logger.error("Error granting chef location access:", error);
        res.status(500).json({ error: error.message || "Failed to grant access" });
      }
    });
    router21.delete("/chef-location-access", async (req, res) => {
      try {
        const sessionUser = await getAuthenticatedUser2(req);
        const isFirebaseAuth = req.neonUser;
        if (!sessionUser && !isFirebaseAuth) {
          return res.status(401).json({ error: "Not authenticated" });
        }
        const user = isFirebaseAuth ? req.neonUser : sessionUser;
        if (user.role !== "admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const { chefId, locationId } = req.body;
        if (!chefId || !locationId) {
          return res.status(400).json({ error: "chefId and locationId are required" });
        }
        await chefService.revokeLocationAccess(chefId, locationId);
        res.json({ success: true });
      } catch (error) {
        logger.error("Error revoking chef location access:", error);
        res.status(500).json({ error: error.message || "Failed to revoke access" });
      }
    });
    router21.get("/chef-location-access", async (req, res) => {
      try {
        logger.info("[Admin Chef Access] GET request received");
        const sessionUser = await getAuthenticatedUser2(req);
        const isFirebaseAuth = req.neonUser;
        logger.info("[Admin Chef Access] Auth check:", { hasSession: !!sessionUser, hasFirebase: !!isFirebaseAuth });
        if (!sessionUser && !isFirebaseAuth) {
          logger.info("[Admin Chef Access] Not authenticated");
          return res.status(401).json({ error: "Not authenticated" });
        }
        const user = isFirebaseAuth ? req.neonUser : sessionUser;
        logger.info("[Admin Chef Access] User:", { id: user.id, role: user.role });
        if (user.role !== "admin") {
          logger.info("[Admin Chef Access] Not admin");
          return res.status(403).json({ error: "Admin access required" });
        }
        const allUsers = await db.select({
          id: users.id,
          username: users.username,
          role: users.role,
          isChef: users.isChef
        }).from(users);
        const chefs = allUsers.filter((u) => {
          const role = u.role;
          const isChef = u.isChef ?? u.is_chef;
          return role === "chef" || isChef === true;
        });
        logger.info(`[Admin Chef Access] Total users: ${allUsers.length}, Found ${chefs.length} chefs in database`);
        const allLocations = await db.select().from(locations);
        logger.info(`[Admin Chef Access] Found ${allLocations.length} locations`);
        let allAccess = [];
        try {
          allAccess = await db.select().from(chefLocationAccess);
          logger.info(`[Admin Chef Access] Found ${allAccess.length} location access records`);
        } catch (error) {
          logger.error(`[Admin Chef Access] Error querying chef_location_access table:`, error.message);
          if (error.message?.includes("does not exist") || error.message?.includes("relation") || error.code === "42P01") {
            logger.info(`[Admin Chef Access] Table doesn't exist yet, returning empty access`);
            allAccess = [];
          } else {
            throw error;
          }
        }
        const response = chefs.map((chef) => {
          const chefAccess = allAccess.filter((a) => {
            const accessChefId = a.chefId ?? a.chef_id;
            return accessChefId === chef.id;
          });
          const accessibleLocations = chefAccess.map((access) => {
            const accessLocationId = access.locationId ?? access.location_id;
            const location = allLocations.find((l) => l.id === accessLocationId);
            if (location) {
              const grantedAt = access.grantedAt ?? access.granted_at;
              return {
                id: location.id,
                name: location.name,
                address: location.address ?? null,
                accessGrantedAt: grantedAt ? typeof grantedAt === "string" ? grantedAt : new Date(grantedAt).toISOString() : void 0
              };
            }
            return null;
          }).filter((l) => l !== null);
          return {
            chef: {
              id: chef.id,
              username: chef.username
            },
            accessibleLocations
          };
        });
        logger.info(`[Admin Chef Access] Returning ${response.length} chefs with location access info`);
        res.json(response);
      } catch (error) {
        logger.error("[Admin Chef Access] Error:", error);
        logger.error("[Admin Chef Access] Error stack:", error.stack);
        res.status(500).json({ error: error.message || "Failed to get access" });
      }
    });
    router21.post("/managers", async (req, res) => {
      try {
        const sessionUser = await getAuthenticatedUser2(req);
        const isFirebaseAuth = req.neonUser;
        if (!sessionUser && !isFirebaseAuth) {
          return res.status(401).json({ error: "Not authenticated" });
        }
        const user = isFirebaseAuth ? req.neonUser : sessionUser;
        if (user.role !== "admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const { username, password, email, name } = req.body;
        if (!username || !password) {
          return res.status(400).json({ error: "Username and password are required" });
        }
        const existingUser = await userService.getUserByUsername(username);
        if (existingUser) {
          return res.status(400).json({ error: "Username already exists" });
        }
        const hashedPassword = await hashPassword(password);
        let manager = await userService.createUser({
          username,
          password: hashedPassword,
          role: "manager",
          has_seen_welcome: false
          // Manager must change password on first login
        });
        const updatedManager = await userService.updateUser(manager.id, {
          isChef: false,
          isManager: true,
          isPortalUser: false
        });
        if (updatedManager) manager = updatedManager;
        try {
          const managerEmail = email || username;
          const welcomeEmail = generateManagerCredentialsEmail({
            email: managerEmail,
            name: name || "Manager",
            username,
            password
          });
          await sendEmail(welcomeEmail);
          logger.info(`\u2705 Welcome email with credentials sent to manager: ${managerEmail}`);
        } catch (emailError) {
          logger.error("Error sending manager welcome email:", emailError);
          logger.error("Email error details:", emailError instanceof Error ? emailError.message : emailError);
        }
        res.status(201).json({ success: true, managerId: manager.id });
      } catch (error) {
        logger.error("Error creating manager:", error);
        logger.error("Error details:", error);
        res.status(500).json({ error: error.message || "Failed to create manager" });
      }
    });
    router21.get("/managers", async (req, res) => {
      try {
        const sessionUser = await getAuthenticatedUser2(req);
        const isFirebaseAuth = req.neonUser;
        if (!sessionUser && !isFirebaseAuth) {
          return res.status(401).json({ error: "Not authenticated" });
        }
        const user = isFirebaseAuth ? req.neonUser : sessionUser;
        if (user.role !== "admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const result = await db.execute(sql19`
            SELECT 
              u.id, 
              u.username, 
              u.role,
              u.firebase_uid,
              COALESCE(
                json_agg(
                  json_build_object(
                    'locationId', l.id,
                    'locationName', l.name,
                    'notificationEmail', l.notification_email
                  )
                ) FILTER (WHERE l.id IS NOT NULL),
                '[]'::json
              ) as locations
            FROM users u
            LEFT JOIN locations l ON l.manager_id = u.id
            WHERE u.role = 'manager'
            GROUP BY u.id, u.username, u.role, u.firebase_uid
            ORDER BY u.username ASC
        `);
        const firebaseUids = result.rows.map((row) => row.firebase_uid).filter((uid) => !!uid);
        const firestoreNames = await getFirestoreDisplayNames(firebaseUids);
        const managersWithEmails = result.rows.map((row) => {
          let locations5 = row.locations;
          if (locations5 === null || locations5 === void 0) {
            locations5 = [];
          } else if (typeof locations5 === "string") {
            try {
              const trimmed = locations5.trim();
              if (trimmed === "[]" || trimmed === "" || trimmed === "null") {
                locations5 = [];
              } else {
                locations5 = JSON.parse(locations5);
              }
            } catch (e) {
              locations5 = [];
            }
          }
          if (!Array.isArray(locations5)) {
            if (locations5 && typeof locations5 === "object" && "0" in locations5) {
              locations5 = Object.values(locations5);
            } else {
              locations5 = [];
            }
          }
          const firestoreName = row.firebase_uid ? firestoreNames[row.firebase_uid] : null;
          const displayName = firestoreName || row.username;
          const managerData = {
            id: row.id,
            username: row.username,
            displayName,
            role: row.role
          };
          managerData.locations = locations5.map((loc) => ({
            locationId: loc.locationId || loc.location_id || loc.id,
            locationName: loc.locationName || loc.location_name || loc.name,
            notificationEmail: loc.notificationEmail || loc.notification_email || null
          }));
          return managerData;
        });
        const verifiedManagers = managersWithEmails.map((manager) => {
          if (!manager.hasOwnProperty("locations")) {
            manager.locations = [];
          } else if (!Array.isArray(manager.locations)) {
            manager.locations = Array.isArray(manager.locations) ? manager.locations : [];
          }
          return {
            id: manager.id,
            username: manager.username,
            displayName: manager.displayName,
            role: manager.role,
            locations: Array.isArray(manager.locations) ? manager.locations : []
          };
        });
        return res.json(verifiedManagers);
      } catch (error) {
        logger.error("Error fetching managers:", error);
        res.status(500).json({ error: error.message || "Failed to fetch managers" });
      }
    });
    router21.get("/locations/licenses", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const { status } = req.query;
        const query = db.select({
          id: locations.id,
          name: locations.name,
          address: locations.address,
          managerId: locations.managerId,
          kitchenLicenseUrl: locations.kitchenLicenseUrl,
          kitchenLicenseStatus: locations.kitchenLicenseStatus,
          kitchenLicenseExpiry: locations.kitchenLicenseExpiry,
          kitchenLicenseFeedback: locations.kitchenLicenseFeedback,
          kitchenLicenseApprovedAt: locations.kitchenLicenseApprovedAt,
          kitchenTermsUrl: locations.kitchenTermsUrl,
          kitchenTermsUploadedAt: locations.kitchenTermsUploadedAt,
          managerName: users.username,
          managerEmail: users.username
          // simplified for now
        }).from(locations).leftJoin(users, eq33(locations.managerId, users.id));
        if (status) {
          query.where(eq33(locations.kitchenLicenseStatus, status));
        }
        const results = await query;
        const licenses = results.map((loc) => ({
          id: loc.id,
          name: loc.name,
          address: loc.address,
          managerId: loc.managerId,
          managerUsername: loc.managerName,
          kitchenLicenseUrl: loc.kitchenLicenseUrl,
          kitchenLicenseStatus: loc.kitchenLicenseStatus || "pending",
          kitchenLicenseExpiry: loc.kitchenLicenseExpiry,
          kitchenLicenseFeedback: loc.kitchenLicenseFeedback,
          kitchenLicenseApprovedAt: loc.kitchenLicenseApprovedAt,
          kitchenTermsUrl: loc.kitchenTermsUrl,
          kitchenTermsUploadedAt: loc.kitchenTermsUploadedAt
        }));
        res.json(licenses);
      } catch (error) {
        logger.error("Error fetching location licenses:", error);
        res.status(500).json({ error: error.message || "Failed to fetch location licenses" });
      }
    });
    router21.get("/locations/pending-licenses", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const pendingLicenses = await db.select({
          id: locations.id,
          name: locations.name,
          address: locations.address,
          managerId: locations.managerId,
          kitchenLicenseUrl: locations.kitchenLicenseUrl,
          kitchenLicenseStatus: locations.kitchenLicenseStatus,
          kitchenLicenseExpiry: locations.kitchenLicenseExpiry,
          kitchenLicenseFeedback: locations.kitchenLicenseFeedback,
          managerName: users.username
        }).from(locations).leftJoin(users, eq33(locations.managerId, users.id)).where(eq33(locations.kitchenLicenseStatus, "pending"));
        const formatted = pendingLicenses.map((loc) => ({
          id: loc.id,
          name: loc.name,
          address: loc.address,
          managerId: loc.managerId,
          managerUsername: loc.managerName,
          kitchenLicenseUrl: loc.kitchenLicenseUrl,
          kitchenLicenseStatus: loc.kitchenLicenseStatus,
          kitchenLicenseExpiry: loc.kitchenLicenseExpiry,
          kitchenLicenseFeedback: loc.kitchenLicenseFeedback
        }));
        res.json(formatted);
      } catch (error) {
        logger.error("Error fetching pending licenses:", error);
        res.status(500).json({ error: error.message || "Failed to fetch pending licenses" });
      }
    });
    router21.get("/locations/pending-licenses-count", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const result = await db.select({ count: sql19`count(*)::int` }).from(locations).where(eq33(locations.kitchenLicenseStatus, "pending"));
        const count3 = result[0]?.count || 0;
        res.json({ count: count3 });
      } catch (error) {
        res.status(500).json({ error: "Failed to get count" });
      }
    });
    router21.put("/locations/:id/kitchen-license", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const locationId = parseInt(req.params.id);
        const { status, feedback } = req.body;
        if (isNaN(locationId)) {
          return res.status(400).json({ error: "Invalid location ID" });
        }
        if (!["approved", "rejected", "pending"].includes(status)) {
          return res.status(400).json({ error: "Invalid status" });
        }
        const updateData = {
          kitchenLicenseStatus: status,
          kitchenLicenseFeedback: feedback || null
        };
        if (status === "approved") {
          updateData.kitchenLicenseApprovedAt = /* @__PURE__ */ new Date();
        } else {
          updateData.kitchenLicenseApprovedAt = null;
        }
        await db.update(locations).set(updateData).where(eq33(locations.id, locationId));
        try {
          const [location] = await db.select({
            name: locations.name,
            managerId: locations.managerId,
            notificationEmail: locations.notificationEmail
          }).from(locations).where(eq33(locations.id, locationId)).limit(1);
          if (location && location.managerId) {
            const [manager] = await db.select({ username: users.username }).from(users).where(eq33(users.id, location.managerId)).limit(1);
            const managerEmail = location.notificationEmail || manager?.username;
            const managerName = manager?.username || "Manager";
            if (managerEmail) {
              if (status === "approved") {
                const approvalEmail = generateKitchenLicenseApprovedEmail({
                  managerEmail,
                  managerName,
                  locationName: location.name || "Kitchen Location",
                  approvedAt: /* @__PURE__ */ new Date()
                });
                await sendEmail(approvalEmail, {
                  trackingId: `kitchen_license_approved_${locationId}_${Date.now()}`
                });
                logger.info(`\u2705 Sent kitchen license approval email to manager: ${managerEmail}`);
              } else if (status === "rejected") {
                const rejectionEmail = generateKitchenLicenseRejectedEmail({
                  managerEmail,
                  managerName,
                  locationName: location.name || "Kitchen Location",
                  feedback: feedback || void 0
                });
                await sendEmail(rejectionEmail, {
                  trackingId: `kitchen_license_rejected_${locationId}_${Date.now()}`
                });
                logger.info(`\u2705 Sent kitchen license rejection email to manager: ${managerEmail}`);
              }
            }
          }
        } catch (emailError) {
          logger.error("Error sending kitchen license status email:", emailError);
        }
        res.json({ message: "License status updated successfully" });
      } catch (error) {
        logger.error("Error updating license status:", error);
        res.status(500).json({ error: error.message || "Failed to update license status" });
      }
    });
    router21.get("/locations", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const user = req.neonUser;
        const locations5 = await locationService.getAllLocations();
        const mappedLocations = locations5.map((loc) => ({
          ...loc,
          managerId: loc.managerId || loc.manager_id || null,
          notificationEmail: loc.notificationEmail || loc.notification_email || null,
          cancellationPolicyHours: loc.cancellationPolicyHours || loc.cancellation_policy_hours || 24,
          cancellationPolicyMessage: loc.cancellationPolicyMessage || loc.cancellation_policy_message || "Bookings cannot be cancelled within {hours} hours of the scheduled time.",
          defaultDailyBookingLimit: loc.defaultDailyBookingLimit || loc.default_daily_booking_limit || 2,
          createdAt: loc.createdAt || loc.created_at,
          updatedAt: loc.updatedAt || loc.updated_at
        }));
        res.json(mappedLocations);
      } catch (error) {
        logger.error("Error fetching locations:", error);
        res.status(500).json({ error: "Failed to fetch locations" });
      }
    });
    router21.post("/locations", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const user = req.neonUser;
        const { name, address, managerId } = req.body;
        let managerIdNum = void 0;
        if (managerId !== void 0 && managerId !== null && managerId !== "") {
          managerIdNum = parseInt(managerId.toString());
          if (isNaN(managerIdNum) || managerIdNum <= 0) {
            return res.status(400).json({ error: "Invalid manager ID format" });
          }
          const manager = await userService.getUser(managerIdNum);
          if (!manager) {
            return res.status(400).json({ error: `Manager with ID ${managerIdNum} does not exist` });
          }
          if (manager.role !== "manager") {
            return res.status(400).json({ error: `User with ID ${managerIdNum} is not a manager` });
          }
        }
        let normalizedNotificationPhone = void 0;
        if (req.body.notificationPhone && req.body.notificationPhone.trim() !== "") {
          const normalized = normalizePhoneForStorage(req.body.notificationPhone);
          if (!normalized) {
            return res.status(400).json({
              error: "Invalid notification phone number format. Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
            });
          }
          normalizedNotificationPhone = normalized;
        }
        const location = await locationService.createLocation({
          name,
          address,
          managerId: managerIdNum,
          notificationEmail: req.body.notificationEmail || void 0,
          notificationPhone: normalizedNotificationPhone
        });
        const mappedLocation = {
          ...location,
          managerId: location.managerId || location.manager_id || null,
          notificationEmail: location.notificationEmail || location.notification_email || null,
          notificationPhone: location.notificationPhone || location.notification_phone || null,
          cancellationPolicyHours: location.cancellationPolicyHours || location.cancellation_policy_hours || 24,
          cancellationPolicyMessage: location.cancellationPolicyMessage || location.cancellation_policy_message || "Bookings cannot be cancelled within {hours} hours of the scheduled time.",
          defaultDailyBookingLimit: location.defaultDailyBookingLimit || location.default_daily_booking_limit || 2,
          createdAt: location.createdAt || location.created_at,
          updatedAt: location.updatedAt || location.updated_at
        };
        res.status(201).json(mappedLocation);
      } catch (error) {
        logger.error("Error creating location:", error);
        res.status(500).json({ error: error.message || "Failed to create location" });
      }
    });
    router21.get("/kitchens", async (req, res) => {
      try {
        const sessionUser = await getAuthenticatedUser2(req);
        const isFirebaseAuth = req.neonUser;
        if (!sessionUser && !isFirebaseAuth) {
          return res.status(401).json({ error: "Not authenticated" });
        }
        const user = isFirebaseAuth ? req.neonUser : sessionUser;
        if (user.role !== "admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const allKitchens = await kitchenService.getAllKitchensWithLocation();
        res.json(allKitchens);
      } catch (error) {
        logger.error("Error fetching all kitchens:", error);
        res.status(500).json({ error: error.message || "Failed to fetch kitchens" });
      }
    });
    router21.get("/kitchens/:locationId", async (req, res) => {
      try {
        const sessionUser = await getAuthenticatedUser2(req);
        const isFirebaseAuth = req.neonUser;
        if (!sessionUser && !isFirebaseAuth) {
          return res.status(401).json({ error: "Not authenticated" });
        }
        const user = isFirebaseAuth ? req.neonUser : sessionUser;
        if (user.role !== "admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const locationId = parseInt(req.params.locationId);
        if (isNaN(locationId) || locationId <= 0) {
          return res.status(400).json({ error: "Invalid location ID" });
        }
        const kitchens3 = await kitchenService.getKitchensByLocationId(locationId);
        res.json(kitchens3);
      } catch (error) {
        logger.error("Error fetching kitchens:", error);
        res.status(500).json({ error: error.message || "Failed to fetch kitchens" });
      }
    });
    router21.post("/kitchens", async (req, res) => {
      try {
        const sessionUser = await getAuthenticatedUser2(req);
        const isFirebaseAuth = req.neonUser;
        if (!sessionUser && !isFirebaseAuth) {
          return res.status(401).json({ error: "Not authenticated" });
        }
        const user = isFirebaseAuth ? req.neonUser : sessionUser;
        if (user.role !== "admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const { locationId, name, description, taxRatePercent } = req.body;
        if (!locationId || !name) {
          return res.status(400).json({ error: "Location ID and name are required" });
        }
        const locationIdNum = parseInt(locationId.toString());
        if (isNaN(locationIdNum) || locationIdNum <= 0) {
          return res.status(400).json({ error: "Invalid location ID format" });
        }
        const location = await locationService.getLocationById(locationIdNum);
        if (!location) {
          return res.status(400).json({ error: `Location with ID ${locationIdNum} does not exist` });
        }
        const kitchen = await kitchenService.createKitchen({
          locationId: locationIdNum,
          name,
          description,
          isActive: true,
          hourlyRate: void 0,
          minimumBookingHours: 1,
          pricingModel: "hourly",
          taxRatePercent: taxRatePercent ? parseFloat(taxRatePercent) : null
        });
        res.status(201).json(kitchen);
      } catch (error) {
        logger.error("Error creating kitchen:", error);
        if (error.code === "23503") {
          return res.status(400).json({ error: "The selected location does not exist or is invalid." });
        }
        res.status(500).json({ error: error.message || "Failed to create kitchen" });
      }
    });
    router21.put("/locations/:id", async (req, res) => {
      try {
        const sessionUser = await getAuthenticatedUser2(req);
        const isFirebaseAuth = req.neonUser;
        if (!sessionUser && !isFirebaseAuth) {
          return res.status(401).json({ error: "Not authenticated" });
        }
        const user = isFirebaseAuth ? req.neonUser : sessionUser;
        if (user.role !== "admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const locationId = parseInt(req.params.id);
        if (isNaN(locationId) || locationId <= 0) {
          return res.status(400).json({ error: "Invalid location ID" });
        }
        const { name, address, managerId, notificationEmail, notificationPhone } = req.body;
        let managerIdNum = void 0;
        if (managerId !== void 0 && managerId !== null && managerId !== "") {
          managerIdNum = parseInt(managerId.toString());
          if (isNaN(managerIdNum) || managerIdNum <= 0) {
            return res.status(400).json({ error: "Invalid manager ID format" });
          }
          const manager = await userService.getUser(managerIdNum);
          if (!manager) {
            return res.status(400).json({ error: `Manager with ID ${managerIdNum} does not exist` });
          }
          if (manager.role !== "manager") {
            return res.status(400).json({ error: `User with ID ${managerIdNum} is not a manager` });
          }
        } else if (managerId === null || managerId === "") {
          managerIdNum = null;
        }
        const updates = {};
        if (name !== void 0) updates.name = name;
        if (address !== void 0) updates.address = address;
        if (managerIdNum !== void 0) updates.managerId = managerIdNum;
        if (notificationEmail !== void 0) updates.notificationEmail = notificationEmail || null;
        if (notificationPhone !== void 0) {
          if (notificationPhone && notificationPhone.trim() !== "") {
            const normalized = normalizePhoneForStorage(notificationPhone);
            if (!normalized) {
              return res.status(400).json({
                error: "Invalid phone number format. Please enter a valid phone number (e.g., (416) 123-4567 or +14161234567)"
              });
            }
            updates.notificationPhone = normalized;
          } else {
            updates.notificationPhone = null;
          }
        }
        const updated = await locationService.updateLocation({ id: locationId, ...updates });
        if (!updated) {
          return res.status(404).json({ error: "Location not found" });
        }
        const mappedLocation = {
          ...updated,
          managerId: updated.managerId || updated.manager_id || null,
          notificationEmail: updated.notificationEmail || updated.notification_email || null,
          cancellationPolicyHours: updated.cancellationPolicyHours || updated.cancellation_policy_hours || 24,
          cancellationPolicyMessage: updated.cancellationPolicyMessage || updated.cancellation_policy_message || "Bookings cannot be cancelled within {hours} hours of the scheduled time.",
          defaultDailyBookingLimit: updated.defaultDailyBookingLimit || updated.default_daily_booking_limit || 2,
          createdAt: updated.createdAt || updated.created_at,
          updatedAt: updated.updatedAt || updated.updated_at
        };
        return res.json(mappedLocation);
      } catch (error) {
        logger.error("Error updating location:", error);
        res.status(500).json({ error: error.message || "Failed to update location" });
      }
    });
    router21.delete("/locations/:id", async (req, res) => {
      try {
        const sessionUser = await getAuthenticatedUser2(req);
        const isFirebaseAuth = req.neonUser;
        if (!sessionUser && !isFirebaseAuth) {
          return res.status(401).json({ error: "Not authenticated" });
        }
        const user = isFirebaseAuth ? req.neonUser : sessionUser;
        if (user.role !== "admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const locationId = parseInt(req.params.id);
        if (isNaN(locationId) || locationId <= 0) {
          return res.status(400).json({ error: "Invalid location ID" });
        }
        await locationService.deleteLocation(locationId);
        res.json({ success: true, message: "Location deleted successfully" });
      } catch (error) {
        logger.error("Error deleting location:", error);
        res.status(500).json({ error: error.message || "Failed to delete location" });
      }
    });
    router21.put("/kitchens/:id", async (req, res) => {
      try {
        const sessionUser = await getAuthenticatedUser2(req);
        const isFirebaseAuth = req.neonUser;
        if (!sessionUser && !isFirebaseAuth) {
          return res.status(401).json({ error: "Not authenticated" });
        }
        const user = isFirebaseAuth ? req.neonUser : sessionUser;
        if (user.role !== "admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const kitchenId = parseInt(req.params.id);
        if (isNaN(kitchenId) || kitchenId <= 0) {
          return res.status(400).json({ error: "Invalid kitchen ID" });
        }
        const currentKitchen = await kitchenService.getKitchenById(kitchenId);
        if (!currentKitchen) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const { name, description, isActive, locationId, taxRatePercent } = req.body;
        const updates = {};
        const changesList = [];
        if (name !== void 0 && name !== currentKitchen.name) {
          updates.name = name;
          changesList.push(`Name changed to "${name}"`);
        }
        if (description !== void 0 && description !== currentKitchen.description) {
          updates.description = description;
          changesList.push(`Description updated`);
        }
        if (isActive !== void 0 && isActive !== currentKitchen.isActive) {
          updates.isActive = isActive;
          changesList.push(`Status changed to ${isActive ? "Active" : "Inactive"}`);
        }
        if (locationId !== void 0) {
          const locationIdNum = parseInt(locationId.toString());
          if (isNaN(locationIdNum) || locationIdNum <= 0) {
            return res.status(400).json({ error: "Invalid location ID format" });
          }
          const location = await locationService.getLocationById(locationIdNum);
          if (!location) {
            return res.status(400).json({ error: `Location with ID ${locationIdNum} does not exist` });
          }
          if (locationIdNum !== currentKitchen.locationId) {
            updates.locationId = locationIdNum;
            changesList.push(`Location changed to "${location.name}"`);
          }
        }
        if (taxRatePercent !== void 0) {
          const newRate = taxRatePercent ? parseFloat(taxRatePercent) : null;
          if (newRate !== currentKitchen.taxRatePercent) {
            updates.taxRatePercent = newRate;
            changesList.push(`Tax rate changed to ${newRate ? newRate + "%" : "None"}`);
          }
        }
        if (Object.keys(updates).length === 0) {
          return res.json(currentKitchen);
        }
        const updated = await kitchenService.updateKitchen({ id: kitchenId, ...updates });
        if (!updated) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        if (changesList.length > 0) {
          try {
            const kitchen = await kitchenService.getKitchenById(kitchenId);
            if (kitchen) {
              const location = await locationService.getLocationById(kitchen.locationId);
              const bookings = await bookingService.getBookingsByKitchenId(kitchenId);
              const customChefIds = bookings.map((b) => b.chefId).filter((id) => id !== null);
              const uniqueChefIds = Array.from(new Set(customChefIds));
              const changes = changesList.join(", ");
              for (const chefId of uniqueChefIds) {
                try {
                  const chef = await userService.getUser(chefId);
                  if (chef) {
                    const email = generateKitchenSettingsChangeEmail({
                      email: chef.username,
                      name: chef.displayName || chef.username || "Chef",
                      kitchenName: kitchen.name,
                      changes,
                      isChef: true
                    });
                    await sendEmail(email);
                  }
                } catch (emailError) {
                  logger.error(`Error sending email to chef ${chefId}:`, emailError);
                }
              }
              if (location?.managerId) {
                try {
                  const manager = await userService.getUser(location.managerId);
                  if (manager) {
                    const notificationEmail = location.notificationEmail || location.notification_email || manager.username;
                    const email = generateKitchenSettingsChangeEmail({
                      email: notificationEmail,
                      name: manager.username,
                      kitchenName: kitchen.name,
                      changes,
                      isChef: false
                    });
                    await sendEmail(email);
                  }
                } catch (emailError) {
                  logger.error(`Error sending email to manager:`, emailError);
                }
              }
            }
          } catch (emailError) {
            logger.error("Error sending kitchen settings change emails:", emailError);
          }
        }
        res.json(updated);
      } catch (error) {
        logger.error("Error updating kitchen:", error);
        res.status(500).json({ error: error.message || "Failed to update kitchen" });
      }
    });
    router21.delete("/kitchens/:id", async (req, res) => {
      try {
        const sessionUser = await getAuthenticatedUser2(req);
        const isFirebaseAuth = req.neonUser;
        if (!sessionUser && !isFirebaseAuth) {
          return res.status(401).json({ error: "Not authenticated" });
        }
        const user = isFirebaseAuth ? req.neonUser : sessionUser;
        if (user.role !== "admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const kitchenId = parseInt(req.params.id);
        if (isNaN(kitchenId) || kitchenId <= 0) {
          return res.status(400).json({ error: "Invalid kitchen ID" });
        }
        await kitchenService.deleteKitchen(kitchenId);
        res.json({ success: true, message: "Kitchen deleted successfully" });
      } catch (error) {
        logger.error("Error deleting kitchen:", error);
        res.status(500).json({ error: error.message || "Failed to delete kitchen" });
      }
    });
    router21.put("/managers/:id", async (req, res) => {
      try {
        const sessionUser = await getAuthenticatedUser2(req);
        const isFirebaseAuth = req.neonUser;
        if (!sessionUser && !isFirebaseAuth) {
          return res.status(401).json({ error: "Not authenticated" });
        }
        const user = isFirebaseAuth ? req.neonUser : sessionUser;
        if (user.role !== "admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const managerId = parseInt(req.params.id);
        if (isNaN(managerId) || managerId <= 0) {
          return res.status(400).json({ error: "Invalid manager ID" });
        }
        const { username, role, isManager, locationNotificationEmails } = req.body;
        const manager = await userService.getUser(managerId);
        if (!manager) {
          return res.status(404).json({ error: "Manager not found" });
        }
        if (manager.role !== "manager") {
          return res.status(400).json({ error: "User is not a manager" });
        }
        const updates = {};
        if (username !== void 0) {
          const existingUser = await userService.getUserByUsername(username);
          if (existingUser && existingUser.id !== managerId) {
            return res.status(400).json({ error: "Username already exists" });
          }
          updates.username = username;
        }
        if (role !== void 0) updates.role = role;
        if (isManager !== void 0) updates.isManager = isManager;
        const updated = await userService.updateUser(managerId, updates);
        if (!updated) {
          return res.status(404).json({ error: "Failed to update manager" });
        }
        if (locationNotificationEmails && Array.isArray(locationNotificationEmails)) {
          const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
          const { locations: locations6 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const { eq: eq39 } = await import("drizzle-orm");
          for (const emailUpdate of locationNotificationEmails) {
            if (emailUpdate.locationId && emailUpdate.notificationEmail !== void 0) {
              const locationId = parseInt(emailUpdate.locationId.toString());
              if (!isNaN(locationId)) {
                const email = emailUpdate.notificationEmail?.trim() || "";
                if (email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                  continue;
                }
                await db2.update(locations6).set({
                  notificationEmail: email || null,
                  updatedAt: /* @__PURE__ */ new Date()
                }).where(eq39(locations6.id, locationId));
              }
            }
          }
        }
        const { locations: locations5 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
        const { eq: eq38 } = await import("drizzle-orm");
        const managedLocations = await db.select().from(locations5).where(eq38(locations5.managerId, managerId));
        const notificationEmails = managedLocations.map((loc) => loc.notificationEmail || loc.notification_email).filter((email) => email && email.trim() !== "");
        const response = {
          ...updated,
          locations: managedLocations.map((loc) => ({
            locationId: loc.id,
            locationName: loc.name,
            notificationEmail: loc.notificationEmail || loc.notification_email || null
          })),
          notificationEmails,
          primaryNotificationEmail: notificationEmails.length > 0 ? notificationEmails[0] : null
        };
        res.json(response);
      } catch (error) {
        logger.error("Error updating manager:", error);
        res.status(500).json({ error: error.message || "Failed to update manager" });
      }
    });
    router21.delete("/managers/:id", async (req, res) => {
      try {
        const sessionUser = await getAuthenticatedUser2(req);
        const isFirebaseAuth = req.neonUser;
        if (!sessionUser && !isFirebaseAuth) {
          return res.status(401).json({ error: "Not authenticated" });
        }
        const user = isFirebaseAuth ? req.neonUser : sessionUser;
        if (user.role !== "admin") {
          return res.status(403).json({ error: "Admin access required" });
        }
        const managerId = parseInt(req.params.id);
        if (isNaN(managerId) || managerId <= 0) {
          return res.status(400).json({ error: "Invalid manager ID" });
        }
        if (managerId === user.id) {
          return res.status(400).json({ error: "You cannot delete your own account" });
        }
        const manager = await userService.getUser(managerId);
        if (!manager) {
          return res.status(404).json({ error: "Manager not found" });
        }
        if (manager.role !== "manager") {
          return res.status(400).json({ error: "User is not a manager" });
        }
        await userService.deleteUser(managerId);
        res.json({ success: true, message: "Manager deleted successfully" });
      } catch (error) {
        logger.error("Error deleting manager:", error);
        res.status(500).json({ error: error.message || "Failed to delete manager" });
      }
    });
    router21.post("/test-email", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const user = req.neonUser;
        logger.info(`POST /api/admin/test-email - User ID: ${user.id}`);
        const {
          email,
          subject,
          previewText,
          sections,
          header,
          footer,
          usageSteps,
          emailContainer,
          customDesign
        } = req.body;
        if (!email) {
          return res.status(400).json({ error: "Email is required" });
        }
        logger.info("Test email request - Validation passed, generating test email");
        const emailContent = generatePromoCodeEmail({
          email,
          promoCode: "TEST123",
          promoCodeLabel: "\u{1F381} Test Promo Code",
          customMessage: "This is a test email to verify the email system is working correctly.",
          greeting: "Hello! \u{1F44B}",
          subject: subject || "Test Email from Local Cooks",
          previewText: previewText || "Test email preview",
          designSystem: customDesign?.designSystem,
          isPremium: true,
          sections: sections || [],
          header: header || {
            title: "Local Cooks Header",
            subtitle: "Premium Quality Food Subheader",
            styling: {
              backgroundColor: "linear-gradient(135deg, #F51042 0%, #FF5470 100%)",
              titleColor: "#ffffff",
              subtitleColor: "#ffffff",
              titleFontSize: "32px",
              subtitleFontSize: "18px",
              padding: "24px",
              borderRadius: "0px",
              textAlign: "center"
            }
          },
          footer: footer || {
            mainText: "Thank you for being part of the Local Cooks community!",
            contactText: "Questions? Contact us at support@localcooks.com",
            copyrightText: "\xA9 2024 Local Cooks. All rights reserved.",
            showContact: true,
            showCopyright: true,
            styling: {
              backgroundColor: "#f8fafc",
              textColor: "#64748b",
              linkColor: "#F51042",
              fontSize: "14px",
              padding: "24px 32px",
              textAlign: "center",
              borderColor: "#e2e8f0"
            }
          },
          usageSteps: usageSteps || {
            title: "\u{1F680} How to use your promo code:",
            steps: [
              'Visit our website: <a href="https://localcooks.ca" style="color: #1d4ed8;">https://localcooks.ca</a>',
              "Browse our amazing local cooks and their delicious offerings",
              "Apply your promo code during checkout",
              "Enjoy your special offer!"
            ],
            enabled: true,
            styling: {
              backgroundColor: "linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)",
              borderColor: "#93c5fd",
              titleColor: "#1d4ed8",
              textColor: "#1e40af",
              linkColor: "#1d4ed8",
              padding: "20px",
              borderRadius: "8px"
            }
          },
          emailContainer: emailContainer || {
            maxWidth: "600px",
            backgroundColor: "#f1f5f9",
            borderRadius: "12px",
            boxShadow: "0 4px 20px rgba(0,0,0,0.08)"
          },
          dividers: {
            enabled: true,
            style: "solid",
            color: "#e2e8f0",
            thickness: "1px",
            margin: "24px 0",
            opacity: "1"
          },
          promoStyle: { colorTheme: "green", borderStyle: "dashed" },
          orderButton: {
            text: "\u{1F31F} Test Order Button",
            url: "https://localcooks.ca",
            styling: {
              backgroundColor: "#F51042",
              color: "#ffffff",
              fontSize: "16px",
              fontWeight: "600",
              padding: "12px 24px",
              borderRadius: "8px",
              textAlign: "center"
            }
          }
        });
        const emailSent = await sendEmail(emailContent, {
          trackingId: `test_email_${email}_${Date.now()}`
        });
        if (emailSent) {
          logger.info(`Test email sent successfully to ${email}`);
          res.json({
            success: true,
            message: "Test email sent successfully",
            recipient: email
          });
        } else {
          logger.error(`Failed to send test email to ${email}`);
          res.status(500).json({
            error: "Failed to send email",
            message: "Email service unavailable"
          });
        }
      } catch (error) {
        logger.error("Error sending test email:", error);
        res.status(500).json({
          error: "Internal server error",
          message: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    router21.post("/send-promo-email", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const user = req.neonUser;
        logger.info(`POST /api/admin/send-promo-email - User ID: ${user.id}`);
        const {
          email,
          customEmails,
          emailMode,
          recipients,
          promoCode,
          promoCodeLabel,
          message,
          customMessage,
          greeting,
          buttonText,
          orderUrl,
          subject,
          previewText,
          designSystem,
          isPremium,
          sections,
          header,
          footer,
          usageSteps,
          emailContainer,
          dividers,
          promoCodeStyling,
          promoStyle,
          customDesign
        } = req.body;
        const messageContent = customMessage || message;
        let targetEmails = [];
        if (recipients && Array.isArray(recipients) && recipients.length > 0) {
          targetEmails = recipients.map(
            (recipient) => typeof recipient === "string" ? recipient : recipient.email
          ).filter(Boolean);
        } else if (emailMode === "custom" && customEmails && Array.isArray(customEmails)) {
          targetEmails = customEmails;
        } else if (email) {
          targetEmails = [email];
        }
        if (targetEmails.length === 0) {
          return res.status(400).json({ error: "At least one email address is required" });
        }
        const results = [];
        let successCount = 0;
        let failureCount = 0;
        for (const targetEmail of targetEmails) {
          try {
            const emailContent = generatePromoCodeEmail({
              email: targetEmail,
              promoCode,
              promoCodeLabel: promoCodeLabel || "\u{1F381} Special Offer Code For You",
              customMessage: messageContent,
              greeting: greeting || "Hi there! \u{1F44B}",
              subject: subject || "Special Offer from Local Cooks",
              previewText: previewText || "Don't miss out on this exclusive offer",
              designSystem,
              isPremium: isPremium || true,
              sections: sections || [],
              header,
              footer,
              usageSteps,
              emailContainer,
              dividers,
              promoCodeStyling,
              promoStyle,
              orderButton: {
                text: buttonText || "\u{1F31F} Start Shopping Now",
                url: orderUrl || "https://localcooks.ca",
                styling: {
                  backgroundColor: "#F51042",
                  color: "#ffffff",
                  fontSize: "16px",
                  fontWeight: "600",
                  padding: "12px 24px",
                  borderRadius: "8px",
                  textAlign: "center"
                }
              }
            });
            const emailSent = await sendEmail(emailContent, {
              trackingId: `promo_email_${targetEmail}_${Date.now()}`
            });
            if (emailSent) {
              results.push({ email: targetEmail, status: "success" });
              successCount++;
            } else {
              results.push({ email: targetEmail, status: "failed", error: "Email sending failed" });
              failureCount++;
            }
          } catch (error) {
            logger.error(`Error sending promo email to ${targetEmail}:`, error);
            results.push({ email: targetEmail, status: "failed", error: error instanceof Error ? error.message : "Unknown error" });
            failureCount++;
          }
        }
        if (successCount > 0) {
          res.json({
            success: true,
            message: `Promo emails sent: ${successCount} successful, ${failureCount} failed`,
            results
          });
        } else {
          res.status(500).json({
            error: "All email sending failed",
            message: "Failed to send promo emails to any recipients.",
            results
          });
        }
      } catch (error) {
        logger.error("Error sending promo email:", error);
        res.status(500).json({
          error: "Internal server error",
          message: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    router21.get("/fees/config", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const config = await getFeeConfig();
        const settings = await db.select().from(platformSettings).where(sql19`key IN ('stripe_percentage_fee', 'stripe_flat_fee_cents', 'platform_commission_rate', 'minimum_application_fee_cents', 'use_stripe_platform_pricing')`);
        const settingsMap = Object.fromEntries(settings.map((s) => [s.key, {
          value: s.value,
          description: s.description,
          updatedAt: s.updatedAt,
          updatedBy: s.updatedBy
        }]));
        res.json({
          success: true,
          config: {
            stripePercentageFee: config.stripePercentageFee,
            stripePercentageFeeDisplay: `${(config.stripePercentageFee * 100).toFixed(1)}%`,
            stripeFlatFeeCents: config.stripeFlatFeeCents,
            stripeFlatFeeDisplay: `$${(config.stripeFlatFeeCents / 100).toFixed(2)}`,
            platformCommissionRate: config.platformCommissionRate,
            platformCommissionRateDisplay: `${(config.platformCommissionRate * 100).toFixed(1)}%`,
            minimumApplicationFeeCents: config.minimumApplicationFeeCents,
            minimumApplicationFeeDisplay: `$${(config.minimumApplicationFeeCents / 100).toFixed(2)}`,
            useStripePlatformPricing: config.useStripePlatformPricing
          },
          rawSettings: settingsMap,
          documentation: {
            stripePercentageFee: "Stripe's processing fee percentage (e.g., 0.029 for 2.9%)",
            stripeFlatFeeCents: "Stripe's flat fee per transaction in cents (e.g., 30 for $0.30)",
            platformCommissionRate: "Platform's commission rate (e.g., 0.05 for 5%)",
            minimumApplicationFeeCents: "Minimum application fee in cents to ensure profitability",
            useStripePlatformPricing: "If true, use Stripe Platform Pricing Tool instead of code-based fees"
          }
        });
      } catch (error) {
        logger.error("Error fetching fee config:", error);
        res.status(500).json({
          error: "Failed to fetch fee configuration",
          message: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    router21.put("/fees/config", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const user = await getAuthenticatedUser2(req);
        if (!user) {
          return res.status(401).json({ error: "Unauthorized" });
        }
        const {
          stripePercentageFee,
          stripeFlatFeeCents,
          platformCommissionRate,
          minimumApplicationFeeCents,
          useStripePlatformPricing
        } = req.body;
        const updates = [];
        if (stripePercentageFee !== void 0) {
          const fee = parseFloat(stripePercentageFee);
          if (isNaN(fee) || fee < 0 || fee > 0.5) {
            return res.status(400).json({ error: "stripePercentageFee must be between 0 and 0.5 (50%)" });
          }
          updates.push({
            key: "stripe_percentage_fee",
            value: fee.toString(),
            description: "Stripe processing fee percentage (e.g., 0.029 for 2.9%)"
          });
        }
        if (stripeFlatFeeCents !== void 0) {
          const cents = parseInt(stripeFlatFeeCents, 10);
          if (isNaN(cents) || cents < 0 || cents > 500) {
            return res.status(400).json({ error: "stripeFlatFeeCents must be between 0 and 500 ($5.00)" });
          }
          updates.push({
            key: "stripe_flat_fee_cents",
            value: cents.toString(),
            description: "Stripe flat fee in cents (e.g., 30 for $0.30)"
          });
        }
        if (platformCommissionRate !== void 0) {
          const rate = parseFloat(platformCommissionRate);
          if (isNaN(rate) || rate < 0 || rate > 0.5) {
            return res.status(400).json({ error: "platformCommissionRate must be between 0 and 0.5 (50%)" });
          }
          updates.push({
            key: "platform_commission_rate",
            value: rate.toString(),
            description: "Platform commission rate as decimal (e.g., 0.05 for 5%)"
          });
        }
        if (minimumApplicationFeeCents !== void 0) {
          const cents = parseInt(minimumApplicationFeeCents, 10);
          if (isNaN(cents) || cents < 0 || cents > 1e3) {
            return res.status(400).json({ error: "minimumApplicationFeeCents must be between 0 and 1000 ($10.00)" });
          }
          updates.push({
            key: "minimum_application_fee_cents",
            value: cents.toString(),
            description: "Minimum application fee in cents (e.g., 50 for $0.50)"
          });
        }
        if (useStripePlatformPricing !== void 0) {
          updates.push({
            key: "use_stripe_platform_pricing",
            value: useStripePlatformPricing ? "true" : "false",
            description: "If true, do not set application_fee_amount in code - let Stripe Platform Pricing Tool handle it"
          });
        }
        if (updates.length === 0) {
          return res.status(400).json({ error: "No valid updates provided" });
        }
        for (const update of updates) {
          await db.insert(platformSettings).values({
            key: update.key,
            value: update.value,
            description: update.description,
            updatedBy: user.id,
            updatedAt: /* @__PURE__ */ new Date()
          }).onConflictDoUpdate({
            target: platformSettings.key,
            set: {
              value: update.value,
              description: update.description,
              updatedBy: user.id,
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
        }
        clearFeeConfigCache();
        logger.info(`[AUDIT] Fee config updated by admin ${user.id} (${user.username}):`, updates);
        const newConfig = await getFeeConfig();
        res.json({
          success: true,
          message: "Fee configuration updated successfully",
          updatedFields: updates.map((u) => u.key),
          newConfig: {
            stripePercentageFee: newConfig.stripePercentageFee,
            stripeFlatFeeCents: newConfig.stripeFlatFeeCents,
            platformCommissionRate: newConfig.platformCommissionRate,
            minimumApplicationFeeCents: newConfig.minimumApplicationFeeCents,
            useStripePlatformPricing: newConfig.useStripePlatformPricing
          }
        });
      } catch (error) {
        logger.error("Error updating fee config:", error);
        res.status(500).json({
          error: "Failed to update fee configuration",
          message: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    router21.get("/cancellation-config", requireFirebaseAuthWithUser, requireAdmin, async (_req, res) => {
      try {
        const [setting] = await db.select({ value: platformSettings.value, updatedAt: platformSettings.updatedAt }).from(platformSettings).where(eq33(platformSettings.key, "cancellation_request_auto_accept_hours")).limit(1);
        const autoAcceptHours = setting ? parseInt(setting.value || "24", 10) : 24;
        res.json({
          success: true,
          config: {
            autoAcceptHours,
            updatedAt: setting?.updatedAt || null
          }
        });
      } catch (error) {
        logger.error("Error fetching cancellation config:", error);
        res.status(500).json({ error: "Failed to fetch cancellation configuration" });
      }
    });
    router21.put("/cancellation-config", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const user = await getAuthenticatedUser2(req);
        if (!user) {
          return res.status(401).json({ error: "Unauthorized" });
        }
        const { autoAcceptHours } = req.body;
        if (autoAcceptHours === void 0 || autoAcceptHours === null) {
          return res.status(400).json({ error: "autoAcceptHours is required" });
        }
        const hours = parseInt(autoAcceptHours, 10);
        if (isNaN(hours) || hours < 0 || hours > 720) {
          return res.status(400).json({ error: "autoAcceptHours must be between 0 and 720 (0 = disabled, max 30 days)" });
        }
        await db.insert(platformSettings).values({
          key: "cancellation_request_auto_accept_hours",
          value: hours.toString(),
          description: "Hours before a cancellation request is auto-accepted (0 = disabled)",
          updatedBy: user.id,
          updatedAt: /* @__PURE__ */ new Date()
        }).onConflictDoUpdate({
          target: platformSettings.key,
          set: {
            value: hours.toString(),
            description: "Hours before a cancellation request is auto-accepted (0 = disabled)",
            updatedBy: user.id,
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        logger.info(`[AUDIT] Cancellation auto-accept hours updated to ${hours} by admin ${user.id} (${user.username})`);
        res.json({
          success: true,
          message: hours === 0 ? "Cancellation auto-accept disabled. Managers must manually respond to all requests." : `Cancellation requests will be auto-accepted after ${hours} hour${hours !== 1 ? "s" : ""} if the manager does not respond.`,
          config: { autoAcceptHours: hours }
        });
      } catch (error) {
        logger.error("Error updating cancellation config:", error);
        res.status(500).json({ error: "Failed to update cancellation configuration" });
      }
    });
    router21.post("/fees/simulate", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const { bookingAmountCents, customConfig } = req.body;
        if (!bookingAmountCents || bookingAmountCents <= 0) {
          return res.status(400).json({ error: "bookingAmountCents must be a positive number" });
        }
        const { calculateCheckoutFeesAsync: calculateCheckoutFeesAsync2, calculateCheckoutFeesWithRates: calculateCheckoutFeesWithRates2 } = await Promise.resolve().then(() => (init_stripe_checkout_fee_service(), stripe_checkout_fee_service_exports));
        const currentResult = await calculateCheckoutFeesAsync2(bookingAmountCents);
        let customResult = null;
        if (customConfig) {
          const {
            stripePercentageFee = 0.029,
            stripeFlatFeeCents = 30,
            platformCommissionRate = 0.05,
            minimumFeeCents = 50
          } = customConfig;
          customResult = calculateCheckoutFeesWithRates2(
            bookingAmountCents / 100,
            // Convert to dollars
            stripePercentageFee,
            stripeFlatFeeCents,
            platformCommissionRate,
            minimumFeeCents
          );
        }
        res.json({
          success: true,
          bookingAmount: {
            cents: bookingAmountCents,
            dollars: `$${(bookingAmountCents / 100).toFixed(2)}`
          },
          currentConfig: {
            result: {
              stripeProcessingFee: `$${(currentResult.stripeProcessingFeeInCents / 100).toFixed(2)}`,
              platformCommission: `$${(currentResult.platformCommissionInCents / 100).toFixed(2)}`,
              totalApplicationFee: `$${(currentResult.totalPlatformFeeInCents / 100).toFixed(2)}`,
              managerReceives: `$${(currentResult.managerReceivesInCents / 100).toFixed(2)}`,
              useStripePlatformPricing: currentResult.useStripePlatformPricing
            },
            raw: currentResult
          },
          customConfig: customResult ? {
            result: {
              stripeProcessingFee: `$${(customResult.stripeProcessingFeeInCents / 100).toFixed(2)}`,
              platformCommission: `$${(customResult.platformCommissionInCents / 100).toFixed(2)}`,
              totalApplicationFee: `$${(customResult.totalPlatformFeeInCents / 100).toFixed(2)}`,
              managerReceives: `$${(customResult.managerReceivesInCents / 100).toFixed(2)}`
            },
            raw: customResult
          } : null
        });
      } catch (error) {
        logger.error("Error simulating fees:", error);
        res.status(500).json({
          error: "Failed to simulate fees",
          message: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    router21.post("/sync-stripe-fees", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const { managerId, limit = 100 } = req.body;
        logger.info("[Admin] Starting Stripe fee sync...", { managerId, limit });
        const { syncStripeFees: syncStripeFees2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
        const result = await syncStripeFees2(db, managerId, limit);
        logger.info("[Admin] Stripe fee sync completed:", result);
        res.json({
          success: true,
          message: `Synced ${result.synced} transactions, ${result.failed} failed`,
          ...result
        });
      } catch (error) {
        logger.error("Error syncing Stripe fees:", error);
        res.status(500).json({
          error: "Failed to sync Stripe fees",
          message: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    router21.get("/damage-claim-limits", requireFirebaseAuthWithUser, requireAdmin, async (_req, res) => {
      try {
        const limits = await damageClaimLimitsService.getDamageClaimLimits();
        const defaults = damageClaimLimitsService.getDefaultLimits();
        res.json({ limits, defaults });
      } catch (error) {
        logger.error("Error fetching damage claim limits:", error);
        res.status(500).json({ error: "Failed to fetch damage claim limits" });
      }
    });
    router21.put("/damage-claim-limits", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const {
          maxClaimAmountCents,
          minClaimAmountCents,
          maxClaimsPerBooking,
          chefResponseDeadlineHours,
          claimSubmissionDeadlineDays
        } = req.body;
        const updates = [];
        if (maxClaimAmountCents !== void 0) {
          if (maxClaimAmountCents < 1e3 || maxClaimAmountCents > 1e7) {
            return res.status(400).json({ error: "Max claim amount must be between $10 and $100,000" });
          }
          updates.push({
            key: "damage_claim_max_amount_cents",
            value: String(maxClaimAmountCents),
            description: "Maximum damage claim amount in cents (admin-controlled limit)"
          });
        }
        if (minClaimAmountCents !== void 0) {
          if (minClaimAmountCents < 100 || minClaimAmountCents > 1e4) {
            return res.status(400).json({ error: "Min claim amount must be between $1 and $100" });
          }
          updates.push({
            key: "damage_claim_min_amount_cents",
            value: String(minClaimAmountCents),
            description: "Minimum damage claim amount in cents"
          });
        }
        if (maxClaimsPerBooking !== void 0) {
          if (maxClaimsPerBooking < 1 || maxClaimsPerBooking > 10) {
            return res.status(400).json({ error: "Max claims per booking must be between 1 and 10" });
          }
          updates.push({
            key: "damage_claim_max_per_booking",
            value: String(maxClaimsPerBooking),
            description: "Maximum number of damage claims allowed per booking"
          });
        }
        if (chefResponseDeadlineHours !== void 0) {
          if (chefResponseDeadlineHours < 24 || chefResponseDeadlineHours > 168) {
            return res.status(400).json({ error: "Chef response deadline must be between 24 and 168 hours" });
          }
          updates.push({
            key: "damage_claim_response_deadline_hours",
            value: String(chefResponseDeadlineHours),
            description: "Hours chef has to respond to a damage claim"
          });
        }
        if (claimSubmissionDeadlineDays !== void 0) {
          if (claimSubmissionDeadlineDays < 1 || claimSubmissionDeadlineDays > 30) {
            return res.status(400).json({ error: "Claim submission deadline must be between 1 and 30 days" });
          }
          updates.push({
            key: "damage_claim_submission_deadline_days",
            value: String(claimSubmissionDeadlineDays),
            description: "Days after booking ends to file a damage claim"
          });
        }
        if (updates.length === 0) {
          return res.status(400).json({ error: "No valid updates provided" });
        }
        for (const update of updates) {
          await db.insert(platformSettings).values({
            key: update.key,
            value: update.value,
            description: update.description
          }).onConflictDoUpdate({
            target: platformSettings.key,
            set: {
              value: update.value,
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
        }
        const newLimits = await damageClaimLimitsService.getDamageClaimLimits();
        logger.info("[Admin] Updated damage claim limits:", newLimits);
        res.json({
          success: true,
          message: `Updated ${updates.length} damage claim limit(s)`,
          limits: newLimits
        });
      } catch (error) {
        logger.error("Error updating damage claim limits:", error);
        res.status(500).json({ error: "Failed to update damage claim limits" });
      }
    });
    router21.get("/storage-checkout-settings", requireFirebaseAuthWithUser, requireAdmin, async (_req, res) => {
      try {
        const settings = await damageClaimLimitsService.getStorageCheckoutSettings();
        const defaults = damageClaimLimitsService.getDefaultStorageCheckoutSettings();
        res.json({ settings, defaults });
      } catch (error) {
        logger.error("Error fetching storage checkout settings:", error);
        res.status(500).json({ error: "Failed to fetch storage checkout settings" });
      }
    });
    router21.put("/storage-checkout-settings", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const { reviewWindowHours, extendedClaimWindowHours } = req.body;
        const updates = [];
        if (reviewWindowHours !== void 0) {
          if (reviewWindowHours < 1 || reviewWindowHours > 24) {
            return res.status(400).json({ error: "Review window must be between 1 and 24 hours" });
          }
          updates.push({
            key: "storage_checkout_review_window_hours",
            value: String(reviewWindowHours),
            description: "Hours manager has to review storage after chef checkout before auto-clear"
          });
        }
        if (extendedClaimWindowHours !== void 0) {
          if (extendedClaimWindowHours < 2 || extendedClaimWindowHours > 168) {
            return res.status(400).json({ error: "Extended claim window must be between 2 and 168 hours (7 days)" });
          }
          updates.push({
            key: "storage_checkout_extended_claim_window_hours",
            value: String(extendedClaimWindowHours),
            description: "Extended hours after checkout during which manager/admin can still file damage claims for serious issues"
          });
        }
        if (updates.length === 0) {
          return res.status(400).json({ error: "No valid updates provided" });
        }
        for (const update of updates) {
          await db.insert(platformSettings).values({
            key: update.key,
            value: update.value,
            description: update.description
          }).onConflictDoUpdate({
            target: platformSettings.key,
            set: {
              value: update.value,
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
        }
        const newSettings = await damageClaimLimitsService.getStorageCheckoutSettings();
        logger.info("[Admin] Updated storage checkout settings:", newSettings);
        res.json({
          success: true,
          message: `Updated ${updates.length} storage checkout setting(s)`,
          settings: newSettings
        });
      } catch (error) {
        logger.error("Error updating storage checkout settings:", error);
        res.status(500).json({ error: "Failed to update storage checkout settings" });
      }
    });
    router21.get("/damage-claims", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const statusFilter = req.query.status;
        const { damageEvidence: damageEvidence2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
        const statusCondition = statusFilter && statusFilter !== "all" ? sql19`AND dc.status = ${statusFilter}` : sql19``;
        const claimsQuery = await db.execute(sql19`
            SELECT 
                dc.*,
                chef_user.username as chef_email,
                COALESCE(cka.full_name, chef_user.username) as chef_name,
                mgr_user.username as manager_email,
                mgr_user.firebase_uid as manager_firebase_uid,
                loc.name as location_name
            FROM damage_claims dc
            INNER JOIN users chef_user ON dc.chef_id = chef_user.id
            INNER JOIN users mgr_user ON dc.manager_id = mgr_user.id
            INNER JOIN locations loc ON dc.location_id = loc.id
            LEFT JOIN chef_kitchen_applications cka 
                ON cka.chef_id = dc.chef_id 
                AND cka.location_id = dc.location_id
            WHERE 1=1 ${statusCondition}
            ORDER BY dc.created_at DESC
        `);
        const mgrFirebaseUids = claimsQuery.rows.map((r) => r.manager_firebase_uid).filter((uid) => !!uid);
        const uniqueMgrUids = Array.from(new Set(mgrFirebaseUids));
        const mgrFirestoreNames = await getFirestoreDisplayNames(uniqueMgrUids);
        const claims = [];
        for (const row of claimsQuery.rows) {
          const evidence = await db.select().from(damageEvidence2).where(eq33(damageEvidence2.damageClaimId, row.id));
          const firestoreMgrName = row.manager_firebase_uid ? mgrFirestoreNames[row.manager_firebase_uid] : null;
          const managerName = firestoreMgrName || emailPrefix(row.manager_email);
          claims.push({
            id: row.id,
            bookingType: row.booking_type,
            kitchenBookingId: row.kitchen_booking_id,
            storageBookingId: row.storage_booking_id,
            chefId: row.chef_id,
            managerId: row.manager_id,
            locationId: row.location_id,
            status: row.status,
            claimTitle: row.claim_title,
            claimDescription: row.claim_description,
            damageDate: row.damage_date,
            claimedAmountCents: row.claimed_amount_cents,
            approvedAmountCents: row.approved_amount_cents,
            finalAmountCents: row.final_amount_cents,
            chefResponse: row.chef_response,
            chefRespondedAt: row.chef_responded_at,
            chefResponseDeadline: row.chef_response_deadline,
            adminDecisionReason: row.admin_decision_reason,
            adminNotes: row.admin_notes,
            createdAt: row.created_at,
            submittedAt: row.submitted_at,
            chefEmail: row.chef_email,
            chefName: row.chef_name,
            managerName,
            locationName: row.location_name,
            evidence
          });
        }
        res.json({ claims });
      } catch (error) {
        logger.error("Error fetching damage claims:", error);
        res.status(500).json({ error: "Failed to fetch damage claims" });
      }
    });
    router21.get("/damage-claims/:id", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const claimId = parseInt(req.params.id);
        if (isNaN(claimId)) {
          return res.status(400).json({ error: "Invalid claim ID" });
        }
        const claim = await damageClaimService.getClaimById(claimId);
        if (!claim) {
          return res.status(404).json({ error: "Claim not found" });
        }
        const history = await damageClaimService.getClaimHistory(claimId);
        res.json({ claim, history });
      } catch (error) {
        logger.error("Error fetching damage claim:", error);
        res.status(500).json({ error: "Failed to fetch damage claim" });
      }
    });
    handleAdminDamageClaimDecision = async (req, res) => {
      try {
        const adminId = req.neonUser.id;
        const claimId = parseInt(req.params.id);
        const { decision, approvedAmountCents, decisionReason, notes } = req.body;
        if (isNaN(claimId)) {
          return res.status(400).json({ error: "Invalid claim ID" });
        }
        if (!decision || !["approve", "partially_approve", "reject"].includes(decision)) {
          return res.status(400).json({ error: "Decision must be 'approve', 'partially_approve', or 'reject'" });
        }
        if (!decisionReason || decisionReason.length < 20) {
          return res.status(400).json({ error: "Decision reason must be at least 20 characters" });
        }
        if (decision === "partially_approve" && (!approvedAmountCents || approvedAmountCents <= 0)) {
          return res.status(400).json({ error: "Approved amount is required for partial approval" });
        }
        const result = await damageClaimService.adminDecision(claimId, adminId, {
          decision,
          approvedAmountCents,
          decisionReason,
          notes
        });
        if (!result.success) {
          return res.status(400).json({ error: result.error });
        }
        res.json({
          success: true,
          message: `Claim ${decision === "reject" ? "rejected" : "approved"}`
        });
      } catch (error) {
        logger.error("Error processing admin decision:", error);
        res.status(500).json({ error: "Failed to process decision" });
      }
    };
    router21.post("/damage-claims/:id/review", requireFirebaseAuthWithUser, requireAdmin, handleAdminDamageClaimDecision);
    router21.post("/damage-claims/:id/decision", requireFirebaseAuthWithUser, requireAdmin, handleAdminDamageClaimDecision);
    router21.post("/damage-claims/:id/charge", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const claimId = parseInt(req.params.id);
        if (isNaN(claimId)) {
          return res.status(400).json({ error: "Invalid claim ID" });
        }
        const result = await damageClaimService.chargeApprovedClaim(claimId);
        if (!result.success) {
          return res.status(400).json({
            error: result.error,
            message: "Failed to charge damage claim"
          });
        }
        res.json({
          success: true,
          message: "Damage claim charged successfully",
          paymentIntentId: result.paymentIntentId,
          chargeId: result.chargeId
        });
      } catch (error) {
        logger.error("Error charging damage claim:", error);
        res.status(500).json({ error: "Failed to charge damage claim" });
      }
    });
    router21.get("/overstay-settings", requireFirebaseAuthWithUser, requireAdmin, async (_req, res) => {
      try {
        const { getOverstayPlatformDefaults: getOverstayPlatformDefaults2 } = await Promise.resolve().then(() => (init_overstay_defaults_service(), overstay_defaults_service_exports));
        const defaults = await getOverstayPlatformDefaults2();
        res.json({
          settings: {
            gracePeriodDays: defaults.gracePeriodDays,
            penaltyRatePercent: defaults.penaltyRate * 100,
            maxPenaltyDays: defaults.maxPenaltyDays
          },
          defaults: {
            gracePeriodDays: 3,
            penaltyRatePercent: 10,
            maxPenaltyDays: 30
          }
        });
      } catch (error) {
        logger.error("Error fetching overstay settings:", error);
        res.status(500).json({ error: "Failed to fetch overstay settings" });
      }
    });
    router21.put("/overstay-settings", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const { gracePeriodDays, penaltyRatePercent, maxPenaltyDays } = req.body;
        const updates = [];
        if (gracePeriodDays !== void 0) {
          if (gracePeriodDays < 0 || gracePeriodDays > 14) {
            return res.status(400).json({ error: "Grace period must be between 0 and 14 days" });
          }
          updates.push({
            key: "overstay_grace_period_days",
            value: String(gracePeriodDays),
            description: "Default grace period days before overstay penalty kicks in"
          });
        }
        if (penaltyRatePercent !== void 0) {
          if (penaltyRatePercent < 1 || penaltyRatePercent > 100) {
            return res.status(400).json({ error: "Penalty rate must be between 1% and 100%" });
          }
          updates.push({
            key: "overstay_penalty_rate",
            value: String(penaltyRatePercent / 100),
            description: "Default daily penalty rate as decimal (e.g. 0.10 = 10%)"
          });
        }
        if (maxPenaltyDays !== void 0) {
          if (maxPenaltyDays < 1 || maxPenaltyDays > 90) {
            return res.status(400).json({ error: "Max penalty days must be between 1 and 90" });
          }
          updates.push({
            key: "overstay_max_penalty_days",
            value: String(maxPenaltyDays),
            description: "Maximum number of days penalties can accumulate"
          });
        }
        if (updates.length === 0) {
          return res.status(400).json({ error: "No valid updates provided" });
        }
        for (const update of updates) {
          await db.insert(platformSettings).values({
            key: update.key,
            value: update.value,
            description: update.description
          }).onConflictDoUpdate({
            target: platformSettings.key,
            set: {
              value: update.value,
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
        }
        const { getOverstayPlatformDefaults: getOverstayPlatformDefaults2 } = await Promise.resolve().then(() => (init_overstay_defaults_service(), overstay_defaults_service_exports));
        const newDefaults = await getOverstayPlatformDefaults2();
        logger.info("[Admin] Updated overstay settings:", newDefaults);
        res.json({
          success: true,
          message: `Updated ${updates.length} overstay setting(s)`
        });
      } catch (error) {
        logger.error("Error updating overstay settings:", error);
        res.status(500).json({ error: "Failed to update overstay settings" });
      }
    });
    router21.get("/escalated-penalties", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const showAll = req.query.all === "true";
        const overstayStatusFilter = showAll ? sql19`` : sql19`AND sor.status = 'escalated'`;
        const overstayResult = await db.execute(sql19`
            SELECT 
                sor.id,
                sor.storage_booking_id as "storageBookingId",
                sor.status,
                sor.days_overdue as "daysOverdue",
                sor.calculated_penalty_cents as "calculatedPenaltyCents",
                sor.final_penalty_cents as "finalPenaltyCents",
                sor.charge_failure_reason as "chargeFailureReason",
                sor.detected_at as "detectedAt",
                sor.resolved_at as "resolvedAt",
                sl.name as "storageName",
                k.name as "kitchenName",
                loc.name as "locationName",
                u.username as "chefEmail",
                COALESCE(cka.full_name, split_part(u.username, '@', 1)) as "chefName"
            FROM storage_overstay_records sor
            INNER JOIN storage_bookings sb ON sor.storage_booking_id = sb.id
            INNER JOIN storage_listings sl ON sb.storage_listing_id = sl.id
            INNER JOIN kitchens k ON sl.kitchen_id = k.id
            INNER JOIN locations loc ON k.location_id = loc.id
            LEFT JOIN users u ON sb.chef_id = u.id
            LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = sb.chef_id AND cka.location_id = loc.id
            WHERE 1=1 ${overstayStatusFilter}
            ORDER BY sor.detected_at DESC
        `);
        const allOverstays = overstayResult.rows;
        const claimStatusFilter = showAll ? sql19`` : sql19`AND dc.status = 'escalated'`;
        const claimResult = await db.execute(sql19`
            SELECT 
                dc.id,
                dc.claim_title as "claimTitle",
                dc.status,
                dc.claimed_amount_cents as "claimedAmountCents",
                dc.final_amount_cents as "finalAmountCents",
                dc.charge_failure_reason as "chargeFailureReason",
                dc.booking_type as "bookingType",
                dc.created_at as "createdAt",
                loc.name as "locationName",
                chef_user.username as "chefEmail",
                COALESCE(cka.full_name, split_part(chef_user.username, '@', 1)) as "chefName"
            FROM damage_claims dc
            INNER JOIN locations loc ON dc.location_id = loc.id
            LEFT JOIN users chef_user ON dc.chef_id = chef_user.id
            LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = dc.chef_id AND cka.location_id = dc.location_id
            WHERE 1=1 ${claimStatusFilter}
            ORDER BY dc.created_at DESC
        `);
        const allClaims = claimResult.rows;
        const escalatedOverstays = allOverstays.filter((o) => o.status === "escalated");
        const escalatedClaims = allClaims.filter((c) => c.status === "escalated");
        res.json({
          overstays: allOverstays,
          damageClaims: allClaims,
          summary: {
            totalEscalatedOverstays: escalatedOverstays.length,
            totalEscalatedClaims: escalatedClaims.length,
            totalEscalatedAmountCents: [
              ...escalatedOverstays.map((o) => o.finalPenaltyCents || o.calculatedPenaltyCents || 0),
              ...escalatedClaims.map((c) => c.finalAmountCents || c.claimedAmountCents || 0)
            ].reduce((sum, val) => sum + val, 0),
            totalOverstays: allOverstays.length,
            totalClaims: allClaims.length
          }
        });
      } catch (error) {
        logger.error("Error fetching escalated penalties:", error);
        res.status(500).json({ error: "Failed to fetch escalated penalties" });
      }
    });
    router21.get("/transactions/locations", requireFirebaseAuthWithUser, requireAdmin, async (_req, res) => {
      try {
        const result = await db.execute(sql19`
            SELECT id, name FROM locations ORDER BY name ASC
        `);
        res.json(result.rows);
      } catch (error) {
        logger.error("[Admin Transactions] Error fetching locations:", error);
        res.status(500).json({ error: "Failed to fetch locations" });
      }
    });
    router21.get("/transactions", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const {
          search,
          status,
          bookingType,
          locationId,
          kitchenId,
          chefId,
          managerId,
          startDate,
          endDate,
          limit = "100",
          offset = "0"
        } = req.query;
        const parsedLimit = Math.min(parseInt(limit) || 100, 500);
        const parsedOffset = parseInt(offset) || 0;
        const conditions = [];
        if (status && ["pending", "processing", "succeeded", "failed", "canceled", "refunded", "partially_refunded"].includes(status)) {
          conditions.push(sql19`pt.status = ${status}`);
        }
        if (bookingType && ["kitchen", "storage", "equipment", "bundle"].includes(bookingType)) {
          conditions.push(sql19`pt.booking_type = ${bookingType}`);
        }
        if (locationId) {
          const parsed = parseInt(locationId);
          if (!isNaN(parsed)) {
            conditions.push(sql19`(
                    (pt.booking_type = 'kitchen' AND k.location_id = ${parsed}) OR
                    (pt.booking_type = 'storage' AND sk.location_id = ${parsed}) OR
                    (pt.booking_type = 'equipment' AND ek.location_id = ${parsed})
                )`);
          }
        }
        if (kitchenId) {
          const parsed = parseInt(kitchenId);
          if (!isNaN(parsed)) {
            conditions.push(sql19`(
                    (pt.booking_type = 'kitchen' AND kb.kitchen_id = ${parsed}) OR
                    (pt.booking_type = 'storage' AND sl.kitchen_id = ${parsed}) OR
                    (pt.booking_type = 'equipment' AND el.kitchen_id = ${parsed})
                )`);
          }
        }
        if (chefId) {
          const parsed = parseInt(chefId);
          if (!isNaN(parsed)) conditions.push(sql19`pt.chef_id = ${parsed}`);
        }
        if (managerId) {
          const parsed = parseInt(managerId);
          if (!isNaN(parsed)) conditions.push(sql19`pt.manager_id = ${parsed}`);
        }
        if (startDate) {
          conditions.push(sql19`pt.created_at >= ${new Date(startDate)}`);
        }
        if (endDate) {
          conditions.push(sql19`pt.created_at <= ${new Date(endDate)}`);
        }
        if (search && typeof search === "string" && search.trim()) {
          const s = search.trim();
          const like = "%" + s + "%";
          const numVal = parseInt(s);
          const isNum = !isNaN(numVal);
          conditions.push(sql19`(
                pt.payment_intent_id ILIKE ${like}
                OR pt.charge_id ILIKE ${like}
                OR pt.refund_id ILIKE ${like}
                OR pt.payment_method_id ILIKE ${like}
                OR pt.webhook_event_id ILIKE ${like}
                OR pt.refund_reason ILIKE ${like}
                OR pt.failure_reason ILIKE ${like}
                OR chef_user.username ILIKE ${like}
                OR COALESCE(cka.full_name, '') ILIKE ${like}
                OR l.name ILIKE ${like}
                OR k.name ILIKE ${like}
                OR CAST(pt.id AS TEXT) = ${s}
                OR CAST(pt.booking_id AS TEXT) = ${s}
                OR COALESCE(kb.reference_code, '') ILIKE ${like}
                OR COALESCE(sb.reference_code, '') ILIKE ${like}
                ${isNum ? sql19`OR pt.chef_id = ${numVal} OR pt.manager_id = ${numVal}` : sql19``}
            )`);
        }
        const whereClause = conditions.length > 0 ? sql19`WHERE ${sql19.join(conditions, sql19` AND `)}` : sql19``;
        const joinBlock = sql19`
            FROM payment_transactions pt
            LEFT JOIN kitchen_bookings kb ON pt.booking_type = 'kitchen' AND pt.booking_id = kb.id
            LEFT JOIN kitchens k ON kb.kitchen_id = k.id
            LEFT JOIN storage_bookings sb ON pt.booking_type = 'storage' AND pt.booking_id = sb.id
            LEFT JOIN storage_listings sl ON sb.storage_listing_id = sl.id
            LEFT JOIN kitchens sk ON sl.kitchen_id = sk.id
            LEFT JOIN equipment_bookings eb ON pt.booking_type = 'equipment' AND pt.booking_id = eb.id
            LEFT JOIN equipment_listings el ON eb.equipment_listing_id = el.id
            LEFT JOIN kitchens ek ON el.kitchen_id = ek.id
            LEFT JOIN locations l ON (
                (pt.booking_type = 'kitchen' AND k.location_id = l.id) OR
                (pt.booking_type = 'storage' AND sk.location_id = l.id) OR
                (pt.booking_type = 'equipment' AND ek.location_id = l.id)
            )
            LEFT JOIN users chef_user ON pt.chef_id = chef_user.id
            LEFT JOIN users manager_user ON pt.manager_id = manager_user.id
            LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = pt.chef_id AND cka.location_id = l.id
        `;
        const countResult = await db.execute(sql19`SELECT COUNT(*) as total ${joinBlock} ${whereClause}`);
        const total = parseInt(countResult.rows[0].total);
        const atSign = "@";
        const result = await db.execute(sql19`
            SELECT
                pt.id, pt.booking_id, pt.booking_type, pt.chef_id, pt.manager_id,
                pt.amount, pt.base_amount, pt.service_fee, pt.stripe_processing_fee,
                pt.manager_revenue, pt.refund_amount, pt.net_amount, pt.currency,
                pt.payment_intent_id, pt.charge_id, pt.refund_id, pt.payment_method_id,
                pt.status, pt.stripe_status, pt.metadata, pt.refund_reason, pt.failure_reason,
                pt.webhook_event_id, pt.last_synced_at, pt.created_at, pt.updated_at,
                pt.paid_at, pt.refunded_at,
                chef_user.username as chef_email,
                COALESCE(cka.full_name, split_part(chef_user.username, ${atSign}, 1)) as chef_name,
                chef_user.stripe_customer_id as stripe_customer_id,
                manager_user.username as manager_email,
                l.id as location_id, l.name as location_name,
                COALESCE(k.id, sk.id, ek.id) as kitchen_id,
                COALESCE(k.name, sk.name, ek.name) as kitchen_name,
                CASE
                    WHEN pt.booking_type = 'kitchen' THEN kb.booking_date::text
                    WHEN pt.booking_type = 'storage' THEN sb.start_date::text
                    WHEN pt.booking_type = 'equipment' THEN eb.start_date::text
                    ELSE NULL
                END as booking_start,
                CASE
                    WHEN pt.booking_type = 'kitchen' THEN NULL
                    WHEN pt.booking_type = 'storage' THEN sb.end_date::text
                    WHEN pt.booking_type = 'equipment' THEN eb.end_date::text
                    ELSE NULL
                END as booking_end,
                CASE
                    WHEN pt.booking_type = 'kitchen' THEN kb.start_time
                    ELSE NULL
                END as kitchen_start_time,
                CASE
                    WHEN pt.booking_type = 'kitchen' THEN kb.end_time
                    ELSE NULL
                END as kitchen_end_time,
                CASE
                    WHEN pt.booking_type = 'kitchen' THEN kb.status::text
                    WHEN pt.booking_type = 'storage' THEN sb.status::text
                    WHEN pt.booking_type = 'equipment' THEN eb.status::text
                    ELSE NULL
                END as booking_status,
                CASE
                    WHEN pt.booking_type = 'kitchen' THEN kb.payment_status::text
                    WHEN pt.booking_type = 'storage' THEN sb.payment_status::text
                    WHEN pt.booking_type = 'equipment' THEN eb.payment_status::text
                    ELSE NULL
                END as booking_payment_status,
                CASE
                    WHEN pt.booking_type = 'kitchen' THEN k.name
                    WHEN pt.booking_type = 'storage' THEN sl.name
                    ELSE NULL
                END as item_name,
                CASE
                    WHEN pt.booking_type = 'kitchen' THEN kb.reference_code
                    WHEN pt.booking_type = 'storage' THEN sb.reference_code
                    ELSE NULL
                END as reference_code
            ${joinBlock}
            ${whereClause}
            ORDER BY pt.created_at DESC
            LIMIT ${parsedLimit} OFFSET ${parsedOffset}
        `);
        const formattedTransactions = result.rows.map((tx) => ({
          id: tx.id,
          bookingId: tx.booking_id,
          bookingType: tx.booking_type,
          chefId: tx.chef_id,
          managerId: tx.manager_id,
          amount: parseFloat(tx.amount || "0"),
          baseAmount: parseFloat(tx.base_amount || "0"),
          serviceFee: parseFloat(tx.service_fee || "0"),
          stripeProcessingFee: parseFloat(tx.stripe_processing_fee || "0"),
          managerRevenue: parseFloat(tx.manager_revenue || "0"),
          refundAmount: parseFloat(tx.refund_amount || "0"),
          netAmount: parseFloat(tx.net_amount || "0"),
          currency: tx.currency,
          paymentIntentId: tx.payment_intent_id,
          chargeId: tx.charge_id,
          refundId: tx.refund_id,
          paymentMethodId: tx.payment_method_id,
          stripeCustomerId: tx.stripe_customer_id,
          status: tx.status,
          stripeStatus: tx.stripe_status,
          bookingStatus: tx.booking_status,
          bookingPaymentStatus: tx.booking_payment_status,
          metadata: tx.metadata,
          refundReason: tx.refund_reason,
          failureReason: tx.failure_reason,
          webhookEventId: tx.webhook_event_id,
          createdAt: tx.created_at,
          updatedAt: tx.updated_at,
          paidAt: tx.paid_at,
          refundedAt: tx.refunded_at,
          lastSyncedAt: tx.last_synced_at,
          chefEmail: tx.chef_email,
          chefName: tx.chef_name,
          managerEmail: tx.manager_email,
          locationId: tx.location_id,
          locationName: tx.location_name,
          kitchenId: tx.kitchen_id,
          kitchenName: tx.kitchen_name,
          itemName: tx.item_name,
          referenceCode: tx.reference_code,
          bookingStart: tx.booking_start,
          bookingEnd: tx.booking_end,
          kitchenStartTime: tx.kitchen_start_time,
          kitchenEndTime: tx.kitchen_end_time
        }));
        res.json({ transactions: formattedTransactions, total });
      } catch (error) {
        logger.error("[Admin Transactions] Error:", error?.message || error);
        if (error?.stack) logger.error("[Admin Transactions] Stack:", error.stack);
        res.status(500).json({ error: "Failed to fetch transactions", detail: error?.message || String(error) });
      }
    });
    router21.get("/overstay-penalties", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const { status: statusFilter, locationId, limit = "200", offset = "0" } = req.query;
        const parsedLimit = Math.min(parseInt(limit) || 200, 500);
        const parsedOffset = parseInt(offset) || 0;
        const statusClause = statusFilter ? sql19`AND sor.status = ${statusFilter}` : sql19``;
        const locationClause = locationId ? sql19`AND loc.id = ${parseInt(locationId)}` : sql19``;
        const result = await db.execute(sql19`
            SELECT 
                sor.id,
                sor.storage_booking_id as "storageBookingId",
                sor.status,
                sor.days_overdue as "daysOverdue",
                sor.calculated_penalty_cents as "calculatedPenaltyCents",
                sor.final_penalty_cents as "finalPenaltyCents",
                sor.daily_rate_cents as "dailyRateCents",
                sor.penalty_rate as "penaltyRate",
                sor.penalty_waived as "penaltyWaived",
                sor.waive_reason as "waiveReason",
                sor.manager_notes as "managerNotes",
                sor.detected_at as "detectedAt",
                sor.end_date as "bookingEndDate",
                sor.grace_period_ends_at as "gracePeriodEndsAt",
                sor.penalty_approved_at as "penaltyApprovedAt",
                sor.penalty_approved_by as "penaltyApprovedBy",
                sor.charge_attempted_at as "chargeAttemptedAt",
                sor.charge_succeeded_at as "chargeSucceededAt",
                sor.charge_failed_at as "chargeFailedAt",
                sor.charge_failure_reason as "chargeFailureReason",
                sor.resolved_at as "resolvedAt",
                sor.resolution_type as "resolutionType",
                sor.resolution_notes as "resolutionNotes",
                sor.stripe_payment_intent_id as "stripePaymentIntentId",
                sor.stripe_charge_id as "stripeChargeId",
                sor.chef_warning_sent_at as "chefWarningSentAt",
                sor.chef_penalty_notice_sent_at as "chefPenaltyNoticeSentAt",
                sor.manager_notified_at as "managerNotifiedAt",
                sor.created_at as "createdAt",
                sor.updated_at as "updatedAt",
                sb.start_date as "bookingStartDate",
                sb.total_price as "bookingTotalPrice",
                sb.chef_id as "chefId",
                sb.stripe_customer_id as "stripeCustomerId",
                sb.stripe_payment_method_id as "stripePaymentMethodId",
                sl.name as "storageName",
                sl.storage_type as "storageType",
                k.id as "kitchenId",
                k.name as "kitchenName",
                loc.id as "locationId",
                loc.name as "locationName",
                u.username as "chefEmail",
                COALESCE(cka.full_name, split_part(u.username, '@', 1)) as "chefName",
                mgr.username as "managerEmail",
                COALESCE(mgr_cka.full_name, split_part(mgr.username, '@', 1)) as "managerName",
                loc.manager_id as "managerId",
                k.tax_rate_percent as "kitchenTaxRatePercent"
            FROM storage_overstay_records sor
            INNER JOIN storage_bookings sb ON sor.storage_booking_id = sb.id
            INNER JOIN storage_listings sl ON sb.storage_listing_id = sl.id
            INNER JOIN kitchens k ON sl.kitchen_id = k.id
            INNER JOIN locations loc ON k.location_id = loc.id
            LEFT JOIN users u ON sb.chef_id = u.id
            LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = sb.chef_id AND cka.location_id = loc.id
            LEFT JOIN users mgr ON loc.manager_id = mgr.id
            LEFT JOIN chef_kitchen_applications mgr_cka ON mgr_cka.chef_id = loc.manager_id AND mgr_cka.location_id = loc.id
            WHERE 1=1 ${statusClause} ${locationClause}
            ORDER BY sor.detected_at DESC
            LIMIT ${parsedLimit} OFFSET ${parsedOffset}
        `);
        const countResult = await db.execute(sql19`
            SELECT COUNT(*) as total
            FROM storage_overstay_records sor
            INNER JOIN storage_bookings sb ON sor.storage_booking_id = sb.id
            INNER JOIN storage_listings sl ON sb.storage_listing_id = sl.id
            INNER JOIN kitchens k ON sl.kitchen_id = k.id
            INNER JOIN locations loc ON k.location_id = loc.id
            WHERE 1=1 ${statusClause} ${locationClause}
        `);
        const total = parseInt(countResult.rows[0]?.total || "0");
        res.json({ overstayPenalties: result.rows, total });
      } catch (error) {
        logger.error("[Admin Overstay Penalties] Error:", error?.message || error);
        res.status(500).json({ error: "Failed to fetch overstay penalties" });
      }
    });
    router21.get("/overstay-penalties/:id/history", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const overstayId = parseInt(req.params.id);
        if (isNaN(overstayId)) return res.status(400).json({ error: "Invalid ID" });
        const result = await db.execute(sql19`
            SELECT 
                soh.id,
                soh.overstay_record_id as "overstayRecordId",
                soh.previous_status as "previousStatus",
                soh.new_status as "newStatus",
                soh.event_type as "eventType",
                soh.event_source as "eventSource",
                soh.description,
                soh.metadata,
                soh.created_at as "createdAt",
                soh.created_by as "createdBy",
                u.username as "createdByEmail"
            FROM storage_overstay_history soh
            LEFT JOIN users u ON soh.created_by = u.id
            WHERE soh.overstay_record_id = ${overstayId}
            ORDER BY soh.created_at ASC
        `);
        res.json({ history: result.rows });
      } catch (error) {
        logger.error("[Admin Overstay History] Error:", error?.message || error);
        res.status(500).json({ error: "Failed to fetch overstay history" });
      }
    });
    router21.get("/damage-claims-history", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const { status: statusFilter, locationId, bookingType, limit = "200", offset = "0" } = req.query;
        const parsedLimit = Math.min(parseInt(limit) || 200, 500);
        const parsedOffset = parseInt(offset) || 0;
        const statusClause = statusFilter ? sql19`AND dc.status = ${statusFilter}` : sql19``;
        const locationClause = locationId ? sql19`AND dc.location_id = ${parseInt(locationId)}` : sql19``;
        const bookingTypeClause = bookingType ? sql19`AND dc.booking_type = ${bookingType}` : sql19``;
        const result = await db.execute(sql19`
            SELECT 
                dc.id,
                dc.booking_type as "bookingType",
                dc.kitchen_booking_id as "kitchenBookingId",
                dc.storage_booking_id as "storageBookingId",
                dc.chef_id as "chefId",
                dc.manager_id as "managerId",
                dc.location_id as "locationId",
                dc.status,
                dc.claim_title as "claimTitle",
                dc.claim_description as "claimDescription",
                dc.damage_date as "damageDate",
                dc.claimed_amount_cents as "claimedAmountCents",
                dc.approved_amount_cents as "approvedAmountCents",
                dc.final_amount_cents as "finalAmountCents",
                dc.chef_response as "chefResponse",
                dc.chef_responded_at as "chefRespondedAt",
                dc.chef_response_deadline as "chefResponseDeadline",
                dc.admin_reviewer_id as "adminReviewerId",
                dc.admin_reviewed_at as "adminReviewedAt",
                dc.admin_notes as "adminNotes",
                dc.admin_decision_reason as "adminDecisionReason",
                dc.stripe_payment_intent_id as "stripePaymentIntentId",
                dc.stripe_charge_id as "stripeChargeId",
                dc.charge_attempted_at as "chargeAttemptedAt",
                dc.charge_succeeded_at as "chargeSucceededAt",
                dc.charge_failed_at as "chargeFailedAt",
                dc.charge_failure_reason as "chargeFailureReason",
                dc.stripe_customer_id as "stripeCustomerId",
                dc.stripe_payment_method_id as "stripePaymentMethodId",
                dc.resolved_at as "resolvedAt",
                dc.resolved_by as "resolvedBy",
                dc.resolution_type as "resolutionType",
                dc.resolution_notes as "resolutionNotes",
                dc.damaged_items as "damagedItems",
                dc.created_at as "createdAt",
                dc.updated_at as "updatedAt",
                dc.submitted_at as "submittedAt",
                loc.name as "locationName",
                chef_user.username as "chefEmail",
                COALESCE(chef_cka.full_name, split_part(chef_user.username, '@', 1)) as "chefName",
                mgr_user.username as "managerEmail",
                COALESCE(mgr_cka.full_name, split_part(mgr_user.username, '@', 1)) as "managerName",
                reviewer.username as "adminReviewerEmail"
            FROM damage_claims dc
            INNER JOIN locations loc ON dc.location_id = loc.id
            LEFT JOIN users chef_user ON dc.chef_id = chef_user.id
            LEFT JOIN chef_kitchen_applications chef_cka ON chef_cka.chef_id = dc.chef_id AND chef_cka.location_id = dc.location_id
            LEFT JOIN users mgr_user ON dc.manager_id = mgr_user.id
            LEFT JOIN chef_kitchen_applications mgr_cka ON mgr_cka.chef_id = dc.manager_id AND mgr_cka.location_id = dc.location_id
            LEFT JOIN users reviewer ON dc.admin_reviewer_id = reviewer.id
            WHERE 1=1 ${statusClause} ${locationClause} ${bookingTypeClause}
            ORDER BY dc.created_at DESC
            LIMIT ${parsedLimit} OFFSET ${parsedOffset}
        `);
        const countResult = await db.execute(sql19`
            SELECT COUNT(*) as total
            FROM damage_claims dc
            WHERE 1=1 ${statusClause} ${locationClause} ${bookingTypeClause}
        `);
        const total = parseInt(countResult.rows[0]?.total || "0");
        res.json({ damageClaims: result.rows, total });
      } catch (error) {
        logger.error("[Admin Damage Claims History] Error:", error?.message || error);
        res.status(500).json({ error: "Failed to fetch damage claims" });
      }
    });
    router21.get("/damage-claims-history/:id/history", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const claimId = parseInt(req.params.id);
        if (isNaN(claimId)) return res.status(400).json({ error: "Invalid ID" });
        const result = await db.execute(sql19`
            SELECT 
                dch.id,
                dch.damage_claim_id as "damageClaimId",
                dch.previous_status as "previousStatus",
                dch.new_status as "newStatus",
                dch.action,
                dch.action_by as "actionBy",
                dch.action_by_user_id as "actionByUserId",
                dch.notes,
                dch.metadata,
                dch.created_at as "createdAt",
                u.username as "actionByEmail"
            FROM damage_claim_history dch
            LEFT JOIN users u ON dch.action_by_user_id = u.id
            WHERE dch.damage_claim_id = ${claimId}
            ORDER BY dch.created_at ASC
        `);
        res.json({ history: result.rows });
      } catch (error) {
        logger.error("[Admin Damage Claim History] Error:", error?.message || error);
        res.status(500).json({ error: "Failed to fetch damage claim history" });
      }
    });
    router21.get("/damage-claims-history/:id/evidence", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const claimId = parseInt(req.params.id);
        if (isNaN(claimId)) return res.status(400).json({ error: "Invalid ID" });
        const result = await db.execute(sql19`
            SELECT 
                de.id,
                de.damage_claim_id as "damageClaimId",
                de.evidence_type as "evidenceType",
                de.file_url as "fileUrl",
                de.file_name as "fileName",
                de.file_size as "fileSize",
                de.mime_type as "mimeType",
                de.description,
                de.uploaded_by as "uploadedBy",
                de.uploaded_at as "uploadedAt",
                de.amount_cents as "amountCents",
                de.vendor_name as "vendorName",
                u.username as "uploadedByEmail"
            FROM damage_evidence de
            LEFT JOIN users u ON de.uploaded_by = u.id
            WHERE de.damage_claim_id = ${claimId}
            ORDER BY de.uploaded_at ASC
        `);
        res.json({ evidence: result.rows });
      } catch (error) {
        logger.error("[Admin Damage Evidence] Error:", error?.message || error);
        res.status(500).json({ error: "Failed to fetch evidence" });
      }
    });
    router21.get("/security/rate-limits", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const { getRateLimitConfig: getRateLimitConfig2, getDefaultRateLimits: getDefaultRateLimits2 } = await Promise.resolve().then(() => (init_security(), security_exports));
        const current = await getRateLimitConfig2();
        const defaults = getDefaultRateLimits2();
        res.json({ current, defaults });
      } catch (error) {
        logger.error("[Admin Security] Error fetching rate limits:", error?.message || error);
        res.status(500).json({ error: "Failed to fetch rate limit settings" });
      }
    });
    router21.put("/security/rate-limits", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
      try {
        const { invalidateRateLimitCache: invalidateRateLimitCache2 } = await Promise.resolve().then(() => (init_security(), security_exports));
        const SETTING_MAP = {
          globalWindowMs: "rate_limit_global_window_ms",
          globalMaxRequests: "rate_limit_global_max",
          authWindowMs: "rate_limit_auth_window_ms",
          authMaxRequests: "rate_limit_auth_max",
          apiWindowMs: "rate_limit_api_window_ms",
          apiMaxRequests: "rate_limit_api_max",
          webhookWindowMs: "rate_limit_webhook_window_ms",
          webhookMaxRequests: "rate_limit_webhook_max"
        };
        const updates = [];
        for (const [bodyKey, settingKey] of Object.entries(SETTING_MAP)) {
          if (bodyKey in req.body) {
            const val = parseInt(req.body[bodyKey], 10);
            if (isNaN(val) || val < 1) {
              return res.status(400).json({ error: `Invalid value for ${bodyKey}: must be a positive integer` });
            }
            updates.push({ key: settingKey, value: String(val) });
          }
        }
        if (updates.length === 0) {
          return res.status(400).json({ error: "No valid settings provided" });
        }
        for (const { key, value } of updates) {
          await db.execute(sql19`
                INSERT INTO platform_settings (key, value) 
                VALUES (${key}, ${value})
                ON CONFLICT (key) DO UPDATE SET value = ${value}
            `);
        }
        invalidateRateLimitCache2();
        logger.info(`[Admin Security] Rate limits updated by admin ${req.neonUser?.id}: ${updates.map((u) => `${u.key}=${u.value}`).join(", ")}`);
        res.json({ success: true, updated: updates.length, settings: Object.fromEntries(updates.map((u) => [u.key, u.value])) });
      } catch (error) {
        logger.error("[Admin Security] Error updating rate limits:", error?.message || error);
        res.status(500).json({ error: "Failed to update rate limit settings" });
      }
    });
    admin_default = router21;
  }
});

// server/services/stripe-checkout-transactions-service.ts
var stripe_checkout_transactions_service_exports = {};
__export(stripe_checkout_transactions_service_exports, {
  createTransaction: () => createTransaction,
  getTransactionBySessionId: () => getTransactionBySessionId,
  updateTransactionBySessionId: () => updateTransactionBySessionId
});
import { sql as sql20 } from "drizzle-orm";
async function createTransaction(params, db2) {
  const {
    bookingId,
    stripeSessionId,
    customerEmail,
    bookingAmountCents,
    platformFeePercentageCents,
    platformFeeFlatCents,
    totalPlatformFeeCents,
    totalCustomerChargedCents,
    managerReceivesCents,
    metadata = {}
  } = params;
  const result = await db2.execute(sql20`
    INSERT INTO transactions (
      booking_id,
      stripe_session_id,
      customer_email,
      booking_amount_cents,
      platform_fee_percentage_cents,
      platform_fee_flat_cents,
      total_platform_fee_cents,
      total_customer_charged_cents,
      manager_receives_cents,
      status,
      metadata
    ) VALUES (
      ${bookingId},
      ${stripeSessionId},
      ${customerEmail},
      ${bookingAmountCents},
      ${platformFeePercentageCents},
      ${platformFeeFlatCents},
      ${totalPlatformFeeCents},
      ${totalCustomerChargedCents},
      ${managerReceivesCents},
      ${"pending"},
      ${JSON.stringify(metadata)}
    )
    RETURNING *
  `);
  if (result.rows.length === 0) {
    throw new Error("Failed to create transaction record");
  }
  return mapRowToTransaction(result.rows[0]);
}
async function updateTransactionBySessionId(sessionId, params, db2) {
  const updates = [];
  if (params.status !== void 0) {
    updates.push(sql20`status = ${params.status}`);
  }
  if (params.stripePaymentIntentId !== void 0) {
    updates.push(sql20`stripe_payment_intent_id = ${params.stripePaymentIntentId}`);
  }
  if (params.stripeChargeId !== void 0) {
    updates.push(sql20`stripe_charge_id = ${params.stripeChargeId}`);
  }
  if (params.completedAt !== void 0) {
    updates.push(sql20`completed_at = ${params.completedAt}`);
  }
  if (params.refundedAt !== void 0) {
    updates.push(sql20`refunded_at = ${params.refundedAt}`);
  }
  if (params.metadata !== void 0) {
    updates.push(sql20`metadata = ${JSON.stringify(params.metadata)}`);
  }
  if (updates.length === 0) {
    return getTransactionBySessionId(sessionId, db2);
  }
  const result = await db2.execute(sql20`
    UPDATE transactions
    SET ${sql20.join(updates, sql20`, `)}
    WHERE stripe_session_id = ${sessionId}
    RETURNING *
  `);
  if (result.rows.length === 0) {
    return null;
  }
  return mapRowToTransaction(result.rows[0]);
}
async function getTransactionBySessionId(sessionId, db2) {
  const result = await db2.execute(sql20`
    SELECT * FROM transactions WHERE stripe_session_id = ${sessionId}
  `);
  if (result.rows.length === 0) {
    return null;
  }
  return mapRowToTransaction(result.rows[0]);
}
function mapRowToTransaction(row) {
  return {
    id: row.id,
    booking_id: row.booking_id,
    stripe_session_id: row.stripe_session_id,
    stripe_payment_intent_id: row.stripe_payment_intent_id,
    stripe_charge_id: row.stripe_charge_id,
    customer_email: row.customer_email,
    booking_amount_cents: row.booking_amount_cents,
    platform_fee_percentage_cents: row.platform_fee_percentage_cents,
    platform_fee_flat_cents: row.platform_fee_flat_cents,
    total_platform_fee_cents: row.total_platform_fee_cents,
    total_customer_charged_cents: row.total_customer_charged_cents,
    manager_receives_cents: row.manager_receives_cents,
    status: row.status,
    created_at: row.created_at,
    completed_at: row.completed_at,
    refunded_at: row.refunded_at,
    metadata: typeof row.metadata === "string" ? JSON.parse(row.metadata) : row.metadata || {}
  };
}
var init_stripe_checkout_transactions_service = __esm({
  "server/services/stripe-checkout-transactions-service.ts"() {
    "use strict";
  }
});

// server/routes/webhooks.ts
var webhooks_exports = {};
__export(webhooks_exports, {
  default: () => webhooks_default
});
import { Router as Router22 } from "express";
import Stripe6 from "stripe";
import { eq as eq34, and as and21, ne as ne5, notInArray } from "drizzle-orm";
import * as Sentry5 from "@sentry/node";
async function handleCheckoutSessionCompleted(session, webhookEventId) {
  if (!pool) {
    logger.error("Database pool not available for webhook");
    return;
  }
  try {
    let updateTransactionBySessionId2 = null;
    try {
      const legacyService = await Promise.resolve().then(() => (init_stripe_checkout_transactions_service(), stripe_checkout_transactions_service_exports));
      updateTransactionBySessionId2 = legacyService.updateTransactionBySessionId;
    } catch {
    }
    const stripeSecretKey6 = process.env.STRIPE_SECRET_KEY;
    if (!stripeSecretKey6) {
      logger.error("Stripe secret key not available");
      return;
    }
    const stripe6 = new Stripe6(stripeSecretKey6, {
      apiVersion: "2025-12-15.clover"
    });
    const expandedSession = await stripe6.checkout.sessions.retrieve(
      session.id,
      {
        expand: ["line_items", "payment_intent"]
      }
    );
    const paymentIntent = expandedSession.payment_intent;
    let paymentIntentId;
    let chargeId;
    let stripeCustomerId;
    let stripePaymentMethodId;
    if (expandedSession.customer) {
      stripeCustomerId = typeof expandedSession.customer === "string" ? expandedSession.customer : expandedSession.customer.id;
    }
    if (typeof paymentIntent === "object" && paymentIntent !== null) {
      paymentIntentId = paymentIntent.id;
      if (paymentIntent.latest_charge) {
        chargeId = typeof paymentIntent.latest_charge === "string" ? paymentIntent.latest_charge : paymentIntent.latest_charge.id;
      }
      if (paymentIntent.payment_method) {
        stripePaymentMethodId = typeof paymentIntent.payment_method === "string" ? paymentIntent.payment_method : paymentIntent.payment_method.id;
      }
    } else if (typeof paymentIntent === "string") {
      paymentIntentId = paymentIntent;
      try {
        const pi = await stripe6.paymentIntents.retrieve(paymentIntent);
        if (pi.latest_charge) {
          chargeId = typeof pi.latest_charge === "string" ? pi.latest_charge : pi.latest_charge.id;
        }
        if (pi.payment_method) {
          stripePaymentMethodId = typeof pi.payment_method === "string" ? pi.payment_method : pi.payment_method.id;
        }
      } catch (error) {
        logger.warn("Could not fetch payment intent details:", { error });
      }
    }
    if (stripeCustomerId || stripePaymentMethodId) {
      logger.info(`[Webhook] Extracted Stripe IDs for off-session charging:`, {
        sessionId: session.id,
        stripeCustomerId,
        stripePaymentMethodId,
        paymentIntentId
      });
    }
    const updateParams = {
      status: "completed",
      completedAt: /* @__PURE__ */ new Date(),
      metadata: {
        webhook_event_id: webhookEventId,
        session_mode: expandedSession.mode
      }
    };
    if (paymentIntentId) {
      updateParams.stripePaymentIntentId = paymentIntentId;
    }
    if (chargeId) {
      updateParams.stripeChargeId = chargeId;
    }
    if (updateTransactionBySessionId2) {
      try {
        const updatedTransaction = await updateTransactionBySessionId2(
          session.id,
          updateParams,
          db
        );
        if (updatedTransaction) {
          logger.info(
            `[Webhook] Updated legacy transaction for Checkout session ${session.id}:`,
            {
              paymentIntentId,
              chargeId,
              amount: updatedTransaction.total_customer_charged_cents ? `$${(updatedTransaction.total_customer_charged_cents / 100).toFixed(2)}` : "N/A",
              managerReceives: updatedTransaction.manager_receives_cents ? `$${(updatedTransaction.manager_receives_cents / 100).toFixed(2)}` : "N/A"
            }
          );
        }
      } catch {
        logger.debug(`[Webhook] Legacy transactions table not available for session ${session.id}`);
      }
    }
    const piObj = expandedSession.payment_intent;
    const piStatus = piObj && typeof piObj === "object" ? piObj.status : void 0;
    const isManualCapture = piStatus === "requires_capture";
    if (isManualCapture) {
      logger.info(`[Webhook] AUTH-THEN-CAPTURE: Payment authorized (not captured) for session ${session.id}`, {
        paymentIntentId,
        piStatus,
        paymentStatus: expandedSession.payment_status
      });
    }
    if (paymentIntentId) {
      try {
        const { findPaymentTransactionByMetadata: findPaymentTransactionByMetadata2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
        const { getStripePaymentAmounts: getStripePaymentAmounts2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
        const ptRecord = await findPaymentTransactionByMetadata2(
          "checkout_session_id",
          session.id,
          db
        );
        if (ptRecord) {
          const paymentSucceeded = expandedSession.payment_status === "paid" && !isManualCapture;
          const correctStatus = isManualCapture ? "authorized" : paymentSucceeded ? "succeeded" : "processing";
          const updateParams2 = {
            paymentIntentId,
            chargeId,
            status: correctStatus,
            stripeStatus: correctStatus,
            paidAt: paymentSucceeded ? /* @__PURE__ */ new Date() : void 0
          };
          if (paymentSucceeded) {
            try {
              let managerConnectAccountId;
              if (ptRecord.manager_id) {
                const [manager] = await db.select({ stripeConnectAccountId: users.stripeConnectAccountId }).from(users).where(eq34(users.id, ptRecord.manager_id)).limit(1);
                if (manager?.stripeConnectAccountId) {
                  managerConnectAccountId = manager.stripeConnectAccountId;
                }
              }
              const stripeAmounts = await getStripePaymentAmounts2(paymentIntentId, managerConnectAccountId);
              if (stripeAmounts) {
                updateParams2.stripeAmount = stripeAmounts.stripeAmount;
                updateParams2.stripeNetAmount = stripeAmounts.stripeNetAmount;
                updateParams2.stripeProcessingFee = stripeAmounts.stripeProcessingFee;
                updateParams2.stripePlatformFee = stripeAmounts.stripePlatformFee;
                updateParams2.lastSyncedAt = /* @__PURE__ */ new Date();
                logger.info(`[Webhook] Syncing Stripe amounts for existing payment_transactions:`, {
                  sessionId: session.id,
                  amount: `$${(stripeAmounts.stripeAmount / 100).toFixed(2)}`,
                  processingFee: `$${(stripeAmounts.stripeProcessingFee / 100).toFixed(2)}`
                });
              }
            } catch (feeError) {
              logger.warn(`[Webhook] Could not fetch Stripe amounts for existing record:`, feeError);
            }
          }
          await updatePaymentTransaction2(ptRecord.id, updateParams2, db);
          logger.info(
            `[Webhook] Updated payment_transactions with paymentIntentId for session ${session.id}, status: ${correctStatus}`
          );
        }
      } catch (ptError) {
        logger.warn(
          `[Webhook] Could not update payment_transactions:`,
          ptError
        );
      }
    }
    const metadata = expandedSession.metadata || {};
    logger.operational(`[Webhook] Checkout session metadata:`, {
      sessionId: session.id,
      metadataType: metadata.type,
      allMetadata: metadata
    });
    if (metadata.type === "storage_extension") {
      logger.info(`[Webhook] Processing storage extension payment for session ${session.id}`, {
        paymentIntentId,
        chargeId,
        stripeCustomerId,
        stripePaymentMethodId
      });
      await handleStorageExtensionPaymentCompleted(
        session.id,
        paymentIntentId,
        chargeId,
        metadata,
        stripeCustomerId,
        stripePaymentMethodId,
        isManualCapture
      );
    }
    if (metadata.type === "overstay_penalty") {
      logger.info(`[Webhook] Processing overstay penalty payment for session ${session.id}`);
      await handleOverstayPenaltyPaymentCompleted(
        session.id,
        paymentIntentId,
        chargeId,
        metadata,
        expandedSession.payment_status
      );
    }
    if (metadata.type === "damage_claim") {
      logger.info(`[Webhook] Processing damage claim payment for session ${session.id}`);
      await handleDamageClaimPaymentCompleted(
        session.id,
        paymentIntentId || "",
        chargeId || "",
        metadata,
        expandedSession.payment_status
      );
    }
    if (metadata.type === "kitchen_booking" && !metadata.booking_id) {
      try {
        if (!isManualCapture && expandedSession.payment_status !== "paid") {
          logger.info(`[Webhook] Payment not yet confirmed for session ${session.id}, status: ${expandedSession.payment_status}`);
          return;
        }
        if (paymentIntentId) {
          const [existingBooking] = await db.select({ id: kitchenBookings.id }).from(kitchenBookings).where(eq34(kitchenBookings.paymentIntentId, paymentIntentId)).limit(1);
          if (existingBooking) {
            logger.info(`[Webhook] Booking ${existingBooking.id} already exists for payment intent ${paymentIntentId}, skipping duplicate creation`);
            return;
          }
        }
        const kitchenId = parseInt(metadata.kitchen_id);
        const chefId = parseInt(metadata.chef_id);
        const bookingDate = new Date(metadata.booking_date);
        const startTime = metadata.start_time;
        const endTime = metadata.end_time;
        const totalPriceCents = parseInt(metadata.total_price_cents);
        const taxCents = parseInt(metadata.tax_cents || "0");
        const hourlyRateCents = parseInt(metadata.hourly_rate_cents || "0");
        const durationHours = parseFloat(metadata.duration_hours || "1");
        const specialNotes = metadata.special_notes || null;
        const selectedSlots = metadata.selected_slots ? JSON.parse(metadata.selected_slots) : [];
        const selectedStorage = metadata.selected_storage ? JSON.parse(metadata.selected_storage) : [];
        const selectedEquipmentIds = metadata.selected_equipment_ids ? JSON.parse(metadata.selected_equipment_ids) : [];
        logger.operational(`[Webhook] Creating booking from metadata for kitchen ${kitchenId}, chef ${chefId}`, {
          sessionId: session.id,
          paymentIntentId,
          bookingDate: bookingDate.toISOString(),
          startTime,
          endTime,
          selectedSlotsCount: selectedSlots.length,
          selectedStorageCount: selectedStorage.length,
          selectedEquipmentCount: selectedEquipmentIds.length
        });
        const bookingPaymentStatus = isManualCapture ? "authorized" : "paid";
        let booking;
        try {
          const kbRefCode = await generateReferenceCode("kitchen_booking");
          const [directBooking] = await db.insert(kitchenBookings).values({
            referenceCode: kbRefCode,
            kitchenId,
            chefId,
            bookingDate,
            startTime,
            endTime,
            status: "pending",
            // Awaiting manager approval
            paymentStatus: bookingPaymentStatus,
            // 'authorized' for manual capture, 'paid' for auto capture
            paymentIntentId,
            specialNotes,
            totalPrice: totalPriceCents.toString(),
            hourlyRate: hourlyRateCents.toString(),
            durationHours: durationHours.toString(),
            serviceFee: parseInt(metadata.platform_fee_cents || "0").toString(),
            currency: "CAD",
            selectedSlots,
            storageItems: [],
            equipmentItems: [],
            // ENTERPRISE STANDARD: Store Stripe customer/payment info for off-session damage claim charging
            stripeCustomerId: stripeCustomerId || null,
            stripePaymentMethodId: stripePaymentMethodId || null
          }).returning();
          if (directBooking) {
            booking = {
              id: directBooking.id,
              referenceCode: directBooking.referenceCode,
              kitchenId: directBooking.kitchenId,
              chefId: directBooking.chefId,
              bookingDate: directBooking.bookingDate,
              startTime: directBooking.startTime,
              endTime: directBooking.endTime,
              status: directBooking.status,
              paymentStatus: directBooking.paymentStatus,
              paymentIntentId: directBooking.paymentIntentId
            };
            logger.operational(`[Webhook] Created booking ${directBooking.id} via direct DB insert`);
          } else {
            throw new Error("Direct DB insert returned no result");
          }
        } catch (insertError) {
          const errorMessage = insertError instanceof Error ? insertError.message : String(insertError);
          const errorStack = insertError instanceof Error ? insertError.stack : void 0;
          logger.error(`[Webhook] CRITICAL: Failed to create booking for session ${session.id}:`, {
            error: errorMessage,
            stack: errorStack,
            kitchenId,
            chefId,
            paymentIntentId
          });
          Sentry5.captureException(insertError, {
            tags: { component: "webhook_booking_creation" },
            extra: { sessionId: session.id, kitchenId, chefId, paymentIntentId }
          });
          throw insertError;
        }
        if (!booking || !booking.id) {
          logger.error(`[Webhook] CRITICAL: No booking was created for session ${session.id}`);
          throw new Error("No booking was created");
        }
        logger.operational(`[Webhook] Created booking ${booking.id} from checkout session ${session.id}`);
        const [verifiedBooking] = await db.select({ id: kitchenBookings.id }).from(kitchenBookings).where(eq34(kitchenBookings.id, booking.id)).limit(1);
        if (!verifiedBooking) {
          const persistError = new Error(`Booking ${booking.id} was not persisted to database`);
          logger.error(`[Webhook] CRITICAL: Booking ${booking.id} was not persisted to database! Session: ${session.id}`);
          Sentry5.captureException(persistError, {
            tags: { component: "webhook_booking_persist" },
            extra: { bookingId: booking.id, sessionId: session.id }
          });
          throw persistError;
        }
        logger.info(`[Webhook] Verified booking ${booking.id} exists in database`);
        if (stripeCustomerId && chefId) {
          try {
            await db.update(users).set({
              stripeCustomerId,
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq34(users.id, chefId));
            logger.info(`[Webhook] Saved Stripe Customer ID to user ${chefId}: ${stripeCustomerId}`);
          } catch (userUpdateError) {
            logger.warn(`[Webhook] Could not save Stripe Customer ID to user:`, userUpdateError);
          }
        }
        const storageItemsForJson = [];
        if (selectedStorage && selectedStorage.length > 0) {
          for (const storage of selectedStorage) {
            try {
              const [storageListing] = await db.select().from(storageListings).where(eq34(storageListings.id, storage.storageListingId)).limit(1);
              if (storageListing) {
                const basePriceCents = storageListing.basePrice ? Math.round(parseFloat(String(storageListing.basePrice))) : 0;
                const minDays = storageListing.minimumBookingDuration || 1;
                const storageStartDate = new Date(storage.startDate);
                const storageEndDate = new Date(storage.endDate);
                const days = Math.ceil((storageEndDate.getTime() - storageStartDate.getTime()) / (1e3 * 60 * 60 * 24));
                const effectiveDays = Math.max(days, minDays);
                let priceCents = basePriceCents * effectiveDays;
                if (storageListing.pricingModel === "hourly") {
                  const durationHoursStorage = Math.max(1, Math.ceil((storageEndDate.getTime() - storageStartDate.getTime()) / (1e3 * 60 * 60)));
                  priceCents = basePriceCents * durationHoursStorage;
                } else if (storageListing.pricingModel === "monthly-flat") {
                  priceCents = basePriceCents;
                }
                const sbRefCode = await generateReferenceCode("storage_booking");
                const [storageBooking] = await db.insert(storageBookings).values({
                  referenceCode: sbRefCode,
                  kitchenBookingId: booking.id,
                  storageListingId: storageListing.id,
                  chefId,
                  startDate: storageStartDate,
                  endDate: storageEndDate,
                  status: "pending",
                  // Requires manager approval
                  totalPrice: priceCents.toString(),
                  pricingModel: storageListing.pricingModel || "daily",
                  paymentStatus: bookingPaymentStatus,
                  // 'authorized' for manual capture, 'paid' for auto capture
                  paymentIntentId: paymentIntentId || null,
                  // Link to the kitchen booking payment
                  serviceFee: "0",
                  currency: "CAD",
                  stripeCustomerId: stripeCustomerId || null,
                  stripePaymentMethodId: stripePaymentMethodId || null
                }).returning();
                if (storageBooking) {
                  storageItemsForJson.push({
                    id: storageBooking.id,
                    storageListingId: storageListing.id,
                    name: storageListing.name || "Storage",
                    storageType: storageListing.storageType || "other",
                    totalPrice: priceCents,
                    startDate: storageStartDate.toISOString(),
                    endDate: storageEndDate.toISOString()
                  });
                }
              }
            } catch (storageItemError) {
              logger.error(`[Webhook] Error creating storage booking for listing ${storage.storageListingId}:`, storageItemError);
            }
          }
          logger.info(`[Webhook] Created ${storageItemsForJson.length}/${selectedStorage.length} storage bookings for booking ${booking.id}`);
        }
        const equipmentItemsForJson = [];
        if (selectedEquipmentIds && selectedEquipmentIds.length > 0) {
          for (const equipmentListingId of selectedEquipmentIds) {
            try {
              const [equipmentListing] = await db.select().from(equipmentListings).where(eq34(equipmentListings.id, equipmentListingId)).limit(1);
              if (equipmentListing && equipmentListing.availabilityType !== "included") {
                const sessionRateCents = equipmentListing.sessionRate ? Math.round(parseFloat(String(equipmentListing.sessionRate))) : 0;
                const [equipmentBooking] = await db.insert(equipmentBookings).values({
                  kitchenBookingId: booking.id,
                  equipmentListingId: equipmentListing.id,
                  chefId,
                  startDate: bookingDate,
                  endDate: bookingDate,
                  status: "pending",
                  // Requires manager approval
                  totalPrice: sessionRateCents.toString(),
                  pricingModel: "daily",
                  damageDeposit: (equipmentListing.damageDeposit || "0").toString(),
                  paymentStatus: bookingPaymentStatus,
                  // 'authorized' for manual capture, 'paid' for auto capture
                  paymentIntentId: paymentIntentId || null,
                  // Link to the kitchen booking payment
                  serviceFee: "0",
                  currency: "CAD"
                }).returning();
                if (equipmentBooking) {
                  equipmentItemsForJson.push({
                    id: equipmentBooking.id,
                    equipmentListingId: equipmentListing.id,
                    name: equipmentListing.equipmentType || "Equipment",
                    totalPrice: sessionRateCents
                  });
                }
              }
            } catch (equipmentItemError) {
              logger.error(`[Webhook] Error creating equipment booking for listing ${equipmentListingId}:`, equipmentItemError);
            }
          }
          logger.info(`[Webhook] Created ${equipmentItemsForJson.length}/${selectedEquipmentIds.length} equipment bookings for booking ${booking.id}`);
        }
        if (storageItemsForJson.length > 0 || equipmentItemsForJson.length > 0) {
          try {
            await db.update(kitchenBookings).set({
              storageItems: storageItemsForJson,
              equipmentItems: equipmentItemsForJson,
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq34(kitchenBookings.id, booking.id));
            logger.info(`[Webhook] Updated booking ${booking.id} with storage/equipment items`);
          } catch (updateError) {
            logger.error(`[Webhook] Error updating booking with storage/equipment items:`, updateError);
          }
        }
        try {
          const { createPaymentTransaction: createPaymentTransaction2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
          const { getStripePaymentAmounts: getStripePaymentAmounts2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
          const [kitchen] = await db.select({ locationId: kitchens.locationId }).from(kitchens).where(eq34(kitchens.id, kitchenId)).limit(1);
          if (kitchen) {
            const [location] = await db.select({ managerId: locations.managerId }).from(locations).where(eq34(locations.id, kitchen.locationId)).limit(1);
            if (location && location.managerId) {
              const paymentIntentObj = expandedSession.payment_intent;
              const chargeId2 = paymentIntentObj && typeof paymentIntentObj === "object" ? typeof paymentIntentObj.latest_charge === "string" ? paymentIntentObj.latest_charge : paymentIntentObj.latest_charge?.id : void 0;
              const ptStatus = isManualCapture ? "authorized" : "succeeded";
              const ptRecord = await createPaymentTransaction2({
                bookingId: booking.id,
                bookingType: "kitchen",
                chefId,
                managerId: location.managerId,
                amount: parseInt(metadata.booking_price_cents),
                baseAmount: totalPriceCents + taxCents,
                serviceFee: parseInt(metadata.platform_fee_cents || "0"),
                managerRevenue: parseInt(metadata.booking_price_cents) - parseInt(metadata.platform_fee_cents || "0"),
                currency: "CAD",
                paymentIntentId,
                status: ptStatus,
                stripeStatus: ptStatus,
                metadata: {
                  checkout_session_id: session.id,
                  booking_id: booking.id.toString(),
                  // ENTERPRISE STANDARD: Include storage_items in PT metadata
                  // This enables the View Details endpoint to identify which storage bookings
                  // belong to this kitchen booking payment (vs. extensions paid separately)
                  ...storageItemsForJson.length > 0 ? { storage_items: storageItemsForJson } : {},
                  ...equipmentItemsForJson.length > 0 ? { equipment_items: equipmentItemsForJson } : {}
                }
              }, db);
              if (ptRecord && !isManualCapture) {
                let managerConnectAccountId;
                try {
                  const [manager] = await db.select({ stripeConnectAccountId: users.stripeConnectAccountId }).from(users).where(eq34(users.id, location.managerId)).limit(1);
                  if (manager?.stripeConnectAccountId) {
                    managerConnectAccountId = manager.stripeConnectAccountId;
                  }
                } catch {
                  logger.warn(`[Webhook] Could not fetch manager Connect account`);
                }
                const stripeAmounts = paymentIntentId ? await getStripePaymentAmounts2(paymentIntentId, managerConnectAccountId) : null;
                const updateParams2 = {
                  chargeId: chargeId2,
                  paidAt: /* @__PURE__ */ new Date(),
                  lastSyncedAt: /* @__PURE__ */ new Date()
                };
                if (stripeAmounts) {
                  updateParams2.stripeAmount = stripeAmounts.stripeAmount;
                  updateParams2.stripeNetAmount = stripeAmounts.stripeNetAmount;
                  updateParams2.stripeProcessingFee = stripeAmounts.stripeProcessingFee;
                  updateParams2.stripePlatformFee = stripeAmounts.stripePlatformFee;
                  logger.info(`[Webhook] Syncing Stripe amounts for booking ${booking.id}:`, {
                    amount: `$${(stripeAmounts.stripeAmount / 100).toFixed(2)}`,
                    netAmount: `$${(stripeAmounts.stripeNetAmount / 100).toFixed(2)}`,
                    processingFee: `$${(stripeAmounts.stripeProcessingFee / 100).toFixed(2)}`
                  });
                }
                await updatePaymentTransaction2(ptRecord.id, updateParams2, db);
              } else if (ptRecord && isManualCapture) {
                logger.info(`[Webhook] AUTH-THEN-CAPTURE: Skipping fee sync for booking ${booking.id} \u2014 fees will sync at capture time`);
              }
              logger.info(`[Webhook] Created payment_transactions record for booking ${booking.id} with status '${ptStatus}'`);
            }
          }
        } catch (ptError) {
          logger.warn(`[Webhook] Could not create payment_transactions record:`, ptError);
        }
        try {
          const [kitchen] = await db.select({
            name: kitchens.name,
            locationId: kitchens.locationId
          }).from(kitchens).where(eq34(kitchens.id, kitchenId)).limit(1);
          if (kitchen) {
            const [location] = await db.select({
              name: locations.name,
              managerId: locations.managerId,
              notificationEmail: locations.notificationEmail,
              timezone: locations.timezone
            }).from(locations).where(eq34(locations.id, kitchen.locationId)).limit(1);
            if (location && location.managerId) {
              let chefName = "Chef";
              const [chef] = await db.select({ username: users.username }).from(users).where(eq34(users.id, chefId)).limit(1);
              if (chef) chefName = chef.username;
              let managerEmailAddress = location.notificationEmail;
              if (!managerEmailAddress) {
                const [manager] = await db.select({ username: users.username }).from(users).where(eq34(users.id, location.managerId)).limit(1);
                if (manager?.username) {
                  managerEmailAddress = manager.username;
                  logger.info(`[Webhook] Using manager's username as notification email: ${managerEmailAddress}`);
                }
              }
              if (managerEmailAddress) {
                const { sendEmail: sendEmail2, generateBookingNotificationEmail: generateBookingNotificationEmail3 } = await Promise.resolve().then(() => (init_email(), email_exports));
                const managerEmail = generateBookingNotificationEmail3({
                  managerEmail: managerEmailAddress,
                  chefName,
                  kitchenName: kitchen.name,
                  bookingDate,
                  startTime,
                  endTime,
                  specialNotes: specialNotes || void 0,
                  timezone: location.timezone || "America/St_Johns",
                  locationName: location.name,
                  bookingId: booking.id,
                  referenceCode: booking.referenceCode
                });
                const emailSent = await sendEmail2(managerEmail, { trackingId: `booking_${booking.id}_manager` });
                if (emailSent) {
                  logger.info(`[Webhook] \u2705 Sent manager notification email for booking ${booking.id} to ${managerEmailAddress}`);
                } else {
                  logger.error(`[Webhook] \u274C Failed to send manager notification email for booking ${booking.id} to ${managerEmailAddress}`);
                }
              } else {
                logger.warn(`[Webhook] No manager email available for booking ${booking.id} - skipping manager notification`);
              }
              await notificationService.notifyNewBooking({
                managerId: location.managerId,
                locationId: kitchen.locationId,
                bookingId: booking.id,
                chefName,
                kitchenName: kitchen.name,
                bookingDate: bookingDate.toISOString().split("T")[0],
                startTime,
                endTime
              });
              logger.info(`[Webhook] Created in-app notification for manager for booking ${booking.id}`);
            }
          }
        } catch (notifyError) {
          logger.error(`[Webhook] Error sending manager notification:`, notifyError);
        }
        try {
          const [chef] = await db.select({ username: users.username }).from(users).where(eq34(users.id, chefId)).limit(1);
          const [kitchen] = await db.select({ name: kitchens.name, locationId: kitchens.locationId }).from(kitchens).where(eq34(kitchens.id, kitchenId)).limit(1);
          if (chef && kitchen) {
            const [location] = await db.select({ name: locations.name, timezone: locations.timezone }).from(locations).where(eq34(locations.id, kitchen.locationId)).limit(1);
            const { sendEmail: sendEmail2, generateBookingRequestEmail: generateBookingRequestEmail3 } = await Promise.resolve().then(() => (init_email(), email_exports));
            const chefEmail = generateBookingRequestEmail3({
              chefEmail: chef.username,
              chefName: chef.username,
              kitchenName: kitchen.name,
              bookingDate,
              startTime,
              endTime,
              specialNotes: specialNotes || void 0,
              timezone: location?.timezone || "America/St_Johns",
              locationName: location?.name
            });
            const emailSent = await sendEmail2(chefEmail, { trackingId: `booking_${booking.id}_chef` });
            if (emailSent) {
              logger.info(`[Webhook] \u2705 Sent chef booking request email for booking ${booking.id} to ${chef.username}`);
            } else {
              logger.error(`[Webhook] \u274C Failed to send chef booking request email for booking ${booking.id} to ${chef.username}`);
            }
          } else {
            logger.warn(`[Webhook] Chef or kitchen not found for booking ${booking.id} - chef: ${!!chef}, kitchen: ${!!kitchen}`);
          }
        } catch (emailError) {
          logger.error(`[Webhook] Error sending chef email:`, emailError);
        }
      } catch (createError) {
        logger.error(`[Webhook] Error creating booking from metadata:`, createError);
      }
    } else if (paymentIntentId && metadata.booking_id && metadata.type === "kitchen_booking") {
      try {
        const bookingId = parseInt(metadata.booking_id);
        if (!isNaN(bookingId)) {
          const paymentSucceeded = expandedSession.payment_status === "paid";
          const newPaymentStatus = paymentSucceeded ? "paid" : "processing";
          await db.update(kitchenBookings).set({
            paymentIntentId,
            paymentStatus: newPaymentStatus,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(
            and21(
              eq34(kitchenBookings.id, bookingId),
              eq34(kitchenBookings.paymentStatus, "pending")
            )
          );
          logger.info(`[Webhook] Updated legacy booking ${bookingId} with paymentIntentId, paymentStatus: ${newPaymentStatus}`);
          if (paymentSucceeded) {
            try {
              const { createPaymentTransaction: createPaymentTransaction2, findPaymentTransactionByBooking: findPaymentTransactionByBooking2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
              const { getStripePaymentAmounts: getStripePaymentAmounts2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
              const [booking] = await db.select({
                id: kitchenBookings.id,
                totalPrice: kitchenBookings.totalPrice,
                serviceFee: kitchenBookings.serviceFee,
                chefId: kitchenBookings.chefId,
                kitchenId: kitchenBookings.kitchenId,
                taxRatePercent: kitchens.taxRatePercent,
                managerId: locations.managerId,
                stripeConnectAccountId: users.stripeConnectAccountId
              }).from(kitchenBookings).innerJoin(kitchens, eq34(kitchenBookings.kitchenId, kitchens.id)).innerJoin(locations, eq34(kitchens.locationId, locations.id)).leftJoin(users, eq34(locations.managerId, users.id)).where(eq34(kitchenBookings.id, bookingId)).limit(1);
              if (booking) {
                let ptRecord = await findPaymentTransactionByBooking2(bookingId, "kitchen", db);
                const stripeAmounts = await getStripePaymentAmounts2(
                  paymentIntentId,
                  booking.stripeConnectAccountId || void 0
                );
                if (ptRecord) {
                  const updateParams2 = {
                    paymentIntentId,
                    chargeId,
                    status: "succeeded",
                    stripeStatus: "succeeded",
                    paidAt: /* @__PURE__ */ new Date(),
                    lastSyncedAt: /* @__PURE__ */ new Date()
                  };
                  if (stripeAmounts) {
                    updateParams2.stripeAmount = stripeAmounts.stripeAmount;
                    updateParams2.stripeNetAmount = stripeAmounts.stripeNetAmount;
                    updateParams2.stripeProcessingFee = stripeAmounts.stripeProcessingFee;
                    updateParams2.stripePlatformFee = stripeAmounts.stripePlatformFee;
                  }
                  await updatePaymentTransaction2(ptRecord.id, updateParams2, db);
                  logger.info(`[Webhook] Updated legacy payment_transactions ${ptRecord.id} with Stripe data`);
                } else {
                  const subtotalCents = booking.totalPrice ? parseInt(String(booking.totalPrice)) : 0;
                  const serviceFeeCents = booking.serviceFee ? parseInt(String(booking.serviceFee)) : 0;
                  const taxRatePercent = booking.taxRatePercent ? Number(booking.taxRatePercent) : 0;
                  const taxCents = Math.round(subtotalCents * taxRatePercent / 100);
                  const totalAmountCents = subtotalCents + taxCents;
                  ptRecord = await createPaymentTransaction2({
                    bookingId,
                    bookingType: "kitchen",
                    chefId: booking.chefId,
                    managerId: booking.managerId,
                    amount: totalAmountCents,
                    baseAmount: subtotalCents,
                    serviceFee: serviceFeeCents,
                    managerRevenue: subtotalCents - serviceFeeCents,
                    currency: "CAD",
                    paymentIntentId,
                    chargeId,
                    status: "succeeded",
                    stripeStatus: "succeeded",
                    metadata: {
                      checkout_session_id: session.id,
                      booking_id: bookingId.toString(),
                      legacy_flow: true
                    }
                  }, db);
                  if (ptRecord && stripeAmounts) {
                    await updatePaymentTransaction2(ptRecord.id, {
                      stripeAmount: stripeAmounts.stripeAmount,
                      stripeNetAmount: stripeAmounts.stripeNetAmount,
                      stripeProcessingFee: stripeAmounts.stripeProcessingFee,
                      stripePlatformFee: stripeAmounts.stripePlatformFee,
                      paidAt: /* @__PURE__ */ new Date(),
                      lastSyncedAt: /* @__PURE__ */ new Date()
                    }, db);
                  }
                  logger.info(`[Webhook] Created legacy payment_transactions for booking ${bookingId} with Stripe fees`);
                }
              }
            } catch (ptError) {
              logger.warn(`[Webhook] Could not create/update payment_transactions for legacy booking:`, ptError);
            }
          }
        }
      } catch (bookingError) {
        logger.error(`[Webhook] Error updating legacy booking:`, bookingError);
      }
    }
  } catch (error) {
    logger.error(`[Webhook] Error handling checkout.session.completed:`, error);
    Sentry5.captureException(error, {
      tags: { component: "webhook_checkout_completed" },
      extra: { sessionId: session.id }
    });
  }
}
async function updateStorageBookingStripeIds(storageBookingId, chefId, stripeCustomerId, stripePaymentMethodId) {
  logger.info(`\u{1F512} [OFF-SESSION] updateStorageBookingStripeIds called:`, {
    storageBookingId,
    chefId,
    stripeCustomerId: stripeCustomerId || "UNDEFINED",
    stripePaymentMethodId: stripePaymentMethodId || "UNDEFINED"
  });
  logger.info(`[Webhook] Updating storage booking ${storageBookingId} with Stripe IDs:`, {
    stripeCustomerId: stripeCustomerId || "undefined",
    stripePaymentMethodId: stripePaymentMethodId || "undefined"
  });
  if (stripeCustomerId || stripePaymentMethodId) {
    try {
      await db.update(storageBookings).set({
        stripeCustomerId: stripeCustomerId || null,
        stripePaymentMethodId: stripePaymentMethodId || null,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq34(storageBookings.id, storageBookingId));
      logger.info(`[Webhook] Updated storage booking ${storageBookingId} with Stripe IDs for off-session charging`);
    } catch (updateError) {
      logger.warn(`[Webhook] Could not update storage booking with Stripe IDs:`, updateError);
    }
  }
  if (stripeCustomerId && !isNaN(chefId)) {
    try {
      await db.update(users).set({
        stripeCustomerId,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq34(users.id, chefId));
      logger.info(`[Webhook] Saved Stripe Customer ID to user ${chefId}: ${stripeCustomerId}`);
    } catch (userUpdateError) {
      logger.warn(`[Webhook] Could not save Stripe Customer ID to user:`, userUpdateError);
    }
  }
}
async function handleStorageExtensionPaymentCompleted(sessionId, paymentIntentId, chargeId, metadata, stripeCustomerId, stripePaymentMethodId, isManualCapture = false) {
  try {
    const { bookingService: bookingService2 } = await Promise.resolve().then(() => (init_booking_service(), booking_service_exports));
    const storageBookingId = parseInt(metadata.storage_booking_id);
    const newEndDate = new Date(metadata.new_end_date);
    const extensionDays = parseInt(metadata.extension_days);
    const chefId = parseInt(metadata.chef_id);
    const managerId = parseInt(metadata.manager_id);
    const extensionBasePriceCents = parseInt(metadata.extension_base_price_cents || "0");
    const extensionServiceFeeCents = parseInt(metadata.extension_service_fee_cents || "0");
    const extensionTotalPriceCents = parseInt(metadata.extension_total_price_cents || "0");
    const managerReceivesCents = parseInt(metadata.manager_receives_cents || "0");
    if (isNaN(storageBookingId) || isNaN(newEndDate.getTime()) || isNaN(extensionDays)) {
      logger.error("[Webhook] Invalid storage extension metadata:", metadata);
      return;
    }
    const existingExtension = await bookingService2.getPendingStorageExtension(
      storageBookingId,
      sessionId
    );
    if (existingExtension) {
      if (existingExtension.status === "paid" || existingExtension.status === "authorized" || existingExtension.status === "completed" || existingExtension.status === "approved") {
        logger.info(
          `[Webhook] Storage extension already processed for session ${sessionId} (status: ${existingExtension.status})`
        );
        await updateStorageBookingStripeIds(storageBookingId, chefId, stripeCustomerId, stripePaymentMethodId);
        return;
      }
      const extensionStatus = isManualCapture ? "authorized" : "paid";
      await bookingService2.updatePendingStorageExtension(existingExtension.id, {
        status: extensionStatus,
        stripePaymentIntentId: paymentIntentId
      });
      logger.info(`[Webhook] Updated existing storage extension ${existingExtension.id} to ${extensionStatus}`);
      await updateStorageBookingStripeIds(storageBookingId, chefId, stripeCustomerId, stripePaymentMethodId);
      return;
    }
    const extensionPaymentStatus = isManualCapture ? "authorized" : "paid";
    const pendingExtension = await bookingService2.createPendingStorageExtension({
      storageBookingId,
      newEndDate,
      extensionDays,
      extensionBasePriceCents,
      extensionServiceFeeCents,
      extensionTotalPriceCents,
      stripeSessionId: sessionId,
      stripePaymentIntentId: paymentIntentId,
      status: extensionPaymentStatus
    });
    logger.info(`[Webhook] Created pending_storage_extensions ${pendingExtension.id} for storage booking ${storageBookingId}`);
    await updateStorageBookingStripeIds(storageBookingId, chefId, stripeCustomerId, stripePaymentMethodId);
    try {
      const { createPaymentTransaction: createPaymentTransaction2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
      const { getStripePaymentAmounts: getStripePaymentAmounts2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
      logger.info(`[Webhook] Creating payment_transactions for storage extension with paymentIntentId: ${paymentIntentId}, chargeId: ${chargeId}`);
      const extPtStatus = isManualCapture ? "authorized" : "succeeded";
      const ptRecord = await createPaymentTransaction2({
        bookingId: storageBookingId,
        bookingType: "storage",
        chefId: isNaN(chefId) ? null : chefId,
        managerId: isNaN(managerId) ? null : managerId,
        amount: extensionTotalPriceCents,
        baseAmount: extensionBasePriceCents,
        serviceFee: extensionServiceFeeCents,
        managerRevenue: managerReceivesCents || extensionTotalPriceCents - extensionServiceFeeCents,
        currency: "CAD",
        paymentIntentId,
        // CRITICAL: Must be saved for Stripe fee syncing
        chargeId,
        // Also save charge ID
        status: extPtStatus,
        stripeStatus: extPtStatus,
        metadata: {
          checkout_session_id: sessionId,
          storage_booking_id: storageBookingId.toString(),
          storage_extension_id: pendingExtension.id.toString(),
          extension_days: extensionDays.toString(),
          new_end_date: newEndDate.toISOString(),
          // Include base price for accurate tax calculation in transaction history
          extension_base_price_cents: extensionBasePriceCents.toString()
        }
      }, db);
      if (ptRecord && paymentIntentId && !isManualCapture) {
        let managerConnectAccountId;
        if (!isNaN(managerId)) {
          try {
            const [manager] = await db.select({ stripeConnectAccountId: users.stripeConnectAccountId }).from(users).where(eq34(users.id, managerId)).limit(1);
            if (manager?.stripeConnectAccountId) {
              managerConnectAccountId = manager.stripeConnectAccountId;
            }
          } catch {
            logger.warn(`[Webhook] Could not fetch manager Connect account for storage extension`);
          }
        }
        const stripeAmounts = await getStripePaymentAmounts2(paymentIntentId, managerConnectAccountId);
        if (stripeAmounts) {
          await updatePaymentTransaction2(ptRecord.id, {
            paidAt: /* @__PURE__ */ new Date(),
            lastSyncedAt: /* @__PURE__ */ new Date(),
            stripeAmount: stripeAmounts.stripeAmount,
            stripeNetAmount: stripeAmounts.stripeNetAmount,
            stripeProcessingFee: stripeAmounts.stripeProcessingFee,
            stripePlatformFee: stripeAmounts.stripePlatformFee
          }, db);
          logger.info(`[Webhook] Updated payment_transactions with Stripe amounts for storage extension`);
        }
      }
      logger.info(`[Webhook] Created payment_transactions for storage extension ${pendingExtension.id}`);
    } catch (ptError) {
      logger.warn(`[Webhook] Could not create payment_transactions for storage extension:`, ptError);
    }
    logger.info(`[Webhook] Storage extension payment received - awaiting manager approval:`, {
      storageBookingId,
      extensionDays,
      newEndDate: newEndDate.toISOString(),
      sessionId,
      paymentIntentId,
      status: "paid"
    });
    try {
      const { sendEmail: sendEmail2, generateStorageExtensionPendingApprovalEmail: generateStorageExtensionPendingApprovalEmail2, generateStorageExtensionPaymentReceivedEmail: generateStorageExtensionPaymentReceivedEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
      const [storageBooking] = await db.select({
        storageName: storageListings.name,
        chefId: storageBookings.chefId,
        chefEmail: users.username,
        locationId: kitchens.locationId
      }).from(storageBookings).innerJoin(storageListings, eq34(storageBookings.storageListingId, storageListings.id)).innerJoin(kitchens, eq34(storageListings.kitchenId, kitchens.id)).innerJoin(users, eq34(storageBookings.chefId, users.id)).where(eq34(storageBookings.id, storageBookingId)).limit(1);
      if (storageBooking) {
        const [location] = await db.select({
          id: locations.id,
          notificationEmail: locations.notificationEmail,
          name: locations.name,
          managerId: locations.managerId
        }).from(locations).where(eq34(locations.id, storageBooking.locationId)).limit(1);
        if (location?.notificationEmail) {
          const managerEmail = generateStorageExtensionPendingApprovalEmail2({
            managerEmail: location.notificationEmail,
            chefName: storageBooking.chefEmail,
            storageName: storageBooking.storageName,
            extensionDays,
            newEndDate,
            totalPrice: extensionTotalPriceCents,
            locationName: location.name
          });
          await sendEmail2(managerEmail);
          logger.info(`[Webhook] Sent storage extension pending approval email to manager: ${location.notificationEmail}`);
        }
        const chefEmail = generateStorageExtensionPaymentReceivedEmail2({
          chefEmail: storageBooking.chefEmail,
          chefName: storageBooking.chefEmail,
          storageName: storageBooking.storageName,
          extensionDays,
          newEndDate,
          totalPrice: extensionTotalPriceCents
        });
        await sendEmail2(chefEmail);
        logger.info(`[Webhook] Sent storage extension payment received email to chef: ${storageBooking.chefEmail}`);
        if (location.managerId) {
          try {
            await notificationService.notifyManagerStorageExtensionPending({
              managerId: location.managerId,
              locationId: location.id,
              storageBookingId,
              storageName: storageBooking.storageName,
              extensionDays,
              newEndDate: typeof newEndDate === "string" ? newEndDate : new Date(newEndDate).toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" }),
              chefName: storageBooking.chefEmail
            });
            logger.info(`[Webhook] Created in-app notification for manager about storage extension`);
          } catch (notifError) {
            logger.error(`[Webhook] Error creating storage extension in-app notification:`, notifError);
          }
        }
      }
    } catch (emailError) {
      logger.error(`[Webhook] Error sending storage extension notification emails:`, emailError);
    }
  } catch (error) {
    logger.error(
      `[Webhook] Error processing storage extension payment:`,
      error
    );
  }
}
async function handlePaymentIntentSucceeded(paymentIntent, webhookEventId) {
  if (!pool) {
    logger.error("Database pool not available for webhook");
    return;
  }
  try {
    const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2, createPaymentTransaction: createPaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
    const { getStripePaymentAmounts: getStripePaymentAmounts2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
    let transaction = await findPaymentTransactionByIntentId2(
      paymentIntent.id,
      db
    );
    if (!transaction) {
      const [booking] = await db.select({
        id: kitchenBookings.id,
        chefId: kitchenBookings.chefId,
        totalPrice: kitchenBookings.totalPrice,
        serviceFee: kitchenBookings.serviceFee,
        currency: kitchenBookings.currency,
        taxRatePercent: kitchens.taxRatePercent,
        managerId: locations.managerId
      }).from(kitchenBookings).innerJoin(kitchens, eq34(kitchenBookings.kitchenId, kitchens.id)).innerJoin(locations, eq34(kitchens.locationId, locations.id)).where(eq34(kitchenBookings.paymentIntentId, paymentIntent.id)).limit(1);
      if (booking) {
        const subtotalCents = booking.totalPrice != null ? parseInt(String(booking.totalPrice)) : 0;
        const serviceFeeCents = booking.serviceFee != null ? parseInt(String(booking.serviceFee)) : 0;
        const taxRatePercent = booking.taxRatePercent != null ? Number(booking.taxRatePercent) : 0;
        const taxCents = Math.round(subtotalCents * taxRatePercent / 100);
        const totalAmountCents = subtotalCents + taxCents;
        const managerRevenueCents = Math.max(0, subtotalCents - serviceFeeCents);
        transaction = await createPaymentTransaction2({
          bookingId: booking.id,
          bookingType: "kitchen",
          chefId: booking.chefId ?? null,
          managerId: booking.managerId ?? null,
          amount: totalAmountCents,
          baseAmount: subtotalCents,
          serviceFee: serviceFeeCents,
          managerRevenue: managerRevenueCents,
          currency: (booking.currency || "CAD").toUpperCase(),
          paymentIntentId: paymentIntent.id,
          status: "succeeded",
          stripeStatus: paymentIntent.status,
          metadata: {
            createdFrom: "webhook_upsert",
            taxRatePercent,
            taxCents
          }
        }, db);
        logger.info(`[Webhook] Created payment_transactions for PaymentIntent ${paymentIntent.id} (upsert)`);
      }
    }
    if (transaction) {
      let managerConnectAccountId;
      try {
        const [manager] = await db.select({ stripeConnectAccountId: users.stripeConnectAccountId }).from(users).where(
          and21(
            eq34(users.id, transaction.manager_id),
            ne5(users.stripeConnectAccountId, "")
          )
        ).limit(1);
        if (manager?.stripeConnectAccountId) {
          managerConnectAccountId = manager.stripeConnectAccountId;
        }
      } catch (error) {
        logger.warn(`[Webhook] Could not fetch manager Connect account:`, {
          error
        });
      }
      const stripeAmounts = await getStripePaymentAmounts2(
        paymentIntent.id,
        managerConnectAccountId
      );
      const existingPtMetadata = transaction.metadata ? typeof transaction.metadata === "string" ? JSON.parse(transaction.metadata) : transaction.metadata : {};
      const mergedMetadata = {
        ...existingPtMetadata,
        stripeMetadata: paymentIntent.metadata
        // Store Stripe's metadata under a nested key
      };
      const updateParams = {
        status: "succeeded",
        stripeStatus: paymentIntent.status,
        chargeId: typeof paymentIntent.latest_charge === "string" ? paymentIntent.latest_charge : paymentIntent.latest_charge?.id,
        paidAt: /* @__PURE__ */ new Date(),
        lastSyncedAt: /* @__PURE__ */ new Date(),
        webhookEventId,
        metadata: mergedMetadata
      };
      if (stripeAmounts) {
        const isPartialCapture = paymentIntent.amount !== paymentIntent.amount_received;
        if (isPartialCapture) {
          logger.info(
            `[Webhook] PARTIAL CAPTURE detected for ${paymentIntent.id}: authorized=$${(paymentIntent.amount / 100).toFixed(2)}, captured=$${((paymentIntent.amount_received || 0) / 100).toFixed(2)}, charge.amount=$${(stripeAmounts.stripeAmount / 100).toFixed(2)}`
          );
        }
        updateParams.stripeAmount = stripeAmounts.stripeAmount;
        updateParams.stripeNetAmount = stripeAmounts.stripeNetAmount;
        updateParams.stripeProcessingFee = stripeAmounts.stripeProcessingFee;
        updateParams.stripePlatformFee = stripeAmounts.stripePlatformFee;
        logger.info(
          `[Webhook] Syncing Stripe amounts for ${paymentIntent.id}:`,
          {
            amount: `$${(stripeAmounts.stripeAmount / 100).toFixed(2)}`,
            netAmount: `$${(stripeAmounts.stripeNetAmount / 100).toFixed(2)}`,
            processingFee: `$${(stripeAmounts.stripeProcessingFee / 100).toFixed(2)}`,
            platformFee: `$${(stripeAmounts.stripePlatformFee / 100).toFixed(2)}`,
            isPartialCapture
          }
        );
      }
      await updatePaymentTransaction2(transaction.id, updateParams, db);
      logger.info(
        `[Webhook] Updated payment_transactions for PaymentIntent ${paymentIntent.id}${stripeAmounts ? " with Stripe amounts" : ""}`
      );
      if (stripeAmounts) {
        const { syncStripeAmountsToBookings: syncStripeAmountsToBookings2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
        await syncStripeAmountsToBookings2(paymentIntent.id, stripeAmounts, db);
      }
    }
    await db.transaction(async (tx) => {
      await tx.update(kitchenBookings).set({
        paymentStatus: "paid",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and21(
          eq34(kitchenBookings.paymentIntentId, paymentIntent.id),
          ne5(kitchenBookings.paymentStatus, "paid")
        )
      );
      await tx.update(storageBookings).set({
        paymentStatus: "paid",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and21(
          eq34(storageBookings.paymentIntentId, paymentIntent.id),
          ne5(storageBookings.paymentStatus, "paid"),
          ne5(storageBookings.paymentStatus, "failed")
        )
      );
      await tx.update(equipmentBookings).set({
        paymentStatus: "paid",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and21(
          eq34(equipmentBookings.paymentIntentId, paymentIntent.id),
          ne5(equipmentBookings.paymentStatus, "paid"),
          ne5(equipmentBookings.paymentStatus, "failed")
        )
      );
      await tx.update(pendingStorageExtensions).set({
        status: "paid",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and21(
          eq34(pendingStorageExtensions.stripePaymentIntentId, paymentIntent.id),
          eq34(pendingStorageExtensions.status, "authorized")
        )
      );
    });
    logger.info(
      `[Webhook] Updated booking payment status to 'paid' for PaymentIntent ${paymentIntent.id}`
    );
    try {
      const [booking] = await db.select({
        id: kitchenBookings.id,
        kitchenId: kitchenBookings.kitchenId,
        chefId: kitchenBookings.chefId,
        totalPrice: kitchenBookings.totalPrice,
        bookingDate: kitchenBookings.bookingDate,
        startTime: kitchenBookings.startTime,
        endTime: kitchenBookings.endTime
      }).from(kitchenBookings).where(eq34(kitchenBookings.paymentIntentId, paymentIntent.id)).limit(1);
      if (booking) {
        const [kitchen] = await db.select({
          id: kitchens.id,
          name: kitchens.name,
          locationId: kitchens.locationId
        }).from(kitchens).where(eq34(kitchens.id, booking.kitchenId)).limit(1);
        if (kitchen) {
          const [location] = await db.select({
            id: locations.id,
            managerId: locations.managerId,
            notificationEmail: locations.notificationEmail,
            name: locations.name
          }).from(locations).where(eq34(locations.id, kitchen.locationId)).limit(1);
          if (location && location.managerId) {
            const [chef] = await db.select({ username: users.username }).from(users).where(eq34(users.id, booking.chefId)).limit(1);
            const chefName = chef?.username || "Chef";
            await notificationService.notifyPaymentReceived({
              managerId: location.managerId,
              locationId: location.id,
              bookingId: booking.id,
              amount: paymentIntent.amount,
              currency: paymentIntent.currency.toUpperCase(),
              chefName,
              kitchenName: kitchen.name
            });
          }
        }
      }
    } catch (notifError) {
      logger.error(
        `[Webhook] Error creating payment notification:`,
        notifError
      );
    }
  } catch (error) {
    logger.error(
      `[Webhook] Error updating payment status for ${paymentIntent.id}:`,
      error
    );
  }
}
async function handlePaymentIntentFailed(paymentIntent, webhookEventId) {
  if (!pool) {
    logger.error("Database pool not available for webhook");
    return;
  }
  try {
    const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
    const transaction = await findPaymentTransactionByIntentId2(
      paymentIntent.id,
      db
    );
    if (transaction) {
      await updatePaymentTransaction2(
        transaction.id,
        {
          status: "failed",
          stripeStatus: paymentIntent.status,
          failureReason: paymentIntent.last_payment_error?.message || "Payment failed",
          lastSyncedAt: /* @__PURE__ */ new Date(),
          webhookEventId
        },
        db
      );
      logger.info(
        `[Webhook] Updated payment_transactions for PaymentIntent ${paymentIntent.id}`
      );
    }
    await db.transaction(async (tx) => {
      const excludedStatuses = ["paid", "refunded", "partially_refunded"];
      await tx.update(kitchenBookings).set({
        paymentStatus: "failed",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and21(
          eq34(kitchenBookings.paymentIntentId, paymentIntent.id),
          notInArray(kitchenBookings.paymentStatus, excludedStatuses)
        )
      );
      await tx.update(storageBookings).set({
        paymentStatus: "failed",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and21(
          eq34(storageBookings.paymentIntentId, paymentIntent.id),
          notInArray(storageBookings.paymentStatus, excludedStatuses)
        )
      );
      await tx.update(equipmentBookings).set({
        paymentStatus: "failed",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and21(
          eq34(equipmentBookings.paymentIntentId, paymentIntent.id),
          notInArray(equipmentBookings.paymentStatus, excludedStatuses)
        )
      );
    });
    logger.info(
      `[Webhook] Updated booking payment status to 'failed' for PaymentIntent ${paymentIntent.id}`
    );
    try {
      const [booking] = await db.select({
        id: kitchenBookings.id,
        kitchenId: kitchenBookings.kitchenId,
        chefId: kitchenBookings.chefId,
        totalPrice: kitchenBookings.totalPrice
      }).from(kitchenBookings).where(eq34(kitchenBookings.paymentIntentId, paymentIntent.id)).limit(1);
      if (booking) {
        const [kitchen] = await db.select({
          id: kitchens.id,
          name: kitchens.name,
          locationId: kitchens.locationId
        }).from(kitchens).where(eq34(kitchens.id, booking.kitchenId)).limit(1);
        if (kitchen) {
          const [location] = await db.select({ id: locations.id, managerId: locations.managerId }).from(locations).where(eq34(locations.id, kitchen.locationId)).limit(1);
          if (location && location.managerId) {
            const [chef] = await db.select({ username: users.username }).from(users).where(eq34(users.id, booking.chefId)).limit(1);
            await notificationService.notifyPaymentFailed({
              managerId: location.managerId,
              locationId: location.id,
              bookingId: booking.id,
              amount: paymentIntent.amount,
              currency: paymentIntent.currency.toUpperCase(),
              chefName: chef?.username || "Chef",
              kitchenName: kitchen.name,
              reason: paymentIntent.last_payment_error?.message
            });
          }
        }
      }
    } catch (notifError) {
      logger.error(
        `[Webhook] Error creating payment failed notification:`,
        notifError
      );
    }
  } catch (error) {
    logger.error(
      `[Webhook] Error updating payment status for ${paymentIntent.id}:`,
      error
    );
  }
}
async function handlePaymentIntentCanceled(paymentIntent, webhookEventId) {
  if (!pool) {
    logger.error("Database pool not available for webhook");
    return;
  }
  try {
    const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
    const transaction = await findPaymentTransactionByIntentId2(
      paymentIntent.id,
      db
    );
    if (transaction) {
      await updatePaymentTransaction2(
        transaction.id,
        {
          status: "canceled",
          stripeStatus: paymentIntent.status,
          lastSyncedAt: /* @__PURE__ */ new Date(),
          webhookEventId
        },
        db
      );
      logger.info(
        `[Webhook] Updated payment_transactions for PaymentIntent ${paymentIntent.id}`
      );
    }
    await db.transaction(async (tx) => {
      const excludedStatuses = ["paid", "refunded", "partially_refunded"];
      await tx.update(kitchenBookings).set({
        paymentStatus: "failed",
        // Map cancel to failed for backward compatibility
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and21(
          eq34(kitchenBookings.paymentIntentId, paymentIntent.id),
          notInArray(kitchenBookings.paymentStatus, excludedStatuses)
        )
      );
      await tx.update(storageBookings).set({
        paymentStatus: "failed",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and21(
          eq34(storageBookings.paymentIntentId, paymentIntent.id),
          notInArray(storageBookings.paymentStatus, excludedStatuses)
        )
      );
      await tx.update(equipmentBookings).set({
        paymentStatus: "failed",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and21(
          eq34(equipmentBookings.paymentIntentId, paymentIntent.id),
          notInArray(equipmentBookings.paymentStatus, excludedStatuses)
        )
      );
      await tx.update(pendingStorageExtensions).set({
        status: "rejected",
        rejectionReason: "Payment authorization cancelled",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and21(
          eq34(pendingStorageExtensions.stripePaymentIntentId, paymentIntent.id),
          eq34(pendingStorageExtensions.status, "authorized")
        )
      );
    });
    logger.info(
      `[Webhook] Updated booking payment status for canceled PaymentIntent ${paymentIntent.id}`
    );
  } catch (error) {
    logger.error(
      `[Webhook] Error updating payment status for ${paymentIntent.id}:`,
      error
    );
  }
}
async function handleChargeRefunded(charge, webhookEventId) {
  if (!pool) {
    logger.error("Database pool not available for webhook");
    return;
  }
  try {
    const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
    const paymentIntentId = typeof charge.payment_intent === "string" ? charge.payment_intent : charge.payment_intent?.id;
    if (!paymentIntentId) {
      logger.warn(`[Webhook] Charge ${charge.id} has no payment_intent`);
      return;
    }
    const refundAmountCents = charge.amount_refunded;
    const transaction = await findPaymentTransactionByIntentId2(
      paymentIntentId,
      db
    );
    let refundStatus;
    if (transaction) {
      const managerRevenue = parseInt(String(transaction.manager_revenue || "0")) || 0;
      const isFullRefund = refundAmountCents >= managerRevenue;
      refundStatus = isFullRefund ? "refunded" : "partially_refunded";
      await updatePaymentTransaction2(
        transaction.id,
        {
          status: refundStatus,
          refundAmount: refundAmountCents,
          refundId: charge.refunds?.data?.[0]?.id,
          refundedAt: /* @__PURE__ */ new Date(),
          lastSyncedAt: /* @__PURE__ */ new Date(),
          webhookEventId
        },
        db
      );
      logger.info(
        `[Webhook] Updated payment_transactions for refund on PaymentIntent ${paymentIntentId}`
      );
    } else {
      refundStatus = charge.amount_refunded < charge.amount ? "partially_refunded" : "refunded";
    }
    await db.transaction(async (tx) => {
      await tx.update(kitchenBookings).set({
        paymentStatus: refundStatus,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and21(
          eq34(kitchenBookings.paymentIntentId, paymentIntentId),
          eq34(kitchenBookings.paymentStatus, "paid")
        )
      );
      await tx.update(storageBookings).set({
        paymentStatus: refundStatus,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and21(
          eq34(storageBookings.paymentIntentId, paymentIntentId),
          eq34(storageBookings.paymentStatus, "paid")
        )
      );
      await tx.update(equipmentBookings).set({
        paymentStatus: refundStatus,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and21(
          eq34(equipmentBookings.paymentIntentId, paymentIntentId),
          eq34(equipmentBookings.paymentStatus, "paid")
        )
      );
    });
    logger.info(
      `[Webhook] Updated booking payment status to '${refundStatus}' for PaymentIntent ${paymentIntentId}`
    );
  } catch (error) {
    logger.error(
      `[Webhook] Error updating refund status for charge ${charge.id}:`,
      error
    );
  }
}
async function handlePayoutPaid(payout, connectedAccountId, _webhookEventId) {
  try {
    if (!connectedAccountId) {
      logger.warn(
        `[Webhook] payout.paid event received without connected account ID`
      );
      return;
    }
    const [manager] = await db.select({ id: users.id, username: users.username }).from(users).where(eq34(users.stripeConnectAccountId, connectedAccountId)).limit(1);
    if (!manager) {
      logger.warn(
        `[Webhook] payout.paid for unknown Connect account ${connectedAccountId}`
      );
      return;
    }
    const payoutAmount = (payout.amount / 100).toFixed(2);
    const arrivalDate = new Date(payout.arrival_date * 1e3).toISOString().split("T")[0];
    logger.info(`[Webhook] Payout successful for manager ${manager.id}:`, {
      payoutId: payout.id,
      amount: `$${payoutAmount} ${payout.currency.toUpperCase()}`,
      arrivalDate,
      method: payout.method,
      status: payout.status
    });
  } catch (error) {
    logger.error(`[Webhook] Error handling payout.paid:`, error);
  }
}
async function handlePayoutFailed(payout, connectedAccountId, _webhookEventId) {
  try {
    if (!connectedAccountId) {
      logger.warn(
        `[Webhook] payout.failed event received without connected account ID`
      );
      return;
    }
    const [manager] = await db.select({ id: users.id, username: users.username }).from(users).where(eq34(users.stripeConnectAccountId, connectedAccountId)).limit(1);
    if (!manager) {
      logger.warn(
        `[Webhook] payout.failed for unknown Connect account ${connectedAccountId}`
      );
      return;
    }
    const payoutAmount = (payout.amount / 100).toFixed(2);
    const failureCode = payout.failure_code || "unknown";
    const failureMessage = payout.failure_message || "Payout failed";
    logger.error(`[Webhook] Payout FAILED for manager ${manager.id}:`, {
      payoutId: payout.id,
      amount: `$${payoutAmount} ${payout.currency.toUpperCase()}`,
      failureCode,
      failureMessage,
      status: payout.status
    });
  } catch (error) {
    logger.error(`[Webhook] Error handling payout.failed:`, error);
  }
}
async function handleAccountUpdated(account, webhookEventId) {
  if (!pool) {
    logger.error("Database pool not available for webhook");
    return;
  }
  try {
    const { getAccountStatus: getAccountStatus2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
    const chargesEnabled = account.charges_enabled;
    const payoutsEnabled = account.payouts_enabled;
    const detailsSubmitted = account.details_submitted;
    const onboardingStatus = detailsSubmitted ? "complete" : "in_progress";
    const [manager] = await db.select({ id: users.id }).from(users).where(eq34(users.stripeConnectAccountId, account.id)).limit(1);
    if (manager) {
      await db.update(users).set({
        stripeConnectOnboardingStatus: onboardingStatus,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq34(users.id, manager.id));
      logger.info(
        `[Webhook] Updated onboarding status to '${onboardingStatus}' for manager ${manager.id} (Account: ${account.id})`
      );
    } else {
      logger.warn(
        `[Webhook] Received account.updated for unknown account ${account.id}`
      );
    }
  } catch (error) {
    logger.error(
      `[Webhook] Error handling account.updated for ${account.id}:`,
      error
    );
  }
}
async function handleOverstayPenaltyPaymentCompleted(sessionId, paymentIntentId, chargeId, metadata, paymentStatus) {
  try {
    const overstayRecordId = parseInt(metadata.overstayRecordId);
    const chefId = parseInt(metadata.chefId);
    const storageBookingId = parseInt(metadata.storageBookingId);
    if (isNaN(overstayRecordId)) {
      logger.error(`[Webhook] Invalid overstayRecordId in metadata:`, metadata);
      return;
    }
    if (paymentStatus !== "paid") {
      logger.info(`[Webhook] Overstay penalty payment not yet confirmed for session ${sessionId}, status: ${paymentStatus}`);
      return;
    }
    const { storageOverstayRecords: storageOverstayRecords2, storageOverstayHistory: storageOverstayHistory2, storageBookings: storageBookings2, storageListings: storageListings3, kitchens: kitchens3, locations: locations5 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
    const [overstayRecord] = await db.select().from(storageOverstayRecords2).where(eq34(storageOverstayRecords2.id, overstayRecordId)).limit(1);
    if (!overstayRecord) {
      logger.error(`[Webhook] Overstay record ${overstayRecordId} not found`);
      return;
    }
    let managerId = null;
    if (metadata.managerId) {
      managerId = parseInt(metadata.managerId) || null;
    } else {
      const [booking] = await db.select().from(storageBookings2).where(eq34(storageBookings2.id, overstayRecord.storageBookingId)).limit(1);
      if (booking) {
        const [listing] = await db.select().from(storageListings3).where(eq34(storageListings3.id, booking.storageListingId)).limit(1);
        if (listing?.kitchenId) {
          const [kitchen] = await db.select().from(kitchens3).where(eq34(kitchens3.id, listing.kitchenId)).limit(1);
          if (kitchen?.locationId) {
            const [location] = await db.select().from(locations5).where(eq34(locations5.id, kitchen.locationId)).limit(1);
            managerId = location?.managerId || null;
          }
        }
      }
    }
    const penaltyAmountCents = overstayRecord.finalPenaltyCents || overstayRecord.calculatedPenaltyCents || 0;
    await db.update(storageOverstayRecords2).set({
      status: "charge_succeeded",
      stripePaymentIntentId: paymentIntentId || null,
      stripeChargeId: chargeId || null,
      chargeSucceededAt: /* @__PURE__ */ new Date(),
      resolvedAt: /* @__PURE__ */ new Date(),
      resolutionType: "paid",
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq34(storageOverstayRecords2.id, overstayRecordId));
    await db.insert(storageOverstayHistory2).values({
      overstayRecordId,
      previousStatus: overstayRecord.status,
      newStatus: "charge_succeeded",
      eventType: "charge_attempt",
      eventSource: "stripe_webhook",
      description: `Chef paid penalty via Stripe Checkout. Session: ${sessionId}`,
      metadata: {
        sessionId,
        paymentIntentId,
        chargeId,
        chefId
      }
    });
    try {
      const { createPaymentTransaction: createPaymentTransaction2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
      const { getStripePaymentAmounts: getStripePaymentAmounts2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
      const ptRecord = await createPaymentTransaction2({
        bookingId: isNaN(storageBookingId) ? overstayRecordId : storageBookingId,
        bookingType: "storage",
        // Overstay penalties are related to storage bookings
        chefId: isNaN(chefId) ? null : chefId,
        managerId: managerId || null,
        amount: penaltyAmountCents,
        baseAmount: penaltyAmountCents,
        serviceFee: 0,
        // No service fee on penalties - full amount goes to manager
        managerRevenue: penaltyAmountCents,
        currency: "CAD",
        paymentIntentId,
        status: "succeeded",
        stripeStatus: "succeeded",
        metadata: {
          checkout_session_id: sessionId,
          type: "overstay_penalty",
          overstay_record_id: overstayRecordId.toString(),
          storage_booking_id: storageBookingId?.toString() || "",
          charge_id: chargeId || ""
        }
      }, db);
      if (ptRecord && paymentIntentId) {
        let managerConnectAccountId;
        if (managerId) {
          try {
            const [manager] = await db.select({ stripeConnectAccountId: users.stripeConnectAccountId }).from(users).where(eq34(users.id, managerId)).limit(1);
            if (manager?.stripeConnectAccountId) {
              managerConnectAccountId = manager.stripeConnectAccountId;
            }
          } catch {
            logger.warn(`[Webhook] Could not fetch manager Connect account for overstay penalty`);
          }
        }
        const stripeAmounts = await getStripePaymentAmounts2(paymentIntentId, managerConnectAccountId);
        if (stripeAmounts) {
          await updatePaymentTransaction2(ptRecord.id, {
            chargeId,
            paidAt: /* @__PURE__ */ new Date(),
            lastSyncedAt: /* @__PURE__ */ new Date(),
            stripeAmount: stripeAmounts.stripeAmount,
            stripeNetAmount: stripeAmounts.stripeNetAmount,
            stripeProcessingFee: stripeAmounts.stripeProcessingFee,
            stripePlatformFee: stripeAmounts.stripePlatformFee
          }, db);
          logger.info(`[Webhook] Synced Stripe amounts for overstay penalty ${overstayRecordId}:`, {
            amount: `$${(stripeAmounts.stripeAmount / 100).toFixed(2)}`,
            processingFee: `$${(stripeAmounts.stripeProcessingFee / 100).toFixed(2)}`
          });
        }
      }
      logger.info(`[Webhook] Created payment_transactions record for overstay penalty ${overstayRecordId}`);
    } catch (ptError) {
      logger.error(`[Webhook] Failed to create payment_transactions for overstay penalty:`, ptError);
    }
    try {
      const bookingIdToComplete = isNaN(storageBookingId) ? overstayRecord.storageBookingId : storageBookingId;
      await db.update(storageBookings2).set({ status: "completed", updatedAt: /* @__PURE__ */ new Date() }).where(eq34(storageBookings2.id, bookingIdToComplete));
      logger.info(`[Webhook] Auto-completed storage booking ${bookingIdToComplete} after overstay penalty paid via checkout`);
    } catch (completeError) {
      logger.error(`[Webhook] Failed to auto-complete booking after overstay payment:`, completeError);
    }
    logger.info(`[Webhook] \u2705 Overstay penalty payment completed`, {
      overstayRecordId,
      chefId,
      sessionId,
      paymentIntentId,
      chargeId,
      penaltyAmountCents
    });
  } catch (error) {
    logger.error(`[Webhook] Error handling overstay penalty payment:`, error);
  }
}
async function handleDamageClaimPaymentCompleted(sessionId, paymentIntentId, chargeId, metadata, paymentStatus) {
  try {
    const claimId = parseInt(metadata.damage_claim_id);
    const chefId = parseInt(metadata.chef_id);
    if (isNaN(claimId)) {
      logger.error(`[Webhook] Invalid damage_claim_id in metadata: ${metadata.damage_claim_id}`);
      return;
    }
    if (paymentStatus !== "paid") {
      logger.info(`[Webhook] Damage claim payment not yet confirmed for session ${sessionId}, status: ${paymentStatus}`);
      return;
    }
    const { damageClaims: damageClaims2, damageClaimHistory: damageClaimHistory2, users: users5 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
    const [claim] = await db.select().from(damageClaims2).where(eq34(damageClaims2.id, claimId)).limit(1);
    if (!claim) {
      logger.error(`[Webhook] Damage claim ${claimId} not found`);
      return;
    }
    const chargeAmount = claim.finalAmountCents || claim.claimedAmountCents || 0;
    await db.update(damageClaims2).set({
      status: "charge_succeeded",
      stripePaymentIntentId: paymentIntentId || null,
      stripeChargeId: chargeId || null,
      chargeSucceededAt: /* @__PURE__ */ new Date(),
      resolvedAt: /* @__PURE__ */ new Date(),
      resolutionType: "paid",
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq34(damageClaims2.id, claimId));
    await db.insert(damageClaimHistory2).values({
      damageClaimId: claimId,
      previousStatus: claim.status,
      newStatus: "charge_succeeded",
      action: "charge_attempt",
      actionBy: "stripe_webhook",
      notes: `Chef paid damage claim via Stripe Checkout. Session: ${sessionId}`,
      metadata: {
        sessionId,
        paymentIntentId,
        chargeId,
        chefId: chefId.toString()
      }
    });
    try {
      const { createPaymentTransaction: createPaymentTransaction2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
      const { getStripePaymentAmounts: getStripePaymentAmounts2 } = await Promise.resolve().then(() => (init_stripe_service(), stripe_service_exports));
      const ptRecord = await createPaymentTransaction2({
        bookingId: claim.bookingType === "storage" ? claim.storageBookingId || claimId : claim.kitchenBookingId || claimId,
        bookingType: claim.bookingType,
        chefId: isNaN(chefId) ? null : chefId,
        managerId: claim.managerId || null,
        amount: chargeAmount,
        baseAmount: chargeAmount,
        serviceFee: 0,
        managerRevenue: chargeAmount,
        currency: "CAD",
        paymentIntentId,
        status: "succeeded",
        stripeStatus: "succeeded",
        metadata: {
          checkout_session_id: sessionId,
          type: "damage_claim",
          damage_claim_id: claimId.toString(),
          charge_id: chargeId || ""
        }
      }, db);
      if (ptRecord && paymentIntentId) {
        let managerConnectAccountId;
        if (claim.managerId) {
          try {
            const [manager] = await db.select({ stripeConnectAccountId: users5.stripeConnectAccountId }).from(users5).where(eq34(users5.id, claim.managerId)).limit(1);
            if (manager?.stripeConnectAccountId) {
              managerConnectAccountId = manager.stripeConnectAccountId;
            }
          } catch {
            logger.warn(`[Webhook] Could not fetch manager Connect account for damage claim`);
          }
        }
        const stripeAmounts = await getStripePaymentAmounts2(paymentIntentId, managerConnectAccountId);
        if (stripeAmounts) {
          await updatePaymentTransaction2(ptRecord.id, {
            chargeId,
            paidAt: /* @__PURE__ */ new Date(),
            lastSyncedAt: /* @__PURE__ */ new Date(),
            stripeAmount: stripeAmounts.stripeAmount,
            stripeNetAmount: stripeAmounts.stripeNetAmount,
            stripeProcessingFee: stripeAmounts.stripeProcessingFee,
            stripePlatformFee: stripeAmounts.stripePlatformFee
          }, db);
          logger.info(`[Webhook] Synced Stripe amounts for damage claim ${claimId}:`, {
            amount: `$${(stripeAmounts.stripeAmount / 100).toFixed(2)}`,
            processingFee: `$${(stripeAmounts.stripeProcessingFee / 100).toFixed(2)}`
          });
        }
      }
      logger.info(`[Webhook] Created payment_transactions record for damage claim ${claimId}`);
    } catch (ptError) {
      logger.error(`[Webhook] Failed to create payment_transactions for damage claim:`, ptError);
    }
    logger.info(`[Webhook] \u2705 Damage claim payment completed`, {
      claimId,
      chefId,
      sessionId,
      paymentIntentId,
      chargeId,
      chargeAmount
    });
  } catch (error) {
    logger.error(`[Webhook] Error handling damage claim payment:`, error);
  }
}
async function handleChargeUpdated(charge, previousAttributes, _webhookEventId) {
  if (!pool) {
    logger.error("[Webhook] Database pool not available for charge.updated");
    return;
  }
  try {
    const balanceTransactionWasNull = previousAttributes?.balance_transaction === null;
    const balanceTransactionNowAvailable = charge.balance_transaction !== null;
    if (!balanceTransactionWasNull || !balanceTransactionNowAvailable) {
      return;
    }
    const paymentIntentId = typeof charge.payment_intent === "string" ? charge.payment_intent : charge.payment_intent?.id;
    if (!paymentIntentId) {
      logger.warn(`[Webhook] charge.updated: No payment_intent on charge ${charge.id}`);
      return;
    }
    logger.info(`[Webhook] charge.updated: balance_transaction now available for charge ${charge.id}, payment_intent ${paymentIntentId}`);
    const { findPaymentTransactionByIntentId: findPaymentTransactionByIntentId2, updatePaymentTransaction: updatePaymentTransaction2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
    const paymentTransaction = await findPaymentTransactionByIntentId2(paymentIntentId, db);
    if (!paymentTransaction) {
      logger.warn(`[Webhook] charge.updated: No payment_transaction found for ${paymentIntentId}`);
      return;
    }
    const existingFee = parseInt(String(paymentTransaction.stripe_processing_fee || "0")) || 0;
    if (existingFee > 0) {
      logger.info(`[Webhook] charge.updated: Stripe fee already synced for ${paymentIntentId}: ${existingFee} cents`);
      return;
    }
    const stripeSecretKey6 = process.env.STRIPE_SECRET_KEY;
    if (!stripeSecretKey6) {
      logger.error("[Webhook] STRIPE_SECRET_KEY not configured");
      return;
    }
    const stripe6 = new Stripe6(stripeSecretKey6, {
      apiVersion: "2025-12-15.clover"
    });
    const balanceTransactionId = typeof charge.balance_transaction === "string" ? charge.balance_transaction : charge.balance_transaction?.id;
    if (!balanceTransactionId) {
      logger.warn(`[Webhook] charge.updated: balance_transaction ID not available for charge ${charge.id}`);
      return;
    }
    const balanceTransaction = await stripe6.balanceTransactions.retrieve(balanceTransactionId);
    const stripeAmount = charge.amount;
    const stripeNetAmount = balanceTransaction.net;
    const stripeProcessingFee = balanceTransaction.fee;
    let stripePlatformFee = 0;
    if (charge.application_fee_amount) {
      stripePlatformFee = charge.application_fee_amount;
    }
    await updatePaymentTransaction2(
      paymentTransaction.id,
      {
        stripeAmount,
        stripeNetAmount,
        stripeProcessingFee,
        stripePlatformFee,
        lastSyncedAt: /* @__PURE__ */ new Date()
      },
      db
    );
    logger.info(`[Webhook] \u2705 charge.updated: Synced actual Stripe fees for ${paymentIntentId}:`, {
      amount: `$${(stripeAmount / 100).toFixed(2)}`,
      netAmount: `$${(stripeNetAmount / 100).toFixed(2)}`,
      processingFee: `$${(stripeProcessingFee / 100).toFixed(2)}`,
      platformFee: `$${(stripePlatformFee / 100).toFixed(2)}`
    });
  } catch (error) {
    logger.error(`[Webhook] Error handling charge.updated:`, error);
  }
}
var router22, webhooks_default;
var init_webhooks = __esm({
  "server/routes/webhooks.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_logger();
    init_api_response();
    init_notification_service();
    init_reference_code();
    router22 = Router22();
    router22.post("/stripe", async (req, res) => {
      logger.operational(`[Webhook] Received Stripe webhook request`);
      try {
        const sig = req.headers["stripe-signature"];
        const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
        const stripeSecretKey6 = process.env.STRIPE_SECRET_KEY;
        logger.operational(`[Webhook] Request details:`, {
          hasSignature: !!sig,
          hasWebhookSecret: !!webhookSecret,
          bodyType: typeof req.body,
          isBuffer: Buffer.isBuffer(req.body),
          bodyLength: Buffer.isBuffer(req.body) ? req.body.length : typeof req.body === "string" ? req.body.length : JSON.stringify(req.body).length
        });
        if (!stripeSecretKey6) {
          logger.error("[Webhook] STRIPE_SECRET_KEY not configured");
          return res.status(500).json({ error: "Stripe not configured" });
        }
        const stripe6 = new Stripe6(stripeSecretKey6, {
          apiVersion: "2025-12-15.clover"
        });
        if (!webhookSecret) {
          if (process.env.NODE_ENV === "production") {
            logger.error(
              "\u274C CRITICAL: STRIPE_WEBHOOK_SECRET is required in production!"
            );
            return res.status(500).json({ error: "Webhook configuration error" });
          }
          logger.warn(
            "\u26A0\uFE0F STRIPE_WEBHOOK_SECRET not configured - webhook verification disabled (development only)"
          );
        }
        let event;
        const rawBody = Buffer.isBuffer(req.body) ? req.body : typeof req.body === "string" ? req.body : JSON.stringify(req.body);
        logger.operational(`[Webhook] Raw body prepared, length: ${rawBody.length}`);
        if (webhookSecret && sig) {
          try {
            event = stripe6.webhooks.constructEvent(
              rawBody,
              sig,
              webhookSecret
            );
          } catch (err) {
            logger.error("\u26A0\uFE0F Webhook signature verification failed:", err.message);
            return res.status(400).json({ error: `Webhook Error: ${err.message}` });
          }
        } else {
          const bodyStr = Buffer.isBuffer(req.body) ? req.body.toString("utf8") : req.body;
          event = typeof bodyStr === "string" ? JSON.parse(bodyStr) : bodyStr;
          logger.warn("\u26A0\uFE0F Processing webhook without signature verification (development mode)");
        }
        const webhookEventId = event.id;
        const wLog = logger.child({ webhookEventId, eventType: event.type });
        switch (event.type) {
          case "checkout.session.completed":
            await handleCheckoutSessionCompleted(
              event.data.object,
              webhookEventId
            );
            break;
          case "payment_intent.succeeded":
            await handlePaymentIntentSucceeded(
              event.data.object,
              webhookEventId
            );
            break;
          case "payment_intent.payment_failed":
            await handlePaymentIntentFailed(
              event.data.object,
              webhookEventId
            );
            break;
          case "payment_intent.canceled":
            await handlePaymentIntentCanceled(
              event.data.object,
              webhookEventId
            );
            break;
          case "charge.refunded":
            await handleChargeRefunded(
              event.data.object,
              webhookEventId
            );
            break;
          case "charge.updated":
            await handleChargeUpdated(
              event.data.object,
              event.data.previous_attributes,
              webhookEventId
            );
            break;
          case "account.updated":
            await handleAccountUpdated(
              event.data.object,
              webhookEventId
            );
            break;
          case "payout.paid":
            await handlePayoutPaid(
              event.data.object,
              event.account,
              webhookEventId
            );
            break;
          case "payout.failed":
            await handlePayoutFailed(
              event.data.object,
              event.account,
              webhookEventId
            );
            break;
          default:
            if (event.type.startsWith("charge.")) {
              await handleChargeRefunded(
                event.data.object,
                webhookEventId
              );
            } else {
              wLog.info(`Unhandled event type: ${event.type}`);
            }
        }
        res.json({ received: true });
      } catch (err) {
        logger.error("Unhandled webhook error:", err);
        Sentry5.captureException(err, { tags: { component: "stripe_webhook" } });
        return errorResponse(res, err);
      }
    });
    router22.post("/stripe/manual-process-session", async (req, res) => {
      if (process.env.NODE_ENV === "production") {
        const adminSecret = req.headers["x-admin-secret"] || req.body.adminSecret;
        const expectedSecret = process.env.ADMIN_WEBHOOK_SECRET || process.env.STRIPE_WEBHOOK_SECRET;
        if (!adminSecret || adminSecret !== expectedSecret) {
          return res.status(403).json({ error: "Unauthorized - admin secret required" });
        }
      }
      try {
        const { sessionId } = req.body;
        if (!sessionId) {
          return res.status(400).json({ error: "sessionId is required" });
        }
        const stripeSecretKey6 = process.env.STRIPE_SECRET_KEY;
        if (!stripeSecretKey6) {
          return res.status(500).json({ error: "Stripe not configured" });
        }
        const stripe6 = new Stripe6(stripeSecretKey6, {
          apiVersion: "2025-12-15.clover"
        });
        const session = await stripe6.checkout.sessions.retrieve(sessionId, {
          expand: ["payment_intent"]
        });
        logger.info(`[Manual Webhook] Processing session ${sessionId}, payment_status: ${session.payment_status}`);
        await handleCheckoutSessionCompleted(session, `manual_${Date.now()}`);
        res.json({
          success: true,
          message: "Session processed successfully",
          sessionId,
          paymentStatus: session.payment_status,
          metadata: session.metadata
        });
      } catch (err) {
        logger.error("Error in manual session processing:", err);
        return res.status(500).json({ error: err.message });
      }
    });
    webhooks_default = router22;
  }
});

// shared/subdomain-utils.ts
function getSubdomainFromHostname(hostname) {
  if (!hostname) return null;
  const hostWithoutPort = hostname.split(":")[0];
  const parts = hostWithoutPort.split(".");
  if (hostWithoutPort === "localhost" || hostWithoutPort === "127.0.0.1") {
    return "main";
  }
  if (parts.length === 2 && parts[1] === "localhost") {
    const subdomain = parts[0].toLowerCase();
    switch (subdomain) {
      case "chef":
        return "chef";
      case "kitchen":
        return "kitchen";
      case "admin":
        return "admin";
      default:
        return "main";
    }
  }
  if (parts.length >= 3) {
    const subdomain = parts[0].toLowerCase();
    switch (subdomain) {
      case "chef":
      case "dev-chef":
        return "chef";
      case "kitchen":
      case "dev-kitchen":
        return "kitchen";
      case "admin":
      case "dev-admin":
        return "admin";
      case "dev":
        return "main";
      default:
        return null;
    }
  }
  return "main";
}
function getSubdomainFromHeaders(headers) {
  const forwardedHost = headers["x-forwarded-host"] || headers["x-vercel-deployment-url"];
  if (forwardedHost) {
    const hostname = Array.isArray(forwardedHost) ? forwardedHost[0] : forwardedHost;
    return getSubdomainFromHostname(hostname);
  }
  const host = headers["host"];
  if (host) {
    const hostname = Array.isArray(host) ? host[0] : host;
    return getSubdomainFromHostname(hostname);
  }
  return null;
}
function getRequiredSubdomainForRole(role) {
  if (!role) return null;
  switch (role.toLowerCase()) {
    case "chef":
      return "chef";
    case "manager":
      return "kitchen";
    case "admin":
      return "admin";
    default:
      return null;
  }
}
function isRoleAllowedForSubdomain(role, subdomain, isPortalUser = false, isChef = false, isManager = false) {
  if (isPortalUser && subdomain === "kitchen") {
    return true;
  }
  let effectiveRole = role;
  if (!effectiveRole) {
    if (isManager) {
      effectiveRole = "manager";
    } else if (isChef) {
      effectiveRole = "chef";
    }
  }
  const requiredSubdomain = getRequiredSubdomainForRole(effectiveRole);
  if (!requiredSubdomain) {
    return false;
  }
  return subdomain === requiredSubdomain;
}
var init_subdomain_utils = __esm({
  "shared/subdomain-utils.ts"() {
    "use strict";
  }
});

// server/routes/portal-auth.ts
var portal_auth_exports = {};
__export(portal_auth_exports, {
  default: () => portal_auth_default
});
import { Router as Router23 } from "express";
import { eq as eq35, and as and22 } from "drizzle-orm";
import * as admin from "firebase-admin";
var router23, portal_auth_default;
var init_portal_auth = __esm({
  "server/routes/portal-auth.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_schema();
    init_user_service();
    init_location_service();
    init_passwordUtils();
    init_phone_utils();
    init_subdomain_utils();
    router23 = Router23();
    router23.post("/portal-login", async (req, res) => {
      try {
        const { username, password } = req.body;
        if (!username || !password) {
          return res.status(400).json({ error: "Username and password are required" });
        }
        logger.info("Portal user login attempt for:", username);
        const portalUser = await userService.getUserByUsername(username);
        if (!portalUser) {
          logger.info("Portal user not found:", username);
          return res.status(401).json({ error: "Incorrect username or password" });
        }
        const isPortalUser = portalUser.isPortalUser || portalUser.is_portal_user;
        if (!isPortalUser) {
          logger.info("User is not a portal user:", username);
          return res.status(403).json({ error: "Not authorized - portal user access required" });
        }
        const passwordMatches = await comparePasswords(password, portalUser.password);
        if (!passwordMatches) {
          logger.info("Password mismatch for portal user:", username);
          return res.status(401).json({ error: "Incorrect username or password" });
        }
        const subdomain = getSubdomainFromHeaders(req.headers);
        const isChef = portalUser.isChef || portalUser.is_chef || false;
        const isManager = portalUser.isManager || portalUser.is_manager || false;
        if (!isRoleAllowedForSubdomain(portalUser.role, subdomain, isPortalUser || false, isChef, isManager)) {
          logger.info(`Portal user ${username} attempted login from wrong subdomain: ${subdomain}`);
          return res.status(403).json({
            error: "Access denied. Portal users must login from the kitchen subdomain.",
            requiredSubdomain: "kitchen"
          });
        }
        const uid = portalUser.firebaseUid || `portal:${portalUser.id}`;
        try {
          const customToken = await admin.auth().createCustomToken(uid, {
            role: portalUser.role,
            isPortalUser: true,
            neonUserId: portalUser.id
          });
          const getPortalUserLocation = async () => {
            try {
              const accessRecords = await db.select().from(portalUserLocationAccess).where(eq35(portalUserLocationAccess.portalUserId, portalUser.id));
              if (accessRecords.length > 0) {
                return accessRecords[0].locationId;
              }
              return null;
            } catch (error) {
              logger.error("Error fetching portal user location:", error);
              return null;
            }
          };
          const locationId = await getPortalUserLocation();
          res.json({
            token: customToken,
            user: {
              id: portalUser.id,
              username: portalUser.username,
              role: portalUser.role,
              isPortalUser: true,
              locationId
            }
          });
        } catch (tokenError) {
          logger.error("Error creating custom token:", tokenError);
          return res.status(500).json({ error: "Failed to create authentication token" });
        }
      } catch (error) {
        logger.error("Portal login error:", error);
        res.status(500).json({ error: error.message || "Portal login failed" });
      }
    });
    router23.post("/portal-register", async (req, res) => {
      logger.info("[Routes] /api/portal-register called");
      try {
        const { username, password, locationId, fullName, email, phone, company } = req.body;
        if (!username || !password || !locationId || !fullName || !email || !phone) {
          return res.status(400).json({ error: "Username, password, locationId, fullName, email, and phone are required" });
        }
        const location = await locationService.getLocationById(parseInt(locationId));
        if (!location) {
          return res.status(400).json({ error: "Location not found" });
        }
        let user = await userService.getUserByUsername(username);
        let isNewUser = false;
        if (!user) {
          const hashedPassword = await hashPassword(password);
          user = await userService.createUser({
            username,
            password: hashedPassword,
            role: "chef"
            // Default role, but portal user flag takes precedence
          });
          const updatedPortalUser = await userService.updateUser(user.id, {
            isChef: false,
            isManager: false,
            isPortalUser: true
          });
          if (updatedPortalUser) user = updatedPortalUser;
          isNewUser = true;
        } else {
          const isPortalUser = user.isPortalUser || user.is_portal_user;
          if (!isPortalUser) {
            return res.status(400).json({ error: "Username already exists with different account type" });
          }
        }
        let existingApplications = [];
        try {
          existingApplications = await db.select().from(portalUserApplications).where(
            and22(
              eq35(portalUserApplications.userId, user.id),
              eq35(portalUserApplications.locationId, parseInt(locationId))
            )
          );
        } catch (dbError) {
          logger.error("Error checking existing applications:", dbError);
          if (dbError.message && dbError.message.includes("does not exist")) {
            return res.status(500).json({
              error: "Database migration required. Please run the migration to create portal_user_applications table.",
              details: "Run: migrations/0005_add_portal_user_tables.sql"
            });
          }
          throw dbError;
        }
        if (existingApplications.length > 0) {
          const existingApp = existingApplications[0];
          if (existingApp.status === "inReview" || existingApp.status === "approved") {
            return res.status(400).json({
              error: "You already have an application for this location",
              applicationId: existingApp.id,
              status: existingApp.status
            });
          }
        }
        let application;
        try {
          const normalizedPhone = normalizePhoneForStorage(phone);
          if (!normalizedPhone) {
            return res.status(400).json({ error: "Invalid phone number format. Please enter a valid phone number." });
          }
          application = await db.insert(portalUserApplications).values({
            userId: user.id,
            locationId: parseInt(locationId),
            fullName,
            email,
            phone: normalizedPhone,
            company: company || null,
            status: "inReview"
          }).returning();
        } catch (dbError) {
          logger.error("Error creating application:", dbError);
          if (dbError.message && dbError.message.includes("does not exist")) {
            return res.status(500).json({
              error: "Database migration required. Please run the migration to create portal_user_applications table.",
              details: "Run: migrations/0005_add_portal_user_tables.sql"
            });
          }
          throw dbError;
        }
        try {
          const uid = user.firebaseUid || `portal:${user.id}`;
          const customToken = await admin.auth().createCustomToken(uid, {
            role: user.role,
            isPortalUser: true,
            neonUserId: user.id
          });
          (async () => {
            try {
              const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
              let managerEmail = location.notificationEmail || location.notification_email;
              if (!managerEmail) {
                const managerId = location.managerId || location.manager_id;
                if (managerId) {
                  const manager = await userService.getUser(managerId);
                  if (manager && manager.username) {
                    managerEmail = manager.username;
                  }
                }
              }
              if (managerEmail) {
                const emailContent = {
                  to: managerEmail,
                  subject: `New Portal User Application - ${location.name}`,
                  text: `A new portal user has applied for access to your location:

Location: ${location.name}
Applicant Name: ${fullName}
Email: ${email}
Phone: ${phone}
${company ? `Company: ${company}
` : ""}
Please log in to your manager dashboard to review and approve this application.`,
                  html: `<h2>New Portal User Application</h2><p><strong>Location:</strong> ${location.name}</p><p><strong>Applicant Name:</strong> ${fullName}</p><p><strong>Email:</strong> ${email}</p><p><strong>Phone:</strong> ${phone}</p>${company ? `<p><strong>Company:</strong> ${company}</p>` : ""}<p>Please log in to your manager dashboard to review and approve this application.</p>`
                };
                await sendEmail2(emailContent);
                logger.info(`\u2705 Portal user application notification sent to manager: ${managerEmail}`);
              } else {
                logger.info("\u26A0\uFE0F No manager email found for location - skipping email notification");
              }
            } catch (emailError) {
              logger.error("Error sending application notification email:", emailError);
            }
            res.status(201).json({
              token: customToken,
              user: {
                id: user.id,
                username: user.username,
                role: user.role,
                isPortalUser: true
              },
              application: {
                id: application[0].id,
                status: application[0].status,
                message: "Your application has been submitted. You are now logged in. The location manager will review it shortly."
              }
            });
          })();
        } catch (tokenError) {
          logger.error("Error creating token after registration:", tokenError);
          return res.status(500).json({ error: "Registration successful but login failed. Please try logging in." });
        }
      } catch (error) {
        logger.error("Portal registration error:", error);
        res.status(500).json({ error: error.message || "Portal registration failed" });
      }
    });
    portal_auth_default = router23;
  }
});

// server/routes/portal.ts
var portal_exports = {};
__export(portal_exports, {
  default: () => portal_default
});
import { Router as Router24 } from "express";
import { eq as eq36, desc as desc19 } from "drizzle-orm";
var router24, portal_default;
var init_portal = __esm({
  "server/routes/portal.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_schema();
    init_middleware();
    init_booking_service();
    init_kitchen_service();
    init_location_service();
    router24 = Router24();
    router24.get("/application-status", async (req, res) => {
      try {
        const user = await getAuthenticatedUser(req);
        if (!user) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const accessRecords = await db.select().from(portalUserLocationAccess).where(eq36(portalUserLocationAccess.portalUserId, user.id)).limit(1);
        if (accessRecords.length > 0) {
          return res.json({
            hasAccess: true,
            status: "approved"
          });
        }
        const applications4 = await db.select().from(portalUserApplications).where(eq36(portalUserApplications.userId, user.id)).orderBy(desc19(portalUserApplications.createdAt)).limit(1);
        if (applications4.length > 0) {
          const app2 = applications4[0];
          return res.json({
            hasAccess: false,
            status: app2.status,
            applicationId: app2.id,
            locationId: app2.locationId,
            awaitingApproval: app2.status === "inReview"
          });
        }
        return res.json({
          hasAccess: false,
          status: "no_application",
          awaitingApproval: false
        });
      } catch (error) {
        logger.error("Error getting portal application status:", error);
        res.status(500).json({ error: error.message || "Failed to get application status" });
      }
    });
    router24.get("/my-location", requirePortalUser, async (req, res) => {
      try {
        const userId = req.neonUser.id;
        const accessRecords = await db.select().from(portalUserLocationAccess).where(eq36(portalUserLocationAccess.portalUserId, userId)).limit(1);
        if (accessRecords.length === 0) {
          return res.status(404).json({ error: "No location assigned to this portal user" });
        }
        const locationId = accessRecords[0].locationId;
        const locationRecords = await db.select().from(locations).where(eq36(locations.id, locationId)).limit(1);
        if (locationRecords.length === 0) {
          return res.status(404).json({ error: "Location not found" });
        }
        const location = locationRecords[0];
        const slug = location.name.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
        res.json({
          id: location.id,
          name: location.name,
          address: location.address,
          logoUrl: location.logoUrl || location.logo_url || null,
          slug
        });
      } catch (error) {
        logger.error("Error fetching portal user location:", error);
        res.status(500).json({ error: error.message || "Failed to fetch location" });
      }
    });
    router24.get("/locations", requirePortalUser, async (req, res) => {
      try {
        const userId = req.neonUser.id;
        const accessRecords = await db.select().from(portalUserLocationAccess).where(eq36(portalUserLocationAccess.portalUserId, userId)).limit(1);
        if (accessRecords.length === 0) {
          return res.status(404).json({ error: "No location assigned to this portal user" });
        }
        const locationId = accessRecords[0].locationId;
        const locationRecords = await db.select().from(locations).where(eq36(locations.id, locationId)).limit(1);
        if (locationRecords.length === 0) {
          return res.status(404).json({ error: "Location not found" });
        }
        const location = locationRecords[0];
        const slug = location.name.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
        res.json([{
          id: location.id,
          name: location.name,
          address: location.address,
          logoUrl: location.logoUrl || location.logo_url || null,
          slug
        }]);
      } catch (error) {
        logger.error("Error fetching portal user location:", error);
        res.status(500).json({ error: error.message || "Failed to fetch location" });
      }
    });
    router24.get("/locations/:locationSlug", requirePortalUser, async (req, res) => {
      try {
        const userId = req.neonUser.id;
        const locationSlug = req.params.locationSlug;
        const accessRecords = await db.select().from(portalUserLocationAccess).where(eq36(portalUserLocationAccess.portalUserId, userId)).limit(1);
        if (accessRecords.length === 0) {
          return res.status(404).json({ error: "No location assigned to this portal user" });
        }
        const userLocationId = accessRecords[0].locationId;
        const locationRecords = await db.select().from(locations).where(eq36(locations.id, userLocationId)).limit(1);
        if (locationRecords.length === 0) {
          return res.status(404).json({ error: "Location not found" });
        }
        const location = locationRecords[0];
        const slug = location.name.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
        if (slug !== locationSlug) {
          return res.status(403).json({ error: "Access denied. You can only access your assigned location." });
        }
        res.json({
          id: location.id,
          name: location.name,
          address: location.address,
          logoUrl: location.logoUrl || location.logo_url || null
        });
      } catch (error) {
        logger.error("Error fetching portal location:", error);
        res.status(500).json({ error: error.message || "Failed to fetch location" });
      }
    });
    router24.get("/locations/:locationSlug/kitchens", requirePortalUser, async (req, res) => {
      try {
        const userId = req.neonUser.id;
        const locationSlug = req.params.locationSlug;
        const accessRecords = await db.select().from(portalUserLocationAccess).where(eq36(portalUserLocationAccess.portalUserId, userId)).limit(1);
        if (accessRecords.length === 0) {
          return res.status(404).json({ error: "No location assigned to this portal user" });
        }
        const userLocationId = accessRecords[0].locationId;
        const locationRecords = await db.select().from(locations).where(eq36(locations.id, userLocationId)).limit(1);
        if (locationRecords.length === 0) {
          return res.status(404).json({ error: "Location not found" });
        }
        const location = locationRecords[0];
        const slug = location.name.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
        if (slug !== locationSlug) {
          return res.status(403).json({ error: "Access denied. You can only access kitchens at your assigned location." });
        }
        const kitchensList = await kitchenService.getKitchensByLocationId(userLocationId, true);
        const publicKitchens = kitchensList.filter((kitchen) => kitchen.isActive !== false).map((kitchen) => ({
          id: kitchen.id,
          name: kitchen.name,
          description: kitchen.description,
          locationId: kitchen.locationId || kitchen.location_id
        }));
        res.json(publicKitchens);
      } catch (error) {
        logger.error("Error fetching portal kitchens:", error);
        res.status(500).json({ error: error.message || "Failed to fetch kitchens" });
      }
    });
    router24.get("/kitchens/:kitchenId/availability", requirePortalUser, async (req, res) => {
      try {
        const userId = req.neonUser.id;
        const kitchenId = parseInt(req.params.kitchenId);
        const date2 = req.query.date;
        if (isNaN(kitchenId) || kitchenId <= 0) {
          return res.status(400).json({ error: "Invalid kitchen ID" });
        }
        if (!date2) {
          return res.status(400).json({ error: "Date parameter is required" });
        }
        const accessRecords = await db.select().from(portalUserLocationAccess).where(eq36(portalUserLocationAccess.portalUserId, userId)).limit(1);
        if (accessRecords.length === 0) {
          return res.status(404).json({ error: "No location assigned to this portal user" });
        }
        const userLocationId = accessRecords[0].locationId;
        const kitchenRecords = await db.select().from(kitchens).where(eq36(kitchens.id, kitchenId)).limit(1);
        if (kitchenRecords.length === 0) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const kitchen = kitchenRecords[0];
        const kitchenLocationId = kitchen.locationId || kitchen.location_id;
        if (kitchenLocationId !== userLocationId) {
          return res.status(403).json({ error: "Access denied. You can only access kitchens at your assigned location." });
        }
        const slots = await bookingService.getAvailableSlots(kitchenId, date2);
        res.json({ slots });
      } catch (error) {
        logger.error("Error fetching portal availability:", error);
        res.status(500).json({ error: error.message || "Failed to fetch availability" });
      }
    });
    router24.post("/bookings", requirePortalUser, async (req, res) => {
      try {
        const userId = req.neonUser.id;
        const {
          locationId,
          kitchenId,
          bookingDate,
          startTime,
          endTime,
          bookingName,
          bookingEmail,
          bookingPhone,
          bookingCompany,
          specialNotes
        } = req.body;
        if (!locationId || !kitchenId || !bookingDate || !startTime || !endTime || !bookingName || !bookingEmail) {
          return res.status(400).json({ error: "Missing required fields" });
        }
        const accessRecords = await db.select().from(portalUserLocationAccess).where(eq36(portalUserLocationAccess.portalUserId, userId)).limit(1);
        if (accessRecords.length === 0) {
          return res.status(404).json({ error: "No location assigned to this portal user" });
        }
        const userLocationId = accessRecords[0].locationId;
        if (parseInt(locationId) !== userLocationId) {
          return res.status(403).json({ error: "Access denied. You can only book kitchens at your assigned location." });
        }
        const kitchenRecords = await db.select().from(kitchens).where(eq36(kitchens.id, parseInt(kitchenId))).limit(1);
        if (kitchenRecords.length === 0) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const kitchen = kitchenRecords[0];
        const kitchenLocationId = kitchen.locationId || kitchen.location_id;
        if (kitchenLocationId !== userLocationId) {
          return res.status(403).json({ error: "Access denied. You can only book kitchens at your assigned location." });
        }
        const bookingDateObj = new Date(bookingDate);
        const now = /* @__PURE__ */ new Date();
        if (bookingDateObj < now) {
          return res.status(400).json({ error: "Cannot book a time slot that has already passed" });
        }
        const availabilityCheck = await bookingService.validateBookingAvailability(
          parseInt(kitchenId),
          bookingDateObj,
          startTime,
          endTime
        );
        if (!availabilityCheck.valid) {
          return res.status(400).json({ error: availabilityCheck.error || "Time slot not available" });
        }
        const minimumBookingHours = kitchen.minimumBookingHours ?? kitchen.minimum_booking_hours ?? 0;
        if (minimumBookingHours > 0) {
          const [sH, sM] = startTime.split(":").map(Number);
          const [eH, eM] = endTime.split(":").map(Number);
          const durationHours = (eH * 60 + eM - sH * 60 - sM) / 60;
          if (durationHours < minimumBookingHours) {
            return res.status(400).json({
              error: `This kitchen requires a minimum of ${minimumBookingHours} hour${minimumBookingHours > 1 ? "s" : ""} per booking. Your booking is ${durationHours} hour${durationHours !== 1 ? "s" : ""}.`
            });
          }
        }
        const location = await locationService.getLocationById(userLocationId);
        const minimumBookingWindowHours = location?.minimumBookingWindowHours ?? 1;
        const locationTimezone = location?.timezone || "America/St_Johns";
        if (minimumBookingWindowHours > 0) {
          const bookingDateStr = typeof bookingDate === "string" ? bookingDate.split("T")[0] : bookingDateObj.toISOString().split("T")[0];
          const { isBookingTimePast: isBookingTimePast2, getHoursUntilBooking: getHoursUntilBooking2 } = await Promise.resolve().then(() => (init_date_utils(), date_utils_exports));
          if (isBookingTimePast2(bookingDateStr, startTime, locationTimezone)) {
            return res.status(400).json({ error: "Cannot book a time slot that has already passed" });
          }
          const hoursUntilBooking = getHoursUntilBooking2(bookingDateStr, startTime, locationTimezone);
          if (hoursUntilBooking < minimumBookingWindowHours) {
            return res.status(400).json({
              error: `Bookings must be made at least ${minimumBookingWindowHours} hour${minimumBookingWindowHours !== 1 ? "s" : ""} in advance`
            });
          }
        }
        const booking = await bookingService.createPortalBooking({
          kitchenId: parseInt(kitchenId),
          bookingDate: bookingDateObj,
          startTime,
          endTime,
          specialNotes: specialNotes || `Portal booking from ${bookingName}${bookingCompany ? ` (${bookingCompany})` : ""}`,
          bookingType: "portal",
          createdBy: userId,
          externalContact: {
            name: bookingName,
            email: bookingEmail,
            phone: bookingPhone || null,
            company: bookingCompany || null
          }
        });
        try {
          const { sendEmail: sendEmail2, generateBookingNotificationEmail: generateBookingNotificationEmail3, generateBookingRequestEmail: generateBookingRequestEmail3 } = await Promise.resolve().then(() => (init_email(), email_exports));
          const { sendSMS: sendSMS2, generatePortalUserBookingConfirmationSMS: generatePortalUserBookingConfirmationSMS3, generateManagerPortalBookingSMS: generateManagerPortalBookingSMS2 } = await Promise.resolve().then(() => (init_sms(), sms_exports));
          const locationData = await locationService.getLocationById(userLocationId);
          const notificationEmail = locationData?.notificationEmail;
          const timezone = locationData?.timezone || "America/St_Johns";
          const locationName = locationData?.name || "Location";
          if (notificationEmail) {
            const managerEmail = generateBookingNotificationEmail3({
              managerEmail: notificationEmail,
              chefName: bookingName,
              kitchenName: kitchen.name,
              bookingDate: bookingDateObj,
              startTime,
              endTime,
              specialNotes: specialNotes || void 0,
              timezone,
              locationName,
              bookingId: booking.id
            });
            await sendEmail2(managerEmail);
            logger.info(`\u2705 Portal booking notification email sent to manager: ${notificationEmail}`);
          }
          if (bookingEmail) {
            const portalUserEmail = generateBookingRequestEmail3({
              chefEmail: bookingEmail,
              chefName: bookingName,
              kitchenName: kitchen.name,
              bookingDate: bookingDateObj,
              startTime,
              endTime,
              specialNotes: specialNotes || void 0,
              timezone,
              locationName
            });
            await sendEmail2(portalUserEmail);
            logger.info(`\u2705 Portal booking confirmation email sent to user: ${bookingEmail}`);
          }
        } catch (error) {
          logger.error("Error sending booking notifications:", error);
        }
        res.status(201).json({
          success: true,
          booking: {
            id: booking.id,
            bookingDate,
            startTime,
            endTime,
            status: "pending"
          },
          message: "Booking submitted successfully."
        });
      } catch (error) {
        logger.error("Error creating portal booking:", error);
        res.status(500).json({ error: error.message || "Failed to create booking" });
      }
    });
    portal_default = router24;
  }
});

// server/routes/chef.ts
var chef_exports = {};
__export(chef_exports, {
  default: () => chef_default
});
import { Router as Router25 } from "express";
import { sql as sql21, eq as eq37 } from "drizzle-orm";
import { and as and23, desc as desc20 } from "drizzle-orm";
var router25, chef_default;
var init_chef = __esm({
  "server/routes/chef.ts"() {
    "use strict";
    init_logger();
    init_inventory_service();
    init_location_service();
    init_kitchen_service();
    init_user_service();
    init_middleware();
    init_db();
    init_schema();
    init_api_response();
    init_config();
    init_schema();
    router25 = Router25();
    router25.post("/stripe-connect/create", requireChef, async (req, res) => {
      logger.info("[Chef Stripe Connect] Create request received for chef:", req.neonUser?.id);
      try {
        const chefId = req.neonUser.id;
        const userResult = await db.execute(sql21`
            SELECT id, username as email, stripe_connect_account_id 
            FROM users 
            WHERE id = ${chefId} 
            LIMIT 1
        `);
        const userRow = userResult.rows ? userResult.rows[0] : userResult[0];
        if (!userRow) {
          logger.error("[Chef Stripe Connect] User not found for ID:", chefId);
          return res.status(404).json({ error: "User not found" });
        }
        const user = {
          id: userRow.id,
          email: userRow.email,
          stripeConnectAccountId: userRow.stripe_connect_account_id
        };
        const { createConnectAccount: createConnectAccount2, createAccountLink: createAccountLink2, isAccountReady: isAccountReady2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
        const baseUrl = getAppBaseUrl("chef");
        const refreshUrl = `${baseUrl}/chef/stripe-connect/refresh?role=chef`;
        const returnUrl = `${baseUrl}/chef/stripe-connect/return?success=true&role=chef`;
        if (user.stripeConnectAccountId) {
          const isReady = await isAccountReady2(user.stripeConnectAccountId);
          if (isReady) {
            return res.json({ alreadyExists: true, accountId: user.stripeConnectAccountId });
          } else {
            const link2 = await createAccountLink2(user.stripeConnectAccountId, refreshUrl, returnUrl);
            return res.json({ url: link2.url });
          }
        }
        logger.info("[Chef Stripe Connect] Creating new account for email:", user.email);
        const { accountId } = await createConnectAccount2({
          managerId: chefId,
          // Using managerId field for consistency with service
          email: user.email,
          country: "CA"
        });
        await userService.updateUser(chefId, { stripeConnectAccountId: accountId });
        const link = await createAccountLink2(accountId, refreshUrl, returnUrl);
        return res.json({ url: link.url });
      } catch (error) {
        logger.error("[Chef Stripe Connect] Error in create route:", error);
        return errorResponse(res, error);
      }
    });
    router25.get("/stripe-connect/onboarding-link", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const userResult = await db.execute(sql21`
            SELECT stripe_connect_account_id 
            FROM users 
            WHERE id = ${chefId} 
            LIMIT 1
        `);
        const userRow = userResult.rows ? userResult.rows[0] : userResult[0];
        if (!userRow?.stripe_connect_account_id) {
          return res.status(400).json({ error: "No Stripe Connect account found" });
        }
        const { createAccountLink: createAccountLink2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
        const baseUrl = getAppBaseUrl("chef");
        const refreshUrl = `${baseUrl}/chef/stripe-connect/refresh?role=chef`;
        const returnUrl = `${baseUrl}/chef/stripe-connect/return?success=true&role=chef`;
        const link = await createAccountLink2(userRow.stripe_connect_account_id, refreshUrl, returnUrl);
        return res.json({ url: link.url });
      } catch (error) {
        logger.error("[Chef Stripe Connect] Error in onboarding-link route:", error);
        return errorResponse(res, error);
      }
    });
    router25.get("/stripe-connect/dashboard-link", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const userResult = await db.execute(sql21`
            SELECT stripe_connect_account_id 
            FROM users 
            WHERE id = ${chefId} 
            LIMIT 1
        `);
        const userRow = userResult.rows ? userResult.rows[0] : userResult[0];
        if (!userRow?.stripe_connect_account_id) {
          return res.status(400).json({ error: "No Stripe Connect account found" });
        }
        const { createDashboardLoginLink: createDashboardLoginLink2, isAccountReady: isAccountReady2, createAccountLink: createAccountLink2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
        const isReady = await isAccountReady2(userRow.stripe_connect_account_id);
        if (isReady) {
          const link = await createDashboardLoginLink2(userRow.stripe_connect_account_id);
          return res.json({ url: link.url });
        } else {
          const baseUrl = getAppBaseUrl("chef");
          const refreshUrl = `${baseUrl}/chef/stripe-connect/refresh`;
          const returnUrl = `${baseUrl}/chef/stripe-connect/return?success=true`;
          const link = await createAccountLink2(userRow.stripe_connect_account_id, refreshUrl, returnUrl);
          return res.json({ url: link.url, requiresOnboarding: true });
        }
      } catch (error) {
        logger.error("[Chef Stripe Connect] Error in dashboard-link route:", error);
        return errorResponse(res, error);
      }
    });
    router25.post("/stripe-connect/sync", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const [chef] = await db.select().from(users).where(eq37(users.id, chefId)).limit(1);
        if (!chef?.stripeConnectAccountId) {
          return res.status(400).json({ error: "No Stripe account connected" });
        }
        const { getAccountStatus: getAccountStatus2 } = await Promise.resolve().then(() => (init_stripe_connect_service(), stripe_connect_service_exports));
        const status = await getAccountStatus2(chef.stripeConnectAccountId);
        const onboardingStatus = status.detailsSubmitted ? "complete" : "in_progress";
        await db.update(users).set({
          stripeConnectOnboardingStatus: onboardingStatus
        }).where(eq37(users.id, chefId));
        res.json({
          connected: true,
          accountId: chef.stripeConnectAccountId,
          status: onboardingStatus,
          details: status
        });
      } catch (error) {
        return errorResponse(res, error);
      }
    });
    router25.get("/kitchens/:kitchenId/equipment-listings", requireChef, async (req, res) => {
      try {
        const kitchenId = parseInt(req.params.kitchenId);
        if (isNaN(kitchenId) || kitchenId <= 0) {
          return res.status(400).json({ error: "Invalid kitchen ID" });
        }
        const allListings = await inventoryService.getEquipmentListingsByKitchen(kitchenId);
        const visibleListings = allListings.filter(
          (listing) => listing.isActive === true
        );
        const includedEquipment = visibleListings.filter((l) => l.availabilityType === "included");
        const rentalEquipment = visibleListings.filter((l) => l.availabilityType === "rental");
        logger.info(`[API] /api/chef/kitchens/${kitchenId}/equipment-listings (chef.ts) - Returning ${visibleListings.length} visible listings (${includedEquipment.length} included, ${rentalEquipment.length} rental)`);
        res.json({
          all: visibleListings,
          included: includedEquipment,
          rental: rentalEquipment
        });
      } catch (error) {
        logger.error("Error getting equipment listings for chef:", error);
        res.status(500).json({ error: error.message || "Failed to get equipment listings" });
      }
    });
    router25.get("/locations", requireChef, async (req, res) => {
      try {
        const allLocations = await locationService.getAllLocations();
        const activeKitchens = await kitchenService.getAllActiveKitchens();
        const locationIdsWithKitchens = new Set(
          activeKitchens.map((kitchen) => kitchen.locationId || kitchen.location_id).filter(Boolean)
        );
        const locationsWithKitchens = allLocations.filter(
          (location) => locationIdsWithKitchens.has(location.id)
        );
        logger.info(`[API] /api/chef/locations - Returning ${locationsWithKitchens.length} locations with active kitchens`);
        const { normalizeImageUrl: normalizeImageUrl2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
        const normalizedLocations = locationsWithKitchens.map((location) => ({
          ...location,
          brandImageUrl: normalizeImageUrl2(location.brandImageUrl, req),
          logoUrl: normalizeImageUrl2(location.logoUrl, req)
        }));
        res.json(normalizedLocations);
      } catch (error) {
        logger.error("Error fetching locations:", error);
        res.status(500).json({ error: "Failed to fetch locations" });
      }
    });
    router25.get("/invoices/storage/:storageBookingId", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const storageBookingId = parseInt(req.params.storageBookingId);
        if (isNaN(storageBookingId) || storageBookingId <= 0) {
          return res.status(400).json({ error: "Invalid storage booking ID" });
        }
        const { storageBookings: storageBookingsTable, storageListings: storageListings3, kitchens: kitchens3, locations: locations5 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
        const [storageBooking] = await db.select({
          id: storageBookingsTable.id,
          kitchenBookingId: storageBookingsTable.kitchenBookingId,
          storageListingId: storageBookingsTable.storageListingId,
          startDate: storageBookingsTable.startDate,
          endDate: storageBookingsTable.endDate,
          status: storageBookingsTable.status,
          totalPrice: storageBookingsTable.totalPrice,
          paymentStatus: storageBookingsTable.paymentStatus,
          paymentIntentId: storageBookingsTable.paymentIntentId,
          chefId: storageBookingsTable.chefId,
          storageName: storageListings3.name,
          storageType: storageListings3.storageType,
          kitchenId: storageListings3.kitchenId,
          kitchenName: kitchens3.name,
          locationName: locations5.name,
          locationId: locations5.id,
          taxRatePercent: kitchens3.taxRatePercent
        }).from(storageBookingsTable).innerJoin(storageListings3, eq37(storageBookingsTable.storageListingId, storageListings3.id)).innerJoin(kitchens3, eq37(storageListings3.kitchenId, kitchens3.id)).innerJoin(locations5, eq37(kitchens3.locationId, locations5.id)).where(eq37(storageBookingsTable.id, storageBookingId)).limit(1);
        if (!storageBooking) {
          return res.status(404).json({ error: "Storage booking not found" });
        }
        if (storageBooking.chefId !== chefId) {
          return res.status(403).json({ error: "Access denied to this storage booking" });
        }
        const [transaction] = await db.select({
          id: paymentTransactions.id,
          amount: paymentTransactions.amount,
          baseAmount: paymentTransactions.baseAmount,
          paymentIntentId: paymentTransactions.paymentIntentId,
          paidAt: paymentTransactions.paidAt,
          createdAt: paymentTransactions.createdAt,
          metadata: paymentTransactions.metadata,
          stripeProcessingFee: paymentTransactions.stripeProcessingFee,
          managerRevenue: paymentTransactions.managerRevenue
        }).from(paymentTransactions).where(and23(
          eq37(paymentTransactions.bookingId, storageBookingId),
          eq37(paymentTransactions.bookingType, "storage"),
          eq37(paymentTransactions.status, "succeeded")
        )).orderBy(desc20(paymentTransactions.createdAt)).limit(1);
        if (!transaction) {
          return res.status(404).json({ error: "No payment found for this storage booking" });
        }
        let extensionDetails = null;
        const metadata = transaction.metadata;
        if (metadata?.storage_extension_id) {
          const extensionId = parseInt(String(metadata.storage_extension_id));
          if (!isNaN(extensionId)) {
            const extensionResult = await db.execute(sql21`
                    SELECT 
                        pse.id,
                        pse.extension_days,
                        pse.extension_base_price_cents,
                        pse.extension_total_price_cents,
                        pse.new_end_date,
                        sl.name as storage_name,
                        sl.base_price as daily_rate_cents,
                        sl.storage_type::text as storage_type
                    FROM pending_storage_extensions pse
                    JOIN storage_bookings sb ON pse.storage_booking_id = sb.id
                    JOIN storage_listings sl ON sb.storage_listing_id = sl.id
                    WHERE pse.id = ${extensionId}
                    LIMIT 1
                `);
            const extensionRows = extensionResult.rows || extensionResult;
            if (Array.isArray(extensionRows) && extensionRows.length > 0) {
              extensionDetails = extensionRows[0];
            }
          }
        }
        let chef = null;
        const chefResult = await db.execute(sql21`
            SELECT u.id, u.username, cka.full_name
            FROM users u
            LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = u.id
            WHERE u.id = ${chefId}
            LIMIT 1
        `);
        const chefRows = chefResult.rows || chefResult;
        if (Array.isArray(chefRows) && chefRows.length > 0) {
          chef = chefRows[0];
        }
        const { generateStorageInvoicePDF: generateStorageInvoicePDF2 } = await Promise.resolve().then(() => (init_invoice_service(), invoice_service_exports));
        const pdfBuffer = await generateStorageInvoicePDF2(
          transaction,
          storageBooking,
          chef,
          extensionDetails,
          { viewer: "chef" }
        );
        res.setHeader("Content-Type", "application/pdf");
        res.setHeader("Content-Disposition", `attachment; filename="storage-invoice-${storageBookingId}.pdf"`);
        res.send(pdfBuffer);
      } catch (error) {
        logger.error("[Chef Invoice] Error downloading storage invoice:", error);
        return errorResponse(res, error);
      }
    });
    router25.get("/invoices/overstay/:overstayRecordId", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const overstayRecordId = parseInt(req.params.overstayRecordId);
        if (isNaN(overstayRecordId) || overstayRecordId <= 0) {
          return res.status(400).json({ error: "Invalid overstay record ID" });
        }
        const { storageOverstayRecords: storageOverstayRecords2, storageBookings: storageBookings2, storageListings: storageListings3, kitchens: kitchens3, locations: locations5 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
        const [overstayRecord] = await db.select({
          id: storageOverstayRecords2.id,
          storageBookingId: storageOverstayRecords2.storageBookingId,
          finalPenaltyCents: storageOverstayRecords2.finalPenaltyCents,
          calculatedPenaltyCents: storageOverstayRecords2.calculatedPenaltyCents,
          daysOverdue: storageOverstayRecords2.daysOverdue,
          chargeSucceededAt: storageOverstayRecords2.chargeSucceededAt,
          stripePaymentIntentId: storageOverstayRecords2.stripePaymentIntentId,
          stripeChargeId: storageOverstayRecords2.stripeChargeId
        }).from(storageOverstayRecords2).where(eq37(storageOverstayRecords2.id, overstayRecordId)).limit(1);
        if (!overstayRecord) {
          return res.status(404).json({ error: "Overstay record not found" });
        }
        const [storageBooking] = await db.select({
          id: storageBookings2.id,
          chefId: storageBookings2.chefId,
          startDate: storageBookings2.startDate,
          endDate: storageBookings2.endDate,
          storageListingId: storageBookings2.storageListingId
        }).from(storageBookings2).where(eq37(storageBookings2.id, overstayRecord.storageBookingId)).limit(1);
        if (!storageBooking) {
          return res.status(404).json({ error: "Storage booking not found" });
        }
        if (storageBooking.chefId !== chefId) {
          return res.status(403).json({ error: "Access denied to this overstay record" });
        }
        const [listing] = await db.select({
          id: storageListings3.id,
          name: storageListings3.name,
          storageType: storageListings3.storageType,
          kitchenId: storageListings3.kitchenId
        }).from(storageListings3).where(eq37(storageListings3.id, storageBooking.storageListingId)).limit(1);
        if (!listing) {
          return res.status(404).json({ error: "Storage listing not found" });
        }
        const [kitchen] = await db.select({
          id: kitchens3.id,
          name: kitchens3.name,
          locationId: kitchens3.locationId,
          taxRatePercent: kitchens3.taxRatePercent
        }).from(kitchens3).where(eq37(kitchens3.id, listing.kitchenId)).limit(1);
        if (!kitchen) {
          return res.status(404).json({ error: "Kitchen not found" });
        }
        const [location] = await db.select({
          id: locations5.id,
          name: locations5.name
        }).from(locations5).where(eq37(locations5.id, kitchen.locationId)).limit(1);
        const [transaction] = await db.select({
          id: paymentTransactions.id,
          amount: paymentTransactions.amount,
          baseAmount: paymentTransactions.baseAmount,
          paymentIntentId: paymentTransactions.paymentIntentId,
          paidAt: paymentTransactions.paidAt,
          createdAt: paymentTransactions.createdAt,
          metadata: paymentTransactions.metadata,
          stripeProcessingFee: paymentTransactions.stripeProcessingFee,
          managerRevenue: paymentTransactions.managerRevenue
        }).from(paymentTransactions).where(and23(
          eq37(paymentTransactions.bookingId, overstayRecord.storageBookingId),
          eq37(paymentTransactions.bookingType, "storage"),
          eq37(paymentTransactions.status, "succeeded")
        )).orderBy(desc20(paymentTransactions.createdAt)).limit(1);
        if (!transaction) {
          return res.status(404).json({ error: "No payment found for this overstay penalty" });
        }
        const metadata = transaction.metadata;
        if (!metadata || metadata.type !== "overstay_penalty") {
          return res.status(404).json({ error: "No payment transaction found for this overstay penalty" });
        }
        let chef = null;
        const chefResult = await db.execute(sql21`
            SELECT u.id, u.username, cka.full_name
            FROM users u
            LEFT JOIN chef_kitchen_applications cka ON cka.chef_id = u.id
            WHERE u.id = ${chefId}
            LIMIT 1
        `);
        const chefRows = chefResult.rows || chefResult;
        if (Array.isArray(chefRows) && chefRows.length > 0) {
          chef = chefRows[0];
        }
        const taxRatePercent = parseFloat(String(metadata.tax_rate_percent || "0")) || 0;
        const penaltyBaseCents = parseInt(String(metadata.penalty_base_cents || "0")) || 0;
        const penaltyTaxCents = parseInt(String(metadata.penalty_tax_cents || "0")) || 0;
        const baseAmount = penaltyBaseCents || parseInt(String(transaction.baseAmount || "0"));
        const totalAmount = parseInt(String(transaction.amount || "0"));
        const displayTaxAmount = penaltyTaxCents || totalAmount - baseAmount;
        const { generateStorageInvoicePDF: generateStorageInvoicePDF2 } = await Promise.resolve().then(() => (init_invoice_service(), invoice_service_exports));
        const overstayDetails = {
          is_overstay_penalty: true,
          days_overdue: overstayRecord.daysOverdue,
          penalty_base_cents: baseAmount,
          penalty_total_cents: totalAmount,
          penalty_tax_cents: displayTaxAmount,
          tax_rate_percent: taxRatePercent
        };
        const pdfBuffer = await generateStorageInvoicePDF2(
          transaction,
          {
            id: storageBooking.id,
            kitchenName: kitchen.name,
            locationName: location?.name,
            storageName: listing.name,
            taxRatePercent
          },
          chef,
          overstayDetails,
          { viewer: "chef" }
        );
        res.setHeader("Content-Type", "application/pdf");
        res.setHeader("Content-Disposition", `attachment; filename="overstay-invoice-${overstayRecordId}.pdf"`);
        res.send(pdfBuffer);
      } catch (error) {
        logger.error("[Chef Invoice] Error downloading overstay invoice:", error);
        return errorResponse(res, error);
      }
    });
    router25.get("/transactions", requireChef, async (req, res) => {
      try {
        const chefId = req.neonUser.id;
        const {
          startDate,
          endDate,
          bookingType,
          status,
          limit = "50",
          offset = "0"
        } = req.query;
        const { getChefPaymentTransactions: getChefPaymentTransactions2 } = await Promise.resolve().then(() => (init_payment_transactions_service(), payment_transactions_service_exports));
        const filters = {
          limit: parseInt(limit),
          offset: parseInt(offset)
        };
        if (startDate) {
          filters.startDate = new Date(startDate);
        }
        if (endDate) {
          filters.endDate = new Date(endDate);
        }
        if (bookingType && ["kitchen", "storage", "equipment", "bundle"].includes(bookingType)) {
          filters.bookingType = bookingType;
        }
        if (status && ["pending", "processing", "succeeded", "failed", "canceled", "refunded", "partially_refunded"].includes(status)) {
          filters.status = status;
        }
        const { transactions, total } = await getChefPaymentTransactions2(
          chefId,
          db,
          filters
        );
        const formattedTransactions = transactions.map((tx) => ({
          id: tx.id,
          bookingId: tx.booking_id,
          bookingType: tx.booking_type,
          amount: parseFloat(tx.amount || "0"),
          baseAmount: parseFloat(tx.base_amount || "0"),
          serviceFee: parseFloat(tx.service_fee || "0"),
          netAmount: parseFloat(tx.net_amount || "0"),
          refundAmount: parseFloat(tx.refund_amount || "0"),
          currency: tx.currency,
          status: tx.status,
          stripeStatus: tx.stripe_status,
          paymentIntentId: tx.payment_intent_id,
          chargeId: tx.charge_id,
          refundId: tx.refund_id,
          refundReason: tx.refund_reason,
          createdAt: tx.created_at,
          paidAt: tx.paid_at,
          refundedAt: tx.refunded_at,
          // Joined fields
          itemName: tx.item_name,
          locationName: tx.location_name,
          bookingStart: tx.booking_start,
          bookingEnd: tx.booking_end,
          referenceCode: tx.reference_code,
          // Metadata for additional context
          metadata: tx.metadata
        }));
        res.json({ transactions: formattedTransactions, total });
      } catch (error) {
        logger.error("[Chef Transactions] Error:", error);
        return errorResponse(res, error);
      }
    });
    chef_default = router25;
  }
});

// server/instrument.ts
import "dotenv/config";
import * as Sentry from "@sentry/node";
var isVercelProduction = process.env.VERCEL_ENV === "production";
var isVercel = !!process.env.VERCEL;
var sentryDsn = process.env.SENTRY_DSN;
if (sentryDsn) {
  Sentry.init({
    dsn: sentryDsn,
    // Environment tagging â€” maps to Sentry's environment filter
    environment: process.env.VERCEL_ENV || process.env.NODE_ENV || "development",
    // Release tracking â€” Vercel sets VERCEL_GIT_COMMIT_SHA automatically
    release: process.env.VERCEL_GIT_COMMIT_SHA || void 0,
    // Attach request headers + IP for user context
    sendDefaultPii: true,
    // Performance sampling â€” FREE TIER BUDGET: 10K transactions/month
    // At current traffic (~2K transactions/day), 5% production rate = ~3K/month (safe)
    // Use tracesSampler for intelligent sampling instead of flat rate
    tracesSampler(samplingContext) {
      if (samplingContext.name?.includes("sentry-test")) return 1;
      if (samplingContext.parentSampled) return 1;
      if (samplingContext.name?.includes("/webhooks/")) return 0.5;
      if (samplingContext.name?.includes("/bookings/")) return 0.2;
      if (samplingContext.name?.includes("/payment")) return 0.2;
      if (samplingContext.name?.includes("/api/")) {
        return isVercelProduction ? 0.05 : 0.2;
      }
      return isVercelProduction ? 0.05 : 0.2;
    },
    // Profiling disabled on free tier (not included)
    profilesSampleRate: 0,
    // Scrub sensitive data from breadcrumbs and events
    beforeSend(event) {
      if (event.request?.headers) {
        delete event.request.headers["authorization"];
        delete event.request.headers["cookie"];
      }
      return event;
    },
    // Filter out noisy, non-actionable errors
    ignoreErrors: [
      // Network interruptions (not bugs)
      "ECONNRESET",
      "ECONNREFUSED",
      "ETIMEDOUT",
      "EPIPE",
      // Client disconnects mid-request (serverless cold starts, browser navigations)
      "aborted",
      // Rate limiter rejections (expected behavior, not errors)
      "Too many requests"
    ],
    // Tag every event with deployment metadata
    initialScope: {
      tags: {
        "vercel.env": process.env.VERCEL_ENV || "local",
        "vercel.region": process.env.VERCEL_REGION || "unknown"
      }
    },
    // ESM loader hooks â€” only wrap packages Sentry instruments (Express, pg, HTTP)
    // Prevents import-in-the-middle from wrapping every module (performance + stability)
    registerEsmLoaderHooks: true,
    // Serverless-optimized: flush events before function timeout
    // Vercel functions have 30s max duration
    ...isVercel ? {
      enableTracing: true
    } : {}
  });
}

// server/index.ts
init_logger();
init_firebase_setup();
import "dotenv/config";
import express3 from "express";
import * as Sentry6 from "@sentry/node";

// server/firebase-routes.ts
init_logger();

// server/routes/firebase/applications.ts
init_logger();
init_schema();
init_firebase_auth_middleware();
init_fileUpload();
init_application_service();
init_domain_error();
init_phone_utils();
init_email();
import { Router } from "express";
import fs2 from "fs";
import { fromZodError } from "zod-validation-error";
var router = Router();
router.post(
  "/firebase/applications",
  requireFirebaseAuthWithUser,
  upload.fields([
    { name: "foodSafetyLicense", maxCount: 1 },
    { name: "foodEstablishmentCert", maxCount: 1 }
  ]),
  async (req, res) => {
    try {
      const userId = req.neonUser.id;
      logger.info(`\u{1F4DD} POST /api/firebase/applications - User ${userId} submitting application`);
      const { userId: _clientUserId, ...bodyWithoutUserId } = req.body;
      const parsedData = insertApplicationSchema.safeParse(bodyWithoutUserId);
      if (!parsedData.success) {
        cleanupUploadedFiles(req);
        const validationError = fromZodError(parsedData.error);
        logger.error("\u274C Validation error:", validationError.details);
        return res.status(400).json({
          error: "Validation error",
          message: validationError.message,
          details: validationError.details
        });
      }
      const applicationData = {
        userId,
        fullName: parsedData.data.fullName,
        email: parsedData.data.email,
        phone: normalizePhoneForStorage(parsedData.data.phone) || parsedData.data.phone,
        foodSafetyLicense: parsedData.data.foodSafetyLicense,
        foodEstablishmentCert: parsedData.data.foodEstablishmentCert,
        kitchenPreference: parsedData.data.kitchenPreference,
        feedback: parsedData.data.feedback,
        foodSafetyLicenseUrl: void 0,
        foodEstablishmentCertUrl: void 0
      };
      const files = req.files;
      if (files) {
        if (files.foodSafetyLicense?.[0]) {
          logger.info("\u{1F4C4} Uploading food safety license file to R2...");
          try {
            applicationData.foodSafetyLicenseUrl = await uploadToBlob(
              files.foodSafetyLicense[0],
              userId,
              "documents"
            );
            logger.info(`\u2705 Food safety license uploaded: ${applicationData.foodSafetyLicenseUrl}`);
          } catch (uploadError) {
            logger.error("\u274C Failed to upload food safety license:", uploadError);
          }
        }
        if (files.foodEstablishmentCert?.[0]) {
          logger.info("\u{1F4C4} Uploading food establishment cert file to R2...");
          try {
            applicationData.foodEstablishmentCertUrl = await uploadToBlob(
              files.foodEstablishmentCert[0],
              userId,
              "documents"
            );
            logger.info(`\u2705 Food establishment cert uploaded: ${applicationData.foodEstablishmentCertUrl}`);
          } catch (uploadError) {
            logger.error("\u274C Failed to upload food establishment cert:", uploadError);
          }
        }
      }
      if (req.body.foodSafetyLicenseUrl && !applicationData.foodSafetyLicenseUrl) {
        applicationData.foodSafetyLicenseUrl = req.body.foodSafetyLicenseUrl;
      }
      if (req.body.foodEstablishmentCertUrl && !applicationData.foodEstablishmentCertUrl) {
        applicationData.foodEstablishmentCertUrl = req.body.foodEstablishmentCertUrl;
      }
      const application = await applicationService.submitApplication(applicationData);
      logger.info("\u2705 Application created successfully:", {
        id: application.id,
        userId: application.userId,
        hasDocuments: !!(application.foodSafetyLicenseUrl || application.foodEstablishmentCertUrl)
      });
      await sendApplicationEmail(application);
      res.status(201).json(application);
    } catch (error) {
      logger.error("\u274C Error creating application:", error);
      cleanupUploadedFiles(req);
      if (error instanceof DomainError) {
        return res.status(error.statusCode).json({
          error: error.code,
          message: error.message
        });
      }
      res.status(500).json({
        error: "INTERNAL_ERROR",
        message: "Failed to submit application"
      });
    }
  }
);
router.patch(
  "/firebase/applications/:id/documents",
  requireFirebaseAuthWithUser,
  upload.fields([
    { name: "foodSafetyLicense", maxCount: 1 },
    { name: "foodEstablishmentCert", maxCount: 1 }
  ]),
  async (req, res) => {
    try {
      const applicationId = parseInt(req.params.id);
      const userId = req.neonUser.id;
      if (isNaN(applicationId)) {
        return res.status(400).json({ error: "Invalid application ID" });
      }
      logger.info(`\u{1F4DD} PATCH /api/firebase/applications/${applicationId}/documents - User ${userId}`);
      const application = await applicationService.getApplicationById(applicationId);
      if (application.userId !== userId) {
        return res.status(403).json({ error: "Access denied" });
      }
      if (application.status === "cancelled" || application.status === "rejected") {
        return res.status(400).json({
          error: "Document uploads are not permitted for cancelled or rejected applications"
        });
      }
      const files = req.files;
      const updates = {};
      if (files) {
        if (files.foodSafetyLicense?.[0]) {
          logger.info("\u{1F4C4} Uploading food safety license file to R2...");
          try {
            updates.foodSafetyLicenseUrl = await uploadToBlob(
              files.foodSafetyLicense[0],
              userId,
              "documents"
            );
            logger.info(`\u2705 Food safety license uploaded: ${updates.foodSafetyLicenseUrl}`);
          } catch (uploadError) {
            logger.error("\u274C Failed to upload food safety license:", uploadError);
            return res.status(500).json({ error: "Failed to upload food safety license" });
          }
        }
        if (files.foodEstablishmentCert?.[0]) {
          logger.info("\u{1F4C4} Uploading food establishment cert file to R2...");
          try {
            updates.foodEstablishmentCertUrl = await uploadToBlob(
              files.foodEstablishmentCert[0],
              userId,
              "documents"
            );
            logger.info(`\u2705 Food establishment cert uploaded: ${updates.foodEstablishmentCertUrl}`);
          } catch (uploadError) {
            logger.error("\u274C Failed to upload food establishment cert:", uploadError);
            return res.status(500).json({ error: "Failed to upload food establishment cert" });
          }
        }
      }
      if (req.body.foodSafetyLicenseUrl && !updates.foodSafetyLicenseUrl) {
        updates.foodSafetyLicenseUrl = req.body.foodSafetyLicenseUrl;
      }
      if (req.body.foodEstablishmentCertUrl && !updates.foodEstablishmentCertUrl) {
        updates.foodEstablishmentCertUrl = req.body.foodEstablishmentCertUrl;
      }
      if (Object.keys(updates).length === 0) {
        return res.status(400).json({ error: "No documents provided for update" });
      }
      const updatedApplication = await applicationService.updateDocuments(applicationId, updates);
      logger.info("\u2705 Application documents updated:", {
        id: updatedApplication.id,
        foodSafetyLicenseUrl: updatedApplication.foodSafetyLicenseUrl,
        foodEstablishmentCertUrl: updatedApplication.foodEstablishmentCertUrl
      });
      res.json(updatedApplication);
    } catch (error) {
      logger.error("\u274C Error updating application documents:", error);
      cleanupUploadedFiles(req);
      if (error instanceof DomainError) {
        return res.status(error.statusCode).json({
          error: error.code,
          message: error.message
        });
      }
      res.status(500).json({
        error: "INTERNAL_ERROR",
        message: "Failed to update application documents"
      });
    }
  }
);
router.patch(
  "/firebase/applications/:id/cancel",
  requireFirebaseAuthWithUser,
  async (req, res) => {
    try {
      const applicationId = parseInt(req.params.id);
      const userId = req.neonUser.id;
      if (isNaN(applicationId)) {
        return res.status(400).json({ error: "Invalid application ID" });
      }
      logger.info(`\u{1F4DD} PATCH /api/firebase/applications/${applicationId}/cancel - User ${userId}`);
      const updatedApplication = await applicationService.cancelApplication(applicationId, userId);
      logger.info("\u2705 Application cancelled:", { id: updatedApplication.id });
      try {
        if (updatedApplication.email) {
          const emailContent = generateStatusChangeEmail({
            fullName: updatedApplication.fullName || "Applicant",
            email: updatedApplication.email,
            status: "cancelled"
          });
          await sendEmail(emailContent, {
            trackingId: `cancel_${updatedApplication.id}_${Date.now()}`
          });
        }
      } catch (emailError) {
        logger.error("Error sending cancellation email:", emailError);
      }
      res.json(updatedApplication);
    } catch (error) {
      logger.error("\u274C Error cancelling application:", error);
      if (error instanceof DomainError) {
        return res.status(error.statusCode).json({
          error: error.code,
          message: error.message
        });
      }
      res.status(500).json({
        error: "INTERNAL_ERROR",
        message: "Failed to cancel application"
      });
    }
  }
);
function cleanupUploadedFiles(req) {
  if (req.files) {
    const files = req.files;
    Object.values(files).flat().forEach((file) => {
      try {
        if (file.path) {
          fs2.unlinkSync(file.path);
        }
      } catch (e) {
        logger.error("Error cleaning up file:", e);
      }
    });
  }
}
async function sendApplicationEmail(application) {
  try {
    if (!application.email) return;
    const hasDocuments = !!(application.foodSafetyLicenseUrl || application.foodEstablishmentCertUrl);
    if (hasDocuments) {
      const emailContent = generateApplicationWithDocumentsEmail({
        fullName: application.fullName || "Applicant",
        email: application.email
      });
      await sendEmail(emailContent, {
        trackingId: `app_with_docs_${application.id}_${Date.now()}`
      });
    } else {
      const emailContent = generateApplicationWithoutDocumentsEmail({
        fullName: application.fullName || "Applicant",
        email: application.email
      });
      await sendEmail(emailContent, {
        trackingId: `app_no_docs_${application.id}_${Date.now()}`
      });
    }
  } catch (emailError) {
    logger.error("Error sending application email:", emailError);
  }
}
var applicationsRouter = router;

// server/routes/firebase/admin-email.ts
init_logger();
init_firebase_auth_middleware();
init_db();
init_schema();
import { Router as Router2 } from "express";
import { and as and5, isNotNull, ne } from "drizzle-orm";
var router2 = Router2();
router2.post("/admin/send-company-email", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
  try {
    logger.info(`\u{1F525} POST /api/admin/send-company-email - Firebase UID: ${req.firebaseUser?.uid}, Neon User ID: ${req.neonUser?.id}`);
    const {
      emailType = "general",
      // 'promotional', 'general', 'announcement', 'newsletter'
      emailMode,
      recipients,
      promoCode,
      // Optional for non-promotional emails
      promoCodeLabel,
      message,
      customMessage,
      greeting,
      subject,
      previewText,
      header,
      footer,
      orderButton,
      usageSteps,
      emailContainer,
      dividers,
      promoCodeStyling,
      promoStyle,
      sections,
      customDesign
    } = req.body;
    const messageContent = customMessage || message;
    if (!messageContent || messageContent.length < 10) {
      logger.info("\u{1F525} Company email request - Invalid message:", {
        customMessage: customMessage?.substring(0, 50),
        message: message?.substring(0, 50),
        messageLength: messageContent?.length
      });
      return res.status(400).json({ error: "Message content is required (minimum 10 characters)" });
    }
    if (emailType === "promotional" && !promoCode) {
      logger.info("\u{1F525} Company email request - Missing promo code for promotional email");
      return res.status(400).json({ error: "Promo code is required for promotional emails" });
    }
    let targetEmails = [];
    if (emailMode === "all") {
      try {
        const result = await db.select({ email: users.username }).from(users).where(
          and5(
            isNotNull(users.username),
            ne(users.username, "")
          )
        );
        targetEmails = result.map((row) => row.email);
      } catch (error) {
        logger.error("\u{1F525} Error fetching user emails:", error);
        return res.status(500).json({ error: "Failed to fetch user emails" });
      }
    } else if (emailMode === "custom" && recipients) {
      const customEmails = recipients.split(",").map((email) => email.trim()).filter((email) => email.length > 0);
      targetEmails = customEmails;
    } else {
      return res.status(400).json({ error: "Invalid email mode or recipients" });
    }
    if (targetEmails.length === 0) {
      logger.info("\u{1F525} Company email request - No valid email addresses provided");
      return res.status(400).json({ error: "At least one email address is required" });
    }
    logger.info(`\u{1F525} Admin ${req.neonUser?.username} sending ${emailType} email to ${targetEmails.length} recipient(s)`);
    const { sendEmail: sendEmail2, generatePromoCodeEmail: generatePromoCodeEmail3 } = await Promise.resolve().then(() => (init_email(), email_exports));
    const results = [];
    let successCount = 0;
    let failureCount = 0;
    for (const targetEmail of targetEmails) {
      try {
        const emailContent = generatePromoCodeEmail3({
          email: targetEmail,
          promoCode,
          promoCodeLabel: promoCodeLabel || "\u{1F381} Special Offer Code For You",
          customMessage: messageContent,
          greeting: greeting || "Hello! \u{1F44B}",
          subject: subject || `\u{1F381} Special Offer: ${promoCode}`,
          previewText,
          header: header || {
            title: "Special Offer Just For You!",
            subtitle: "Don't miss out on this exclusive deal"
          },
          footer,
          orderButton: orderButton || {
            text: "\u{1F31F} Start Shopping Now",
            url: "https://localcooks.ca"
          },
          usageSteps: usageSteps || {
            enabled: true,
            title: "\u{1F680} How to use your offer:",
            steps: [
              `Visit our website: <a href="https://localcooks.ca" style="color: #1d4ed8;">https://localcooks.ca</a>`,
              "Browse our amazing local cooks and their delicious offerings",
              promoCode ? "Apply your promo code during checkout" : "Complete your order",
              "Enjoy your special offer!"
            ]
          },
          emailContainer: emailContainer || {
            maxWidth: "600px",
            backgroundColor: "#f1f5f9",
            borderRadius: "12px",
            boxShadow: "0 4px 20px rgba(0,0,0,0.08)",
            opacity: "1"
          },
          dividers,
          promoCodeStyling,
          promoStyle: promoStyle || { colorTheme: "green", borderStyle: "dashed" },
          sections
        });
        const emailSent = await sendEmail2(emailContent, {
          trackingId: `promo_email_${targetEmail}_${Date.now()}`
        });
        if (emailSent) {
          logger.info(`\u{1F525} ${emailType} email sent successfully to ${targetEmail}`);
          results.push({ email: targetEmail, status: "success" });
          successCount++;
        } else {
          logger.error(`\u{1F525} Failed to send ${emailType} email to ${targetEmail}`);
          results.push({ email: targetEmail, status: "failed", error: "Email sending failed" });
          failureCount++;
        }
      } catch (error) {
        logger.error(`\u{1F525} Error sending ${emailType} email to ${targetEmail}:`, error);
        results.push({ email: targetEmail, status: "failed", error: error instanceof Error ? error.message : "Unknown error" });
        failureCount++;
      }
    }
    if (successCount > 0) {
      res.json({
        success: true,
        message: `${emailType} emails sent: ${successCount} successful, ${failureCount} failed`,
        emailType,
        results,
        summary: {
          total: targetEmails.length,
          successful: successCount,
          failed: failureCount
        }
      });
    } else {
      res.status(500).json({
        error: "All email sending failed",
        message: `Failed to send ${emailType} emails to any recipients.`,
        results
      });
    }
  } catch (error) {
    logger.error("\u{1F525} Error sending company email:", error);
    res.status(500).json({
      error: "Internal server error",
      message: error instanceof Error ? error.message : "Unknown error occurred"
    });
  }
});
router2.post("/admin/send-promo-email", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
  try {
    logger.info(`\u{1F525} POST /api/admin/send-promo-email - Firebase UID: ${req.firebaseUser?.uid}, Neon User ID: ${req.neonUser?.id}`);
    const {
      email,
      customEmails,
      emailMode,
      promoCode,
      customMessage,
      message,
      promoCodeLabel,
      greeting,
      recipientType,
      designSystem,
      isPremium,
      sections,
      orderButton,
      header,
      footer,
      usageSteps,
      emailContainer,
      subject,
      previewText,
      promoStyle,
      promoCodeStyling,
      buttonText,
      orderUrl
    } = req.body;
    const messageContent = customMessage || message;
    if (emailMode === "custom") {
      if (!customEmails || !Array.isArray(customEmails) || customEmails.length === 0) {
        logger.info("Promo email request - Missing custom emails");
        return res.status(400).json({ error: "At least one email address is required" });
      }
    } else {
      if (!email) {
        logger.info("Promo email request - Missing email");
        return res.status(400).json({ error: "Email is required" });
      }
    }
    if (promoCode && promoCode.length > 0 && promoCode.length < 3) {
      logger.info("\u{1F525} Promo email request - Invalid promo code length");
      return res.status(400).json({ error: "Promo code must be at least 3 characters long if provided" });
    }
    if (!messageContent || messageContent.length < 10) {
      logger.info("Promo email request - Invalid message:", {
        customMessage: customMessage?.substring(0, 50),
        message: message?.substring(0, 50),
        messageContent: messageContent?.substring(0, 50)
      });
      return res.status(400).json({ error: "Message must be at least 10 characters" });
    }
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (emailMode === "custom") {
      for (const customEmail of customEmails) {
        if (!emailRegex.test(customEmail)) {
          return res.status(400).json({
            error: "Invalid email",
            message: `Please provide a valid email address: ${customEmail}`
          });
        }
      }
    } else {
      if (!emailRegex.test(email)) {
        return res.status(400).json({
          error: "Invalid email",
          message: "Please provide a valid email address"
        });
      }
    }
    if (promoCode && promoCode.length > 0 && (promoCode.length < 3 || promoCode.length > 50)) {
      return res.status(400).json({
        error: "Invalid promo code",
        message: "Promo code must be between 3 and 50 characters"
      });
    }
    if (messageContent.length > 1e3) {
      return res.status(400).json({
        error: "Invalid message",
        message: "Message must be less than 1000 characters"
      });
    }
    const targetEmails = emailMode === "custom" ? customEmails : [email];
    logger.info(`\u{1F525} Admin ${req.neonUser?.username} sending promo email to ${targetEmails.length} recipient(s) with code: ${promoCode}`);
    const { sendEmail: sendEmail2, generatePromoCodeEmail: generatePromoCodeEmail3 } = await Promise.resolve().then(() => (init_email(), email_exports));
    const results = [];
    let successCount = 0;
    let failureCount = 0;
    for (const targetEmail of targetEmails) {
      try {
        const emailContent = generatePromoCodeEmail3({
          email: targetEmail,
          promoCode: promoCode.trim(),
          customMessage: messageContent.trim(),
          greeting,
          promoStyle: promoStyle || { colorTheme: "green", borderStyle: "dashed" },
          promoCodeStyling,
          designSystem,
          isPremium: isPremium || false,
          sections: sections || [],
          orderButton: orderButton || {
            text: buttonText || "Get Started",
            url: orderUrl || "https://localcooks.ca",
            styling: {
              backgroundColor: "#F51042",
              color: "#ffffff",
              fontSize: "16px",
              fontWeight: "600",
              padding: "12px 24px",
              borderRadius: "8px",
              textAlign: "center"
            }
          },
          header: header || {
            title: "Local Cooks Header",
            subtitle: "Premium Quality Food Subheader",
            styling: {
              backgroundColor: "linear-gradient(135deg, #F51042 0%, #FF5470 100%)",
              titleColor: "#ffffff",
              subtitleColor: "#ffffff",
              titleFontSize: "32px",
              subtitleFontSize: "18px",
              padding: "24px",
              borderRadius: "0px",
              textAlign: "center"
            }
          },
          footer: footer || {
            mainText: "Thank you for being part of the Local Cooks community!",
            contactText: "Questions? Contact us at support@localcooks.com",
            copyrightText: "\xA9 2024 Local Cooks. All rights reserved.",
            showContact: true,
            showCopyright: true,
            styling: {
              backgroundColor: "#f8fafc",
              textColor: "#64748b",
              linkColor: "#F51042",
              fontSize: "14px",
              padding: "24px 32px",
              textAlign: "center",
              borderColor: "#e2e8f0"
            }
          },
          usageSteps: usageSteps || {
            title: "\u{1F680} How to use your promo code:",
            steps: [
              `Visit our website: <a href="${orderUrl || "https://localcooks.ca"}" style="color: #1d4ed8;">${orderUrl || "https://localcooks.ca"}</a>`,
              "Browse our amazing local cooks and their delicious offerings",
              "Apply your promo code during checkout",
              "Enjoy your special offer!"
            ],
            enabled: true,
            styling: {
              backgroundColor: "linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)",
              borderColor: "#93c5fd",
              titleColor: "#1d4ed8",
              textColor: "#1e40af",
              linkColor: "#1d4ed8",
              padding: "20px",
              borderRadius: "8px"
            }
          },
          emailContainer: emailContainer || {
            maxWidth: "600px",
            backgroundColor: "#f1f5f9",
            borderRadius: "12px",
            boxShadow: "0 4px 20px rgba(0,0,0,0.08)"
          },
          dividers: {
            enabled: true,
            style: "solid",
            color: "#e2e8f0",
            thickness: "1px",
            margin: "24px 0",
            opacity: "1"
          },
          subject,
          previewText,
          promoCodeLabel
        });
        const emailSent = await sendEmail2(emailContent, {
          trackingId: `promo_custom_${targetEmail}_${promoCode}_${Date.now()}`
        });
        if (emailSent) {
          logger.info(`\u{1F525} Promo email sent successfully to ${targetEmail} with code ${promoCode}`);
          results.push({ email: targetEmail, status: "success" });
          successCount++;
        } else {
          logger.error(`\u{1F525} Failed to send promo email to ${targetEmail}`);
          results.push({ email: targetEmail, status: "failed", error: "Email sending failed" });
          failureCount++;
        }
      } catch (error) {
        logger.error(`\u{1F525} Error sending promo email to ${targetEmail}:`, error);
        results.push({ email: targetEmail, status: "failed", error: error instanceof Error ? error.message : "Unknown error" });
        failureCount++;
      }
    }
    if (successCount > 0) {
      return res.status(200).json({
        message: `Promo code emails sent: ${successCount} successful, ${failureCount} failed`,
        results,
        promoCode,
        sentBy: req.neonUser?.username,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        summary: {
          total: targetEmails.length,
          successful: successCount,
          failed: failureCount
        }
      });
    } else {
      return res.status(500).json({
        error: "All email sending failed",
        message: "Failed to send promo code emails to any recipients.",
        results
      });
    }
  } catch (error) {
    logger.error("\u{1F525} Error sending promo email:", error);
    return res.status(500).json({
      error: "Internal server error",
      message: "An error occurred while sending the promo code email"
    });
  }
});
router2.post("/admin/test-promo-email", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
  try {
    logger.info(`\u{1F525} POST /api/admin/test-promo-email - Firebase UID: ${req.firebaseUser?.uid}, Neon User ID: ${req.neonUser?.id}`);
    const {
      email,
      promoCode,
      customMessage,
      message,
      promoCodeLabel,
      greeting,
      designSystem,
      isPremium,
      sections,
      orderButton,
      header,
      footer,
      usageSteps,
      emailContainer,
      subject,
      previewText,
      promoStyle,
      promoCodeStyling
    } = req.body;
    const messageContent = customMessage || message;
    logger.info(`\u{1F525} Admin ${req.neonUser?.username} testing promo email`);
    const { sendEmail: sendEmail2, generatePromoCodeEmail: generatePromoCodeEmail3 } = await Promise.resolve().then(() => (init_email(), email_exports));
    const emailContent = generatePromoCodeEmail3({
      email: email || "test@example.com",
      promoCode: promoCode || "TEST20",
      customMessage: messageContent || "This is a test promo code email from the admin panel. Thank you for being an amazing customer!",
      greeting,
      promoStyle: promoStyle || { colorTheme: "green", borderStyle: "dashed" },
      promoCodeStyling,
      designSystem,
      isPremium: isPremium || false,
      sections: sections || [],
      orderButton,
      header: header || {
        title: "Local Cooks Header",
        subtitle: "Premium Quality Food Subheader",
        styling: {
          backgroundColor: "linear-gradient(135deg, #F51042 0%, #FF5470 100%)",
          titleColor: "#ffffff",
          subtitleColor: "#ffffff",
          titleFontSize: "32px",
          subtitleFontSize: "18px",
          padding: "24px",
          borderRadius: "0px",
          textAlign: "center"
        }
      },
      footer: footer || {
        mainText: "Thank you for being part of the Local Cooks community!",
        contactText: "Questions? Contact us at support@localcooks.com",
        copyrightText: "\xA9 2024 Local Cooks. All rights reserved.",
        showContact: true,
        showCopyright: true,
        styling: {
          backgroundColor: "#f8fafc",
          textColor: "#64748b",
          linkColor: "#F51042",
          fontSize: "14px",
          padding: "24px 32px",
          textAlign: "center",
          borderColor: "#e2e8f0"
        }
      },
      usageSteps: usageSteps || {
        title: "\u{1F680} How to use your promo code:",
        steps: [
          'Visit our website: <a href="https://localcooks.ca" style="color: #1d4ed8;">https://localcooks.ca</a>',
          "Browse our amazing local cooks and their delicious offerings",
          "Apply your promo code during checkout",
          "Enjoy your special offer!"
        ],
        enabled: true,
        styling: {
          backgroundColor: "linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)",
          borderColor: "#93c5fd",
          titleColor: "#1d4ed8",
          textColor: "#1e40af",
          linkColor: "#1d4ed8",
          padding: "20px",
          borderRadius: "8px"
        }
      },
      emailContainer: emailContainer || {
        maxWidth: "600px",
        backgroundColor: "#f1f5f9",
        borderRadius: "12px",
        boxShadow: "0 4px 20px rgba(0,0,0,0.08)"
      },
      dividers: {
        enabled: true,
        style: "solid",
        color: "#e2e8f0",
        thickness: "1px",
        margin: "24px 0",
        opacity: "1"
      },
      subject,
      previewText,
      promoCodeLabel
    });
    const emailSent = await sendEmail2(emailContent, {
      trackingId: `test_promo_custom_${email || "test"}_${Date.now()}`
    });
    if (emailSent) {
      return res.status(200).json({
        message: "Test promo email sent successfully",
        email: email || "test@example.com",
        promoCode: promoCode || "TEST20"
      });
    } else {
      return res.status(500).json({
        error: "Test email failed",
        message: "Failed to send test promo email"
      });
    }
  } catch (error) {
    logger.error("\u{1F525} Error sending test promo email:", error);
    return res.status(500).json({
      error: "Internal server error",
      message: "An error occurred while testing promo email"
    });
  }
});
router2.post(
  "/admin/preview-promo-email",
  requireFirebaseAuthWithUser,
  requireAdmin,
  async (req, res) => {
    try {
      logger.info(`\u{1F525} POST /api/admin/preview-promo-email - Firebase UID: ${req.firebaseUser?.uid}, Neon User ID: ${req.neonUser?.id}`);
      const {
        promoCode,
        customMessage,
        message,
        promoCodeLabel,
        greeting,
        designSystem,
        isPremium,
        sections,
        orderButton,
        header,
        footer,
        usageSteps,
        emailContainer,
        subject,
        previewText,
        promoStyle,
        promoCodeStyling,
        buttonText,
        orderUrl
      } = req.body;
      const messageContent = customMessage || message;
      if (!promoCode || !messageContent) {
        return res.status(400).json({
          error: "Missing required fields",
          message: "Promo code and message are required for preview"
        });
      }
      logger.info(`\u{1F525} Admin ${req.neonUser?.username} previewing promo email`);
      const { generatePromoCodeEmail: generatePromoCodeEmail3 } = await Promise.resolve().then(() => (init_email(), email_exports));
      const emailContent = generatePromoCodeEmail3({
        email: "preview@example.com",
        // Dummy email for preview
        promoCode: promoCode.trim(),
        customMessage: messageContent.trim(),
        message: messageContent.trim(),
        // Also pass as message for compatibility
        greeting,
        promoStyle: promoStyle || { colorTheme: "green", borderStyle: "dashed" },
        promoCodeStyling,
        designSystem,
        isPremium: isPremium || false,
        sections: sections || [],
        orderButton: orderButton || {
          text: buttonText || "Get Started",
          url: orderUrl || "https://localcooks.ca",
          styling: {
            backgroundColor: "#F51042",
            color: "#ffffff",
            fontSize: "16px",
            fontWeight: "600",
            padding: "12px 24px",
            borderRadius: "8px",
            textAlign: "center"
          }
        },
        header: header || {
          title: "Local Cooks Header",
          subtitle: "Premium Quality Food Subheader",
          styling: {
            backgroundColor: "linear-gradient(135deg, #F51042 0%, #FF5470 100%)",
            titleColor: "#ffffff",
            subtitleColor: "#ffffff",
            titleFontSize: "32px",
            subtitleFontSize: "18px",
            padding: "24px",
            borderRadius: "0px",
            textAlign: "center"
          }
        },
        footer: footer || {
          mainText: "Thank you for being part of the Local Cooks community!",
          contactText: "Questions? Contact us at support@localcooks.com",
          copyrightText: "\xA9 2024 Local Cooks. All rights reserved.",
          showContact: true,
          showCopyright: true,
          styling: {
            backgroundColor: "#f8fafc",
            textColor: "#64748b",
            linkColor: "#F51042",
            fontSize: "14px",
            padding: "24px 32px",
            textAlign: "center",
            borderColor: "#e2e8f0"
          }
        },
        usageSteps: usageSteps || {
          title: "\u{1F680} How to use your promo code:",
          steps: [
            `Visit our website: <a href="${orderUrl || "https://localcooks.ca"}" style="color: #1d4ed8;">${orderUrl || "https://localcooks.ca"}</a>`,
            "Browse our amazing local cooks and their delicious offerings",
            "Apply your promo code during checkout",
            "Enjoy your special offer!"
          ],
          enabled: true,
          styling: {
            backgroundColor: "linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)",
            borderColor: "#93c5fd",
            titleColor: "#1d4ed8",
            textColor: "#1e40af",
            linkColor: "#1d4ed8",
            padding: "20px",
            borderRadius: "8px"
          }
        },
        emailContainer: emailContainer || {
          maxWidth: "600px",
          backgroundColor: "#f1f5f9",
          borderRadius: "12px",
          boxShadow: "0 4px 20px rgba(0,0,0,0.08)"
        },
        dividers: {
          enabled: true,
          style: "solid",
          color: "#e2e8f0",
          thickness: "1px",
          margin: "24px 0",
          opacity: "1"
        },
        subject,
        previewText,
        promoCodeLabel
      });
      res.setHeader("Content-Type", "text/html");
      return res.status(200).send(emailContent.html || "<p>No HTML content generated</p>");
    } catch (error) {
      logger.error("\u{1F525} Error generating promo email preview:", error);
      return res.status(500).json({
        error: "Internal server error",
        message: "An error occurred while generating email preview"
      });
    }
  }
);
var adminEmailRouter = router2;

// server/routes/firebase/dashboard.ts
init_logger();
init_firebase_auth_middleware();
init_application_service();
init_microlearning_service();
import { Router as Router3 } from "express";
var router3 = Router3();
router3.get("/firebase/dashboard", requireFirebaseAuthWithUser, async (req, res) => {
  try {
    const userId = req.neonUser.id;
    const firebaseUid = req.firebaseUser.uid;
    const [applications4, microlearningProgress] = await Promise.all([
      applicationService.getApplicationsByUserId(userId),
      microlearningService.getUserProgress(userId)
    ]);
    res.json({
      user: {
        id: userId,
        username: req.neonUser.username,
        role: req.neonUser.role,
        firebaseUid
      },
      applications: applications4,
      microlearningProgress
    });
  } catch (error) {
    logger.error("Error getting dashboard data:", error);
    res.status(500).json({ error: "Failed to get dashboard data" });
  }
});
router3.get("/firebase/applications/my", requireFirebaseAuthWithUser, async (req, res) => {
  try {
    const userId = req.neonUser.id;
    logger.info(`\u{1F4CB} GET /api/firebase/applications/my - User ${userId}`);
    const applications4 = await applicationService.getApplicationsByUserId(userId);
    const transformed = applications4.map((app2) => ({
      ...app2,
      // Add snake_case aliases for legacy frontend compatibility
      user_id: app2.userId,
      full_name: app2.fullName,
      created_at: app2.createdAt,
      food_safety_license: app2.foodSafetyLicense,
      food_safety_license_url: app2.foodSafetyLicenseUrl
    }));
    res.json(transformed);
  } catch (error) {
    logger.error("Error getting user applications:", error);
    res.status(500).json({ error: "Failed to get applications" });
  }
});
var dashboardRouter = router3;

// server/routes/firebase/media.ts
init_fileUpload();
init_firebase_auth_middleware();
import { Router as Router4 } from "express";

// server/upload-handler.ts
init_logger();
init_fileUpload();
init_r2_storage();
import fs3 from "fs";
async function handleFileUpload(req, res) {
  try {
    const userId = req.neonUser?.id || req.user?.id;
    if (!userId) {
      if (req.file && req.file.path) {
        try {
          fs3.unlinkSync(req.file.path);
        } catch (e) {
          logger.error("Error cleaning up file:", e);
        }
      }
      res.status(401).json({ error: "Not authenticated" });
      return;
    }
    if (!req.file) {
      res.status(400).json({ error: "No file uploaded" });
      return;
    }
    let fileUrl;
    let fileName;
    const folder = req.file.fieldname === "profileImage" ? "profiles" : req.file.fieldname === "image" ? "images" : "documents";
    const r2Available = isR2Configured();
    logger.info(`\u{1F4E6} handleFileUpload: R2 configured = ${r2Available}`);
    if (r2Available) {
      try {
        logger.info(`\u2601\uFE0F Uploading to Cloudflare R2 (folder: ${folder})...`);
        fileUrl = await uploadToBlob(req.file, userId, folder);
        fileName = fileUrl.split("/").pop() || req.file.originalname;
        logger.info(`\u2705 R2 upload complete: ${fileUrl}`);
      } catch (error) {
        logger.error("\u274C Error uploading to R2:", error);
        if (req.file.path) {
          try {
            fs3.unlinkSync(req.file.path);
          } catch (e) {
            logger.error("Error cleaning up file:", e);
          }
        }
        res.status(500).json({
          error: "File upload failed",
          details: "Failed to upload file to cloud storage"
        });
        return;
      }
    } else {
      logger.info(`\u{1F4C1} R2 not configured, using local storage`);
      fileUrl = getFileUrl(req.file.filename || `${userId}_${Date.now()}_${req.file.originalname}`);
      fileName = req.file.filename || req.file.originalname;
    }
    res.status(200).json({
      success: true,
      url: fileUrl,
      fileName,
      size: req.file.size,
      type: req.file.mimetype
    });
  } catch (error) {
    logger.error("File upload error:", error);
    if (req.file && req.file.path) {
      try {
        fs3.unlinkSync(req.file.path);
      } catch (e) {
        logger.error("Error cleaning up file:", e);
      }
    }
    res.status(500).json({
      error: "File upload failed",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
}

// server/routes/firebase/media.ts
var router4 = Router4();
var handleUpload = [
  upload.single("file"),
  requireFirebaseAuthWithUser,
  handleFileUpload
];
router4.post("/upload", ...handleUpload);
router4.post("/firebase/upload-file", ...handleUpload);
var mediaRouter = router4;

// server/routes/firebase/health.ts
import { Router as Router5 } from "express";
var router5 = Router5();
router5.get("/firebase-health", (req, res) => {
  res.json({
    status: "OK",
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    message: "Firebase Auth \u2192 Neon DB bridge is working",
    architecture: "Stateless JWT - No Sessions Required",
    auth: {
      firebaseConfigured: !!process.env.FIREBASE_PROJECT_ID,
      neonConfigured: !!process.env.DATABASE_URL,
      sessionFree: true
    }
  });
});
var healthRouter = router5;

// server/routes/firebase/platform.ts
init_logger();
init_firebase_auth_middleware();
init_db();
init_schema();
import { Router as Router6 } from "express";
import { eq as eq10 } from "drizzle-orm";
var router6 = Router6();
router6.get("/platform-settings/stripe-fees", async (req, res) => {
  try {
    const { getFeeConfig: getFeeConfig2 } = await Promise.resolve().then(() => (init_stripe_checkout_fee_service(), stripe_checkout_fee_service_exports));
    const config = await getFeeConfig2();
    return res.json({
      stripePercentageFee: config.stripePercentageFee,
      stripeFlatFeeCents: config.stripeFlatFeeCents,
      platformCommissionRate: config.platformCommissionRate,
      useStripePlatformPricing: config.useStripePlatformPricing,
      // Human-readable values
      stripePercentageDisplay: `${(config.stripePercentageFee * 100).toFixed(1)}%`,
      stripeFlatFeeDisplay: `$${(config.stripeFlatFeeCents / 100).toFixed(2)}`,
      platformCommissionDisplay: `${(config.platformCommissionRate * 100).toFixed(1)}%`
    });
  } catch (error) {
    logger.error("Error getting Stripe fee config:", error);
    return res.json({
      stripePercentageFee: 0.029,
      stripeFlatFeeCents: 30,
      platformCommissionRate: 0,
      useStripePlatformPricing: false,
      stripePercentageDisplay: "2.9%",
      stripeFlatFeeDisplay: "$0.30",
      platformCommissionDisplay: "0%"
    });
  }
});
router6.get("/platform-settings/service-fee-rate", async (req, res) => {
  try {
    const [setting] = await db.select().from(platformSettings).where(eq10(platformSettings.key, "service_fee_rate")).limit(1);
    if (setting) {
      const rate = parseFloat(setting.value);
      if (!isNaN(rate) && rate >= 0 && rate <= 1) {
        return res.json({
          key: "service_fee_rate",
          value: setting.value,
          rate,
          percentage: (rate * 100).toFixed(2),
          description: setting.description
        });
      }
    }
    return res.json({
      key: "service_fee_rate",
      value: "0.05",
      rate: 0.05,
      percentage: "5.00",
      description: "Platform service fee rate as decimal (e.g., 0.05 for 5%). Admin configurable."
    });
  } catch (error) {
    logger.error("Error getting service fee rate:", error);
    res.status(500).json({
      error: "Failed to get service fee rate",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router6.get("/admin/platform-settings/service-fee-rate", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
  try {
    const [setting] = await db.select().from(platformSettings).where(eq10(platformSettings.key, "service_fee_rate")).limit(1);
    if (setting) {
      const rate = parseFloat(setting.value);
      if (!isNaN(rate) && rate >= 0 && rate <= 1) {
        return res.json({
          key: "service_fee_rate",
          value: setting.value,
          rate,
          percentage: (rate * 100).toFixed(2),
          description: setting.description,
          updatedAt: setting.updatedAt
        });
      }
    }
    return res.json({
      key: "service_fee_rate",
      value: "0.05",
      rate: 0.05,
      percentage: "5.00",
      description: "Platform service fee rate as decimal (e.g., 0.05 for 5%). Admin configurable."
    });
  } catch (error) {
    logger.error("Error getting service fee rate:", error);
    res.status(500).json({
      error: "Failed to get service fee rate",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router6.put("/admin/platform-settings/service-fee-rate", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
  try {
    const { rate } = req.body;
    if (rate === void 0 || rate === null) {
      return res.status(400).json({ error: "Rate is required" });
    }
    const rateValue = typeof rate === "string" ? parseFloat(rate) : rate;
    if (isNaN(rateValue) || rateValue < 0 || rateValue > 1) {
      return res.status(400).json({ error: "Rate must be a number between 0 and 1 (e.g., 0.05 for 5%)" });
    }
    const userId = req.neonUser.id;
    if (!userId) {
      return res.status(401).json({ error: "User not authenticated" });
    }
    const [existing] = await db.select().from(platformSettings).where(eq10(platformSettings.key, "service_fee_rate")).limit(1);
    if (existing) {
      const [updated] = await db.update(platformSettings).set({
        value: rateValue.toString(),
        updatedBy: userId,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq10(platformSettings.key, "service_fee_rate")).returning();
      return res.json({
        key: "service_fee_rate",
        value: updated.value,
        rate: rateValue,
        percentage: (rateValue * 100).toFixed(2),
        description: updated.description,
        updatedAt: updated.updatedAt,
        message: "Service fee rate updated successfully"
      });
    } else {
      const [created] = await db.insert(platformSettings).values({
        key: "service_fee_rate",
        value: rateValue.toString(),
        description: "Platform service fee rate as decimal (e.g., 0.05 for 5%). Admin configurable.",
        updatedBy: userId
      }).returning();
      return res.json({
        key: "service_fee_rate",
        value: created.value,
        rate: rateValue,
        percentage: (rateValue * 100).toFixed(2),
        description: created.description,
        updatedAt: created.updatedAt,
        message: "Service fee rate created successfully"
      });
    }
  } catch (error) {
    logger.error("Error updating service fee rate:", error);
    res.status(500).json({
      error: "Failed to update service fee rate",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router6.get("/platform-settings/overstay-penalties", async (req, res) => {
  try {
    const [gracePeriodSetting] = await db.select().from(platformSettings).where(eq10(platformSettings.key, "overstay_grace_period_days")).limit(1);
    const [penaltyRateSetting] = await db.select().from(platformSettings).where(eq10(platformSettings.key, "overstay_penalty_rate")).limit(1);
    const [maxDaysSetting] = await db.select().from(platformSettings).where(eq10(platformSettings.key, "overstay_max_penalty_days")).limit(1);
    const gracePeriodDays = gracePeriodSetting ? parseInt(gracePeriodSetting.value) : 3;
    const penaltyRate = penaltyRateSetting ? parseFloat(penaltyRateSetting.value) : 0.1;
    const maxPenaltyDays = maxDaysSetting ? parseInt(maxDaysSetting.value) : 30;
    return res.json({
      gracePeriodDays,
      penaltyRate,
      maxPenaltyDays,
      penaltyRatePercent: (penaltyRate * 100).toFixed(0),
      description: "Platform default overstay penalty settings. Managers can override per storage listing."
    });
  } catch (error) {
    logger.error("Error getting overstay penalty defaults:", error);
    return res.json({
      gracePeriodDays: 3,
      penaltyRate: 0.1,
      maxPenaltyDays: 30,
      penaltyRatePercent: "10",
      description: "Platform default overstay penalty settings. Managers can override per storage listing."
    });
  }
});
router6.get("/admin/platform-settings/overstay-penalties", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
  try {
    const [gracePeriodSetting] = await db.select().from(platformSettings).where(eq10(platformSettings.key, "overstay_grace_period_days")).limit(1);
    const [penaltyRateSetting] = await db.select().from(platformSettings).where(eq10(platformSettings.key, "overstay_penalty_rate")).limit(1);
    const [maxDaysSetting] = await db.select().from(platformSettings).where(eq10(platformSettings.key, "overstay_max_penalty_days")).limit(1);
    return res.json({
      gracePeriodDays: {
        key: "overstay_grace_period_days",
        value: gracePeriodSetting?.value || "3",
        intValue: gracePeriodSetting ? parseInt(gracePeriodSetting.value) : 3,
        description: "Default grace period before penalties apply (days)",
        updatedAt: gracePeriodSetting?.updatedAt
      },
      penaltyRate: {
        key: "overstay_penalty_rate",
        value: penaltyRateSetting?.value || "0.10",
        decimalValue: penaltyRateSetting ? parseFloat(penaltyRateSetting.value) : 0.1,
        percentValue: penaltyRateSetting ? (parseFloat(penaltyRateSetting.value) * 100).toFixed(0) : "10",
        description: "Default penalty rate as decimal (e.g., 0.10 for 10%)",
        updatedAt: penaltyRateSetting?.updatedAt
      },
      maxPenaltyDays: {
        key: "overstay_max_penalty_days",
        value: maxDaysSetting?.value || "30",
        intValue: maxDaysSetting ? parseInt(maxDaysSetting.value) : 30,
        description: "Default maximum days penalties can accrue",
        updatedAt: maxDaysSetting?.updatedAt
      }
    });
  } catch (error) {
    logger.error("Error getting overstay penalty settings:", error);
    res.status(500).json({ error: "Failed to get overstay penalty settings" });
  }
});
router6.put("/admin/platform-settings/overstay-penalties", requireFirebaseAuthWithUser, requireAdmin, async (req, res) => {
  try {
    const { gracePeriodDays, penaltyRate, maxPenaltyDays } = req.body;
    const userId = req.neonUser.id;
    if (!userId) {
      return res.status(401).json({ error: "User not authenticated" });
    }
    const results = {};
    if (gracePeriodDays !== void 0) {
      const days = parseInt(gracePeriodDays);
      if (isNaN(days) || days < 0 || days > 14) {
        return res.status(400).json({ error: "Grace period must be between 0 and 14 days" });
      }
      const [existing] = await db.select().from(platformSettings).where(eq10(platformSettings.key, "overstay_grace_period_days")).limit(1);
      if (existing) {
        const [updated] = await db.update(platformSettings).set({ value: days.toString(), updatedBy: userId, updatedAt: /* @__PURE__ */ new Date() }).where(eq10(platformSettings.key, "overstay_grace_period_days")).returning();
        results.gracePeriodDays = { value: days, updated: true };
      } else {
        await db.insert(platformSettings).values({ key: "overstay_grace_period_days", value: days.toString(), description: "Default grace period before penalties apply (days)", updatedBy: userId });
        results.gracePeriodDays = { value: days, created: true };
      }
    }
    if (penaltyRate !== void 0) {
      const rate = typeof penaltyRate === "string" ? parseFloat(penaltyRate) : penaltyRate;
      if (isNaN(rate) || rate < 0 || rate > 0.5) {
        return res.status(400).json({ error: "Penalty rate must be between 0 and 0.50 (0% to 50%)" });
      }
      const [existing] = await db.select().from(platformSettings).where(eq10(platformSettings.key, "overstay_penalty_rate")).limit(1);
      if (existing) {
        const [updated] = await db.update(platformSettings).set({ value: rate.toString(), updatedBy: userId, updatedAt: /* @__PURE__ */ new Date() }).where(eq10(platformSettings.key, "overstay_penalty_rate")).returning();
        results.penaltyRate = { value: rate, percent: (rate * 100).toFixed(0), updated: true };
      } else {
        await db.insert(platformSettings).values({ key: "overstay_penalty_rate", value: rate.toString(), description: "Default penalty rate as decimal (e.g., 0.10 for 10%)", updatedBy: userId });
        results.penaltyRate = { value: rate, percent: (rate * 100).toFixed(0), created: true };
      }
    }
    if (maxPenaltyDays !== void 0) {
      const days = parseInt(maxPenaltyDays);
      if (isNaN(days) || days < 1 || days > 90) {
        return res.status(400).json({ error: "Max penalty days must be between 1 and 90" });
      }
      const [existing] = await db.select().from(platformSettings).where(eq10(platformSettings.key, "overstay_max_penalty_days")).limit(1);
      if (existing) {
        const [updated] = await db.update(platformSettings).set({ value: days.toString(), updatedBy: userId, updatedAt: /* @__PURE__ */ new Date() }).where(eq10(platformSettings.key, "overstay_max_penalty_days")).returning();
        results.maxPenaltyDays = { value: days, updated: true };
      } else {
        await db.insert(platformSettings).values({ key: "overstay_max_penalty_days", value: days.toString(), description: "Default maximum days penalties can accrue", updatedBy: userId });
        results.maxPenaltyDays = { value: days, created: true };
      }
    }
    return res.json({
      message: "Overstay penalty defaults updated successfully",
      results
    });
  } catch (error) {
    logger.error("Error updating overstay penalty defaults:", error);
    res.status(500).json({ error: "Failed to update overstay penalty defaults" });
  }
});
var platformRouter = router6;

// server/routes/firebase/kitchen-applications.ts
init_logger();
init_fileUpload();
init_firebase_auth_middleware();
init_db();
init_schema();
import { Router as Router7 } from "express";
import { fromZodError as fromZodError2 } from "zod-validation-error";

// server/domains/applications/chef-application.service.ts
init_logger();
init_db();
init_schema();
import { eq as eq11, and as and7, desc as desc6, inArray as inArray3, getTableColumns } from "drizzle-orm";
var ChefApplicationService = class {
  /**
   * Get all applications for a specific location (Manager view)
   */
  async getApplicationsByLocation(locationId) {
    try {
      return await db.select({
        ...getTableColumns(chefKitchenApplications),
        chef: {
          id: users.id,
          username: users.username,
          role: users.role
          // Not selecting fullName/email if not guaranteed on users table
        }
      }).from(chefKitchenApplications).leftJoin(users, eq11(chefKitchenApplications.chefId, users.id)).where(eq11(chefKitchenApplications.locationId, locationId)).orderBy(desc6(chefKitchenApplications.createdAt));
    } catch (error) {
      logger.error("[ChefApplicationService] Error fetching applications by location:", error);
      throw error;
    }
  }
  /**
   * Get applications for a specific chef (Chef view)
   */
  async getChefApplications(chefId) {
    try {
      const apps = await db.select({
        ...getTableColumns(chefKitchenApplications),
        location: {
          id: locations.id,
          name: locations.name,
          address: locations.address,
          managerId: locations.managerId
          // city not explicitly in schema snippet I saw, omit to be safe or check if needed
        }
      }).from(chefKitchenApplications).leftJoin(locations, eq11(chefKitchenApplications.locationId, locations.id)).where(eq11(chefKitchenApplications.chefId, chefId)).orderBy(desc6(chefKitchenApplications.createdAt));
      return apps.map((app2) => ({
        ...app2,
        locationName: app2.location?.name,
        locationAddress: app2.location?.address,
        location: app2.location
        // Ensure full location object is passed
      }));
    } catch (error) {
      logger.error("[ChefApplicationService] Error fetching chef applications:", error);
      throw error;
    }
  }
  /**
   * Update application status
   */
  async updateApplicationStatus(applicationId, status, feedback, reviewedBy) {
    try {
      const [updatedApp] = await db.update(chefKitchenApplications).set({
        status,
        feedback,
        reviewedBy,
        reviewedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq11(chefKitchenApplications.id, applicationId)).returning();
      return updatedApp;
    } catch (error) {
      logger.error("[ChefApplicationService] Error updating application status:", error);
      throw error;
    }
  }
  /**
   * Grant location access to a chef
   */
  async grantLocationAccess(chefId, locationId, grantedBy) {
    try {
      const existingAccess = await db.select().from(chefLocationAccess).where(and7(
        eq11(chefLocationAccess.chefId, chefId),
        eq11(chefLocationAccess.locationId, locationId)
      )).limit(1);
      if (existingAccess.length > 0) {
        return existingAccess[0];
      }
      const [newAccess] = await db.insert(chefLocationAccess).values({
        chefId,
        locationId,
        grantedBy
      }).returning();
      return newAccess;
    } catch (error) {
      logger.error("[ChefApplicationService] Error granting location access:", error);
      if (error.code === "23505") return null;
      throw error;
    }
  }
  /**
   * Get a specific application for a chef at a location
   */
  async getChefApplication(chefId, locationId) {
    try {
      const [application] = await db.select().from(chefKitchenApplications).where(and7(
        eq11(chefKitchenApplications.chefId, chefId),
        eq11(chefKitchenApplications.locationId, locationId)
      )).limit(1);
      return application;
    } catch (error) {
      logger.error("[ChefApplicationService] Error fetching chef application:", error);
      throw error;
    }
  }
  /**
   * Get all applications for a manager across their locations
   */
  async getApplicationsForManager(managerId) {
    try {
      const managedLocations = await db.select({ id: locations.id }).from(locations).where(eq11(locations.managerId, managerId));
      if (managedLocations.length === 0) return [];
      const locationIds = managedLocations.map((l) => l.id);
      return await db.select({
        ...getTableColumns(chefKitchenApplications),
        chef: {
          id: users.id,
          username: users.username,
          role: users.role
          // Using safe fields
        },
        location: {
          id: locations.id,
          name: locations.name,
          address: locations.address
        }
      }).from(chefKitchenApplications).leftJoin(users, eq11(chefKitchenApplications.chefId, users.id)).leftJoin(locations, eq11(chefKitchenApplications.locationId, locations.id)).where(inArray3(chefKitchenApplications.locationId, locationIds)).orderBy(desc6(chefKitchenApplications.createdAt));
    } catch (error) {
      logger.error("[ChefApplicationService] Error fetching manager applications:", error);
      throw error;
    }
  }
  /**
   * Get approved kitchens for a chef
   */
  async getApprovedKitchens(chefId) {
    try {
      const approvedApps = await db.select({
        applicationId: chefKitchenApplications.id,
        locationId: chefKitchenApplications.locationId,
        approvedAt: chefKitchenApplications.updatedAt,
        location: {
          id: locations.id,
          name: locations.name,
          address: locations.address,
          logoUrl: locations.logoUrl,
          brandImageUrl: locations.brandImageUrl,
          managerId: locations.managerId
        }
      }).from(chefKitchenApplications).leftJoin(locations, eq11(chefKitchenApplications.locationId, locations.id)).where(and7(
        eq11(chefKitchenApplications.chefId, chefId),
        eq11(chefKitchenApplications.status, "approved")
      ));
      return approvedApps.filter((app2) => app2.location).map((app2) => ({
        id: app2.location.id,
        name: app2.location.name,
        address: app2.location.address,
        logoUrl: app2.location.logoUrl,
        brandImageUrl: app2.location.brandImageUrl,
        applicationId: app2.applicationId,
        approvedAt: app2.approvedAt,
        locationId: app2.locationId,
        managerId: app2.location.managerId
      }));
    } catch (error) {
      logger.error("[ChefApplicationService] Error fetching approved kitchens:", error);
      throw error;
    }
  }
  /**
   * Get detailed status for kitchen access/application
   */
  async getApplicationStatus(chefId, locationId) {
    try {
      const application = await this.getChefApplication(chefId, locationId);
      if (!application) {
        return {
          hasApplication: false,
          status: null,
          canBook: false,
          message: "You must apply to this kitchen before booking. Please submit an application first."
        };
      }
      const currentTier = application.current_tier ?? 1;
      const isFullyApproved = currentTier >= 3;
      switch (application.status) {
        case "approved":
          return {
            hasApplication: true,
            status: isFullyApproved ? "approved" : "inReview",
            canBook: isFullyApproved,
            message: isFullyApproved ? "Application completed. You can book kitchens at this location." : "Application approved but not fully complete. Please complete all steps to book."
          };
        case "inReview":
          return {
            hasApplication: true,
            status: "inReview",
            canBook: false,
            message: "Your application is pending manager review. Please wait for approval before booking."
          };
        case "rejected":
          return {
            hasApplication: true,
            status: "rejected",
            canBook: false,
            message: "Your application was rejected. You can re-apply with updated documents."
          };
        case "cancelled":
          return {
            hasApplication: true,
            status: "cancelled",
            canBook: false,
            message: "Your application was cancelled. You can submit a new application."
          };
        default:
          return {
            hasApplication: true,
            status: application.status,
            canBook: false,
            message: "Unknown application status. Please contact support."
          };
      }
    } catch (error) {
      logger.error("[ChefApplicationService] Error checking application status:", error);
      return {
        hasApplication: false,
        status: null,
        canBook: false,
        message: "Error checking application status. Please try again."
      };
    }
  }
  /**
   * Create or update chef kitchen application (resubmission support)
   */
  async createApplication(data) {
    try {
      const [existing] = await db.select().from(chefKitchenApplications).where(
        and7(
          eq11(chefKitchenApplications.chefId, data.chefId),
          eq11(chefKitchenApplications.locationId, data.locationId)
        )
      ).limit(1);
      if (existing) {
        const newStatus = existing.status === "approved" ? "approved" : "inReview";
        const shouldClearFeedback = existing.status === "rejected" || existing.status === "cancelled";
        const [updated] = await db.update(chefKitchenApplications).set({
          ...data,
          status: newStatus,
          ...shouldClearFeedback && { feedback: null },
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq11(chefKitchenApplications.id, existing.id)).returning();
        return updated;
      }
      const [created] = await db.insert(chefKitchenApplications).values({
        ...data,
        status: "inReview",
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      return created;
    } catch (error) {
      logger.error("[ChefApplicationService] Error creating/updating application:", error);
      throw error;
    }
  }
  /**
   * Cancel application (Chef side)
   */
  async cancelApplication(applicationId, chefId) {
    try {
      const [application] = await db.select().from(chefKitchenApplications).where(and7(
        eq11(chefKitchenApplications.id, applicationId),
        eq11(chefKitchenApplications.chefId, chefId)
      )).limit(1);
      if (!application) {
        throw new Error("Application not found or unauthorized");
      }
      const [cancelled] = await db.update(chefKitchenApplications).set({
        status: "cancelled",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq11(chefKitchenApplications.id, applicationId)).returning();
      return cancelled;
    } catch (error) {
      logger.error("[ChefApplicationService] Error cancelling application:", error);
      throw error;
    }
  }
  /**
   * Update application documents
   */
  async updateApplicationDocuments(data) {
    try {
      const [updated] = await db.update(chefKitchenApplications).set({
        ...data.foodSafetyLicenseUrl && { foodSafetyLicenseUrl: data.foodSafetyLicenseUrl },
        ...data.foodEstablishmentCertUrl && { foodEstablishmentCertUrl: data.foodEstablishmentCertUrl },
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq11(chefKitchenApplications.id, data.id)).returning();
      if (!updated) {
        throw new Error("Application not found");
      }
      return updated;
    } catch (error) {
      logger.error("[ChefApplicationService] Error updating application documents:", error);
      throw error;
    }
  }
  /**
   * Get application by ID
   */
  async getApplicationById(applicationId) {
    try {
      const [application] = await db.select().from(chefKitchenApplications).where(eq11(chefKitchenApplications.id, applicationId)).limit(1);
      return application;
    } catch (error) {
      logger.error("[ChefApplicationService] Error getting application by ID:", error);
      throw error;
    }
  }
  /**
   * Update application tier
   */
  async updateApplicationTier(applicationId, newTier, tierData) {
    try {
      const current = await this.getApplicationById(applicationId);
      if (!current) {
        throw new Error("Application not found");
      }
      const now = /* @__PURE__ */ new Date();
      const setData = {
        current_tier: newTier,
        updatedAt: now
      };
      if (newTier >= 2 && !current.tier1_completed_at) {
        setData.tier1_completed_at = now;
      }
      if (newTier >= 3 && !current.tier2_completed_at) {
        setData.tier2_completed_at = now;
      }
      if (newTier === 3 && !current.tier3_submitted_at) {
        setData.tier3_submitted_at = now;
      }
      if (newTier >= 4 && !current.tier4_completed_at) {
        setData.tier4_completed_at = now;
      }
      if (tierData !== void 0) {
        setData.tier_data = tierData;
      }
      const [updated] = await db.update(chefKitchenApplications).set(setData).where(eq11(chefKitchenApplications.id, applicationId)).returning();
      return updated;
    } catch (error) {
      logger.error("[ChefApplicationService] Error updating application tier:", error);
      throw error;
    }
  }
};
var chefApplicationService = new ChefApplicationService();

// server/routes/firebase/kitchen-applications.ts
init_location_repository();
init_location_service();
init_kitchen_repository();
init_kitchen_service();
init_application_repository();
init_application_service();
init_chat_service();
init_notification_service();
init_email();
import { and as and10, eq as eq16 } from "drizzle-orm";
var router7 = Router7();
var locationRepository = new LocationRepository();
var locationService2 = new LocationService(locationRepository);
var kitchenRepository = new KitchenRepository();
var kitchenService2 = new KitchenService(kitchenRepository);
var applicationRepository = new ApplicationRepository();
var applicationService2 = new ApplicationService(applicationRepository);
router7.post(
  "/firebase/chef/kitchen-applications",
  upload.any(),
  // Use any() to accept dynamic custom field file uploads (customFile_*)
  requireFirebaseAuthWithUser,
  async (req, res) => {
    try {
      logger.info(`\u{1F373} POST /api/firebase/chef/kitchen-applications - Chef ${req.neonUser.id} submitting kitchen application`);
      const filesArray = req.files;
      const files = {};
      if (filesArray) {
        filesArray.forEach((file) => {
          if (!files[file.fieldname]) {
            files[file.fieldname] = [];
          }
          files[file.fieldname].push(file);
        });
      }
      let foodSafetyLicenseUrl;
      let foodEstablishmentCertUrl;
      const tierFileUrls = {};
      if (files) {
        if (files["foodSafetyLicenseFile"]?.[0]) {
          try {
            foodSafetyLicenseUrl = await uploadToBlob(files["foodSafetyLicenseFile"][0], req.neonUser.id, "documents");
            logger.info(`\u2705 Uploaded food safety license: ${foodSafetyLicenseUrl}`);
          } catch (uploadError) {
            logger.error("\u274C Failed to upload food safety license:", uploadError);
          }
        }
        if (files["foodEstablishmentCertFile"]?.[0]) {
          try {
            foodEstablishmentCertUrl = await uploadToBlob(files["foodEstablishmentCertFile"][0], req.neonUser.id, "documents");
            logger.info(`\u2705 Uploaded food establishment cert: ${foodEstablishmentCertUrl}`);
          } catch (uploadError) {
            logger.error("\u274C Failed to upload food establishment cert:", uploadError);
          }
        }
        const tierFileFields = [
          "tier2_insurance_document",
          "tier3_food_safety_plan",
          "tier3_production_timeline",
          "tier3_cleaning_schedule",
          "tier3_training_records"
        ];
        for (const field of tierFileFields) {
          if (files[field]?.[0]) {
            try {
              const url = await uploadToBlob(files[field][0], req.neonUser.id, "documents");
              tierFileUrls[field] = url;
              logger.info(`\u2705 Uploaded ${field}: ${url}`);
            } catch (uploadError) {
              logger.error(`\u274C Failed to upload ${field}:`, uploadError);
            }
          }
        }
      }
      let customFieldsData;
      if (req.body.customFieldsData) {
        try {
          customFieldsData = typeof req.body.customFieldsData === "string" ? JSON.parse(req.body.customFieldsData) : req.body.customFieldsData;
          logger.info("\u2705 Parsed customFieldsData:", JSON.stringify(customFieldsData));
        } catch (error) {
          logger.error("Error parsing customFieldsData:", error);
          customFieldsData = void 0;
        }
      } else {
        logger.info("\u26A0\uFE0F No customFieldsData in request body");
      }
      if (files) {
        const customFileFields = Object.keys(files).filter((key) => key.startsWith("customFile_"));
        for (const fieldKey of customFileFields) {
          const fieldId = fieldKey.replace("customFile_", "");
          const file = files[fieldKey]?.[0];
          if (file) {
            try {
              const url = await uploadToBlob(file, req.neonUser.id, "documents");
              logger.info(`\u2705 Uploaded custom field file ${fieldId}: ${url}`);
              if (!customFieldsData) {
                customFieldsData = {};
              }
              customFieldsData[fieldId] = url;
            } catch (uploadError) {
              logger.error(`\u274C Failed to upload custom field file ${fieldId}:`, uploadError);
            }
          }
        }
      }
      let tierData;
      if (req.body.tier_data) {
        try {
          tierData = typeof req.body.tier_data === "string" ? JSON.parse(req.body.tier_data) : req.body.tier_data;
          if (Object.keys(tierFileUrls).length > 0) {
            tierData = { ...tierData, tierFiles: tierFileUrls };
          }
        } catch (error) {
          logger.error("Error parsing tier_data:", error);
        }
      }
      const locationId = parseInt(req.body.locationId);
      const location = await locationService2.getLocationById(locationId);
      if (!location) {
        return res.status(404).json({ error: "Kitchen location not found" });
      }
      const requirements = await locationService2.getLocationRequirementsWithDefaults(locationId);
      let phoneValue = "";
      const phoneInput = req.body.phone ? req.body.phone.trim() : "";
      if (requirements.requirePhone) {
        if (!phoneInput || phoneInput === "") {
          return res.status(400).json({
            error: "Validation error",
            message: "Phone number is required for this location",
            details: [{
              code: "too_small",
              minimum: 1,
              type: "string",
              inclusive: true,
              exact: false,
              message: "Phone number is required",
              path: ["phone"]
            }]
          });
        }
        const { phoneNumberSchema: phoneNumberSchema2 } = await Promise.resolve().then(() => (init_phone_validation(), phone_validation_exports));
        const phoneValidation = phoneNumberSchema2.safeParse(phoneInput);
        if (!phoneValidation.success) {
          const validationError = fromZodError2(phoneValidation.error);
          return res.status(400).json({
            error: "Validation error",
            message: validationError.message,
            details: validationError.details
          });
        }
        phoneValue = phoneValidation.data;
      } else {
        if (phoneInput && phoneInput !== "") {
          const { optionalPhoneNumberSchema: optionalPhoneNumberSchema2 } = await Promise.resolve().then(() => (init_phone_validation(), phone_validation_exports));
          const phoneValidation = optionalPhoneNumberSchema2.safeParse(phoneInput);
          if (!phoneValidation.success) {
            const validationError = fromZodError2(phoneValidation.error);
            return res.status(400).json({
              error: "Validation error",
              message: validationError.message,
              details: validationError.details
            });
          }
          phoneValue = phoneValidation.data || "";
        }
      }
      let businessInfo = {};
      if (req.body.businessDescription) {
        try {
          businessInfo = typeof req.body.businessDescription === "string" ? JSON.parse(req.body.businessDescription) : req.body.businessDescription;
        } catch (error) {
          logger.error("Error parsing businessDescription:", error);
          businessInfo = {};
        }
      }
      const fullNameParts = (req.body.fullName || "").trim().split(/\s+/);
      const firstName = fullNameParts[0] || "";
      const lastName = fullNameParts.slice(1).join(" ") || "";
      if (requirements.requireFirstName && (!firstName || firstName.trim() === "")) {
        return res.status(400).json({
          error: "Validation error",
          message: "First name is required for this location",
          details: [{
            code: "too_small",
            minimum: 1,
            type: "string",
            message: "First name is required",
            path: ["firstName"]
          }]
        });
      }
      if (requirements.requireLastName && (!lastName || lastName.trim() === "")) {
        return res.status(400).json({
          error: "Validation error",
          message: "Last name is required for this location",
          details: [{
            code: "too_small",
            minimum: 1,
            type: "string",
            message: "Last name is required",
            path: ["lastName"]
          }]
        });
      }
      if (requirements.requireEmail && (!req.body.email || req.body.email.trim() === "")) {
        return res.status(400).json({
          error: "Validation error",
          message: "Email is required for this location",
          details: [{
            code: "too_small",
            minimum: 1,
            type: "string",
            message: "Email is required",
            path: ["email"]
          }]
        });
      }
      if (requirements.requireBusinessName && (!businessInfo.businessName || businessInfo.businessName.trim() === "")) {
        return res.status(400).json({
          error: "Validation error",
          message: "Business name is required for this location",
          details: [{
            code: "too_small",
            minimum: 1,
            type: "string",
            message: "Business name is required",
            path: ["businessName"]
          }]
        });
      }
      if (requirements.requireBusinessType && (!businessInfo.businessType || businessInfo.businessType.trim() === "")) {
        return res.status(400).json({
          error: "Validation error",
          message: "Business type is required for this location",
          details: [{
            code: "too_small",
            minimum: 1,
            type: "string",
            message: "Business type is required",
            path: ["businessType"]
          }]
        });
      }
      if (requirements.tier1_years_experience_required && (!businessInfo.experience || businessInfo.experience.trim() === "") && (!req.body.cookingExperience || req.body.cookingExperience.trim() === "")) {
        return res.status(400).json({
          error: "Validation error",
          message: "Experience level is required for this location",
          details: [{
            code: "too_small",
            minimum: 1,
            type: "string",
            message: "Experience level is required",
            path: ["experience"]
          }]
        });
      }
      if (requirements.requireBusinessDescription && (!businessInfo.description || businessInfo.description.trim() === "")) {
        return res.status(400).json({
          error: "Validation error",
          message: "Business description is required for this location",
          details: [{
            code: "too_small",
            minimum: 1,
            type: "string",
            message: "Business description is required",
            path: ["businessDescription"]
          }]
        });
      }
      if (requirements.requireFoodHandlerCert && !req.body.foodSafetyLicense) {
        return res.status(400).json({
          error: "Validation error",
          message: "Food handler certificate is required for this location",
          details: [{
            code: "custom",
            message: "Food handler certificate is required",
            path: ["foodSafetyLicense"]
          }]
        });
      }
      if (requirements.requireFoodHandlerExpiry && (!businessInfo.foodHandlerCertExpiry || businessInfo.foodHandlerCertExpiry.trim() === "") && (!req.body.foodSafetyLicenseExpiry || req.body.foodSafetyLicenseExpiry.trim() === "")) {
        return res.status(400).json({
          error: "Validation error",
          message: "Food handler certificate expiry date is required for this location",
          details: [{
            code: "too_small",
            minimum: 1,
            type: "string",
            message: "Food handler certificate expiry date is required",
            path: ["foodHandlerCertExpiry"]
          }]
        });
      }
      let foodEstablishmentCertValue = "no";
      foodEstablishmentCertValue = req.body.foodEstablishmentCert || "no";
      if (requirements.requireUsageFrequency && (!businessInfo.usageFrequency || businessInfo.usageFrequency.trim() === "")) {
        return res.status(400).json({
          error: "Validation error",
          message: "Usage frequency is required for this location",
          details: [{
            code: "too_small",
            minimum: 1,
            type: "string",
            message: "Usage frequency is required",
            path: ["usageFrequency"]
          }]
        });
      }
      if (requirements.requireSessionDuration && (!businessInfo.sessionDuration || businessInfo.sessionDuration.trim() === "")) {
        return res.status(400).json({
          error: "Validation error",
          message: "Session duration is required for this location",
          details: [{
            code: "too_small",
            minimum: 1,
            type: "string",
            message: "Session duration is required",
            path: ["sessionDuration"]
          }]
        });
      }
      const formData = {
        chefId: req.neonUser.id,
        locationId,
        fullName: req.body.fullName || `${firstName} ${lastName}`.trim() || "N/A",
        email: req.body.email || "",
        phone: phoneValue,
        // Empty string if not required (database has notNull constraint)
        kitchenPreference: req.body.kitchenPreference || "commercial",
        businessDescription: req.body.businessDescription || void 0,
        cookingExperience: req.body.cookingExperience || businessInfo.experience || void 0,
        foodSafetyLicense: req.body.foodSafetyLicense || "no",
        foodSafetyLicenseUrl: foodSafetyLicenseUrl || req.body.foodSafetyLicenseUrl || void 0,
        foodSafetyLicenseExpiry: req.body.foodSafetyLicenseExpiry || businessInfo.foodHandlerCertExpiry || void 0,
        foodEstablishmentCert: foodEstablishmentCertValue,
        foodEstablishmentCertUrl: foodEstablishmentCertUrl || req.body.foodEstablishmentCertUrl || void 0,
        foodEstablishmentCertExpiry: req.body.foodEstablishmentCertExpiry || businessInfo.foodEstablishmentCertExpiry || void 0,
        customFieldsData: customFieldsData || void 0
      };
      const currentTierValue = parseInt(req.body.current_tier) || 1;
      if (req.body.current_tier) {
        formData.current_tier = currentTierValue;
      }
      if (currentTierValue === 2) {
        const existingApp = await chefApplicationService.getChefApplication(req.neonUser.id, locationId);
        const mergedTierData = {
          ...existingApp?.tier_data || {},
          ...tierData || {},
          // Ensure tierFiles are included (uploaded documents like insurance)
          tierFiles: {
            ...existingApp?.tier_data?.tierFiles || {},
            ...tierData?.tierFiles || {},
            ...tierFileUrls
          },
          // Store Step 2 custom fields separately in tier_data
          tier2_custom_fields_data: customFieldsData || {},
          tier2_submitted_at: (/* @__PURE__ */ new Date()).toISOString()
        };
        formData.tier_data = mergedTierData;
        if (existingApp?.customFieldsData) {
          formData.customFieldsData = existingApp.customFieldsData;
        }
        formData.tier2_completed_at = /* @__PURE__ */ new Date();
      } else if (tierData) {
        formData.tier_data = tierData;
      } else if (Object.keys(tierFileUrls).length > 0) {
        formData.tier_data = { tierFiles: tierFileUrls };
      }
      const currentTier = parseInt(req.body.current_tier) || 1;
      if (currentTier === 2) {
        if (requirements.tier2_food_establishment_cert_required) {
          const hasFoodEstablishmentCert = foodEstablishmentCertUrl || req.body.foodEstablishmentCertUrl;
          if (!hasFoodEstablishmentCert) {
            return res.status(400).json({
              error: "Validation error",
              message: "Food Establishment Certificate is required for Tier 2",
              details: [{
                code: "custom",
                message: "Food Establishment Certificate is required",
                path: ["foodEstablishmentCert"]
              }]
            });
          }
        }
        if (requirements.tier2_insurance_document_required) {
          const hasInsuranceDoc = tierFileUrls["tier2_insurance_document"];
          if (!hasInsuranceDoc) {
            return res.status(400).json({
              error: "Validation error",
              message: "Insurance Document is required for Tier 2",
              details: [{
                code: "custom",
                message: "Insurance Document is required",
                path: ["tier2_insurance_document"]
              }]
            });
          }
        }
        if (requirements.tier2_kitchen_experience_required) {
          const kitchenExperienceDesc = tierData?.kitchen_experience_description;
          if (!kitchenExperienceDesc || kitchenExperienceDesc.trim() === "") {
            return res.status(400).json({
              error: "Validation error",
              message: "Kitchen Experience Description is required for Tier 2",
              details: [{
                code: "custom",
                message: "Kitchen Experience Description is required",
                path: ["kitchenExperienceDescription"]
              }]
            });
          }
        }
      }
      if (req.body.government_license_number) {
        formData.government_license_number = req.body.government_license_number;
      }
      if (req.body.government_license_received_date) {
        formData.government_license_received_date = req.body.government_license_received_date;
      }
      if (req.body.government_license_expiry_date) {
        formData.government_license_expiry_date = req.body.government_license_expiry_date;
      }
      const parsedData = insertChefKitchenApplicationSchema.safeParse(formData);
      if (!parsedData.success) {
        const validationError = fromZodError2(parsedData.error);
        logger.info("\u274C Validation failed:", validationError.details);
        return res.status(400).json({
          error: "Validation error",
          message: validationError.message,
          details: validationError.details
        });
      }
      const applicationData = {
        ...parsedData.data,
        // Include tier fields (not in Zod schema but needed for storage)
        ...formData.current_tier && { current_tier: formData.current_tier },
        ...formData.tier_data && { tier_data: formData.tier_data },
        ...formData.tier2_completed_at && { tier2_completed_at: formData.tier2_completed_at },
        ...foodEstablishmentCertUrl && { foodEstablishmentCertUrl },
        // [FIX] Explicitly set customFieldsData from formData (not from Zod which may have empty default)
        customFieldsData: formData.customFieldsData || parsedData.data.customFieldsData || {}
      };
      logger.info("\u{1F4E6} Application data being saved:", {
        hasCustomFieldsData: !!applicationData.customFieldsData && Object.keys(applicationData.customFieldsData).length > 0,
        customFieldsData: applicationData.customFieldsData,
        formDataCustomFields: formData.customFieldsData,
        parsedDataCustomFields: parsedData.data.customFieldsData
      });
      const application = await chefApplicationService.createApplication(applicationData);
      logger.info(`\u2705 Kitchen application created/updated: Chef ${req.neonUser.id} \u2192 Location ${parsedData.data.locationId}, ID: ${application.id}`);
      try {
        if (location.managerId) {
          await notificationService.notifyNewApplication({
            managerId: location.managerId,
            locationId: location.id,
            applicationId: application.id,
            chefName: formData.fullName || "Chef",
            chefEmail: formData.email || ""
          });
        }
      } catch (notifError) {
        logger.error("Error creating application notification:", notifError);
      }
      try {
        if (location.notificationEmail && location.managerId) {
          const managerEmailContent = generateNewKitchenApplicationManagerEmail({
            managerEmail: location.notificationEmail,
            chefName: formData.fullName || "Chef",
            chefEmail: formData.email || "",
            locationName: location.name || "Kitchen Location",
            applicationId: application.id,
            submittedAt: /* @__PURE__ */ new Date()
          });
          await sendEmail(managerEmailContent, {
            trackingId: `kitchen_app_new_${application.id}_${Date.now()}`
          });
          logger.info(`\u2705 Sent new kitchen application email to manager: ${location.notificationEmail}`);
        }
      } catch (emailError) {
        logger.error("Error sending new kitchen application email to manager:", emailError);
      }
      res.status(201).json({
        success: true,
        application,
        message: "Kitchen application submitted successfully. The kitchen manager will review your application.",
        isResubmission: application.createdAt < application.updatedAt
      });
    } catch (error) {
      logger.error("Error creating kitchen application:", error);
      res.status(500).json({
        error: "Failed to submit kitchen application",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  }
);
router7.get("/firebase/chef/kitchen-applications", requireFirebaseAuthWithUser, async (req, res) => {
  try {
    const chefId = req.neonUser.id;
    const applications4 = await chefApplicationService.getChefApplications(chefId);
    res.json(applications4);
  } catch (error) {
    logger.error("Error getting chef kitchen applications:", error);
    res.status(500).json({ error: "Failed to get kitchen applications" });
  }
});
router7.get("/firebase/chef/kitchen-applications/location/:locationId", requireFirebaseAuthWithUser, async (req, res) => {
  try {
    const locationId = parseInt(req.params.locationId);
    if (isNaN(locationId)) {
      return res.status(400).json({ error: "Invalid location ID" });
    }
    const application = await chefApplicationService.getChefApplication(req.neonUser.id, locationId);
    if (!application) {
      return res.json({
        hasApplication: false,
        canBook: false,
        message: "You have not applied to this kitchen yet.",
        application: null
      });
    }
    const location = await locationService2.getLocationById(locationId);
    const currentTier = application.current_tier ?? 1;
    res.json({
      ...application,
      hasApplication: true,
      canBook: application.status === "approved" && currentTier >= 3,
      location: location ? {
        id: location.id,
        name: location.name,
        address: location.address,
        managerId: location.managerId
      } : null
    });
  } catch (error) {
    logger.error("Error getting chef kitchen application:", error);
    res.status(500).json({ error: "Failed to get kitchen application" });
  }
});
router7.get("/firebase/chef/kitchen-access-status/:locationId", requireFirebaseAuthWithUser, async (req, res) => {
  try {
    const locationId = parseInt(req.params.locationId);
    if (isNaN(locationId)) {
      return res.status(400).json({ error: "Invalid location ID" });
    }
    const accessStatus = await chefApplicationService.getApplicationStatus(req.neonUser.id, locationId);
    res.json(accessStatus);
  } catch (error) {
    logger.error("Error getting kitchen access status:", error);
    res.status(500).json({ error: "Failed to get kitchen access status" });
  }
});
router7.get("/firebase/chef/approved-kitchens", requireFirebaseAuthWithUser, async (req, res) => {
  try {
    const approvedKitchens = await chefApplicationService.getApprovedKitchens(req.neonUser.id);
    res.json(approvedKitchens);
  } catch (error) {
    logger.error("Error getting approved kitchens:", error);
    res.status(500).json({ error: "Failed to get approved kitchens" });
  }
});
router7.patch("/firebase/chef/kitchen-applications/:id/cancel", requireFirebaseAuthWithUser, async (req, res) => {
  try {
    const applicationId = parseInt(req.params.id);
    if (isNaN(applicationId)) {
      return res.status(400).json({ error: "Invalid application ID" });
    }
    const cancelledApplication = await chefApplicationService.cancelApplication(applicationId, req.neonUser.id);
    res.json({
      success: true,
      application: cancelledApplication,
      message: "Application cancelled successfully"
    });
  } catch (error) {
    logger.error("Error cancelling kitchen application:", error);
    res.status(500).json({
      error: "Failed to cancel application",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router7.patch(
  "/firebase/chef/kitchen-applications/:id/documents",
  upload.fields([
    { name: "foodSafetyLicenseFile", maxCount: 1 },
    { name: "foodEstablishmentCertFile", maxCount: 1 }
  ]),
  requireFirebaseAuthWithUser,
  async (req, res) => {
    try {
      const applicationId = parseInt(req.params.id);
      if (isNaN(applicationId)) {
        return res.status(400).json({ error: "Invalid application ID" });
      }
      const [existing] = await chefApplicationService.getChefApplications(req.neonUser.id);
      const applications4 = await chefApplicationService.getChefApplications(req.neonUser.id);
      const application = applications4.find((a) => a.id === applicationId);
      if (!application) {
        return res.status(403).json({ error: "Application not found or access denied" });
      }
      const files = req.files;
      const updateData = { id: applicationId };
      if (files) {
        if (files["foodSafetyLicenseFile"]?.[0]) {
          try {
            updateData.foodSafetyLicenseUrl = await uploadToBlob(files["foodSafetyLicenseFile"][0], req.neonUser.id, "documents");
          } catch (uploadError) {
            logger.error("\u274C Failed to upload food safety license:", uploadError);
          }
        }
        if (files["foodEstablishmentCertFile"]?.[0]) {
          try {
            updateData.foodEstablishmentCertUrl = await uploadToBlob(files["foodEstablishmentCertFile"][0], req.neonUser.id, "documents");
          } catch (uploadError) {
            logger.error("\u274C Failed to upload food establishment cert:", uploadError);
          }
        }
      }
      const updatedApplication = await chefApplicationService.updateApplicationDocuments(updateData);
      res.json({
        success: true,
        application: updatedApplication,
        message: "Documents updated successfully. They will be reviewed by the manager."
      });
    } catch (error) {
      logger.error("Error updating kitchen application documents:", error);
      res.status(500).json({
        error: "Failed to update documents",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  }
);
router7.get("/manager/kitchen-applications", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
  try {
    const user = req.neonUser;
    const applications4 = await chefApplicationService.getApplicationsForManager(user.id);
    res.json(applications4);
  } catch (error) {
    logger.error("Error getting kitchen applications for manager:", error);
    res.status(500).json({ error: "Failed to get applications" });
  }
});
router7.get("/manager/kitchen-applications/location/:locationId", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
  try {
    const user = req.neonUser;
    const locationId = parseInt(req.params.locationId);
    if (isNaN(locationId)) {
      return res.status(400).json({ error: "Invalid location ID" });
    }
    const location = await locationService2.getLocationById(locationId);
    if (!location || location.managerId !== user.id) {
      return res.status(403).json({ error: "Access denied to this location" });
    }
    const applications4 = await chefApplicationService.getApplicationsByLocation(locationId);
    res.json(applications4);
  } catch (error) {
    logger.error("Error getting kitchen applications for location:", error);
    res.status(500).json({ error: "Failed to get applications" });
  }
});
router7.patch("/manager/kitchen-applications/:id/status", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
  try {
    const user = req.neonUser;
    const applicationId = parseInt(req.params.id);
    if (isNaN(applicationId)) {
      return res.status(400).json({ error: "Invalid application ID" });
    }
    const { status, feedback } = req.body;
    if (!status || !["approved", "rejected", "inReview"].includes(status)) {
      return res.status(400).json({ error: 'Status must be "approved", "rejected", or "inReview"' });
    }
    const applications4 = await chefApplicationService.getApplicationsForManager(user.id);
    const application = applications4.find((a) => a.id === applicationId);
    if (!application) {
      return res.status(404).json({ error: "Application not found or access denied" });
    }
    const location = await locationService2.getLocationById(application.locationId);
    if (!location || location.managerId !== user.id) {
      return res.status(403).json({ error: "Access denied to this application" });
    }
    let updatedApplication = await chefApplicationService.updateApplicationStatus(
      applicationId,
      status,
      feedback,
      user.id
    );
    if (req.body.current_tier !== void 0 && updatedApplication) {
      const newTier = parseInt(req.body.current_tier);
      const tierData = req.body.tier_data;
      updatedApplication = await chefApplicationService.updateApplicationTier(
        applicationId,
        newTier,
        tierData
      ) || updatedApplication;
    }
    logger.info(`\u2705 Application ${applicationId} ${status} by Manager ${user.id}`);
    if (status === "approved" && updatedApplication) {
      try {
        await notificationService.notifyApplicationApproved({
          managerId: user.id,
          locationId: application.locationId,
          applicationId: application.id,
          chefName: application.fullName || "Chef",
          chefEmail: application.email || ""
        });
      } catch (notifError) {
        logger.error("Error creating application approval notification:", notifError);
      }
      try {
        if (application.email) {
          const location2 = await locationService2.getLocationById(application.locationId);
          const approvalTier = updatedApplication?.current_tier ?? 1;
          if (approvalTier <= 1) {
            const step1Email = generateKitchenApplicationSubmittedChefEmail({
              chefEmail: application.email,
              chefName: application.fullName || "Chef",
              locationName: location2?.name || "Kitchen Location",
              locationAddress: location2?.address || void 0
            });
            await sendEmail(step1Email, {
              trackingId: `kitchen_app_step1_approved_${application.id}_${Date.now()}`
            });
            logger.info(`\u2705 Sent step 1 approval email to chef: ${application.email} (Tier ${approvalTier})`);
          } else {
            const approvalEmail = generateKitchenApplicationApprovedEmail({
              chefEmail: application.email,
              chefName: application.fullName || "Chef",
              locationName: location2?.name || "Kitchen Location"
            });
            await sendEmail(approvalEmail, {
              trackingId: `kitchen_app_approved_${application.id}_${Date.now()}`
            });
            logger.info(`\u2705 Sent full approval email to chef: ${application.email} (Tier ${approvalTier})`);
          }
        }
      } catch (emailError) {
        logger.error("Error sending kitchen application approval email:", emailError);
      }
      try {
        if (application.chefId) {
          const location2 = await locationService2.getLocationById(application.locationId);
          await notificationService.notifyChefApplicationApproved({
            chefId: application.chefId,
            kitchenName: location2?.name || "Kitchen",
            locationName: location2?.name || "Kitchen Location"
          });
        }
      } catch (notifError) {
        logger.error("Error creating chef application approval notification:", notifError);
      }
    }
    if (status === "rejected" && updatedApplication) {
      try {
        if (application.email) {
          const location2 = await locationService2.getLocationById(application.locationId);
          const rejectionEmail = generateKitchenApplicationRejectedEmail({
            chefEmail: application.email,
            chefName: application.fullName || "Chef",
            locationName: location2?.name || "Kitchen Location",
            feedback: feedback || void 0
          });
          await sendEmail(rejectionEmail, {
            trackingId: `kitchen_app_rejected_${application.id}_${Date.now()}`
          });
          logger.info(`\u2705 Sent kitchen application rejection email to chef: ${application.email}`);
        }
      } catch (emailError) {
        logger.error("Error sending kitchen application rejection email:", emailError);
      }
      try {
        if (application.chefId) {
          const location2 = await locationService2.getLocationById(application.locationId);
          await notificationService.notifyChefApplicationRejected({
            chefId: application.chefId,
            kitchenName: location2?.name || "Kitchen",
            locationName: location2?.name || "Kitchen Location",
            reason: feedback || void 0
          });
        }
      } catch (notifError) {
        logger.error("Error creating chef application rejection notification:", notifError);
      }
    }
    if (status === "approved" && updatedApplication) {
      const currentTier = updatedApplication.current_tier ?? 1;
      const previousTier = application.current_tier ?? 1;
      if (currentTier > previousTier) {
        await notifyTierTransition(applicationId, previousTier, currentTier);
      }
      if (currentTier >= 2) {
        const { tierValidationService: tierValidationService2 } = await Promise.resolve().then(() => (init_tier_validation(), tier_validation_exports));
        const requirements = await locationService2.getLocationRequirementsWithDefaults(application.locationId);
        const validation = tierValidationService2.validateTierRequirements(
          updatedApplication,
          requirements,
          2
          // Validate for Tier 2 strictness
        );
        if (validation.valid) {
          try {
            const existingAccess = await db.select().from(chefLocationAccess).where(
              and10(
                eq16(chefLocationAccess.chefId, application.chefId),
                eq16(chefLocationAccess.locationId, application.locationId)
              )
            );
            if (existingAccess.length === 0) {
              await db.insert(chefLocationAccess).values({
                chefId: application.chefId,
                locationId: application.locationId,
                grantedBy: req.neonUser.id,
                grantedAt: /* @__PURE__ */ new Date()
              });
              logger.info(`\u2705 Granted chef ${application.chefId} access to location ${application.locationId} (Requirements Met)`);
            }
          } catch (accessError) {
            logger.error("Error granting chef access:", accessError);
          }
        } else {
          logger.info(`\u2139\uFE0F Chef ${application.chefId} at Tier ${currentTier} but missing requirements: ${validation.missingRequirements.join(", ")}`);
        }
      }
    }
    res.json({
      success: true,
      application: updatedApplication,
      message: `Application ${status} successfully`
    });
  } catch (error) {
    logger.error("Error updating kitchen application status:", error);
    res.status(500).json({
      error: "Failed to update application status",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router7.patch("/manager/kitchen-applications/:id/verify-documents", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
  try {
    const user = req.neonUser;
    const applicationId = parseInt(req.params.id);
    if (isNaN(applicationId)) {
      return res.status(400).json({ error: "Invalid application ID" });
    }
    const { foodSafetyLicenseStatus, foodEstablishmentCertStatus } = req.body;
    const validStatuses = ["pending", "approved", "rejected"];
    if (foodSafetyLicenseStatus && !validStatuses.includes(foodSafetyLicenseStatus)) {
      return res.status(400).json({ error: "Invalid food safety license status" });
    }
    if (foodEstablishmentCertStatus && !validStatuses.includes(foodEstablishmentCertStatus)) {
      return res.status(400).json({ error: "Invalid food establishment cert status" });
    }
    const application = await chefApplicationService.getApplicationById(applicationId);
    if (!application) {
      return res.status(404).json({ error: "Application not found" });
    }
    const location = await locationService2.getLocationById(application.locationId);
    if (!location || location.managerId !== user.id) {
      return res.status(403).json({ error: "Access denied to this application" });
    }
    const updateData = { id: applicationId };
    if (foodSafetyLicenseStatus) updateData.foodSafetyLicenseStatus = foodSafetyLicenseStatus;
    if (foodEstablishmentCertStatus) updateData.foodEstablishmentCertStatus = foodEstablishmentCertStatus;
    const updatedApplication = await chefApplicationService.updateApplicationDocuments(updateData);
    if (updatedApplication?.chat_conversation_id) {
      const documentName = foodSafetyLicenseStatus === "approved" ? "Food Safety License" : foodEstablishmentCertStatus === "approved" ? "Food Establishment Certificate" : "Document";
      if (foodSafetyLicenseStatus === "approved" || foodEstablishmentCertStatus === "approved") {
        await sendSystemNotification(
          updatedApplication.chat_conversation_id,
          "DOCUMENT_VERIFIED",
          { documentName }
        );
      }
    }
    res.json({
      success: true,
      application: updatedApplication,
      message: "Document verification updated"
    });
  } catch (error) {
    logger.error("Error verifying kitchen application documents:", error);
    res.status(500).json({
      error: "Failed to verify documents",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router7.patch("/manager/kitchen-applications/:id/tier", requireFirebaseAuthWithUser, requireManager, async (req, res) => {
  try {
    const user = req.neonUser;
    const applicationId = parseInt(req.params.id);
    if (isNaN(applicationId)) {
      return res.status(400).json({ error: "Invalid application ID" });
    }
    const parsed = updateApplicationTierSchema.safeParse({
      id: applicationId,
      ...req.body
    });
    if (!parsed.success) {
      return res.status(400).json({
        error: "Validation error",
        message: parsed.error.message
      });
    }
    const application = await chefApplicationService.getApplicationById(applicationId);
    if (!application) {
      return res.status(404).json({ error: "Application not found" });
    }
    const location = await locationService2.getLocationById(application.locationId);
    if (!location || location.managerId !== user.id) {
      return res.status(403).json({ error: "Access denied to this application" });
    }
    const updatedApplication = await chefApplicationService.updateApplicationTier(
      applicationId,
      parsed.data.current_tier,
      parsed.data.tier_data
    );
    if (updatedApplication?.chat_conversation_id) {
      const fromTier = application.current_tier ?? 1;
      const toTier = parsed.data.current_tier;
      await notifyTierTransition(applicationId, fromTier, toTier);
    }
    res.json({
      success: true,
      application: updatedApplication,
      message: `Application advanced to Tier ${parsed.data.current_tier}`
    });
  } catch (error) {
    logger.error("Error updating application tier:", error);
    res.status(500).json({
      error: "Failed to update application tier",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
var kitchenApplicationsRouter = router7;

// server/firebase-routes.ts
function registerFirebaseRoutes(app2) {
  logger.info("\u{1F525} Registering Firebase Routes (Modular)...");
  const apiPrefix = "/api";
  app2.use(apiPrefix, applicationsRouter);
  app2.use(apiPrefix, adminEmailRouter);
  app2.use(apiPrefix, dashboardRouter);
  app2.use(apiPrefix, mediaRouter);
  app2.use(apiPrefix, healthRouter);
  app2.use(apiPrefix, platformRouter);
  app2.use(apiPrefix, kitchenApplicationsRouter);
  logger.info("\u2705 All Firebase modules registered.");
}

// server/routes.ts
init_logger();
init_email();
init_firebase_setup();
init_firebase_auth_middleware();
init_user_repository();
init_user_service();
import { createServer } from "http";
async function registerRoutes(app2) {
  logger.info("[Routes] Registering all routes including chef-kitchen-access and portal user routes...");
  app2.get("/api/sentry-test", (_req, _res) => {
    throw new Error("Sentry test error \u2014 if you see this in Sentry, it works!");
  });
  app2.get("/api/sentry-test/trace", (_req, res) => {
    res.json({ ok: true, message: "Sentry trace generated. Check Sentry Performance tab." });
  });
  app2.use(optionalFirebaseAuth);
  app2.use("/api/user", (await Promise.resolve().then(() => (init_user(), user_exports))).default);
  app2.use("/api/places", (await Promise.resolve().then(() => (init_places(), places_exports))).default);
  app2.post("/api/logout", (req, res) => {
    logger.info("\u{1F6AA} Logout request received (Firebase Auth is stateless)");
    res.json({ success: true, message: "Logged out successfully" });
  });
  const userRouter = (await Promise.resolve().then(() => (init_user(), user_exports))).default;
  app2.use("/api/sync-verification-status", (req, res, next) => {
    req.url = "/sync-verification-status";
    userRouter(req, res, next);
  });
  app2.use("/api/applications", (await Promise.resolve().then(() => (init_applications(), applications_exports))).default);
  app2.use("/api", (await Promise.resolve().then(() => (init_locations(), locations_exports))).default);
  app2.use("/api/microlearning", (await Promise.resolve().then(() => (init_microlearning(), microlearning_exports))).default);
  app2.use("/api/firebase/microlearning", (await Promise.resolve().then(() => (init_microlearning(), microlearning_exports))).default);
  app2.use("/api/files", (await Promise.resolve().then(() => (init_files(), files_exports))).default);
  const userRepo2 = new UserRepository();
  const userService3 = new UserService(userRepo2);
  app2.get("/api/user-exists", async (req, res) => {
    const username = req.query.username;
    if (!username) {
      return res.status(400).json({ error: "Username required" });
    }
    const exists = await userService3.checkUsernameExists(username);
    res.json({ exists });
  });
  app2.get("/api/firebase/user/me", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      const user = req.neonUser;
      res.json({
        ...user,
        is_verified: user.isVerified,
        has_seen_welcome: user.has_seen_welcome
      });
    } catch (error) {
      logger.error("[API] Error getting user:", error);
      res.status(500).json({ error: "Failed to get user info" });
    }
  });
  app2.post("/api/firebase-sync-user", requireFirebaseAuthWithUser, async (req, res) => {
    try {
      let user = req.neonUser;
      const firebaseEmailVerified = req.firebaseUser?.email_verified;
      if (firebaseEmailVerified && !user.isVerified) {
        logger.info(`\u{1F4E7} Updating is_verified for user ${user.id} - Firebase email verified`);
        const updatedUser = await userService3.updateUser(user.id, { isVerified: true });
        if (updatedUser) {
          user = updatedUser;
        }
      }
      if (firebaseEmailVerified && user.isVerified && !user.welcomeEmailSentAt) {
        try {
          const { sendEmail: sendEmail2, generateWelcomeEmail: generateWelcomeEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
          logger.info(`\u{1F4E7} Sending welcome email to newly verified user: ${user.username}`);
          const welcomeEmail = generateWelcomeEmail2({
            fullName: req.firebaseUser?.name || user.username.split("@")[0],
            email: user.username,
            role: user.role
          });
          const emailResult = await sendEmail2(welcomeEmail, {
            trackingId: `welcome_verified_${user.id}_${Date.now()}`
          });
          if (emailResult) {
            await userService3.updateUser(user.id, { welcomeEmailSentAt: /* @__PURE__ */ new Date() });
            logger.info(`\u2705 Welcome email sent successfully to ${user.username}`);
          }
        } catch (emailError) {
          logger.error("\u274C Error sending welcome email on sync verification:", emailError);
        }
      }
      res.json(user);
    } catch (error) {
      logger.error("Error syncing user:", error);
      res.status(500).json({ error: "Failed to sync user" });
    }
  });
  app2.post("/api/firebase-register-user", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader?.startsWith("Bearer ")) {
        return res.status(401).json({ error: "No token provided" });
      }
      const token = authHeader.split("Bearer ")[1];
      const decodedToken = await verifyFirebaseToken(token);
      if (!decodedToken) {
        return res.status(401).json({ error: "Invalid token" });
      }
      const { email, uid, role, ...otherData } = req.body;
      if (decodedToken.uid !== uid) {
        return res.status(403).json({ error: "Token mismatch" });
      }
      const existingByUid = await userService3.getUserByFirebaseUid(uid);
      if (existingByUid) {
        logger.info(`\u2705 User already exists with Firebase UID ${uid}, returning existing user`);
        return res.json(existingByUid);
      }
      const existingByUsername = await userService3.getUserByUsername(email);
      if (existingByUsername) {
        if (!existingByUsername.firebaseUid) {
          logger.info(`\u{1F517} Linking Firebase UID ${uid} to existing Neon user ${existingByUsername.id}`);
          const updatedUser = await userService3.updateUser(existingByUsername.id, {
            firebaseUid: uid,
            isVerified: decodedToken.email_verified || existingByUsername.isVerified
          });
          return res.json(updatedUser || existingByUsername);
        } else if (existingByUsername.firebaseUid !== uid) {
          logger.info(`\u26A0\uFE0F User ${email} exists with different Firebase UID. Old: ${existingByUsername.firebaseUid}, New: ${uid}`);
          logger.info(`\u{1F504} Updating Firebase UID to new account (user may have re-registered in Firebase)`);
          const updatedUser = await userService3.updateUser(existingByUsername.id, {
            firebaseUid: uid,
            isVerified: decodedToken.email_verified || false
            // Reset verification for new Firebase account
          });
          return res.json(updatedUser || existingByUsername);
        }
        return res.json(existingByUsername);
      }
      logger.info(`\u{1F4DD} Creating new user: ${email} with role: ${role || "user"}`);
      const finalRole = role || "user";
      const newUser = await userService3.createUser({
        username: email,
        firebaseUid: uid,
        role: finalRole,
        isVerified: decodedToken.email_verified || false,
        ...otherData
      });
      try {
        const { sendEmail: sendEmail2, generateWelcomeEmail: generateWelcomeEmail2, generateNewUserRegistrationAdminEmail: generateNewUserRegistrationAdminEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
        const { users: users5 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
        const { eq: eq38 } = await import("drizzle-orm");
        const displayName = otherData.displayName || email.split("@")[0];
        if (decodedToken.email_verified) {
          logger.info(`\u{1F4E7} Sending welcome email to VERIFIED new ${finalRole}: ${email}`);
          const welcomeEmail = generateWelcomeEmail2({
            fullName: displayName,
            email,
            role: finalRole
          });
          const welcomeSent = await sendEmail2(welcomeEmail, {
            trackingId: `welcome_${finalRole}_${email}_${Date.now()}`
          });
          if (welcomeSent) {
            await userService3.updateUser(newUser.id, { welcomeEmailSentAt: /* @__PURE__ */ new Date() });
            logger.info(`\u2705 Welcome email sent to new ${finalRole}: ${email}`);
          } else {
            logger.info(`\u274C Failed to send welcome email to ${email}`);
          }
        } else {
          logger.info(`\u2139\uFE0F Skipping welcome email for UNVERIFIED new ${finalRole}: ${email} - will be sent after verification`);
        }
        const admins = await db2.select({ username: users5.username }).from(users5).where(eq38(users5.role, "admin"));
        for (const admin2 of admins) {
          if (admin2.username && admin2.username !== email) {
            const adminEmail = generateNewUserRegistrationAdminEmail2({
              adminEmail: admin2.username,
              newUserName: displayName,
              newUserEmail: email,
              userRole: finalRole,
              registrationDate: /* @__PURE__ */ new Date()
            });
            const adminSent = await sendEmail2(adminEmail, {
              trackingId: `new_user_admin_${admin2.username}_${Date.now()}`
            });
            if (adminSent) {
              logger.info(`\u2705 Admin notification sent to ${admin2.username} about new ${finalRole} registration`);
            }
          }
        }
      } catch (emailError) {
        logger.error("\u274C Error sending registration emails:", emailError);
      }
      res.status(201).json(newUser);
    } catch (error) {
      logger.error("Error registering user:", error);
      if (error.message?.includes("already taken") || error.code === "23505") {
        return res.status(409).json({
          error: "Email already registered",
          code: "EMAIL_EXISTS",
          message: "This email is already registered. Please try signing in instead."
        });
      }
      res.status(500).json({ error: "Failed to register user" });
    }
  });
  app2.post("/api/unsubscribe", async (req, res) => {
    try {
      const { email, reason, feedback, timestamp: timestamp2 } = req.body;
      if (!email) {
        return res.status(400).json({
          success: false,
          message: "Email address is required"
        });
      }
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        return res.status(400).json({
          success: false,
          message: "Invalid email format"
        });
      }
      const unsubscribeNotificationContent = {
        to: "localcooks@localcook.shop",
        subject: `\u{1F6AB} Unsubscribe Request - ${email}`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f9fafb;">
            <div style="background: linear-gradient(135deg, #F51042 0%, #FF5470 100%); padding: 20px; border-radius: 8px 8px 0 0; text-align: center;">
              <h1 style="color: white; margin: 0; font-size: 24px;">Local Cooks - Unsubscribe Request</h1>
            </div>
            
            <div style="background: white; padding: 30px; border-radius: 0 0 8px 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
              <h2 style="color: #1f2937; margin-top: 0;">New Unsubscribe Request</h2>
              
              <div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 15px; margin: 20px 0;">
                <p style="margin: 0; color: #dc2626; font-weight: 600;">
                  \u{1F4E7} Email: <span style="font-weight: normal;">${email}</span>
                </p>
              </div>
              
              <div style="margin: 20px 0;">
                <h3 style="color: #374151; margin-bottom: 10px;">Request Details:</h3>
                <ul style="color: #6b7280; line-height: 1.6;">
                  <li><strong>Timestamp:</strong> ${new Date(timestamp2).toLocaleString()}</li>
                  <li><strong>Reason:</strong> ${reason || "Not specified"}</li>
                  ${feedback ? `<li><strong>Feedback:</strong> ${feedback}</li>` : ""}
                </ul>
              </div>
              
              <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 6px; padding: 15px; margin: 20px 0;">
                <h4 style="color: #0369a1; margin: 0 0 10px 0;">Action Required:</h4>
                <p style="color: #0c4a6e; margin: 0; font-size: 14px;">
                  Please manually remove <strong>${email}</strong> from all email lists and marketing databases within 24 hours.
                </p>
              </div>
              
              <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb;">
                <p style="color: #6b7280; font-size: 12px; margin: 0;">
                  This is an automated notification from the Local Cooks unsubscribe system.
                </p>
              </div>
            </div>
          </div>
        `,
        text: `
          Local Cooks - Unsubscribe Request
          
          New unsubscribe request received:
          
          Email: ${email}
          Timestamp: ${new Date(timestamp2).toLocaleString()}
          Reason: ${reason || "Not specified"}
          ${feedback ? `Feedback: ${feedback}` : ""}
          
          ACTION REQUIRED: Please manually remove ${email} from all email lists and marketing databases within 24 hours.
        `
      };
      const emailSent = await sendEmail(unsubscribeNotificationContent, {
        trackingId: `unsubscribe_${email}_${Date.now()}`
      });
      if (!emailSent) {
        logger.error("Failed to send unsubscribe notification email");
        return res.status(500).json({
          success: false,
          message: "Failed to process unsubscribe request"
        });
      }
      const userConfirmationContent = {
        to: email,
        subject: "Local Cooks - Unsubscribe Request Received",
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f9fafb;">
            <div style="background: linear-gradient(135deg, #F51042 0%, #FF5470 100%); padding: 20px; border-radius: 8px 8px 0 0; text-align: center;">
              <h1 style="color: white; margin: 0; font-size: 24px;">Local Cooks</h1>
              <p style="color: white; margin: 5px 0 0 0; opacity: 0.9;">Unsubscribe Confirmation</p>
            </div>
            
            <div style="background: white; padding: 30px; border-radius: 0 0 8px 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
              <h2 style="color: #1f2937; margin-top: 0;">We've Received Your Request</h2>
              
              <p style="color: #374151; line-height: 1.6;">
                Hi there,
              </p>
              
              <p style="color: #374151; line-height: 1.6;">
                We've received your request to unsubscribe from our email communications. We're sorry to see you go!
              </p>
              
              <div style="background: #f0f9ff; border-left: 4px solid #0ea5e9; padding: 15px; margin: 20px 0;">
                <p style="margin: 0; color: #0c4a6e;">
                  <strong>What happens next:</strong><br>
                  Your email address will be removed from our mailing lists within 24 hours. You may receive one final confirmation email once the process is complete.
                </p>
              </div>
              
              <p style="color: #374151; line-height: 1.6;">
                If you have any questions or if this was done in error, please don't hesitate to contact us at 
                <a href="mailto:localcooks@localcook.shop" style="color: #F51042; text-decoration: none;">localcooks@localcook.shop</a>.
              </p>
              
              <p style="color: #374151; line-height: 1.6;">
                Thank you for being part of the Local Cooks community!
              </p>
              
              <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center;">
                <p style="color: #6b7280; font-size: 12px; margin: 0;">
                  Local Cooks Team<br>
                  <a href="mailto:localcooks@localcook.shop" style="color: #F51042; text-decoration: none;">localcooks@localcook.shop</a>
                </p>
              </div>
            </div>
          </div>
        `,
        text: `
          Local Cooks - Unsubscribe Confirmation
          
          Hi there,
          
          We've received your request to unsubscribe from our email communications. We're sorry to see you go!
          
          What happens next:
          Your email address will be removed from our mailing lists within 24 hours. You may receive one final confirmation email once the process is complete.
          
          If you have any questions or if this was done in error, please contact us at localcooks@localcook.shop.
          
          Thank you for being part of the Local Cooks community!
          
          Local Cooks Team
          localcooks@localcook.shop
        `
      };
      await sendEmail(userConfirmationContent, {
        trackingId: `unsubscribe_confirmation_${email}_${Date.now()}`
      });
      logger.info(`\u2705 Unsubscribe request processed for: ${email}`);
      res.json({
        success: true,
        message: "Unsubscribe request processed successfully"
      });
    } catch (error) {
      logger.error("Error processing unsubscribe request:", error);
      res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.use("/api/manager", (await Promise.resolve().then(() => (init_manager(), manager_exports))).default);
  app2.use("/api/manager/notifications", (await Promise.resolve().then(() => (init_notifications(), notifications_exports))).default);
  app2.use("/api/chef/notifications", (await Promise.resolve().then(() => (init_chef_notifications(), chef_notifications_exports))).default);
  app2.use("/api", (await Promise.resolve().then(() => (init_kitchens(), kitchens_exports))).default);
  app2.use("/api", (await Promise.resolve().then(() => (init_bookings(), bookings_exports))).default);
  app2.use("/api", (await Promise.resolve().then(() => (init_equipment(), equipment_exports))).default);
  app2.use("/api", (await Promise.resolve().then(() => (init_storage_listings(), storage_listings_exports))).default);
  app2.use("/api/admin", (await Promise.resolve().then(() => (init_admin(), admin_exports))).default);
  app2.use("/api/webhooks", (await Promise.resolve().then(() => (init_webhooks(), webhooks_exports))).default);
  app2.use("/api", (await Promise.resolve().then(() => (init_portal_auth(), portal_auth_exports))).default);
  app2.use("/api/portal", (await Promise.resolve().then(() => (init_portal(), portal_exports))).default);
  app2.use("/api/chef", (await Promise.resolve().then(() => (init_chef(), chef_exports))).default);
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
init_logger();
import express2 from "express";
import fs6 from "fs";
import { nanoid } from "nanoid";
import path3 from "path";
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  logger.info(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const { createLogger, createServer: createViteServer } = await import("vite");
  const viteConfigPath = "../vite.config";
  const viteConfigModule = await import(viteConfigPath);
  const viteConfig = viteConfigModule.default;
  const viteLogger = createLogger();
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    if (req.originalUrl.startsWith("/api/")) {
      return next();
    }
    const url = req.originalUrl;
    try {
      const clientTemplate = path3.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs6.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path3.resolve(import.meta.dirname, "public");
  if (!fs6.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express2.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path3.resolve(distPath, "index.html"));
  });
}

// server/index.ts
init_security();
init_logger();
import pinoHttp from "pino-http";
var app = express3();
app.set("env", process.env.NODE_ENV || "development");
app.post("/api/webhooks/stripe", express3.raw({ type: "application/json" }));
app.use(express3.json({ limit: "12mb" }));
app.use(express3.urlencoded({ limit: "12mb", extended: true }));
registerSecurityMiddleware(app);
initializeFirebaseAdmin();
var isLocalDev2 = process.env.NODE_ENV === "development" && !process.env.VERCEL;
app.use(pinoHttp({
  logger: pinoInstance,
  // Only log API requests, skip static assets
  autoLogging: {
    ignore: (req) => !req.url?.startsWith("/api")
  },
  // Custom log level based on response status code
  customLogLevel: (_req, res, err) => {
    if (res.statusCode >= 500 || err) return "error";
    if (res.statusCode >= 400) return "warn";
    return "info";
  },
  // Attach useful request metadata to each log line
  customProps: (req) => ({
    userAgent: req.headers["user-agent"],
    ip: req.headers["x-forwarded-for"]?.split(",")[0]?.trim() || req.socket?.remoteAddress
  }),
  // Redact sensitive headers from logs
  serializers: {
    req: (req) => ({
      method: req.method,
      url: req.url
      // Do NOT log authorization or cookie headers
    }),
    res: (res) => ({
      statusCode: res.statusCode
    })
  },
  // Use quiet mode in local dev (pino-pretty handles formatting)
  // In production, let pino-http output standard structured logs
  quietReqLogger: isLocalDev2
}));
var routesInitialized = false;
var initPromise = (async () => {
  if (routesInitialized) return;
  try {
    log("[INIT] Starting route registration...");
    await registerRoutes(app);
    registerFirebaseRoutes(app);
    Sentry6.setupExpressErrorHandler(app);
    app.use((err, _req, res, _next) => {
      const status = err.status || err.statusCode || 500;
      const message = err.message || "Internal Server Error";
      const isProduction2 = process.env.NODE_ENV === "production" || !!process.env.VERCEL;
      const safeMessage = isProduction2 && status >= 500 ? "An unexpected error occurred. Please try again later." : message;
      res.status(status).json({ message: safeMessage });
      pinoInstance.error({ err, statusCode: status, path: _req.path }, `Express error handler [${status}]`);
    });
    routesInitialized = true;
    log("[ROUTES] All routes registered successfully");
    if (process.env.VERCEL) {
      log("[SERVERLESS] Running on Vercel - routes registered");
    } else {
      const { createServer: createServer2 } = await import("http");
      const server = createServer2(app);
      const port = process.env.PORT || (app.get("env") === "development" ? 5001 : 5e3);
      if (app.get("env") === "development") {
        await setupVite(app, server);
      } else {
        serveStatic(app);
      }
      server.listen(port, () => {
        log(`[LOCAL] Server running on http://localhost:${port}`);
      });
    }
  } catch (error) {
    logger.error("Failed to register routes:", error);
    throw error;
  }
})();
app.use(async (req, res, next) => {
  if (!routesInitialized) {
    await initPromise;
  }
  next();
});
var index_default = app;
export {
  index_default as default
};
