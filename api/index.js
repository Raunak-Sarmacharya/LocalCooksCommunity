// Auto-generated API file for Vercel deployment
// Source: server/routes.ts
// Generated: 2025-12-09T01:20:43.495Z
// 
// âš ï¸  DO NOT EDIT THIS FILE MANUALLY
// âš ï¸  All changes should be made in server/routes.ts
// âš ï¸  Run 'npm run sync-routes' to update this file

import { Pool } from '@neondatabase/serverless';
import connectPgSimple from 'connect-pg-simple';
import { randomBytes, scrypt, timingSafeEqual } from 'crypto';
import express from 'express';
import session from 'express-session';
import fs from 'fs';
import createMemoryStore from 'memorystore';
import multer from 'multer';
import path from 'path';
import { promisify } from 'util';
import { firebaseStorage } from './server/storage-firebase.js';
import { storage } from './server/storage.js';

// Setup
const app = express();
const scryptAsync = promisify(scrypt);
const MemoryStore = createMemoryStore(session);
const PgStore = connectPgSimple(session);

// {{MIDDLEWARE_SETUP}}

// Configure multer for file uploads
let upload;

try {
  // Check if we're in production
  const uploadIsProduction = process.env.VERCEL_ENV === 'production' || process.env.NODE_ENV === 'production';
  
  // File filter to only allow certain file types
  const fileFilter = (req, file, cb) => {
    // Allow PDF, JPG, JPEG, PNG files
    const allowedMimes = [
      'application/pdf',
      'image/jpeg',
      'image/jpg', 
      'image/png',
      'image/webp'
    ];
    
    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type. Only PDF, JPG, JPEG, PNG, and WebP files are allowed.'));
    }
  };

  if (uploadIsProduction) {
    // Production: Use memory storage for Vercel Blob
    const memoryStorage = multer.memoryStorage();
    upload = multer({
      storage: memoryStorage,
      fileFilter: fileFilter,
      limits: {
        fileSize: 10 * 1024 * 1024, // 10MB limit
      },
    });
  } else {
    // Development: Use disk storage
    const uploadsDir = path.join(process.cwd(), 'uploads', 'documents');
    
    // Only create directory in development
    if (!fs.existsSync(uploadsDir)) {
      fs.mkdirSync(uploadsDir, { recursive: true });
    }

    const diskStorage = multer.diskStorage({
      destination: (req, file, cb) => {
        cb(null, uploadsDir);
      },
      filename: (req, file, cb) => {
        // Generate unique filename: userId_documentType_timestamp_originalname
        const userId = req.session.userId || req.headers['x-user-id'] || 'unknown';
        const timestamp = Date.now();
        const documentType = file.fieldname; // 'foodSafetyLicense' or 'foodEstablishmentCert'
        const ext = path.extname(file.originalname);
        const baseName = path.basename(file.originalname, ext);
        
        const filename = `${userId}_${documentType}_${timestamp}_${baseName}${ext}`;
        cb(null, filename);
      }
    });

    upload = multer({
      storage: diskStorage,
      fileFilter: fileFilter,
      limits: {
        fileSize: 10 * 1024 * 1024, // 10MB limit
      },
    });
  }

  console.log('File upload configuration initialized successfully');
} catch (error) {
  console.error('Failed to initialize file upload configuration:', error);
  // Create a proper dummy upload middleware with all required methods
  const dummyMiddleware = (req, res, next) => {
    res.status(500).json({ message: "File upload not available in this environment" });
  };
  
  upload = {
    single: () => dummyMiddleware,
    fields: () => dummyMiddleware,
    array: () => dummyMiddleware,
    any: () => dummyMiddleware,
    none: () => dummyMiddleware
  };
}

// {{DATABASE_SETUP}}

// Database connection with small pool size for serverless
let pool;
let sessionStore;

try {
  if (process.env.DATABASE_URL) {
    pool = new Pool({
      connectionString: process.env.DATABASE_URL,
      max: 1 // Small pool for serverless
    });

    // Create PG session store
    sessionStore = new PgStore({
      pool: pool,
      createTableIfMissing: true,
      // Add automatic cleanup configuration
      pruneSessionInterval: 60 * 15, // Prune every 15 minutes (in seconds)
      errorLog: console.error,
      debugLog: console.log
    });

    console.log('Connected to database and initialized session store');

    // Create session table
    (async () => {
      try {
        await pool.query(`
          CREATE TABLE IF NOT EXISTS "session" (
            "sid" varchar NOT NULL COLLATE "default",
            "sess" json NOT NULL,
            "expire" timestamp(6) NOT NULL,
            CONSTRAINT "session_pkey" PRIMARY KEY ("sid")
          );
          CREATE INDEX IF NOT EXISTS "IDX_session_expire" ON "session" ("expire");
        `);
        console.log('Session table created or verified');
      } catch (err) {
        console.error('Error setting up session table:', err);
      }
    })();

    // Run initial session cleanup on startup
    (async () => {
      try {
        console.log('Running startup session cleanup...');
        const cleanupResult = await cleanupExpiredSessions();
        console.log(`Startup cleanup: Removed ${cleanupResult.cleaned} expired sessions`);
        
        const stats = await getSessionStats();
        console.log('Session stats after startup cleanup:', {
          total: stats.total_sessions,
          active: stats.active_sessions,
          expired: stats.expired_sessions
        });
      } catch (err) {
        console.error('Error during startup session cleanup:', err);
      }
    })();

  } else {
    console.log('DATABASE_URL not provided, using in-memory storage');
    sessionStore = new MemoryStore({
      checkPeriod: 86400000 // prune expired entries every 24h
    });
  }
} catch (error) {
  console.error('Database connection error:', error);
  // Fallback to memory store
  sessionStore = new MemoryStore({
    checkPeriod: 86400000 // prune expired entries every 24h
  });
}

// In-memory fallback for users
const users = new Map();

// Middleware
app.use(express.json({ limit: '12mb' }));
app.use(express.urlencoded({ limit: '12mb', extended: true }));

// Session setup
const sessionSecret = process.env.SESSION_SECRET || 'local-cooks-dev-secret';
const isProduction = process.env.NODE_ENV === 'production';

console.log('Setting up session with', {
  production: isProduction,
  storeType: pool ? 'PostgreSQL' : 'Memory',
  sessionSecret: sessionSecret ? 'Provided' : 'Missing'
});

app.use(session({
  secret: sessionSecret,
  resave: true,
  saveUninitialized: true,
  store: sessionStore,
  cookie: {
    secure: isProduction,
    httpOnly: true,
    maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
    sameSite: isProduction ? 'strict' : 'lax'
  }
}));

const getPortalUserLocation = async () => {
          try {
            const { portalUserLocationAccess } = await import('../shared/schema');
            const { eq } = await import('drizzle-orm');
            
            const accessRecords = await db.select()
              .from(portalUserLocationAccess)
              .where(eq(portalUserLocationAccess.portalUserId, portalUser.id));
            
            if (accessRecords.length > 0) {
              return accessRecords[0].locationId;
            }
            return null;
          } catch (error) {
            console.error('Error fetching portal user location:', error);
            return null;
          }
        };

// Helper functions extracted from server/routes.ts
async function hashPassword(password) {
  const salt = randomBytes(16).toString('hex');
  const hash = await scryptAsync(password, salt, 64);
  return `${salt}:${hash.toString('hex')}`;
}

async function comparePasswords(supplied, stored) {
  const [salt, key] = stored.split(':');
  const hashedBuffer = await scryptAsync(supplied, salt, 64);
  const keyBuffer = Buffer.from(key, 'hex');
  return timingSafeEqual(hashedBuffer, keyBuffer);
}

// Database helper functions
async function getUserByUsername(username) {
  if (!pool) {
    // Fallback to in-memory storage
    for (const [id, user] of users.entries()) {
      if (user.username === username) {
        return { id, ...user };
      }
    }
    return null;
  }

  try {
    const result = await pool.query('SELECT * FROM users WHERE username = $1', [username]);
    return result.rows[0] || null;
  } catch (error) {
    console.error('Error fetching user by username:', error);
    return null;
  }
}

async function getUser(id) {
  if (!pool) {
    return users.get(id) || null;
  }

  try {
    const result = await pool.query('SELECT * FROM users WHERE id = $1', [id]);
    return result.rows[0] || null;
  } catch (error) {
    console.error('Error fetching user:', error);
    return null;
  }
}

async function createUser(userData) {
  if (!pool) {
    const id = Date.now();
    users.set(id, { ...userData, id });
    return { id, ...userData };
  }

  try {
    const result = await pool.query(
      'INSERT INTO users (username, email, password_hash, full_name, created_at) VALUES ($1, $2, $3, $4, NOW()) RETURNING *',
      [userData.username, userData.email, userData.password_hash, userData.full_name]
    );
    return result.rows[0];
  } catch (error) {
    console.error('Error creating user:', error);
    throw error;
  }
}

// Microlearning helper functions
async function hasApprovedApplication(userId) {
  if (!pool) {
    console.log('No database connection, assuming no approved application');
    return false;
  }

  try {
    const result = await pool.query(
      'SELECT COUNT(*) FROM applications WHERE user_id = $1 AND status = $2',
      [userId, 'approved']
    );
    
    const count = parseInt(result.rows[0].count);
    console.log(`User ${userId} has ${count} approved applications`);
    return count > 0;
  } catch (error) {
    console.error('Error checking approved application:', error);
    return false;
  }
}

async function getMicrolearningProgress(userId) {
  if (!pool) {
    // Fallback to in-memory storage
    return {
      completedVideos: 0,
      videoProgress: {},
      accessLevel: 1,
      canAccessTraining: true
    };
  }

  try {
    // Create table if it doesn't exist
    await pool.query(`
      CREATE TABLE IF NOT EXISTS video_progress (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL,
        video_id INTEGER NOT NULL,
        progress DECIMAL(5,2) DEFAULT 0,
        completed BOOLEAN DEFAULT FALSE,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(user_id, video_id)
      )
    `);

    const result = await pool.query(
      'SELECT video_id, progress, completed FROM video_progress WHERE user_id = $1',
      [userId]
    );

    const videoProgress = {};
    let completedVideos = 0;

    result.rows.forEach(row => {
      videoProgress[row.video_id] = {
        progress: parseFloat(row.progress),
        completed: row.completed
      };
      if (row.completed) {
        completedVideos++;
      }
    });

    // Check if user has approved application for access control
    const hasApproved = await hasApprovedApplication(userId);
    
    return {
      completedVideos,
      videoProgress,
      accessLevel: hasApproved ? 10 : 1, // First video free, rest require approval
      canAccessTraining: true
    };
  } catch (error) {
    console.error('Error getting microlearning progress:', error);
    return {
      completedVideos: 0,
      videoProgress: {},
      accessLevel: 1,
      canAccessTraining: true
    };
  }
}

// Session cleanup functions
async function cleanupExpiredSessions() {
  if (!pool) {
    return { cleaned: 0, remaining: 0 };
  }

  try {
    const result = await pool.query(
      'DELETE FROM session WHERE expire < NOW() RETURNING sid'
    );
    
    const cleaned = result.rowCount || 0;
    
    const countResult = await pool.query('SELECT COUNT(*) as remaining FROM session');
    const remaining = parseInt(countResult.rows[0].remaining);
    
    return { cleaned, remaining };
  } catch (error) {
    console.error('Error cleaning up expired sessions:', error);
    return { cleaned: 0, remaining: 0 };
  }
}

async function getSessionStats() {
  if (!pool) {
    return {
      total_sessions: 0,
      active_sessions: 0,
      expired_sessions: 0
    };
  }

  try {
    const result = await pool.query(`
      SELECT 
        COUNT(*) as total_sessions,
        COUNT(CASE WHEN expire > NOW() THEN 1 END) as active_sessions,
        COUNT(CASE WHEN expire <= NOW() THEN 1 END) as expired_sessions
      FROM session
    `);
    
    return result.rows[0];
  } catch (error) {
    console.error('Error getting session stats:', error);
    return {
      total_sessions: 0,
      active_sessions: 0,
      expired_sessions: 0
    };
  }
}

app.get("/api/auth/facebook", (req, res, next) => { console.log("Starting Facebook auth flow");
    if (process.env.FACEBOOK_CLIENT_ID && process.env.FACEBOOK_CLIENT_SECRET) {
      passport.authenticate("facebook", {
        scope })(req, res, next);
    } else {
      console.error("Facebook OAuth credentials not configured");
      res.redirect("/login?error=facebook_not_configured");
    }
  });

app.get("/api/auth/instagram", (req, res, next) => { console.log("Starting Instagram auth flow");
    if (process.env.INSTAGRAM_CLIENT_ID && process.env.INSTAGRAM_CLIENT_SECRET) {
      passport.authenticate("instagram", {
        failureRedirect })(req, res, next);
    } else {
      console.error("Instagram OAuth credentials not configured");
      res.redirect("/login?error=instagram_not_configured");
    }
  });

app.post("/api/applications", 
    upload.fields([
      { name },
      { name }
    ]), 
    async (req, res) => { try {
        // Require authentication to submit an application
        if (!req.isAuthenticated()) {
          // Clean up uploaded files on error
          if (req.files) {
            const files = req.files as { [fieldname };
            Object.values(files).flat().forEach(file => {
              try {
                fs.unlinkSync(file.path);
              } catch (e) { console.error('Error cleaning up file }
            });
          }
          return res.status(401).json({ message });
        }

        // Validate the request body using Zod schema
        const parsedData = insertApplicationSchema.safeParse(req.body);

        if (!parsedData.success) { // Clean up uploaded files on validation error
          if (req.files) {
            const files = req.files as { [fieldname };
            Object.values(files).flat().forEach(file => {
              try {
                fs.unlinkSync(file.path);
              } catch (e) { console.error('Error cleaning up file }
            });
          }
          
          const validationError = fromZodError(parsedData.error);
          return res.status(400).json({ message });
        }

        // Ensure the application is associated with the current user
        // Override any userId in the request to prevent spoofing
        // Normalize phone number before storing (schema already does this via transform, but ensure it's done)
        const applicationData = { ...parsedData.data,
          userId };

        console.log('=== APPLICATION SUBMISSION WITH DOCUMENTS ===');
        console.log('Request details),
          bodyData: { foodSafetyLicense }
        });
        console.log('Form data);

        // Handle uploaded files and URL inputs
        const files = req.files as { [fieldname };
        
        // Handle file uploads
        if (files) {
          const isProduction = process.env.VERCEL_ENV === 'production' || process.env.NODE_ENV === 'production';
          
          if (files.foodSafetyLicense && files.foodSafetyLicense[0]) {
            console.log('ðŸ“„ Uploading food safety license file...');
            if (isProduction) {
              applicationData.foodSafetyLicenseUrl = await uploadToBlob(files.foodSafetyLicense[0], req.user.id);
            } else {
              applicationData.foodSafetyLicenseUrl = getFileUrl(files.foodSafetyLicense[0].filename);
            }
            console.log('âœ… Food safety license uploaded);
          }
          
          if (files.foodEstablishmentCert && files.foodEstablishmentCert[0]) {
            console.log('ðŸ“„ Uploading food establishment cert file...');
            if (isProduction) {
              applicationData.foodEstablishmentCertUrl = await uploadToBlob(files.foodEstablishmentCert[0], req.user.id);
            } else {
              applicationData.foodEstablishmentCertUrl = getFileUrl(files.foodEstablishmentCert[0].filename);
            }
            console.log('âœ… Food establishment cert uploaded);
          }
        }

        // Handle URL inputs from form (fallback if no files uploaded)
        if (req.body.foodSafetyLicenseUrl && !applicationData.foodSafetyLicenseUrl) { applicationData.foodSafetyLicenseUrl = req.body.foodSafetyLicenseUrl;
          console.log('ðŸ“„ Using provided food safety license URL }
        
        if (req.body.foodEstablishmentCertUrl && !applicationData.foodEstablishmentCertUrl) { applicationData.foodEstablishmentCertUrl = req.body.foodEstablishmentCertUrl;
          console.log('ðŸ“„ Using provided food establishment cert URL }

        // Set initial document status based on what w and user responses
        if (applicationData.foodSafetyLicenseUrl) {
          applicationData.foodSafetyLicenseStatus = "pending";
          console.log('âœ… Food safety license document provided, status set to pending');
        }
        
        if (applicationData.foodEstablishmentCertUrl) {
          applicationData.foodEstablishmentCertStatus = "pending";
          console.log('âœ… Food establishment cert document provided, status set to pending');
        }

        console.log('Final application data);

        // Create the application in storage
        const application = await storage.createApplication(applicationData);

        // Fetch the full application record to ensure all fields are present
        const fullApplication = await storage.getApplicationById(application.id);

        console.log('âœ… Application created successfully);

        // Send appropriate email notification for new application
        try { if (fullApplication && fullApplication.email) {
            const hasDocuments = !!(fullApplication.foodSafetyLicenseUrl || fullApplication.foodEstablishmentCertUrl);
            
            if (hasDocuments) {
              // Application submitted WITH documents - send combined email
              const emailContent = generateApplicationWithDocumentsEmail({
                fullName });

              await sendEmail(emailContent, { trackingId }_${Date.now()}`
              });
              console.log(`Application with documents email sent to ${fullApplication.email} for application ${fullApplication.id}`);
            } else { // Application submitted WITHOUT documents - prompt to upload
              const emailContent = generateApplicationWithoutDocumentsEmail({
                fullName });

              await sendEmail(emailContent, { trackingId }_${Date.now()}`
              });
              console.log(`Application without documents email sent to ${fullApplication.email} for application ${fullApplication.id}`);
            }
          } else { console.warn(`Cannot send new application email }
        } catch (emailError) { // Log the error but don't fail the request
          console.error("Error sending new application email }

        console.log('=== APPLICATION SUBMISSION COMPLETE ===');
        return res.status(201).json(application);
      } catch (error) { console.error("Error creating application };
          Object.values(files).flat().forEach(file => {
            try {
              // Only clean up files if they have a path (development mode)
              if (file.path) {
                fs.unlinkSync(file.path);
              }
            } catch (e) { console.error('Error cleaning up file }
          });
        }
        
        return res.status(500).json({ message });
      }
    }
  );

app.get("/api/applications", async (req, res) => { // Check if user is authenticated and is an admin
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message });
    }

    if (req.user.role !== "admin") { return res.status(403).json({ message });
    }

    try {
      const applications = await storage.getAllApplications();
      return res.status(200).json(applications);
    } catch (error) { console.error("Error fetching applications });
    }
  });

app.get("/api/applications/my-applications", async (req, res) => { // Check if user is authenticated
    if (!req.isAuthenticated()) {
      return res.status(401).json({ error });
    }

    try {
      const userId = req.user.id;
      const applications = await storage.getApplicationsByUserId(userId);
      return res.status(200).json(applications);
    } catch (error) { console.error("Error fetching user applications });
    }
  });

app.get("/api/applications/) => { try {
      const id = parseInt(req.params.id);

      if (isNaN(id)) {
        return res.status(400).json({ message });
      }

      const application = await storage.getApplicationById(id);

      if (!application) { return res.status(404).json({ message });
      }

      return res.status(200).json(application);
    } catch (error) { console.error("Error fetching application });
    }
  });

app.patch("/api/applications/) => { try {
      // Check if user is authenticated and is an admin
      console.log('Status update request - Auth info });

      if (!req.isAuthenticated()) { return res.status(401).json({ message });
      }

      if (req.user.role !== "admin") { return res.status(403).json({ message });
      }

      const id = parseInt(req.params.id);
      if (isNaN(id)) { return res.status(400).json({ message });
      }

      // Check if the application exists
      const application = await storage.getApplicationById(id);
      if (!application) { return res.status(404).json({ message });
      }

      // Validate the request body using Zod schema
      const parsedData = updateApplicationStatusSchema.safeParse({
        id,
        ...req.body
      });

      if (!parsedData.success) { const validationError = fromZodError(parsedData.error);
        return res.status(400).json({
          message });
      }

      // Update the application in storage
      const updatedApplication = await storage.updateApplicationStatus(parsedData.data);
      if (!updatedApplication) { return res.status(404).json({ message });
      }

      // Send email notification about status change
      try { if (updatedApplication.email) {
          const emailContent = generateStatusChangeEmail({
            fullName });

          await sendEmail(emailContent, { trackingId }_${updatedApplication.status}_${Date.now()}`
          });
          
          console.log(`Status change email sent to ${updatedApplication.email} for application ${updatedApplication.id}`);
        } else {
          console.warn(`Cannot send status change email for application ${updatedApplication.id});
        }
      } catch (emailError) { // Log the error but don't fail the request
        console.error("Error sending status change email }

      return res.status(200).json(updatedApplication);
    } catch (error) { console.error("Error updating application status });
    }
  });

app.patch("/api/delivery-partner-applications/) => { try {
      // Check if user is authenticated and is an admin
      console.log('Delivery partner status update request - Auth info });

      if (!req.isAuthenticated()) { return res.status(401).json({ message });
      }

      if (req.user.role !== "admin") { return res.status(403).json({ message });
      }

      const id = parseInt(req.params.id);
      if (isNaN(id)) { return res.status(400).json({ message });
      }

      // Check if the application exists
      const application = await storage.getDeliveryPartnerApplicationById(id);
      if (!application) { return res.status(404).json({ message });
      }

      // Validate the request body using Zod schema
      const parsedData = updateDeliveryPartnerApplicationStatusSchema.safeParse({
        id,
        ...req.body
      });

      if (!parsedData.success) { const validationError = fromZodError(parsedData.error);
        return res.status(400).json({
          message });
      }

      // Update the application in storage
      const updatedApplication = await storage.updateDeliveryPartnerApplicationStatus(parsedData.data);
      if (!updatedApplication) { return res.status(404).json({ message });
      }

      // Send email notification about status change
      try { if (updatedApplication.email) {
          const emailContent = generateDeliveryPartnerStatusChangeEmail({
            fullName });

          await sendEmail(emailContent, { trackingId }_${updatedApplication.status}_${Date.now()}`
          });
          
          console.log(`Delivery partner status change email sent to ${updatedApplication.email} for application ${updatedApplication.id}`);
        } else {
          console.warn(`Cannot send status change email for delivery partner application ${updatedApplication.id});
        }
      } catch (emailError) { // Log the error but don't fail the request
        console.error("Error sending delivery partner status change email }

      return res.status(200).json(updatedApplication);
    } catch (error) { console.error("Error updating delivery partner application status });
    }
  });

app.patch("/api/applications/) => { // Check if user is authenticated via session or X-User-ID header
    const userId = req.isAuthenticated() ? req.user.id  });

    if (!userId) { return res.status(401).json({ message });
    }

    try { const id = parseInt(req.params.id);

      if (isNaN(id)) {
        return res.status(400).json({ message });
      }

      // First get the application to verify ownership
      const application = await storage.getApplicationById(id);

      if (!application) { return res.status(404).json({ message });
      }

      // Check if the application belongs to the authenticated user
      if (application.userId !== userId) { return res.status(403).json({ message });
      }

      const updateData = { id,
        status };

      const updatedApplication = await storage.updateApplicationStatus(updateData);

      if (!updatedApplication) { return res.status(404).json({ message });
      }

      // Send email notification about application cancellation
      try { if (updatedApplication.email) {
          const emailContent = generateStatusChangeEmail({
            fullName });

          await sendEmail(emailContent, { trackingId }_${Date.now()}`
          });
          
          console.log(`Cancellation email sent to ${updatedApplication.email} for application ${updatedApplication.id}`);
        } else {
          console.warn(`Cannot send cancellation email for application ${updatedApplication.id});
        }
      } catch (emailError) { // Log the error but don't fail the request
        console.error("Error sending cancellation email }

      return res.status(200).json(updatedApplication);
    } catch (error) { console.error("Error cancelling application });
    }
  });

app.post("/api/test-status-email", async (req, res) => { try {
      // Check if user is authenticated and is an admin
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message });
      }

      if (req.user.role !== "admin") { return res.status(403).json({ message });
      }

      const { fullName, email, status } = req.body;

      // Generate and send a test email
      const emailContent = generateStatusChangeEmail({ fullName });

      const emailSent = await sendEmail(emailContent, { trackingId }_${status}_${Date.now()}`
      });

      if (emailSent) { console.log(`Test status email sent to }`);
        return res.status(200).json({ message });
      } else { return res.status(500).json({ message });
      }
    } catch (error) { console.error("Error sending test email });
    }
  });

app.post("/api/test-verification-email", async (req, res) => { try {
      // Check if user is authenticated and is an admin
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message });
      }

      if (req.user.role !== "admin") { return res.status(403).json({ message });
      }

      const { fullName, email, phone } = req.body;

      // Generate and send a test verification email
      const { generateFullVerificationEmail } = await import('./email.js');
      const emailContent = generateFullVerificationEmail({ fullName });

      const emailSent = await sendEmail(emailContent, { trackingId }_${Date.now()}`
      });

      if (emailSent) { console.log(`Test verification email sent to }`);
        return res.status(200).json({ message });
      } else { return res.status(500).json({ message });
      }
    } catch (error) { console.error("Error sending test verification email });
    }
  });

app.post("/api/test-document-status-email", async (req, res) => { try {
      // Check if user is authenticated and is an admin
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message });
      }

      if (req.user.role !== "admin") { return res.status(403).json({ message });
      }

      const { fullName, email, documentType, status, adminFeedback } = req.body;

      // Generate and send a test document status change email
      const emailContent = generateDocumentStatusChangeEmail({ fullName });

      const emailSent = await sendEmail(emailContent, { trackingId }_${documentType}_${status}_${Date.now()}`
      });

      if (emailSent) { console.log(`Test document status email sent to } for ${documentType});
        return res.status(200).json({ message });
      } else { return res.status(500).json({ message });
      }
    } catch (error) { console.error("Error sending test document status email });
    }
  });

app.post("/api/register", async (req, res) => { try {
      // Check if user already exists
      const existingUser = await storage.getUserByUsername(req.body.username);
      
      if (existingUser) {
        return res.status(400).json({ error });
      }
      
      // Hash password and create user
      const hashedPassword = await hashPassword(req.body.password);
      
      const user = await storage.createUser({ username });
      
      // Log the user in
      req.login(user, (err) => { if (err) {
          return res.status(500).json({ error });
        }
        
        return res.status(201).json({ id });
      });
    } catch (error) { console.error("Registration error });
    }
  });

app.post("/api/login", (req, res, next) => { passport.authenticate("local", (err, user, info } | undefined) => {
      if (err) {
        return next(err);
      }
      
      if (!user) { return res.status(401).json({ error });
      }
      
      req.login(user, (err) => {
        if (err) {
          return next(err);
        }
        
        return res.json({ id });
      });
    })(req, res, next);
  });

app.post("/api/admin-login", async (req, res) => {
    try {
      const { username, password } = req.body;

      if (!username || !password) { return res.status(400).json({ error });
      }

      console.log('Admin login attempt for);
      console.log('Storage type);
      console.log('DATABASE_URL exists);

      // Get admin user
      let admin;
      try { console.log('Calling storage.getUserByUsername...');
        admin = await storage.getUserByUsername(username);
        console.log('Storage call completed, user } catch (dbError) { console.error('Database error fetching user });
      }

      if (!admin) { console.log('Admin user not found });
      }
      
      console.log('User found);

      // Verify user is admin (only admins can use this endpoint)
      if (admin.role !== 'admin') { console.log('User is not an admin });
      }

      // Check password - first try exact match for 'localcooks' (legacy admin password)
      let passwordMatches = false;

      if (password === 'localcooks' && admin.role === 'admin') {
        passwordMatches = true;
        console.log('Admin password matched with hardcoded value');
      } else { // Compare with database password hash
        try {
          passwordMatches = await comparePasswords(password, admin.password);
          console.log('Password compared with stored hash } catch (error) { console.error('Error comparing passwords }
      }

      if (!passwordMatches) { return res.status(401).json({ error });
      }

      console.log('Admin login successful for);

      // Store session data for admin (both Passport and direct session)
      (req.session ).userId = admin.id;
      (req.session ).user = { ...admin, password };

      // Use Passport.js login to set session
      req.login(admin, (err) => { if (err) {
          console.error('Error setting session });
        }

        // Ensure session data is persisted
        req.session.save((saveErr) => { if (saveErr) {
            console.error('Error saving session });
          }

          // Remove sensitive info
          const { password, ...adminWithoutPassword } = admin;

          // Return user data
          return res.status(200).json(adminWithoutPassword);
        });
      });
    } catch (error) { console.error('Admin login error });
    }
  });

app.post("/api/manager-login", async (req, res) => {
    try {
      const { username, password } = req.body;

      if (!username || !password) { return res.status(400).json({ error });
      }

      console.log('Manager login attempt for);
      console.log('Storage type);
      console.log('DATABASE_URL exists);

      // Get manager user
      let manager;
      try { console.log('Calling storage.getUserByUsername...');
        manager = await storage.getUserByUsername(username);
        console.log('Storage call completed, user } catch (dbError) { console.error('Database error fetching user });
      }

      if (!manager) { console.log('Manager user not found });
      }
      
      console.log('User found);

      // Verify user is manager (only managers can use this endpoint)
      if (manager.role !== 'manager') { console.log('User is not a manager });
      }

      // Check password - compare with database password hash
      let passwordMatches = false;

      try { passwordMatches = await comparePasswords(password, manager.password);
        console.log('Password compared with stored hash } catch (error) { console.error('Error comparing passwords }

      if (!passwordMatches) { return res.status(401).json({ error });
      }

      console.log('Manager login successful for);

      // Store session data for manager (both Passport and direct session)
      (req.session ).userId = manager.id;
      (req.session ).user = { ...manager, password };

      // Use Passport.js login to set session
      req.login(manager, (err) => { if (err) {
          console.error('Error setting session });
        }

        // Ensure session data is persisted
        req.session.save((saveErr) => { if (saveErr) {
            console.error('Error saving session });
          }

          // Remove sensitive info
          const { password, ...managerWithoutPassword } = manager;

          // Return user data
          return res.status(200).json(managerWithoutPassword);
        });
      });
    } catch (error) { console.error('Manager login error });
    }
  });

app.get("/api/user-exists", async (req, res) => { const username = req.query.username ;
    if (!username) {
      return res.status(400).json({ error });
    }
    const user = await storage.getUserByUsername(username);
    res.json({ exists });
  });

app.get("/api/user-session", async (req, res) => { try {
      const user = await getAuthenticatedUser(req);
      
      if (!user) {
        return res.status(401).json({ error });
      }

      // Fetch full user data including has_seen_welcome from database
      const fullUser = await storage.getUser(user.id);
      const { password, ...userWithoutPassword } = (fullUser || user) ;
      
      return res.json({ ...userWithoutPassword,
        authMethod });
    } catch (error) { console.error("Error checking user session });
    }
  });

app.get("/api/get-users", async (req, res) => { try {
      if (!pool) {
        return res.status(500).json({ error });
      }

      const { search } = req.query;

      let query: string;
      let params = [];

      if (search && typeof search === 'string' && search.trim()) {
        // Search by username (which is usually email) or application data
        query = `
          SELECT 
            u.id,
            u.username,
            COALESCE(a.email, u.username) ,
            COALESCE(a.full_name, 
              CASE 
                WHEN u.username LIKE '%@%' THEN SPLIT_PART(u.username, '@', 1)
                ELSE u.username 
              END
            ) ,
            u.role
          FROM users u
          LEFT JOIN applications a ON u.id = a.user_id
          WHERE 
            LOWER(u.username) LIKE LOWER($1) OR 
            LOWER(COALESCE(a.email, '')) LIKE LOWER($1) OR
            LOWER(COALESCE(a.full_name, '')) LIKE LOWER($1)
          ORDER BY 
            u.role = 'admin' DESC,
            u.username
          LIMIT 20
        `;
        params = [`%${search.trim()}%`];
      } else {
        // Return all users with their info
        query = `
          SELECT 
            u.id,
            u.username,
            COALESCE(a.email, u.username) ,
            COALESCE(a.full_name, 
              CASE 
                WHEN u.username LIKE '%@%' THEN SPLIT_PART(u.username, '@', 1)
                ELSE u.username 
              END
            ) ,
            u.role
          FROM users u
          LEFT JOIN applications a ON u.id = a.user_id
          ORDER BY 
            u.role = 'admin' DESC,
            u.username
          LIMIT 50
        `;
      }

      const result = await pool.query(query, params);

      // Format the response for the frontend
      const users = result.rows.map((user) => ({ id } (${user.email})` // For dropdown display
      }));

      res.status(200).json({ users });
    } catch (error) { console.error("Error fetching users });
    }
  });

app.post("/api/upload-file", 
    upload.single('file'), 
    async (req, res) => {
      try {
        // Check if user is authenticated
        if (!req.isAuthenticated()) {
          // Clean up uploaded file (development only)
          if (req.file && req.file.path) {
            try {
              fs.unlinkSync(req.file.path);
            } catch (e) { console.error('Error cleaning up file }
          }
          return res.status(401).json({ error });
        }

        if (!req.file) { return res.status(400).json({ error });
        }

        const isProduction = process.env.VERCEL_ENV === 'production' || process.env.NODE_ENV === 'production';
        let fileUrl: string;
        let fileName: string;

        if (isProduction) {
          // Upload to Vercel Blob in production
          fileUrl = await uploadToBlob(req.file, req.user.id);
          // Extract filename from Vercel Blob URL for response
          fileName = fileUrl.split('/').pop() || req.file.originalname;
        } else {
          // Use local storage in development
          fileUrl = getFileUrl(req.file.filename);
          fileName = req.file.filename;
        }

        // Return success response with file information
        return res.status(200).json({ success,
          url,
          fileName,
          size });
      } catch (error) { console.error("File upload error } catch (e) { console.error('Error cleaning up file }
        }
        
        return res.status(500).json({ error });
      }
    }
  );

app.get("/api/files/documents/) => { try {
      // Check if user is authenticated
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message });
      }

      const filename = req.params.filename;
      const filePath = path.join(process.cwd(), 'uploads', 'documents', filename);
      
      // Check if file exists
      if (!fs.existsSync(filePath)) { return res.status(404).json({ message });
      }

      // Extract userId from filename (format)
      const fileUserId = parseInt(filename.split('_')[0]);
      
      // Allow access if user owns the file or is admin
      if (req.user.id !== fileUserId && req.user.role !== "admin") { return res.status(403).json({ message });
      }

      // Get file info
      const stat = fs.statSync(filePath);
      const ext = path.extname(filename).toLowerCase();
      
      // Set appropriate content type
      let contentType = 'application/octet-stream';
      if (ext === '.pdf') {
        contentType = 'application/pdf';
      } else if (['.jpg', '.jpeg'].includes(ext)) {
        contentType = 'image/jpeg';
      } else if (ext === '.png') {
        contentType = 'image/png';
      } else if (ext === '.webp') {
        contentType = 'image/webp';
      }

      res.setHeader('Content-Type', contentType);
      res.setHeader('Content-Length', stat.size);
      res.setHeader('Content-Disposition', `inline; filename="${filename}"`);
      
      // Stream the file
      const readStream = fs.createReadStream(filePath);
      readStream.pipe(res);
    } catch (error) { console.error("Error serving file });
    }
  });

app.patch("/api/applications/) => { // Check content type to decide whether to use multer
      const contentType = req.get('Content-Type') || '';
      
      if (contentType.includes('multipart/form-data')) {
        // Use multer for file uploads
        const fileUploadMiddleware = upload.fields([
          { name },
          { name }
        ]);
        fileUploadMiddleware(req, res, next);
      } else {
        // Skip multer for JSON requests
        next();
      }
    },
    async (req, res) => { try {
        // Check if user is authenticated
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message });
        }

        const applicationId = parseInt(req.params.id);
        if (isNaN(applicationId)) { return res.status(400).json({ message });
        }

        // Get the application to verify ownership and status
        const application = await storage.getApplicationById(applicationId);
        if (!application) { // Clean up uploaded files
          if (req.files) {
            const files = req.files as { [fieldname };
            Object.values(files).flat().forEach(file => {
              try {
                fs.unlinkSync(file.path);
              } catch (e) { console.error('Error cleaning up file }
            });
          }
          return res.status(404).json({ message });
        }

        // Check if user owns the application or is admin
        if (application.userId !== req.user.id && req.user.role !== "admin") { // Clean up uploaded files
          if (req.files) {
            const files = req.files as { [fieldname };
            Object.values(files).flat().forEach(file => {
              try {
                fs.unlinkSync(file.path);
              } catch (e) { console.error('Error cleaning up file }
            });
          }
          return res.status(403).json({ message });
        }

        // Check if application status allows document uploads
        if (application.status === 'cancelled' || application.status === 'rejected') { // Clean up uploaded files
          if (req.files) {
            const files = req.files as { [fieldname };
            Object.values(files).flat().forEach(file => {
              try {
                fs.unlinkSync(file.path);
              } catch (e) { console.error('Error cleaning up file }
            });
          }
          return res.status(400).json({ message });
        }

        const updateData = {
          id,
        };

        // Check if this is a file upload request or JSON request
        const contentType = req.get('Content-Type') || '';
        const isFileUpload = contentType.includes('multipart/form-data');

        if (isFileUpload) { // Handle multipart file uploads
          const files = req.files as { [fieldname };
          const isProduction = process.env.VERCEL_ENV === 'production' || process.env.NODE_ENV === 'production';

          // Handle food safety license file
          if (files && files.foodSafetyLicense && files.foodSafetyLicense[0]) {
            // Delete old file if it exists and is a file path (not URL) - development only
            if (!isProduction && application.foodSafetyLicenseUrl && application.foodSafetyLicenseUrl.startsWith('/api/files/')) {
              const oldFilename = application.foodSafetyLicenseUrl.split('/').pop();
              if (oldFilename) {
                const oldFilePath = path.join(process.cwd(), 'uploads', 'documents', oldFilename);
                deleteFile(oldFilePath);
              }
            }
            
            if (isProduction) {
              updateData.foodSafetyLicenseUrl = await uploadToBlob(files.foodSafetyLicense[0], req.user.id);
            } else {
              const filename = files.foodSafetyLicense[0].filename;
              updateData.foodSafetyLicenseUrl = getFileUrl(filename);
            }
          }

          // Handle food establishment cert file  
          if (files && files.foodEstablishmentCert && files.foodEstablishmentCert[0]) {
            // Delete old file if it exists and is a file path (not URL) - development only
            if (!isProduction && application.foodEstablishmentCertUrl && application.foodEstablishmentCertUrl.startsWith('/api/files/')) {
              const oldFilename = application.foodEstablishmentCertUrl.split('/').pop();
              if (oldFilename) {
                const oldFilePath = path.join(process.cwd(), 'uploads', 'documents', oldFilename);
                deleteFile(oldFilePath);
              }
            }
            
            if (isProduction) {
              updateData.foodEstablishmentCertUrl = await uploadToBlob(files.foodEstablishmentCert[0], req.user.id);
            } else {
              const filename = files.foodEstablishmentCert[0].filename;
              updateData.foodEstablishmentCertUrl = getFileUrl(filename);
            }
          }

          // Handle URL inputs from form data if no files uploaded
          if (req.body.foodSafetyLicenseUrl && !updateData.foodSafetyLicenseUrl) {
            updateData.foodSafetyLicenseUrl = req.body.foodSafetyLicenseUrl;
          }

          if (req.body.foodEstablishmentCertUrl && !updateData.foodEstablishmentCertUrl) {
            updateData.foodEstablishmentCertUrl = req.body.foodEstablishmentCertUrl;
          }
        } else {
          // Handle JSON requests (from our new upload system)
          if (req.body.foodSafetyLicenseUrl) {
            updateData.foodSafetyLicenseUrl = req.body.foodSafetyLicenseUrl;
          }

          if (req.body.foodEstablishmentCertUrl) {
            updateData.foodEstablishmentCertUrl = req.body.foodEstablishmentCertUrl;
          }
        }

        // Update the application documents
        const updatedApplication = await storage.updateApplicationDocuments(updateData);

        if (!updatedApplication) { return res.status(404).json({ message });
        }

        return res.status(200).json(updatedApplication);
      } catch (error) { console.error("Error updating application documents };
          Object.values(files).flat().forEach(file => {
            try {
              fs.unlinkSync(file.path);
            } catch (e) { console.error('Error cleaning up file }
          });
        }
        
        return res.status(500).json({ message });
      }
    }
  );

app.patch("/api/applications/) => { try {
      // Check if user is authenticated and is an admin
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message });
      }

      if (req.user.role !== "admin") { return res.status(403).json({ message });
      }

      const applicationId = parseInt(req.params.id);
      if (isNaN(applicationId)) { return res.status(400).json({ message });
      }

      // Validate the request body using Zod schema
      const parsedData = updateDocumentVerificationSchema.safeParse({ id,
        ...req.body,
        documentsReviewedBy });

      if (!parsedData.success) { const validationError = fromZodError(parsedData.error);
        return res.status(400).json({
          message });
      }

      // Update the application document verification
      const updatedApplication = await storage.updateApplicationDocumentVerification(parsedData.data);

      if (!updatedApplication) { return res.status(404).json({ message });
      }

      console.log(`Document verification updated for application ${applicationId});

      // Check if both documents are approved, then update user verification status
      if (updatedApplication.foodSafetyLicenseStatus === "approved" && 
          (!updatedApplication.foodEstablishmentCertUrl || updatedApplication.foodEstablishmentCertStatus === "approved")) {
        await storage.updateUserVerificationStatus(updatedApplication.userId!, true);
        console.log(`User ${updatedApplication.userId} h fully verified`);
        
        // NOTE: Full verification email is handled by api/index.js in production
        // Removed duplicate email logic to prevent double emails
      }

      // Check if all documents are approved and send consolidated email
      try { if (updatedApplication.email) {
          // Check if all documents are approved
          const hasFoodSafetyLicense = updatedApplication.foodSafetyLicenseUrl;
          const hasFoodEstablishmentCert = updatedApplication.foodEstablishmentCertUrl;
          
          const foodSafetyApproved = updatedApplication.foodSafetyLicenseStatus === "approved";
          const foodEstablishmentApproved = !hasFoodEstablishmentCert || updatedApplication.foodEstablishmentCertStatus === "approved";
          
          // If all documents are approved, send consolidated email
          if (foodSafetyApproved && foodEstablishmentApproved) {
            const approvedDocuments = [];
            if (hasFoodSafetyLicense) approvedDocuments.push("Food Safety License");
            if (hasFoodEstablishmentCert) approvedDocuments.push("Food Establishment Certificate");
            
            const emailContent = generateChefAllDocumentsApprovedEmail({
              fullName });

            await sendEmail(emailContent, { trackingId }_${Date.now()}`
            });
            
            console.log(`All documents approved email sent to ${updatedApplication.email} for application ${updatedApplication.id}`);
          }
        } else {
          console.warn(`Cannot send all documents approved email for application ${updatedApplication.id});
        }
      } catch (emailError) { // Log the error but don't fail the request
        console.error("Error sending all documents approved email }

      return res.status(200).json(updatedApplication);
    } catch (error) { console.error("Error updating application document verification });
    }
  });

app.get("/api/microlearning/progress/) => { try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message });
      }

      const userId = parseInt(req.params.userId);
      
      // Verify user can access this data (either their own or admin)
      if (req.user.id !== userId && req.user.role !== 'admin') { return res.status(403).json({ message });
      }

      const progress = await storage.getMicrolearningProgress(userId);
      const completionStatus = await storage.getMicrolearningCompletion(userId);
      const hasApproval = await hasApprovedApplication(userId);
      
      // Admins and completed users have unrestricted access regardless of application status
      const isAdmin = req.user.role === 'admin';
      const isCompleted = completionStatus.confirmed || false;
      const accessLevel = isAdmin || hasApproval || isCompleted ? 'full' : 'limited';

      res.json({ success,
        progress });
    } catch (error) { console.error('Error fetching microlearning progress });
    }
  });

app.post("/api/microlearning/progress", async (req, res) => { try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message });
      }

      const { userId, videoId, progress, completed, completedAt, watchedPercentage } = req.body;
      
      // Verify user can update this data (either their own or admin)
      if (req.user.id !== userId && req.user.role !== 'admin') { return res.status(403).json({ message });
      }

      // Check if user h application for videos beyond the first one
      const hasApproval = await hasApprovedApplication(userId);
      const completionStatus = await storage.getMicrolearningCompletion(userId);
      const isCompleted = completionStatus.confirmed || false;
      const firstVideoId = 'basics-cross-contamination'; // First video that everyone can access
      const isAdmin = req.user.role === 'admin';
      
      // Admins and completed users have unrestricted access to all videos
      if (!hasApproval && !isAdmin && !isCompleted && videoId !== firstVideoId) { return res.status(403).json({ 
          message });
      }

      // Accept completion status 
      const actualCompleted = completed;

      const progressData = { userId,
        videoId,
        progress };

      await storage.updateVideoProgress(progressData);

      res.json({ success,
        message });
    } catch (error) { console.error('Error updating video progress });
    }
  });

app.post("/api/microlearning/complete", async (req, res) => { try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message });
      }

      const { userId, completionDate, videoProgress } = req.body;
      
      // Verify user can complete this (either their own or admin)
      if (req.user.id !== userId && req.user.role !== 'admin') { return res.status(403).json({ message });
      }

      // Check if user h application to complete full training
      const hasApproval = await hasApprovedApplication(userId);
      const isAdmin = req.user.role === 'admin';
      
      // Admins can complete certification without application approval
      // Regular users need approval unless they're completing 
      if (!hasApproval && !isAdmin) { return res.status(403).json({ 
          message });
      }

      // Verify all required videos are completed (2 comprehensive modules)
      const requiredVideos = [
        // Food Safety Basics Module (14 videos)
        'basics-personal-hygiene', 'basics-temperature-danger', 'basics-cross-contamination',
        'basics-allergen-awareness', 'basics-food-storage', 'basics-cooking-temps',
        'basics-cooling-reheating', 'basics-thawing', 'basics-receiving', 'basics-fifo',
        'basics-illness-reporting', 'basics-pest-control', 'basics-chemical-safety', 'basics-food-safety-plan',
        // Safety and Hygiene How-To's Module (8 videos)
        'howto-handwashing', 'howto-sanitizing', 'howto-thermometer', 'howto-cleaning-schedule',
        'howto-equipment-cleaning', 'howto-uniform-care', 'howto-wound-care', 'howto-inspection-prep'
      ];
      const completedVideos = videoProgress.filter((v) => v.completed).map((v) => v.videoId);
      const allRequired = requiredVideos.every((videoId) => completedVideos.includes(videoId));

      if (!allRequired) { return res.status(400).json({ 
          message });
      }

      // Get user details for certificate generation
      const user = await storage.getUser(userId);
      if (!user) { return res.status(404).json({ message });
      }

      // Create completion record
      const completionData = { userId,
        completedAt };

      await storage.createMicrolearningCompletion(completionData);

      // Integration with Always Food Safe API (if configured)
      let alwaysFoodSafeResult = null;
      if (isAlwaysFoodSafeConfigured()) { try {
          alwaysFoodSafeResult = await submitToAlwaysFoodSafe({
            userId, userName }@localcooks.ca`, // Placeholder email since User type doesn't have email
            completionDate),
            videoProgress
          });
        } catch (afsError) { console.error('Always Food Safe API error }
      }
      
      res.json({ success,
        message });
    } catch (error) { console.error('Error completing microlearning });
    }
  });

app.get("/api/microlearning/completion/) => { try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message });
      }

      const userId = parseInt(req.params.userId);
      
      // Verify user can access this completion (either their own or admin)
      if (req.user.id !== userId && req.user.role !== 'admin') { return res.status(403).json({ message });
      }

      const completion = await storage.getMicrolearningCompletion(userId);
      
      if (!completion) { return res.status(404).json({ message });
      }

      res.json(completion);
    } catch (error) { console.error('Error getting microlearning completion status });
    }
  });

app.get("/api/microlearning/certificate/) => { try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message });
      }

      const userId = parseInt(req.params.userId);
      
      // Verify user can access this certificate (either their own or admin)
      if (req.user.id !== userId && req.user.role !== 'admin') { return res.status(403).json({ message });
      }

      const completion = await storage.getMicrolearningCompletion(userId);
      if (!completion || !completion.confirmed) { return res.status(404).json({ message });
      }

      const user = await storage.getUser(userId);
      if (!user) { return res.status(404).json({ message });
      }

      // For now, return a placeholder certificate URL
      const certificateUrl = `/api/certificates/microlearning-${userId}-${Date.now()}.pdf`;

      res.json({ success,
        certificateUrl,
        completionDate });
    } catch (error) { console.error('Error generating certificate });
    }
  });

app.post("/api/auth/forgot-password", async (req, res) => {
    try {
      const { email } = req.body;

      if (!email) { return res.status(400).json({ message });
      }

      // Check if user exists
      const user = await storage.getUserByEmail(email);
      if (!user) { // Don't reveal if user exists or not for security
        return res.status(200).json({ 
          message });
      }

      // Generate reset token (expires in 1 hour)
      const crypto = await import('crypto');
      const resetToken = crypto.randomBytes(32).toString('hex');
      const resetTokenExpiry = new Date(Date.now() + 3600000); // 1 hour from now
      
      // Store reset token in database
      await storage.storePasswordResetToken(user.id, resetToken, resetTokenExpiry);

      // Generate reset URL
      const resetUrl = `${ process.env.BASE_URL || 'http }/auth/reset-password?token=${resetToken}`;

      // Send password reset email
      const { generatePasswordResetEmail } = await import('./email.js');
      const emailContent = generatePasswordResetEmail({ fullName });

      const emailSent = await sendEmail(emailContent, { trackingId }_${Date.now()}`
      });

      if (emailSent) {
        console.log(`Password reset email sent to ${email}`);
        return res.status(200).json({ message });
      } else {
        console.error(`Failed to send password reset email to ${email}`);
        return res.status(500).json({ message });
      }
    } catch (error) { console.error("Error in forgot password });
    }
  });

app.post("/api/auth/reset-password", async (req, res) => {
    try {
      const { token, newPassword } = req.body;

      if (!token || !newPassword) { return res.status(400).json({ message });
      }

      // Validate password strength
      if (newPassword.length < 8) { return res.status(400).json({ message });
      }

      // Verify reset token and get user
      const user = await storage.getUserByResetToken(token);
      if (!user) { return res.status(400).json({ message });
      }

      // Update password
      const bcrypt = await import('bcryptjs');
      const hashedPassword = await bcrypt.hash(newPassword, 12);
      await storage.updateUserPassword(user.id, hashedPassword);

      // Clear reset token
      await storage.clearPasswordResetToken(user.id);

      console.log(`Password successfully reset for user ${user.id}`);
      return res.status(200).json({ message });

    } catch (error) { console.error("Error in reset password });
    }
  });

app.post("/api/auth/send-verification-email", async (req, res) => {
    try {
      const { email, fullName } = req.body;

      if (!email || !fullName) { return res.status(400).json({ message });
      }

      // Generate verification token
      const crypto = await import('crypto');
      const verificationToken = crypto.randomBytes(32).toString('hex');
      const verificationTokenExpiry = new Date(Date.now() + 86400000); // 24 hours from now
      
      // Store verification token in database directly (bypassing storage interface for now)
      const { pool } = await import('./db.js');
      await pool.query(`
        INSERT INTO email_verification_tokens (email, token, expires_at, created_at) 
        VALUES ($1, $2, $3, NOW()) 
        ON CONFLICT (email) DO UPDATE SET token = $2, expires_at = $3, created_at = NOW()
      `, [email, verificationToken, verificationTokenExpiry]);

      // Generate verification URL
      const verificationUrl = `${ process.env.BASE_URL || 'http }/auth/verify-email?token=${verificationToken}`;

      // Send verification email
      const { sendEmail, generateEmailVerificationEmail } = await import('./email.js');
      const emailContent = generateEmailVerificationEmail({
        fullName,
        email,
        verificationToken,
        verificationUrl
      });

      const emailSent = await sendEmail(emailContent, { trackingId }_${Date.now()}`
      });

      if (emailSent) {
        console.log(`Email verification sent to ${email}`);
        return res.status(200).json({ message });
      } else {
        console.error(`Failed to send verification email to ${email}`);
        return res.status(500).json({ message });
      }
    } catch (error) { console.error("Error sending verification email });
    }
  });

app.get("/api/auth/verify-email", async (req, res) => {
    try {
      const { token } = req.query;

      if (!token || typeof token !== 'string') { return res.status(400).json({ message });
      }

      // Verify token and get email - using direct database query
      const { pool } = await import('./db.js');
      const result = await pool.query(
        'SELECT email FROM email_verification_tokens WHERE token = $1 AND expires_at > NOW()',
        [token]
      );

      if (result.rows.length === 0) { return res.status(400).json({ message });
      }

      const { email } = result.rows[0];

      // Mark email  - need to update Firebase user too
      await pool.query('UPDATE users SET is_verified = true, updated_at = NOW() WHERE email = $1', [email]);

      // Also update the user in the users table (using Firebase UID)
      await pool.query('UPDATE users SET is_verified = true, updated_at = NOW() WHERE email = $1', [email]);

      // Clear verification token
      await pool.query('DELETE FROM email_verification_tokens WHERE token = $1', [token]);

      console.log(`Email verified successfully);
      
      // Redirect to success page
      return res.redirect(`${ process.env.BASE_URL || 'http }/auth?verified=true`);

    } catch (error) { console.error("Error in email verification });
    }
  });

app.post('/api/admin/send-promo-email', async (req, res) => { try {
      console.log(`POST /api/admin/send-promo-email - Session ID }, User ID);
      
      // Check if user is authenticated
      if (!req.isAuthenticated || !req.isAuthenticated() || !req.user) { console.log('Promo email request - User not authenticated');
        return res.status(401).json({ error });
      }

      // Check if user is admin
      if (req.user.role !== 'admin') {
        console.log(`Promo email request - User ${req.user.id} is not admin (role)`);
        return res.status(403).json({ error });
      }

      const { 
        email, 
        customEmails,
        emailMode,
        recipients,
        promoCode, 
        promoCodeLabel, 
        message, 
        customMessage, 
        greeting,
        buttonText, 
        orderUrl, 
        subject, 
        previewText,
        designSystem,
        isPremium,
        sections,
        header,
        footer,
        usageSteps,
        emailContainer,
        dividers,
        promoCodeStyling,
        promoStyle,
        customDesign
      } = req.body;

      // Handle both customMessage and message fields (different frontend components use different names)
      const messageContent = customMessage || message;

      console.log('Promo email request - Auth info);

      // Determine target emails - support both old and new formats
      let targetEmails = [];
      
      if (recipients && Array.isArray(recipients) && recipients.length > 0) { // New unified format - extract emails from recipients array
        targetEmails = recipients.map((recipient) => 
          typeof recipient === 'string' ? recipient  } else if (emailMode === 'custom' && customEmails && Array.isArray(customEmails)) {
        // Old custom email format
        targetEmails = customEmails;
      } else if (email) {
        // Old single email format
        targetEmails = [email];
      }

      // Validate that we have at least one email
      if (targetEmails.length === 0) { console.log('Promo email request - No valid email addresses provided');
        return res.status(400).json({ error });
      }

      // Promo code is now optional - if empty, it will be a general company email
      if (promoCode && promoCode.length > 0 && promoCode.length < 3) { console.log('Promo email request - Invalid promo code length');
        return res.status(400).json({ error });
      }

      if (!messageContent || messageContent.length < 10) { console.log('Promo email request - Invalid message });
        return res.status(400).json({ error });
      }

      console.log('Promo email request - Validation passed, generating email');

      console.log(`Promo email request - Sending to ${targetEmails.length} recipient(s)`);

      // Send emails to all recipients
      const results = [];
      let successCount = 0;
      let failureCount = 0;

      for (const targetEmail of targetEmails) { try {
          // Generate promo code email for each recipient
          const emailContent = generatePromoCodeEmail({
            email, promoCode, promoCodeLabel }
          }, footer);

          // Send email
          const emailSent = await sendEmail(emailContent, { trackingId }_${Date.now()}`
          });

          if (emailSent) {
            console.log(`Promo email sent successfully to ${targetEmail}`);
            results.push({ email, status });
            successCount++;
          } else {
            console.error(`Failed to send promo email to ${targetEmail}`);
            results.push({ email, status });
            failureCount++;
          }
        } catch (error) {
          console.error(`Error sending promo email to ${targetEmail});
          results.push({ email, status });
          failureCount++;
        }
      }

      // Return results
      if (successCount > 0) { res.json({ 
          success, message } successful, ${failureCount} failed`, results, promoCode, summary);
      } else { res.status(500).json({ 
          error });
      }
    } catch (error) { console.error('Error sending promo email });
    }
  });

app.post('/api/admin/test-email', async (req, res) => { try {
      console.log(`POST /api/admin/test-email - Session ID }, User ID);
      
      // Check if user is authenticated
      if (!req.isAuthenticated || !req.isAuthenticated() || !req.user) { console.log('Test email request - User not authenticated');
        return res.status(401).json({ error });
      }

      // Check if user is admin
      if (req.user.role !== 'admin') {
        console.log(`Test email request - User ${req.user.id} is not admin (role)`);
        return res.status(403).json({ error });
      }

      const { 
        email, 
        subject, 
        previewText, 
        sections, 
        header, 
        footer,
        usageSteps,
        emailContainer,
        customDesign 
      } = req.body;

      // Validate required fields
      if (!email) { return res.status(400).json({ error });
      }

      console.log('Test email request - Validation passed, generating test email');

      // Generate a simple test email
      const emailContent = generatePromoCodeEmail({ email, promoCode }
        }, footer);

      // Send test email
      const emailSent = await sendEmail(emailContent, { trackingId }_${Date.now()}`
      });

      if (emailSent) {
        console.log(`Test email sent successfully to ${email}`);
        res.json({ success, 
          message });
      } else {
        console.error(`Failed to send test email to ${email}`);
        res.status(500).json({ error });
      }
    } catch (error) { console.error('Error sending test email });
    }
  });

app.post('/api/user/seen-welcome', async (req, res) => { try {
      if (!req.isAuthenticated || !req.isAuthenticated() || !req.user) {
        return res.status(401).json({ error });
      }
      const user = req.user;
      await storage.setUserHasSeenWelcome(user.id);
      res.json({ success });
    } catch (error) { console.error('Error setting has_seen_welcome });
    }
  });

app.post('/api/unsubscribe', async (req, res) => {
    try {
      const { email, reason, feedback, timestamp } = req.body;

      if (!email) { return res.status(400).json({ 
          success, 
          message });
      }

      // Validate email format
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) { return res.status(400).json({ 
          success, 
          message });
      }

      // Create unsubscribe notification email content
      const unsubscribeNotificationContent = { to }`,
        html: `
          <div style="font-family, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f9fafb;">
            <div style="background: linear-gradient(135deg, #F51042 0%, #FF5470 100%); padding: 20px; border-radius: 8px 8px 0 0; text-align: center;">
              <h1 style="color: white; margin: 0; font-size: 24px;">Local Cooks - Unsubscribe Request</h1>
            </div>
            
            <div style="background: white; padding: 30px; border-radius: 0 0 8px 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
              <h2 style="color: #1f2937; margin-top: 0;">New Unsubscribe Request</h2>
              
              <div style="background: #fef2f2; border-left: 4px solid #ef4444; padding: 15px; margin: 20px 0;">
                <p style="margin: 0; color: #dc2626; font-weight: 600;">
                  ðŸ“§ Email: <span style="font-weight: normal;">${email}</span>
                </p>
              </div>
              
              <div style="margin: 20px 0;">
                <h3 style="color: #374151; margin-bottom: 10px;">Request Details:</h3>
                <ul style="color: #6b7280; line-height: 1.6;">
                  <li><strong>Timestamp:</strong> ${new Date(timestamp).toLocaleString()}</li>
                  <li><strong>Reason:</strong> ${reason || 'Not specified'}</li>
                  ${ feedback ? `<li><strong>Feedback }</li>` : ''}
                </ul>
              </div>
              
              <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 6px; padding: 15px; margin: 20px 0;">
                <h4 style="color: #0369a1; margin: 0 0 10px 0;">Action Required:</h4>
                <p style="color: #0c4a6e; margin: 0; font-size: 14px;">
                  Please manually remove <strong>${email}</strong> from all email lists and marketing databases within 24 hours.
                </p>
              </div>
              
              <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb;">
                <p style="color: #6b7280; font-size: 12px; margin: 0;">
                  This is an automated notification from the Local Cooks unsubscribe system.
                </p>
              </div>
            </div>
          </div>
        `,
        text: `
          Local Cooks - Unsubscribe Request
          
          New unsubscribe request received:
          
          Email: ${email}
          Timestamp: ${new Date(timestamp).toLocaleString()}
          Reason: ${reason || 'Not specified'}
          ${ feedback ? `Feedback }` : ''}
          
          ACTION REQUIRED: Please manually remove ${email} from all email lists and marketing databases within 24 hours.
        `
      };

      // Send notification email to admin
      const emailSent = await sendEmail(unsubscribeNotificationContent, { trackingId }_${Date.now()}`
      });

      if (!emailSent) { console.error('Failed to send unsubscribe notification email');
        return res.status(500).json({ 
          success, 
          message });
      }

      // Send confirmation email to user
      const userConfirmationContent = { to,
        subject };

      // Send confirmation to user (optional - they might not want more emails)
      await sendEmail(userConfirmationContent, { trackingId }_${Date.now()}`
      });

      console.log(`âœ… Unsubscribe request processed for);
      
      res.json({ success, 
        message });

    } catch (error) { console.error('Error processing unsubscribe request });
    }
  });

app.get('/api/vehicles/preload', async (req, res) => { try {
      // Check if already preloaded and cache is valid
      if (vehicleCache.isPreloaded && isCacheValid()) {
        return res.json({
          success,
          message });
      }

      console.log('ðŸš— Starting vehicle data preload...');
      
      // Fetch all makes first
      const makesResponse = await fetch('https);
      if (!makesResponse.ok) { throw new Error(`NHTSA API error }`);
      }
      
      const makesData = await makesResponse.json();
      
      // Filter for 4-wheeled vehicles only (exclude motorcycles, etc.)
      const fourWheeledMakes = makesData.Results.filter((make) => {
        // Filter out motorcycle manufacturers and other non-4-wheeled vehicles
        const excludedMakes = [
          'HARLEY-DAVIDSON', 'YAMAHA', 'KAWASAKI', 'SUZUKI', 'HONDA MOTORCYCLE',
          'BMW MOTORRAD', 'DUCATI', 'TRIUMPH', 'INDIAN', 'VICTORY', 'APRILIA',
          'KTM', 'HUSQVARNA', 'MOTO GUZZI', 'MV AGUSTA', 'BENELLI', 'NORTON',
          'ROYAL ENFIELD', 'HUSABERG', 'GAS GAS', 'SHERCO', 'BETA', 'TM RACING'
        ];
        
        return !excludedMakes.some(excluded => 
          make.Make_Name.toUpperCase().includes(excluded) || 
          excluded.includes(make.Make_Name.toUpperCase())
        );
      });

      const formattedMakes = fourWheeledMakes.map((make) => ({ id }));

      // Cache the makes
      vehicleCache.makes = formattedMakes;
      
      // Preload models for the first 20 most common makes to avoid overwhelming the API
      const commonMakes = formattedMakes.slice(0, 20);
      console.log(`ðŸš— Preloading models for ${commonMakes.length} common makes...`);
      
      for (const make of commonMakes) { try {
          const modelsResponse = await fetch(`https }?format=json`);
          if (modelsResponse.ok) {
            const modelsData = await modelsResponse.json();
            
            // Filter for 4-wheeled vehicles only
            const fourWheeledModels = modelsData.Results.filter((model) => {
              const modelName = model.Model_Name.toUpperCase();
              
              // Very specific exclusions only for obvious non-4-wheeled vehicles
              const excludedPatterns = [
                /MOTORCYCLE$/i, /BIKE$/i, /SCOOTER$/i, /MOPED$/i, /ATV$/i, /QUAD$/i, /TRIKE$/i, /SIDECAR$/i,
                /^HARLEY/i, /^YAMAHA\s+(R|MT|YZ|WR|XT|TW|TTR|PW|GRIZZLY|RAPTOR|WOLVERINE|KODIAK|BIG\s+BEAR)/i,
                /^KAWASAKI\s+(NINJA|ZX|VERSYS|CONCOURS|VULCAN|CONCORDE|KLX|KX|KLR|BRUTE\s+FORCE)/i,
                /^SUZUKI\s+(GSX|HAYABUSA|V-STROM|BURGMAN|ADDRESS|GSF|SV|DL|RM|RMZ|DR|DRZ)/i,
                /^HONDA\s+(CBR|CB|VFR|VTR|CRF|CR|XR|TRX|RUBICON|FOREMAN|RECON|RANCHER)/i,
                /^BMW\s+(R|S|F|G|K|HP|C|CE)/i,
                /^DUCATI\s+(MONSTER|PANIGALE|MULTISTRADA|HYPERMOTARD|SCRAMBLER|DIAPER|STREETFIGHTER)/i,
                /^TRIUMPH\s+(SPEED|STREET|TIGER|BONNEVILLE|SCRAMBLER|THRUXTON|ROCKET|DAYTONA)/i,
                /^INDIAN\s+(CHIEF|SCOUT|ROADMASTER|CHALLENGER|FTR|SPRINGFIELD)/i,
                /^VICTORY\s+(VEGAS|HAMMER|VISION|CROSS\s+COUNTRY|CROSS\s+ROADS|GUNNER)/i,
                /^APRILIA\s+(RS|TUONO|SHIVER|MANA|CAPONORD|PEGASO|ETV|RXV|SXV)/i,
                /^KTM\s+(RC|DUKE|ADVENTURE|EXC|SX|EXC|XC|FREERIDE)/i,
                /^HUSQVARNA\s+(FE|FC|TC|TE|WR|YZ|CR|CRF|KX|RM|SX|EXC)/i,
                /^MOTO\s+GUZZI\s+(V7|V9|CALIFORNIA|GRISO|STELVIO|NORGE|BREVA|BELLAGIO)/i,
                /^MV\s+AGUSTA\s+(F3|F4|BRUTALE|DRAGSTER|RIVALE|STRADALE|TURISMO|F3|F4)/i,
                /^BENELLI\s+(TNT|BN|TRK|LEONCINO|ZENTO|IMPERIALE|502C|752S)/i,
                /^NORTON\s+(COMMANDO|DOMINATOR|ATLAS|MANX|INTER|ES2|16H)/i,
                /^ROYAL\s+ENFIELD\s+(CLASSIC|BULLET|THUNDERBIRD|CONTINENTAL|HIMALAYAN|INTERCEPTOR|GT)/i,
                /^HUSABERG\s+(FE|FC|TE|TC|WR|CR|CRF|KX|RM|SX|EXC)/i,
                /^GAS\s+GAS\s+(EC|MC|TXT|RAGA|PAMPERA|TRIALS|ENDURO|MOTOCROSS)/i,
                /^SHERCO\s+(SE|ST|SC|4T|2T|RACING|FACTORY|WORK|TRIALS)/i,
                /^BETA\s+(RR|RE|RS|EVO|FACTORY|RACING|ENDURO|TRIALS|MOTOCROSS)/i,
                /^TM\s+RACING\s+(EN|MX|SM|RACING|FACTORY|ENDURO|MOTOCROSS|SUPERMOTO)/i
              ];
              
              return !excludedPatterns.some(pattern => pattern.test(modelName));
            });
            
            const formattedModels = fourWheeledModels.map((model) => ({ id }));
            
            vehicleCache.modelsByMake.set(make.id.toString(), formattedModels);
          }
          
          // Small delay to be respectful to the NHTSA API
          await new Promise(resolve => setTimeout(resolve, 100));
        } catch (error) {
          console.warn(`âš ï¸ Failed to preload models for make ${make.name});
          // Continue with other makes
        }
      }
      
      // Set cache 
      vehicleCache.isPreloaded = true;
      vehicleCache.lastFetch = Date.now();
      
      console.log('ðŸš— Vehicle data preload completed successfully');
      
      res.json({ success,
        message });
    } catch (error) { console.error('Error preloading vehicle data });
    }
  });

app.get('/api/vehicles/makes', async (req, res) => {
    try {
      const { type } = req.query;
      
      // Check cache first
      if (type && vehicleCache.makesByType.has(type ) && isCacheValid()) { return res.json({
          success,
          makes });
      }
      
      if (!type && vehicleCache.makes && isCacheValid()) { return res.json({
          success,
          makes });
      }

      // If not cached, trigger preload first
      if (!vehicleCache.isPreloaded) {
        console.log('ðŸš— Makes not cached, triggering preload...');
        try {
          const preloadResponse = await fetch(`${req.protocol})}/api/vehicles/preload`);
          if (preloadResponse.ok) { // Now return the cached data
            if (type && vehicleCache.makesByType.has(type )) {
              return res.json({
                success,
                makes });
            }
            
            if (!type && vehicleCache.makes) { return res.json({
                success,
                makes });
            }
          }
        } catch (preloadError) { console.warn('âš ï¸ Preload failed, falling back to direct API call }
      }

      // Fallback to direct API call if preload failed
      const response = await fetch('https);
      if (!response.ok) { throw new Error(`NHTSA API error }`);
      }
      
      const data = await response.json();
      
      // Filter for 4-wheeled vehicles only (exclude motorcycles, etc.)
      const fourWheeledMakes = data.Results.filter((make) => {
        // Filter out motorcycle manufacturers and other non-4-wheeled vehicles
        const excludedMakes = [
          'HARLEY-DAVIDSON', 'YAMAHA', 'KAWASAKI', 'SUZUKI', 'HONDA MOTORCYCLE',
          'BMW MOTORRAD', 'DUCATI', 'TRIUMPH', 'INDIAN', 'VICTORY', 'APRILIA',
          'KTM', 'HUSQVARNA', 'MOTO GUZZI', 'MV AGUSTA', 'BENELLI', 'NORTON',
          'ROYAL ENFIELD', 'HUSABERG', 'GAS GAS', 'SHERCO', 'BETA', 'TM RACING'
        ];
        
        return !excludedMakes.some(excluded => 
          make.Make_Name.toUpperCase().includes(excluded) || 
          excluded.includes(make.Make_Name.toUpperCase())
        );
      });

      const formattedMakes = fourWheeledMakes.map((make) => ({ id }));

      // Cache the results
      if (type) {
        vehicleCache.makesByType.set(type , formattedMakes);
      } else {
        vehicleCache.makes = formattedMakes;
      }
      vehicleCache.lastFetch = Date.now();

      res.json({ success,
        makes });
    } catch (error) { console.error('Error fetching vehicle makes });
    }
  });

app.get('/api/vehicles/makes/type/) => {
    try {
      const { vehicleType } = req.params;
      
      // Check cache first
      if (vehicleCache.makesByType.has(vehicleType) && isCacheValid()) { return res.json({
          success,
          makes });
      }

      // If not cached, trigger preload first
      if (!vehicleCache.isPreloaded) {
        console.log('ðŸš— Makes for type not cached, triggering preload...');
        try {
          const preloadResponse = await fetch(`${req.protocol})}/api/vehicles/preload`);
          if (preloadResponse.ok && vehicleCache.makesByType.has(vehicleType)) { return res.json({
              success,
              makes });
          }
        } catch (preloadError) { console.warn('âš ï¸ Preload failed, falling back to direct API call }
      }

      const response = await fetch(`https)}?format=json`);
      if (!response.ok) { throw new Error(`NHTSA API error }`);
      }
      
      const data = await response.json();
      
      // Filter for 4-wheeled vehicles only
      const fourWheeledMakes = data.Results.filter((make) => {
        const excludedMakes = [
          'HARLEY-DAVIDSON', 'YAMAHA', 'KAWASAKI', 'SUZUKI', 'HONDA MOTORCYCLE',
          'BMW MOTORRAD', 'DUCATI', 'TRIUMPH', 'INDIAN', 'VICTORY', 'APRILIA',
          'KTM', 'HUSQVARNA', 'MOTO GUZZI', 'MV AGUSTA', 'BENELLI', 'NORTON',
          'ROYAL ENFIELD', 'HUSABERG', 'GAS GAS', 'SHERCO', 'BETA', 'TM RACING'
        ];
        
        return !excludedMakes.some(excluded => 
          make.MakeName.toUpperCase().includes(excluded) || 
          excluded.includes(make.MakeName.toUpperCase())
        );
      });

      const formattedMakes = fourWheeledMakes.map((make) => ({ id }));

      // Cache the results
      vehicleCache.makesByType.set(vehicleType, formattedMakes);
      vehicleCache.lastFetch = Date.now();

      res.json({ success,
        makes });
    } catch (error) { console.error('Error fetching makes for vehicle type });
    }
  });

app.get('/api/vehicles/models/by-name/) => {
    try {
      const { makeName } = req.params;
      const decodedMakeName = decodeURIComponent(makeName);
      
      // Check cache first (use make name )
      if (vehicleCache.modelsByMake.has(decodedMakeName) && isCacheValid()) { return res.json({
          success,
          models });
      }
      
      // Direct call to NHTSA API with make name (no need to lookup make ID)
      const response = await fetch(`https)}?format=json`);
      if (!response.ok) { throw new Error(`NHTSA API error }`);
      }
      
      const data = await response.json();
      
      // Filter for 4-wheeled vehicles only
      const fourWheeledModels = data.Results.filter((model) => {
        const modelName = model.Model_Name.toUpperCase();
        const excludedPatterns = [
          /MOTORCYCLE$/i, /BIKE$/i, /SCOOTER$/i, /MOPED$/i, /ATV$/i,
          /SNOWMOBILE$/i, /WATERCRAFT$/i, /BOAT$/i, /JET.?SKI$/i
        ];
        return !excludedPatterns.some(pattern => pattern.test(modelName));
      });

      const formattedModels = fourWheeledModels.map((model) => ({ id }));

      // Cache the results
      vehicleCache.modelsByMake.set(decodedMakeName, formattedModels);

      res.json({ success,
        models });
    } catch (error) { console.error('Error fetching vehicle models });
    }
  });

app.get('/api/vehicles/models/) => {
    try {
      const { makeId } = req.params;
      
      // Check cache first
      if (vehicleCache.modelsByMake.has(makeId) && isCacheValid()) { return res.json({
          success,
          models });
      }
      
      // If not cached, trigger preload first
      if (!vehicleCache.isPreloaded) {
        console.log('ðŸš— Models not cached, triggering preload...');
        try {
          const preloadResponse = await fetch(`${req.protocol})}/api/vehicles/preload`);
          if (preloadResponse.ok && vehicleCache.modelsByMake.has(makeId)) { return res.json({
              success,
              models });
          }
        } catch (preloadError) { console.warn('âš ï¸ Preload failed, falling back to direct API call }
      }
      
      // First get the make name from our makes list
      const makesResponse = await fetch(`https);
      if (!makesResponse.ok) { throw new Error(`NHTSA API error }`);
      }
      
      const makesData = await makesResponse.json();
      const selectedMake = makesData.Results.find((make) => make.Make_ID === parseInt(makeId));
      
      if (!selectedMake) {
        throw new Error('Make not found');
      }
      
      // Get all models for this make (without year)
      const response = await fetch(`https)}?format=json`);
      if (!response.ok) { throw new Error(`NHTSA API error }`);
      }
      
      const data = await response.json();
      
      console.log(`ðŸš— NHTSA API returned ${data.Results.length || 0} models for make);
      
      // Filter for 4-wheeled vehicles only, but be much less aggressive
      const fourWheeledModels = data.Results.filter((model) => {
        // Only exclude very obvious non-4-wheeled vehicle models
        const modelName = model.Model_Name.toUpperCase();
        
        // Very specific exclusions only for obvious non-4-wheeled vehicles
        const excludedPatterns = [
          // Motorcycle patterns
          /MOTORCYCLE$/i,
          /BIKE$/i,
          /SCOOTER$/i,
          /MOPED$/i,
          /ATV$/i,
          /QUAD$/i,
          /TRIKE$/i,
          /SIDECAR$/i,
          
          // Very specific motorcycle model names
          /^HARLEY/i,
          /^YAMAHA\s+(R|MT|YZ|WR|XT|TW|TTR|PW|GRIZZLY|RAPTOR|WOLVERINE|KODIAK|BIG\s+BEAR)/i,
          /^KAWASAKI\s+(NINJA|ZX|VERSYS|CONCOURS|VULCAN|CONCORDE|KLX|KX|KLR|BRUTE\s+FORCE)/i,
          /^SUZUKI\s+(GSX|HAYABUSA|V-STROM|BURGMAN|ADDRESS|GSF|SV|DL|RM|RMZ|DR|DRZ)/i,
          /^HONDA\s+(CBR|CB|VFR|VTR|CRF|CR|XR|TRX|RUBICON|FOREMAN|RECON|RANCHER)/i,
          /^BMW\s+(R|S|F|G|K|HP|C|CE)/i,
          /^DUCATI\s+(MONSTER|PANIGALE|MULTISTRADA|HYPERMOTARD|SCRAMBLER|DIAPER|STREETFIGHTER)/i,
          /^TRIUMPH\s+(SPEED|STREET|TIGER|BONNEVILLE|SCRAMBLER|THRUXTON|ROCKET|DAYTONA)/i,
          /^INDIAN\s+(CHIEF|SCOUT|ROADMASTER|CHALLENGER|FTR|SPRINGFIELD)/i,
          /^VICTORY\s+(VEGAS|HAMMER|VISION|CROSS\s+COUNTRY|CROSS\s+ROADS|GUNNER)/i,
          /^APRILIA\s+(RS|TUONO|SHIVER|MANA|CAPONORD|PEGASO|ETV|RXV|SXV)/i,
          /^KTM\s+(RC|DUKE|ADVENTURE|EXC|SX|EXC|XC|FREERIDE)/i,
          /^HUSQVARNA\s+(FE|FC|TC|TE|WR|YZ|CR|CRF|KX|RM|SX|EXC)/i,
          /^MOTO\s+GUZZI\s+(V7|V9|CALIFORNIA|GRISO|STELVIO|NORGE|BREVA|BELLAGIO)/i,
          /^MV\s+AGUSTA\s+(F3|F4|BRUTALE|DRAGSTER|RIVALE|STRADALE|TURISMO|F3|F4)/i,
          /^BENELLI\s+(TNT|BN|TRK|LEONCINO|ZENTO|IMPERIALE|502C|752S)/i,
          /^NORTON\s+(COMMANDO|DOMINATOR|ATLAS|MANX|INTER|ES2|16H)/i,
          /^ROYAL\s+ENFIELD\s+(CLASSIC|BULLET|THUNDERBIRD|CONTINENTAL|HIMALAYAN|INTERCEPTOR|GT)/i,
          /^HUSABERG\s+(FE|FC|TE|TC|WR|CR|CRF|KX|RM|SX|EXC)/i,
          /^GAS\s+GAS\s+(EC|MC|TXT|RAGA|PAMPERA|TRIALS|ENDURO|MOTOCROSS)/i,
          /^SHERCO\s+(SE|ST|SC|4T|2T|RACING|FACTORY|WORK|TRIALS)/i,
          /^BETA\s+(RR|RE|RS|EVO|FACTORY|RACING|ENDURO|TRIALS|MOTOCROSS)/i,
          /^TM\s+RACING\s+(EN|MX|SM|RACING|FACTORY|ENDURO|MOTOCROSS|SUPERMOTO)/i
        ];
        
        // Check if model matches any excluded patterns
        return !excludedPatterns.some(pattern => pattern.test(modelName));
      });

      console.log(`ðŸš— After filtering, ${fourWheeledModels.length} models remain for make);
      
      const formattedModels = fourWheeledModels.map((model) => ({ id }));

      // Cache the results
      vehicleCache.modelsByMake.set(makeId, formattedModels);

      res.json({ success,
        models });
    } catch (error) { console.error('Error fetching vehicle models });
    }
  });

app.get('/api/vehicles/years/) => {
    try {
      const { makeId } = req.params;
      
      // Check cache first
      if (vehicleCache.yearsByMake.has(makeId) && isCacheValid()) { return res.json({
          success,
          years });
      }
      
      // Get the make name from cache or fallback to a reasonable guess
      let selectedMake = null;
      
      // Try to get from our car makes cache first
      if (vehicleCache.makesByType.has('car') && isCacheValid()) {
        const carMakes = vehicleCache.makesByType.get('car');
        selectedMake = carMakes.find((make) => make.id === parseInt(makeId));
      }
      
      // If not found in cache, try the NHTSA API (with error handling)
      if (!selectedMake) { try {
          const makesResponse = await fetch(`https });
          
          if (makesResponse.ok) {
            const makesData = await makesResponse.json();
            selectedMake = makesData.Results.find((make) => make.Make_ID === parseInt(makeId));
          }
        } catch (error) {
          console.log(`âš ï¸ NHTSA GetAllMakes API failed for makeId ${makeId}, using fallback`);
        }
      }
      
      // Final fallback: create a reasonable make object
      if (!selectedMake) { // Common make ID to name mappings for popular manufacturers
        const commonMakes } = { 441 };
        
        const makeName = commonMakes[parseInt(makeId)] || `MAKE_${makeId}`;
        selectedMake = { Make_ID };
        console.log(`ðŸš— Using fallback make name);
      }
      
      // Use NHTSA API to find years that actually have vehicle models
      const currentYear = new Date().getFullYear();
      const makeName = selectedMake.Make_Name.toUpperCase();
      console.log(`ðŸš— Finding actual model years for ${selectedMake.Make_Name} (ID)`);
      
      const years = [];
      const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
      
      // Helper function to check if a year h
      const hasModelsInYear = async (year): Promise<boolean> => { try {
          const response = await fetch(`https }/${year}?format=json`, { signal });
          
          if (!response.ok) return false;
          const data = await response.json();
          return data && data.Results && data.Results.length > 0;
        } catch {
          return false;
        }
      };
      
      // Smart sampling strategy: Check key years and find the range
      const currentPlusOne = currentYear + 1;
      const testYears = [
        // Recent years (most likely to have models)
        currentPlusOne, currentYear, currentYear - 1, currentYear - 2, currentYear - 3,
        // Sample years going back
        currentYear - 5, currentYear - 10, currentYear - 15, currentYear - 20, currentYear - 25,
        // Common milestone years
        2020, 2015, 2010, 2005, 2000, 1995, 1990, 1985
      ].filter((year, index, arr) => 
        // Remove duplicates and keep only reasonable years
        arr.indexOf(year) === index && year >= 1980 && year <= currentPlusOne
      ).sort((a, b) => b - a); // Start with recent years
      
      let earliestFoundYear = currentPlusOne;
      let latestFoundYear = 0;
      let foundCount = 0;
      
      console.log(`ðŸš— Testing ${testYears.length} sample years for ${selectedMake.Make_Name}...`);
      
      // Test sample years with rate limiting
      for (let i = 0; i < testYears.length && foundCount < 10; i++) {
        const year = testYears[i];
        const hasModels = await hasModelsInYear(year);
        
        if (hasModels) {
          foundCount++;
          earliestFoundYear = Math.min(earliestFoundYear, year);
          latestFoundYear = Math.max(latestFoundYear, year);
          console.log(`ðŸš— âœ… Found models for ${selectedMake.Make_Name} in ${year}`);
        }
        
        // Add delay between requests to respect rate limits
        if (i < testYears.length - 1) {
          await delay(150); // 150ms delay
        }
      }
      
      if (foundCount > 0) { // Generate the full range based on found years
        console.log(`ðŸš— Found model years range } to ${earliestFoundYear}`);
        
        // Fill in the range between earliest and latest found years
        for (let year = latestFoundYear; year >= earliestFoundYear; year--) {
          years.push(year);
        }
        
        console.log(`ðŸš— Generated ${years.length} years with actual models for ${selectedMake.Make_Name}`);
      } else { // Fallback }, using intelligent fallback`);
        
        let fallbackStartYear = 1995; // Conservative default
        
        // Smart fallbacks based on manufacturer patterns
        if (makeName.includes('TESLA') || makeName.includes('LUCID') || makeName.includes('RIVIAN')) {
          fallbackStartYear = 2010; // Recent EV manufacturers
        } else if (makeName.includes('GENESIS') || makeName.includes('SCION')) {
          fallbackStartYear = 2000; // Recent sub-brands
        } else if (makeName.includes('SATURN') || makeName.includes('HUMMER')) {
          fallbackStartYear = 1990; // Newer American brands
        }
        
        // Generate reasonable fallback range (last 30 years max)
        const fallbackEndYear = Math.min(currentYear + 1, fallbackStartYear + 35);
        for (let year = fallbackEndYear; year >= fallbackStartYear; year--) {
          years.push(year);
        }
        
        console.log(`ðŸš— Using fallback range);
      }

      // Cache the results
      vehicleCache.yearsByMake.set(makeId, years);

      res.json({ success,
        years });
    } catch (error) { console.error('Error fetching vehicle years });
    }
  });

app.put("/api/manager/locations/) => { console.log('[PUT] /api/manager/locations/ });
    try { const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }

      const { locationId } = req.params;
      const locationIdNum = parseInt(locationId);
      
      if (isNaN(locationIdNum) || locationIdNum <= 0) { console.error('[PUT] Invalid locationId });
      }
      
      const { cancellationPolicyHours, cancellationPolicyMessage, defaultDailyBookingLimit, minimumBookingWindowHours, notificationEmail, notificationPhone, logoUrl, brandImageUrl, timezone } = req.body;
      
      console.log('[PUT] Request body);

      if (cancellationPolicyHours !== undefined && (typeof cancellationPolicyHours !== 'number' || cancellationPolicyHours < 0)) { return res.status(400).json({ error });
      }

      if (defaultDailyBookingLimit !== undefined && (typeof defaultDailyBookingLimit !== 'number' || defaultDailyBookingLimit < 1 || defaultDailyBookingLimit > 24)) { return res.status(400).json({ error });
      }

      if (minimumBookingWindowHours !== undefined && (typeof minimumBookingWindowHours !== 'number' || minimumBookingWindowHours < 0 || minimumBookingWindowHours > 168)) { return res.status(400).json({ error });
      }

      // Import db dynamically
      const { db } = await import('./db');
      const { locations } = await import('@shared/schema');
      const { eq, and, sql } = await import('drizzle-orm');

      // Verify manager owns this location
      const locationResults = await db
        .select()
        .from(locations)
        .where(and(eq(locations.id, locationIdNum), eq(locations.managerId, user.id)));
      
      const location = locationResults[0];

      if (!location) { console.error('[PUT] Location not found or access denied });
        return res.status(404).json({ error });
      }
      
      console.log('[PUT] Location verified);

      // Get old notification email before updating
      const oldNotificationEmail = (location ).notificationEmail || (location ).notification_email || null;

      // Update location settings
      // Build updates object with proper field names matching the schema
      const updates: Partial<typeof locations.$inferInsert> = { updatedAt };
      
      if (cancellationPolicyHours !== undefined) {
        (updates ).cancellationPolicyHours = cancellationPolicyHours;
      }
      if (cancellationPolicyMessage !== undefined) {
        (updates ).cancellationPolicyMessage = cancellationPolicyMessage;
      }
      if (defaultDailyBookingLimit !== undefined) {
        (updates ).defaultDailyBookingLimit = defaultDailyBookingLimit;
      }
      if (minimumBookingWindowHours !== undefined) {
        (updates ).minimumBookingWindowHours = minimumBookingWindowHours;
      }
      if (notificationEmail !== undefined) { // Validate email format if provided and not empty
        if (notificationEmail && notificationEmail.trim() !== '' && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(notificationEmail)) {
          return res.status(400).json({ error });
        }
        // Set to null if empty string, otherwise use the value
        (updates ).notificationEmail = notificationEmail && notificationEmail.trim() !== '' ? notificationEmail.trim() : null;
        console.log('[PUT] Setting notificationEmail);
      }
      if (notificationPhone !== undefined) { // Normalize phone number if provided
        if (notificationPhone && notificationPhone.trim() !== '') {
          const normalized = normalizePhoneForStorage(notificationPhone);
          if (!normalized) {
            return res.status(400).json({ 
              error });
          }
          (updates ).notificationPhone = normalized;
          console.log('[PUT] Setting notificationPhone);
        } else {
          (updates ).notificationPhone = null;
        }
      }
      if (logoUrl !== undefined) { // Set to null if empty string, otherwise use the value
        // Use the schema field name (logoUrl) - Drizzle will map it to logo_url column
        const processedLogoUrl = logoUrl && logoUrl.trim() !== '' ? logoUrl.trim()  });
      }
      if (brandImageUrl !== undefined) { // Set to null if empty string, otherwise use the value
        const processedBrandImageUrl = brandImageUrl && brandImageUrl.trim() !== '' ? brandImageUrl.trim()  });
      }
      if (timezone !== undefined) {
        // Validate timezone format (basic validation - should be a valid IANA timezone)
        if (timezone && typeof timezone === 'string' && timezone.trim() !== '') {
          (updates ).timezone = timezone.trim();
        } else if (timezone === null || timezone === '') {
          // Use default if empty
          (updates ).timezone = DEFAULT_TIMEZONE;
        }
        console.log('[PUT] Setting timezone);
      }

      console.log('[PUT] Final updates object before DB update));
      console.log('[PUT] Updates keys));
      console.log('[PUT] Updates object h?', 'logoUrl' in updates);
      console.log('[PUT] Updates object logoUrl value).logoUrl);
      console.log('[PUT] Updates object h?', 'logo_url' in updates);
      console.log('[PUT] Updates object logo_url value).logo_url);

      const updatedResults = await db
        .update(locations)
        .set(updates)
        .where(eq(locations.id, locationIdNum))
        .returning();
      
      console.log('[PUT] Updated location from DB (full object):', JSON.stringify(updatedResults[0], null, 2));
      console.log('[PUT] Updated location logoUrl (camelCase):', (updatedResults[0] ).logoUrl);
      console.log('[PUT] Updated location logo_url (snake_case):', (updatedResults[0] ).logo_url);
      console.log('[PUT] Updated location all keys));

      if (!updatedResults || updatedResults.length === 0) { console.error('[PUT] Cancellation policy update failed });
        return res.status(500).json({ error });
      }

      const updated = updatedResults[0];
      console.log('[PUT] Location settings updated successfully);
      
      // Map snake_case fields to camelCase for the frontend
      const response = { ...updated,
        logoUrl };
      
      // Send email to new notification email if it w
      if (notificationEmail !== undefined && response.notificationEmail && response.notificationEmail !== oldNotificationEmail) { try {
          const emailContent = generateLocationEmailChangedEmail({
            email });
          await sendEmail(emailContent);
          console.log(`âœ… Location notification email change notification sent to);
        } catch (emailError) { console.error("Error sending location email change notification }
      }
      
      console.log('[PUT] Sending response with notificationEmail);
      res.status(200).json(response);
    } catch (error) { console.error("Error updating cancellation policy });
    }
  });

app.get("/api/manager/locations", async (req, res) => { try {
      // Check authentication - managers use session-based auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }

      const locations = await firebaseStorage.getLocationsByManager(user.id);
      
      console.log('[GET] /api/manager/locations - Raw locations from DB)));
      
      // Map snake_case fields to camelCase for the frontend
      const mappedLocations = locations.map(loc => ({ ...loc,
        notificationEmail }));
      
      // Log to verify logoUrl is included in response
      console.log('[GET] /api/manager/locations - Mapped locations))
      );
      
      res.json(mappedLocations);
    } catch (error) { console.error("Error fetching locations });
    }
  });

// Get kitchens for a location (manager)
app.get("/api/manager/kitchens/:locationId", async (req, res) => {
  try {
    // Check authentication - managers use session-based auth
    const sessionUser = await getAuthenticatedUser(req);
    const isFirebaseAuth = req.neonUser;

    if (!sessionUser && !isFirebaseAuth) {
      return res.status(401).json({ error: "Not authenticated" });
    }

    const user = isFirebaseAuth ? req.neonUser : sessionUser;
    if (user.role !== "manager") {
      return res.status(403).json({ error: "Manager access required" });
    }

    const locationId = parseInt(req.params.locationId);
    if (isNaN(locationId) || locationId <= 0) {
      return res.status(400).json({ error: "Invalid location ID" });
    }

    // Verify the manager has access to this location
    const locations = await firebaseStorage.getLocationsByManager(user.id);
    const hasAccess = locations.some(loc => loc.id === locationId);
    if (!hasAccess) {
      return res.status(403).json({ error: "Access denied to this location" });
    }

    const kitchens = await firebaseStorage.getKitchensByLocation(locationId);
    res.json(kitchens);
  } catch (error) {
    console.error("Error fetching kitchens:", error);
    res.status(500).json({ error: error.message || "Failed to fetch kitchens" });
  }
});

// Update kitchen image (manager)
app.put("/api/manager/kitchens/:kitchenId/image", async (req, res) => {
  try {
    // Check authentication - managers use session-based auth
    const sessionUser = await getAuthenticatedUser(req);
    const isFirebaseAuth = req.neonUser;

    if (!sessionUser && !isFirebaseAuth) {
      return res.status(401).json({ error: "Not authenticated" });
    }

    const user = isFirebaseAuth ? req.neonUser : sessionUser;
    if (user.role !== "manager") {
      return res.status(403).json({ error: "Manager access required" });
    }

    const kitchenId = parseInt(req.params.kitchenId);
    if (isNaN(kitchenId) || kitchenId <= 0) {
      return res.status(400).json({ error: "Invalid kitchen ID" });
    }

    // Get the kitchen to verify manager has access to its location
    const kitchen = await firebaseStorage.getKitchenById(kitchenId);
    if (!kitchen) {
      return res.status(404).json({ error: "Kitchen not found" });
    }

    // Verify the manager has access to this kitchen's location
    const locations = await firebaseStorage.getLocationsByManager(user.id);
    const hasAccess = locations.some(loc => loc.id === kitchen.locationId);
    if (!hasAccess) {
      return res.status(403).json({ error: "Access denied to this kitchen" });
    }

    const { imageUrl } = req.body;

    const updated = await firebaseStorage.updateKitchen(kitchenId, { imageUrl: imageUrl || null });

    console.log(`âœ… Kitchen ${kitchenId} image updated by manager ${user.id}`);

    res.json(updated);
  } catch (error) {
    console.error("Error updating kitchen image:", error);
    res.status(500).json({ error: error.message || "Failed to update kitchen image" });
  }
});

app.post("/api/manager/availability", async (req, res) => { try {
      // Check authentication - managers use session-based auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }
      
      const { kitchenId, dayOfWeek, startTime, endTime, isAvailable } = req.body;
      await firebaseStorage.setKitchenAvailability(kitchenId, { dayOfWeek, startTime, endTime, isAvailable });
      
      // Send email notifications to chefs and managers
      try { const kitchen = await firebaseStorage.getKitchenById(kitchenId);
        if (kitchen) {
          const location = await firebaseStorage.getLocationById(kitchen.locationId);
          
          // Get all chefs who have bookings at this kitchen
          const bookings = await firebaseStorage.getBookingsByKitchen(kitchenId);
          const uniqueChefIds = Array.from(new Set(bookings.map(b => b.chefId)));
          
          // Send emails to chefs
          for (const chefId of uniqueChefIds) {
            try {
              const chef = await storage.getUser(chefId);
              if (chef) {
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const changeType = isAvailable ? 'Availability Updated'  } from ${startTime} to ${endTime}.`
                  : `The kitchen is now closed on ${dayNames[dayOfWeek]}.`;
                
                const email = generateKitchenAvailabilityChangeEmail({ chefEmail });
                await sendEmail(email);
                console.log(`âœ… Availability change email sent to chef);
              }
            } catch (emailError) {
              console.error(`Error sending email to chef ${chefId});
            }
          }
          
          // Send email to manager
          if (location.managerId) { try {
              const manager = await storage.getUser(location.managerId);
              if (manager) {
                const notificationEmail = (location ).notificationEmail || (location ).notification_email || manager.username;
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const changes = `Kitchen availability updated } ${isAvailable ? `is now available from ${startTime} to ${endTime}` : 'is now closed'}.`;
                
                const email = generateKitchenSettingsChangeEmail({ email,
                  name });
                await sendEmail(email);
                console.log(`âœ… Availability change email sent to manager);
              }
            } catch (emailError) { console.error(`Error sending email to manager }
          }
        }
      } catch (emailError) { console.error("Error sending availability change emails }
      
      res.json({ success });
    } catch (error) { console.error("Error setting availability });
    }
  });

app.get("/api/manager/availability/) => { try {
      // Check authentication - managers use session-based auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }
      
      const kitchenId = parseInt(req.params.kitchenId);
      const availability = await firebaseStorage.getKitchenAvailability(kitchenId);
      res.json(availability);
    } catch (error) { console.error("Error fetching availability });
    }
  });

app.get("/api/manager/bookings", async (req, res) => { try {
      // Check authentication - managers use session-based auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }

      const bookings = await firebaseStorage.getBookingsByManager(user.id);
      res.json(bookings);
    } catch (error) { console.error("Error fetching bookings });
    }
  });

app.get("/api/manager/chef-profiles", async (req, res) => { try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }

      const profiles = await firebaseStorage.getChefProfilesForManager(user.id);
      res.json(profiles);
    } catch (error) { console.error("Error getting chef profiles for manager });
    }
  });

app.get("/api/manager/portal-applications", async (req, res) => { try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }

      // Get all locations managed by this manager
      const { users } = await import('@shared/schema');
      
      console.log(`[Manager Portal Applications] Fetching for manager ID);
      
      const managedLocations = await db.select()
        .from(locations)
        .where(eq(locations.managerId, user.id));
      
      console.log(`[Manager Portal Applications] Found ${managedLocations.length} managed locations`);
      
      if (managedLocations.length === 0) {
        console.log(`[Manager Portal Applications] No locations found for manager ${user.id}`);
        return res.json([]);
      }
      
      const locationIds = managedLocations.map(loc => loc.id);
      console.log(`[Manager Portal Applications] Location IDs)}`);
      
      // Get ALL portal user applications for these locations (not just inReview)
      const applications = await db.select({
        application,
        location,
        user,
      })
        .from(portalUserApplications)
        .innerJoin(locations, eq(portalUserApplications.locationId, locations.id))
        .innerJoin(users, eq(portalUserApplications.userId, users.id))
        .where(
          inArray(portalUserApplications.locationId, locationIds)
        );
      
      console.log(`[Manager Portal Applications] Found ${applications.length} total applications`);
      
      // Format response
      const formatted = applications.map(app => ({ id }, user));
      
      console.log(`[Manager Portal Applications] Returning ${formatted.length} applications (statuses).join(', ')})`);
      
      res.json(formatted);
    } catch (error) { console.error("Error getting portal applications for manager });
    }
  });

app.put("/api/manager/portal-applications/) => { try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }

      const applicationId = parseInt(req.params.id);
      const { status, feedback } = req.body;
      
      if (!status || ['approved', 'rejected'].includes(status)) { return res.status(400).json({ error });
      }

      const { users } = await import('@shared/schema');
      
      // Get application and verify it belongs to a location managed by this manager
      const applicationRecords = await db.select({
        application,
        location,
      })
        .from(portalUserApplications)
        .innerJoin(locations, eq(portalUserApplications.locationId, locations.id))
        .where(eq(portalUserApplications.id, applicationId))
        .limit(1);
      
      if (applicationRecords.length === 0) { return res.status(404).json({ error });
      }
      
      const applicationData = applicationRecords[0];
      const location = applicationData.location;
      const application = applicationData.application;
      
      // Verify manager owns this location
      if ((location ).managerId !== user.id) { return res.status(403).json({ error });
      }
      
      // Update application status
      const updatedApplication = await db.update(portalUserApplications)
        .set({ status,
          feedback })
        .where(eq(portalUserApplications.id, applicationId))
        .returning();
      
      // If approved, grant location access
      if (status === 'approved') { // Check if access already exists
        const existingAccess = await db.select()
          .from(portalUserLocationAccess)
          .where(
            and(
              eq(portalUserLocationAccess.portalUserId, application.userId),
              eq(portalUserLocationAccess.locationId, application.locationId)
            )
          )
          .limit(1);
        
        if (existingAccess.length === 0) {
          // Create location access
          await db.insert(portalUserLocationAccess).values({
            portalUserId });
        }
        
        // Send notification email to portal user
        try {
          const { sendEmail } = await import('./email');
          const portalUser = await firebaseStorage.getUser(application.userId);
          if (portalUser && (portalUser ).username) { const userEmail = (portalUser ).username;
            const emailContent = {
              to,
              subject }`,
              text: `Your application for portal access h approved!\n\n` +
                    `Location: ${(location ).name}\n` +
                    `Address: ${(location ).address}\n` +
                    `${ feedback ? `\nManager Feedback }\n` : ''}` +
                    `\nYou can now log in to the portal and book kitchens at this location.`,
              html: `<h2>Portal Access Approved</h2>` +
                    `<p>Your application for portal access h approved!</p>` +
                    `<p><strong>Location:</strong> ${(location ).name}</p>` +
                    `<p><strong>Address:</strong> ${(location ).address}</p>` +
                    `${ feedback ? `<p><strong>Manager Feedback }</p>` : ''}` +
                    `<p>You can now log in to the portal and book kitchens at this location.</p>`,
            };
            await sendEmail(emailContent);
          }
        } catch (emailError) { console.error("Error sending portal approval email }
      } else if (status === 'rejected') {
        // Send rejection email
        try {
          const { sendEmail } = await import('./email');
          const portalUser = await firebaseStorage.getUser(application.userId);
          if (portalUser && (portalUser ).username) { const userEmail = (portalUser ).username;
            const emailContent = {
              to,
              subject }`,
              text: `Your application for portal access h reviewed.\n\n` +
                    `Location: ${(location ).name}\n` +
                    `Status: Rejected\n` +
                    `${ feedback ? `\nManager Feedback }\n` : ''}` +
                    `\nIf you have questions, please contact the location manager.`,
              html: `<h2>Portal Access Application</h2>` +
                    `<p>Your application for portal access h reviewed.</p>` +
                    `<p><strong>Location:</strong> ${(location ).name}</p>` +
                    `<p><strong>Status:</strong> Rejected</p>` +
                    `${ feedback ? `<p><strong>Manager Feedback }</p>` : ''}` +
                    `<p>If you have questions, please contact the location manager.</p>`,
            };
            await sendEmail(emailContent);
          }
        } catch (emailError) { console.error("Error sending portal rejection email }
      }
      
      res.json(updatedApplication[0]);
    } catch (error) { console.error("Error updating portal application status });
    }
  });

app.put("/api/manager/chef-profiles/) => { try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }

      const profileId = parseInt(req.params.id);
      const { status, reviewFeedback } = req.body;
      
      if (!status || ['approved', 'rejected'].includes(status)) { return res.status(400).json({ error });
      }

      const updated = await firebaseStorage.updateChefLocationProfileStatus(
        profileId,
        status,
        user.id,
        reviewFeedback
      );
      
      // Send email notification to chef when access is approved
      if (status === 'approved') {
        try {
          // Get location details
          const location = await firebaseStorage.getLocationById(updated.locationId);
          if (!location) {
            console.warn(`âš ï¸ Location ${updated.locationId} not found for email notification`);
          } else {
            // Get chef details
            const chef = await storage.getUser(updated.chefId);
            if (!chef) {
              console.warn(`âš ï¸ Chef ${updated.chefId} not found for email notification`);
            } else { try {
                const chefEmail = generateChefLocationAccessApprovedEmail({
                  chefEmail });
                await sendEmail(chefEmail);
                console.log(`âœ… Chef location access approved email sent to chef);
              } catch (emailError) { console.error("Error sending chef approval email }
            }
          }
        } catch (emailError) { console.error("Error sending chef approval emails }
      }
      
      res.json(updated);
    } catch (error) { console.error("Error updating chef profile status });
    }
  });

app.get("/api/manager/kitchens/) => { try {
      // Check authentication - managers use session-based auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }

      const kitchenId = parseInt(req.params.kitchenId);
      console.log(`ðŸ“‹ Fetching bookings for kitchen ${kitchenId}`);
      
      const bookings = await firebaseStorage.getBookingsByKitchen(kitchenId);
      console.log(`âœ… Found ${bookings.length} bookings for kitchen ${kitchenId}`);
      
      // Return ALL bookings (not just confirmed) so manager can see pending ones too
      res.json(bookings);
    } catch (error) { console.error("Error fetching kitchen bookings });
    }
  });

app.put("/api/manager/bookings/) => { try {
      // Check authentication - managers use session-based auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }
      
      const id = parseInt(req.params.id);
      const { status } = req.body;
      
      // Get booking details before updating
      const booking = await firebaseStorage.getBookingById(id);
      
      await firebaseStorage.updateKitchenBookingStatus(id, status);
      
      // Send email notifications to chef and manager based on status change
      if (booking) {
        try {
          const kitchen = await firebaseStorage.getKitchenById(booking.kitchenId);
          const chef = await storage.getUser(booking.chefId);
          
          if (chef && kitchen) {
            // Get location details (DIRECT DATABASE QUERY - emails are in Neon database)
            const kitchenLocationId = (kitchen ).locationId || (kitchen ).location_id;
            let location = null;
            let manager = null;
            
            if (kitchenLocationId && pool) {
              // DIRECT DATABASE QUERY - emails are stored in Neon database
              const locationData = await pool.query(`
                SELECT l.id, l.name, l.manager_id, l.notification_email, l.timezone
                FROM locations l
                WHERE l.id = $1
              `, [kitchenLocationId]);
              
              if (locationData.rows.length > 0) {
                location = locationData.rows[0];
                
                // Get manager details if manager_id is set (DIRECT DATABASE QUERY)
                const managerId = location.manager_id;
                if (managerId) {
                  const managerData = await pool.query(`
                    SELECT id, username
                    FROM users
                    WHERE id = $1
                  `, [managerId]);
                  
                  if (managerData.rows.length > 0) {
                    manager = managerData.rows[0];
                  }
                }
              }
            }
            
            // Get chef's full name and phone from application if available (better than just email)
            let chefName = chef.username || 'Chef';
            let chefPhone = null;
            if (pool && booking.chefId) {
              // Get phone using utility function (from applications table)
              chefPhone = await getChefPhone(booking.chefId, pool);
              
              // Get full name from application
              try {
                const appResult = await pool.query(
                  'SELECT full_name FROM applications WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1',
                  [booking.chefId]
                );
                if (appResult.rows.length > 0 && appResult.rows[0].full_name) {
                  chefName = appResult.rows[0].full_name;
                }
                console.log(`ðŸ“‹ Using application full name "${chefName}" for chef ${booking.chefId} in confirmation email${ chefPhone ? `, phone }`);
              } catch (error) {
                console.debug(`Could not get full name for chef ${booking.chefId} from applications, using username`);
              }
            }
            
            const chefEmailAddress = chef.username;
            
            if (!chefEmailAddress) {
              console.warn(`âš ï¸ Chef ${booking.chefId} h email address, skipping status update email`);
            } else { if (status === 'confirmed') {
                // Send confirmation email to chef
                try {
                  const locationTimezone = location ? ((location ).timezone || DEFAULT_TIMEZONE)  });
                  const emailSent = await sendEmail(confirmationEmail);
                  if (emailSent) { console.log(`âœ… Booking confirmation email sent to chef }`);
                  } else { console.error(`âŒ Failed to send booking confirmation email to chef }`);
                  }
                } catch (confirmationEmailError) {
                  console.error(`âŒ Error sending booking confirmation email to chef ${chefEmailAddress});
                  console.error("Confirmation email error details));
                }

                // Send confirmation SMS to chef
                if (chefPhone) { try {
                    const smsMessage = generateChefBookingConfirmationSMS({
                      kitchenName });
                    await sendSMS(chefPhone, smsMessage, { trackingId }_chef_confirmed` });
                    console.log(`âœ… Booking confirmation SMS sent to chef);
                  } catch (smsError) { console.error(`âŒ Error sending booking confirmation SMS to chef }
                }
                
                // Send notification email to manager (use notification_email from direct database query)
                const notificationEmailAddress = location ? (location.notification_email || (manager ? manager.username )) : null;
                if (notificationEmailAddress) { try {
                    const locationTimezone = location ? (location.timezone || DEFAULT_TIMEZONE)  });
                    const emailSent = await sendEmail(managerEmail);
                    if (emailSent) { console.log(`âœ… Booking confirmation notification email sent to manager }`);
                    } else { console.error(`âŒ Failed to send booking confirmation notification email to manager }`);
                    }
                  } catch (managerEmailError) { console.error(`âŒ Error sending manager confirmation email }
                }

                // Check if this is a portal user booking and send SMS to portal user
                try { // Check if booking is a portal user booking (h contact or bookingType is 'external')
                  const bookingData = await firebaseStorage.getBookingById(id);
                  const isPortalBooking = bookingData && ((bookingData ).bookingType === 'external' || (bookingData ).externalContact);
                  
                  if (isPortalBooking && kitchenLocationId && booking.chefId && pool) {
                    try {
                      // Get portal user phone using utility function (normalized)
                      const portalUserPhone = await getPortalUserPhone(booking.chefId, kitchenLocationId, pool);
                      
                      if (portalUserPhone) {
                        const smsMessage = generatePortalUserBookingConfirmationSMS({
                          kitchenName });
                        await sendSMS(portalUserPhone, smsMessage, { trackingId }_portal_confirmed` });
                        console.log(`âœ… Booking confirmation SMS sent to portal user);
                      } else {
                        console.log(`ðŸ“± No phone number found in portal_user_applications for user ${booking.chefId} and location ${kitchenLocationId}`);
                      }
                    } catch (portalAppError) { console.error(`âŒ Error querying portal_user_applications for SMS }
                  }
                } catch (portalSmsError) { console.error(`âŒ Error sending booking confirmation SMS to portal user }
              } else if (status === 'cancelled') { // Send cancellation email to chef
                try {
                  const cancellationEmail = generateBookingCancellationEmail({
                    chefEmail,
                    chefName,
                    kitchenName });
                  const emailSent = await sendEmail(cancellationEmail);
                  if (emailSent) { console.log(`âœ… Booking cancellation email sent to chef }`);
                  } else { console.error(`âŒ Failed to send booking cancellation email to chef }`);
                  }
                } catch (cancellationEmailError) {
                  console.error(`âŒ Error sending booking cancellation email to chef ${chefEmailAddress});
                  console.error("Cancellation email error details));
                }

                // Send cancellation SMS to chef
                if (chefPhone) { try {
                    const smsMessage = generateChefBookingCancellationSMS({
                      kitchenName });
                    await sendSMS(chefPhone, smsMessage, { trackingId }_chef_cancelled` });
                    console.log(`âœ… Booking cancellation SMS sent to chef);
                  } catch (smsError) { console.error(`âŒ Error sending booking cancellation SMS to chef }
                }
                
                // Send notification email to manager (use notification_email from direct database query)
                const notificationEmailAddress = location ? (location.notification_email || (manager ? manager.username )) : null;
                if (notificationEmailAddress) { try {
                    const locationTimezone = location ? (location.timezone || DEFAULT_TIMEZONE)  });
                    const emailSent = await sendEmail(managerEmail);
                    if (emailSent) { console.log(`âœ… Booking cancellation notification email sent to manager }`);
                    } else { console.error(`âŒ Failed to send booking cancellation notification email to manager }`);
                    }
                  } catch (managerEmailError) { console.error(`âŒ Error sending manager cancellation email }
                }

                // Check if this is a portal user booking and send SMS to portal user
                try { // Check if booking is a portal user booking (h contact or bookingType is 'external')
                  const bookingData = await firebaseStorage.getBookingById(id);
                  const isPortalBooking = bookingData && ((bookingData ).bookingType === 'external' || (bookingData ).externalContact);
                  
                  if (isPortalBooking && kitchenLocationId && booking.chefId && pool) {
                    // Get portal user phone using utility function (normalized)
                    const portalUserPhone = await getPortalUserPhone(booking.chefId, kitchenLocationId, pool);
                    
                    if (portalUserPhone) {
                      const smsMessage = generatePortalUserBookingCancellationSMS({
                        kitchenName });
                      await sendSMS(portalUserPhone, smsMessage, { trackingId }_portal_cancelled` });
                      console.log(`âœ… Booking cancellation SMS sent to portal user);
                    } else {
                      console.log(`ðŸ“± No phone number found in portal_user_applications for user ${booking.chefId} and location ${kitchenLocationId}`);
                    }
                  }
                } catch (portalAppError) { console.error(`âŒ Error querying portal_user_applications for SMS }
              }
            }
          }
        } catch (emailError) { console.error("Error sending booking status email }
      }
      
      res.json({ success });
    } catch (error) { console.error("Error updating booking status });
    }
  });

app.get("/api/manager/kitchens/) => { try {
      // Check authentication - managers use session-based auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }

      const kitchenId = parseInt(req.params.kitchenId);
      const { startDate, endDate } = req.query;
      
      const start = startDate ? new Date(startDate ) : undefined;
      const end = endDate ? new Date(endDate ) : undefined;
      
      const overrides = await firebaseStorage.getKitchenDateOverrides(kitchenId, start, end);
      res.json(overrides);
    } catch (error) { console.error("Error fetching date overrides });
    }
  });

app.post("/api/manager/kitchens/) => { try {
      // Check authentication - managers use session-based auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }

      const kitchenId = parseInt(req.params.kitchenId);
      const { specificDate, startTime, endTime, isAvailable, reason } = req.body;
      
      // Validate input
      if (!specificDate) { return res.status(400).json({ error });
      }
      
      // Validate time range if kitchen is available
      if (isAvailable) { if (!startTime || !endTime) {
          return res.status(400).json({ 
            error });
        }
        if (startTime >= endTime) { return res.status(400).json({ 
            error });
        }
      }
      
      // If closing the kitchen (isAvailable = false), check for existing bookings
      if (!isAvailable) {
        const bookings = await firebaseStorage.getBookingsByKitchen(kitchenId);
        const dateStr = new Date(specificDate).toISOString().split('T')[0];
        const bookingsOnDate = bookings.filter(b => {
          const bookingDateStr = new Date(b.bookingDate).toISOString().split('T')[0];
          return bookingDateStr === dateStr && b.status === 'confirmed';
        });
        
        if (bookingsOnDate.length > 0) { return res.status(400).json({ 
            error } confirmed booking(s) on this date. Please cancel or reschedule them first.`,
            bookings: bookingsOnDate 
          });
        }
      }
      
      const override = await firebaseStorage.createKitchenDateOverride({ kitchenId,
        specificDate });
      
      // Send email notifications to chefs and managers
      try { const kitchen = await firebaseStorage.getKitchenById(kitchenId);
        if (kitchen) {
          const location = await firebaseStorage.getLocationById(kitchen.locationId);
          const dateStr = new Date(specificDate).toLocaleDateString();
          
          // Get all chefs who have bookings at this kitchen
          const bookings = await firebaseStorage.getBookingsByKitchen(kitchenId);
          const uniqueChefIds = Array.from(new Set(bookings.map(b => b.chefId)));
          
          const changeType = isAvailable ? 'Special Availability Added'  } from ${startTime} to ${endTime}.${ reason ? ` Reason }` : ''}`
            : `Kitchen will be closed on ${dateStr}.${ reason ? ` Reason }` : ''}`;
          
          // Send emails to chefs
          for (const chefId of uniqueChefIds) { try {
              const chef = await storage.getUser(chefId);
              if (chef) {
                const email = generateKitchenAvailabilityChangeEmail({
                  chefEmail });
                await sendEmail(email);
                console.log(`âœ… Date override email sent to chef);
              }
            } catch (emailError) {
              console.error(`Error sending email to chef ${chefId});
            }
          }
          
          // Send email to manager
          if (location.managerId) { try {
              const manager = await storage.getUser(location.managerId);
              if (manager) {
                const notificationEmail = (location ).notificationEmail || (location ).notification_email || manager.username;
                const changes = `Date override created } - ${isAvailable ? `special availability from ${startTime} to ${endTime}` : 'kitchen closed'}.${ reason ? ` Reason }` : ''}`;
                
                const email = generateKitchenSettingsChangeEmail({ email,
                  name });
                await sendEmail(email);
                console.log(`âœ… Date override email sent to manager);
              }
            } catch (emailError) { console.error(`Error sending email to manager }
          }
        }
      } catch (emailError) { console.error("Error sending date override emails }
      
      res.json(override);
    } catch (error) { console.error("Error creating date override });
    }
  });

app.put("/api/manager/date-overrides/) => { try {
      // Check authentication - managers use session-based auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }

      const id = parseInt(req.params.id);
      const { startTime, endTime, isAvailable, reason } = req.body;
      
      // Validate time range if kitchen is available
      if (isAvailable === true) { if (!startTime || !endTime) {
          return res.status(400).json({ 
            error });
        }
        if (startTime >= endTime) { return res.status(400).json({ 
            error });
        }
      }
      
      // If changing to closed (isAvailable = false), check for existing bookings
      if (isAvailable === false) {
        // Load the specific override to find its kitchen and date
        const override = await firebaseStorage.getKitchenDateOverrideById(id);
        if (override) {
          const bookings = await firebaseStorage.getBookingsByKitchen(override.kitchenId);
          const dateStr = new Date(override.specificDate).toISOString().split('T')[0];
          const bookingsOnDate = bookings.filter(b => {
            const bookingDateStr = new Date(b.bookingDate).toISOString().split('T')[0];
            return bookingDateStr === dateStr && b.status === 'confirmed';
          });
          if (bookingsOnDate.length > 0) { return res.status(400).json({ 
              error } confirmed booking(s) on this date. Please cancel or reschedule them first.`,
              bookings: bookingsOnDate 
            });
          }
        }
      }
      
      const updated = await firebaseStorage.updateKitchenDateOverride(id, {
        startTime,
        endTime,
        isAvailable,
        reason,
      });
      
      // Send email notifications to chefs and managers
      try { const override = await firebaseStorage.getKitchenDateOverrideById(id);
        if (override) {
          const kitchen = await firebaseStorage.getKitchenById(override.kitchenId);
          if (kitchen) {
            const location = await firebaseStorage.getLocationById(kitchen.locationId);
            const dateStr = new Date(override.specificDate).toLocaleDateString();
            
            // Get all chefs who have bookings at this kitchen
            const bookings = await firebaseStorage.getBookingsByKitchen(override.kitchenId);
            const uniqueChefIds = Array.from(new Set(bookings.map(b => b.chefId)));
            
            const changeType = isAvailable !== undefined 
              ? (isAvailable ? 'Date Override Updated - Special Availability'  } is now available${startTime && endTime ? ` from ${startTime} to ${endTime}`)
              : `Date override updated for ${dateStr}.${ startTime && endTime ? ` Time } to ${endTime}` : ''}${ reason ? ` Reason }` : ''}`;
            
            // Send emails to chefs
            for (const chefId of uniqueChefIds) { try {
                const chef = await storage.getUser(chefId);
                if (chef) {
                  const email = generateKitchenAvailabilityChangeEmail({
                    chefEmail });
                  await sendEmail(email);
                  console.log(`âœ… Date override update email sent to chef);
                }
              } catch (emailError) {
                console.error(`Error sending email to chef ${chefId});
              }
            }
            
            // Send email to manager
            if (location.managerId) {
              try {
                const manager = await storage.getUser(location.managerId);
                if (manager) {
                  const notificationEmail = (location ).notificationEmail || (location ).notification_email || manager.username;
                  const changes = `Date override updated for ${dateStr}.${isAvailable !== undefined ? (isAvailable ? ` Special availability${startTime && endTime ? ` from ${startTime} to ${endTime}`) : ''}${ reason ? `. Reason }` : ''}`;
                  
                  const email = generateKitchenSettingsChangeEmail({ email,
                    name });
                  await sendEmail(email);
                  console.log(`âœ… Date override update email sent to manager);
                }
              } catch (emailError) { console.error(`Error sending email to manager }
            }
          }
        }
      } catch (emailError) { console.error("Error sending date override update emails }
      
      res.json(updated);
    } catch (error) { console.error("Error updating date override });
    }
  });

app.delete("/api/manager/date-overrides/) => { try {
      // Check authentication - managers use session-based auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }

      const id = parseInt(req.params.id);
      await firebaseStorage.deleteKitchenDateOverride(id);
      res.json({ success });
    } catch (error) { console.error("Error deleting date override });
    }
  });

app.get("/api/chef/kitchens", requireChef, async (req, res) => { try {
      // For marketing purposes, show ALL active kitchens at all locations
      // Chefs can see all available commercial kitchen locations
      const allKitchens = await firebaseStorage.getAllKitchensWithLocationAndManager();
      
      // Filter only active kitchens
      const activeKitchens = allKitchens.filter((kitchen) => {
        const isActive = kitchen.isActive !== undefined ? kitchen.isActive  });
      
      console.log(`[API] /api/chef/kitchens - Returning ${activeKitchens.length} active kitchens (all locations for marketing)`);
      
      res.json(activeKitchens);
    } catch (error) { console.error("Error fetching kitchens });
    }
  });

app.get("/api/chef/locations", requireChef, async (req, res) => { try {
      // Get all locations with active kitchens for marketing purposes
      const allLocations = await firebaseStorage.getAllLocations();
      const allKitchens = await firebaseStorage.getAllKitchensWithLocationAndManager();
      
      // Filter to only locations that have at least one active kitchen
      const activeKitchens = allKitchens.filter((kitchen) => {
        const isActive = kitchen.isActive !== undefined ? kitchen.isActive  });
      
      const locationIdsWithKitchens = new Set(
        activeKitchens.map((kitchen) => kitchen.locationId || kitchen.location_id).filter(Boolean)
      );
      
      const locationsWithKitchens = allLocations.filter((location) => 
        locationIdsWithKitchens.has(location.id)
      );
      
      console.log(`[API] /api/chef/locations - Returning ${locationsWithKitchens.length} locations with active kitchens`);
      
      res.json(locationsWithKitchens);
    } catch (error) { console.error("Error fetching locations });
    }
  });

app.get("/api/chef/kitchens/) => {
    try {
      const kitchenId = parseInt(req.params.kitchenId);
      const { date } = req.query;
      
      if (!date) { return res.status(400).json({ error });
      }
      
      const bookingDate = new Date(date );
      
      // Validate date
      if (isNaN(bookingDate.getTime())) { return res.status(400).json({ error });
      }
      
      const slotsInfo = await firebaseStorage.getAllTimeSlotsWithBookingInfo(kitchenId, bookingDate);
      
      res.json(slotsInfo);
    } catch (error) { console.error("Error fetching time slots });
    }
  });

app.get("/api/chef/kitchens/) => {
    try {
      const kitchenId = parseInt(req.params.kitchenId);
      const { date } = req.query;
      
      if (!date) { return res.status(400).json({ error });
      }
      
      const bookingDate = new Date(date );
      
      // Validate date
      if (isNaN(bookingDate.getTime())) { return res.status(400).json({ error });
      }
      
      console.log(`ðŸ” Fetching available slots for kitchen ${kitchenId} on ${date}`);
      
      const slots = await firebaseStorage.getAvailableTimeSlots(kitchenId, bookingDate);
      
      console.log(`âœ… Returning ${slots.length} available slots`);
      
      res.json(slots);
    } catch (error) { console.error("Error fetching available slots });
    }
  });

app.post("/api/chef/bookings", requireChef, async (req, res) => {
    try {
      const { kitchenId, bookingDate, startTime, endTime, specialNotes } = req.body;
      const chefId = req.user.id;
      
      // Check if chef h-granted access to the location containing this kitchen
      const kitchenLocationId1 = await firebaseStorage.getKitchenLocation(kitchenId);
      if (!kitchenLocationId1) { return res.status(400).json({ error });
      }
      
      const hasLocationAccess = await firebaseStorage.chefHasLocationAccess(chefId, kitchenLocationId1);
      
      if (!hasLocationAccess) { return res.status(403).json({ error });
      }
      
      // Check if chef h their profile with the location and it's been approved by manager
      const profile = await firebaseStorage.getChefLocationProfile(chefId, kitchenLocationId1);
      if (!profile) { return res.status(403).json({ error });
      }
      
      if (profile.status !== 'approved') { return res.status(403).json({ 
          error });
      }
      
      // First validate that the booking is within manager-set availability
      const bookingDateObj = new Date(bookingDate);
      const availabilityCheck = await firebaseStorage.validateBookingAvailability(
        kitchenId, 
        bookingDateObj, 
        startTime, 
        endTime
      );
      
      if (!availabilityCheck.valid) { return res.status(400).json({ error });
      }
      
      // Get location to get timezone and minimum booking window
      const kitchenLocationId2 = await firebaseStorage.getKitchenLocation(kitchenId);
      let location = null;
      let timezone = DEFAULT_TIMEZONE;
      let minimumBookingWindowHours = 1; // Default
      
      if (kitchenLocationId2) {
        location = await firebaseStorage.getLocationById(kitchenLocationId2);
        if (location) {
          timezone = (location ).timezone || DEFAULT_TIMEZONE;
          minimumBookingWindowHours = (location ).minimumBookingWindowHours || 1;
        }
      }
      
      // Extract date string from ISO string to avoid timezone shifts
      // The frontend sends bookingDate  string (e.g., "2025-01-15T00)
      // We need to extract the date part (YYYY-MM-DD) before timezone conversion
      const bookingDateStr = typeof bookingDate === 'string' 
        ? bookingDate.split('T')[0] 
        : bookingDateObj.toISOString().split('T')[0];
      
      // Validate booking time using timezone-aware functions
      if (isBookingTimePast(bookingDateStr, startTime, timezone)) { return res.status(400).json({ error });
      }
      
      // Check if booking is within minimum booking window (timezone-aware)
      const hoursUntilBooking = getHoursUntilBooking(bookingDateStr, startTime, timezone);
      if (hoursUntilBooking < minimumBookingWindowHours) { return res.status(400).json({ 
          error } hour${ minimumBookingWindowHours !== 1 ? 's'  } in advance` 
        });
      }
      
      // Check for conflicts with existing bookings
      const hasConflict = await firebaseStorage.checkBookingConflict(kitchenId, bookingDateObj, startTime, endTime);
      if (hasConflict) { return res.status(409).json({ error });
      }

      // Check daily booking limit
      const { pool } = await import('./db');
      
      // Calculate requested slots
      const [sH, sM] = String(startTime).split(').map(Number);
      const [eH, eM] = String(endTime).split(').map(Number);
      const requestedSlots = Math.max(1, Math.ceil(((eH * 60 + eM) - (sH * 60 + sM)) / 60));

      // Find maxSlotsPerChef for this kitchen/date
      let maxSlotsPerChef = 2;
      if (pool) { try {
          // 1. Try date-specific override first
          const overrideResult = await pool.query(`
            SELECT max_slots_per_chef
            FROM kitchen_date_overrides
            WHERE kitchen_id = $1 AND DATE(specific_date) = $2 } else {
            // 2. Try weekly schedule for this day of week
            const dayOfWeek = bookingDateObj.getDay();
            const availabilityResult = await pool.query(`
              SELECT max_slots_per_chef
              FROM kitchen_availability
              WHERE kitchen_id = $1 AND day_of_week = $2
            `, [kitchenId, dayOfWeek]);
            
            if (availabilityResult.rows.length > 0) {
              const v = Number(availabilityResult.rows[0].max_slots_per_chef);
              if (Number.isFinite(v) && v > 0) maxSlotsPerChef = v;
            } else {
              // 3. Fall back to location default
              const locationLimitResult = await pool.query(`
                SELECT l.default_daily_booking_limit
                FROM locations l
                INNER JOIN kitchens k ON k.location_id = l.id
                WHERE k.id = $1
              `, [kitchenId]);
              
              if (locationLimitResult.rows.length > 0) {
                const locVal = Number(locationLimitResult.rows[0].default_daily_booking_limit);
                if (Number.isFinite(locVal) && locVal > 0) maxSlotsPerChef = locVal;
              }
            }
          }
        } catch (error) { console.error('Error fetching daily booking limit }

        // Count already booked slots for this chef on this date (confirmed + pending)
        const existingBookings = await pool.query(`
          SELECT start_time, end_time
          FROM kitchen_bookings
          WHERE chef_id = $1
            AND kitchen_id = $2
            AND DATE(booking_date) = $3::date
            AND status IN ('pending','confirmed')
        `, [chefId, kitchenId, bookingDateStr]);

        let existingSlots = 0;
        for (const b of existingBookings.rows) { const [bsH, bsM] = String(b.start_time).split(' }

        // Check if booking would exceed daily limit
        if (existingSlots + requestedSlots > maxSlotsPerChef) { return res.status(400).json({ 
            error } hour(s).` 
          });
        }
      }

      // Step 1: Create booking in database
      console.log(`ðŸ“ STEP 1);
      const booking = await firebaseStorage.createKitchenBooking({ chefId });
      console.log(`âœ… STEP 1 COMPLETE);

      // Step 2: Send email notifications - SEQUENTIAL execution to ensure reliability
      console.log(`ðŸ“§ STEP 2);
      
      let emailResults = { chefEmailSent,
        managerEmailSent,
        errors };

      try { // Step 2.1 } not found`;
          console.error(`âŒ STEP 2.1 FAILED);
          emailResults.errors.push(errorMsg);
          throw new Error(errorMsg);
        }
        console.log(`âœ… STEP 2.1 COMPLETE);
        
        // Step 2.2: Get location details (DIRECT DATABASE QUERY - emails are in Neon database)
        console.log(`ðŸ“§ STEP 2.2);
        const kitchenLocationId = (kitchen ).locationId || (kitchen ).location_id;
        if (!kitchenLocationId) {
          const errorMsg = `Kitchen ${kitchenId} h locationId`;
          console.error(`âŒ STEP 2.2 FAILED);
          emailResults.errors.push(errorMsg);
          throw new Error(errorMsg);
        }
        console.log(`âœ… STEP 2.2 PROGRESS);
        
        // DIRECT DATABASE QUERY - emails are stored in Neon database, not Firebase
        if (!pool) { const errorMsg = `Database pool not available`;
          console.error(`âŒ STEP 2.2 FAILED }`);
          emailResults.errors.push(errorMsg);
          throw new Error(errorMsg);
        }
        
        const locationData = await pool.query(`
          SELECT l.id, l.name, l.manager_id, l.notification_email, l.timezone
          FROM locations l
          WHERE l.id = $1
        `, [kitchenLocationId]);
        
        if (locationData.rows.length === 0) {
          const errorMsg = `Location ${kitchenLocationId} not found`;
          console.error(`âŒ STEP 2.2 FAILED);
          emailResults.errors.push(errorMsg);
          throw new Error(errorMsg);
        }
        
        const location = locationData.rows[0];
        console.log(`âœ… STEP 2.2 COMPLETE);
        
        // Step 2.3: Get chef details
        console.log(`ðŸ“§ STEP 2.3);
        const chef = await storage.getUser(req.user.id);
        if (!chef) {
          const errorMsg = `Chef ${req.user.id} not found`;
          console.error(`âŒ STEP 2.3 FAILED);
          emailResults.errors.push(errorMsg);
          throw new Error(errorMsg);
        }
        console.log(`âœ… STEP 2.3 COMPLETE);
        
        // Step 2.4: Get manager details (DIRECT DATABASE QUERY - managers use session auth)
        console.log(`ðŸ“§ STEP 2.4);
        const managerId = location.manager_id;
        console.log(`ðŸ“‹ STEP 2.4 PROGRESS);
        
        let manager = null;
        if (managerId) { const managerData = await pool.query(`
            SELECT id, username
            FROM users
            WHERE id = $1
          `, [managerId]);
          
          if (managerData.rows.length > 0) {
            manager = managerData.rows[0];
            console.log(`âœ… STEP 2.4 COMPLETE }`);
          } else { console.warn(`âš ï¸ STEP 2.4 WARNING } not found in database, will use notification email only`);
          }
        } else { console.log(`âœ… STEP 2.4 COMPLETE }

        // Step 2.5)
        console.log(`ðŸ“§ STEP 2.5);
        let chefName = chef.username || 'Chef';
        let chefPhone = null;
        if (pool && req.user.id) {
          // Use utility function to get normalized phone
          chefPhone = await getChefPhone(req.user.id, pool);
          try {
            const appResult = await pool.query(
              'SELECT full_name FROM applications WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1',
              [req.user.id]
            );
            if (appResult.rows.length > 0 && appResult.rows[0].full_name) {
              chefName = appResult.rows[0].full_name;
            }
            console.log(`âœ… STEP 2.5 COMPLETE);
          } catch (error) {
            console.debug(`Could not get full name for chef ${req.user.id} from applications, using username`);
          }
          if (!chefPhone) { console.log(`âœ… STEP 2.5 COMPLETE }
        } else { console.log(`âœ… STEP 2.5 COMPLETE }

        // Step 2.6)
        console.log(`ðŸ“§ STEP 2.6);
        const chefEmailAddress = chef.username; // chef.username is the email
        if (!chefEmailAddress) {
          const errorMsg = `Chef ${req.user.id} h email address (username)`;
          console.error(`âŒ STEP 2.6 FAILED);
          emailResults.errors.push(errorMsg);
        } else { console.log(`ðŸ“§ STEP 2.6 PROGRESS }`);
          try { const chefEmail = generateBookingRequestEmail({
              chefEmail,
              chefName,
              kitchenName });
            console.log(`ðŸ“§ STEP 2.6 PROGRESS);
            
            // CRITICAL: Wait for email to complete before proceeding
            const emailSent = await sendEmail(chefEmail);
            if (emailSent) { console.log(`âœ… STEP 2.6 COMPLETE }`);
              emailResults.chefEmailSent = true;
            } else { const errorMsg = `sendEmail() returned false for chef email }`;
              console.error(`âŒ STEP 2.6 FAILED);
              emailResults.errors.push(errorMsg);
            }
          } catch (chefEmailError) { const errorMsg = `Exception sending chef email }`;
            console.error(`âŒ STEP 2.6 FAILED);
            console.error("Chef email error stack);
            emailResults.errors.push(errorMsg);
          }
        }
        
        // Step 2.7: Send manager email (ONLY after chef email completes)
        console.log(`ðŸ“§ STEP 2.7);
        // Use notification_email from direct database query (snake_case from DB)
        const notificationEmailAddress = location.notification_email || (manager ? manager.username );
        if (!notificationEmailAddress) { const errorMsg = `No notification email available - location.notification_email }, manager.username: ${manager.username || 'N/A'}`;
          console.error(`âŒ STEP 2.7 FAILED);
          console.error(`   Location ID);
          emailResults.errors.push(errorMsg);
        } else { console.log(`ðŸ“§ STEP 2.7 PROGRESS }`);
          console.log(`   Email source);
          try { const managerEmail = generateBookingNotificationEmail({
              managerEmail,
              chefName,
              kitchenName });
            console.log(`ðŸ“§ STEP 2.7 PROGRESS);
            
            // CRITICAL: Wait for email to complete before proceeding
            const emailSent = await sendEmail(managerEmail);
            if (emailSent) { console.log(`âœ… STEP 2.7 COMPLETE }`);
              emailResults.managerEmailSent = true;
            } else { const errorMsg = `sendEmail() returned false for manager email }`;
              console.error(`âŒ STEP 2.7 FAILED);
              console.error(`   This indicates the email sending failed silently. Check EMAIL_USER and EMAIL_PASS environment variables.`);
              emailResults.errors.push(errorMsg);
            }
          } catch (managerEmailError) { const errorMsg = `Exception sending manager email }`;
            console.error(`âŒ STEP 2.7 FAILED);
            console.error("Manager email error stack);
            emailResults.errors.push(errorMsg);
          }
        }

        // Step 2.8: Send manager SMS notification
        console.log(`ðŸ“± STEP 2.8);
        try { // Get manager phone number using utility function (with fallback logic)
          // Convert location to expected format for getManagerPhone
          const locationForSMS = {
            ...location,
            managerId };
          const managerPhone = await getManagerPhone(locationForSMS, managerId, pool);

          if (managerPhone) { const smsMessage = generateManagerBookingSMS({
              chefName,
              kitchenName });
            const smsSent = await sendSMS(managerPhone, smsMessage, { trackingId }_manager` });
            if (smsSent) { console.log(`âœ… STEP 2.8 COMPLETE }`);
            } else { console.warn(`âš ï¸ STEP 2.8 WARNING }`);
            }
          } else { console.log(`ðŸ“± STEP 2.8 SKIPPED }
        } catch (smsError) { console.error(`âŒ STEP 2.8 ERROR }
        
        // Final summary
        console.log(`ðŸ“§ STEP 2 COMPLETE);
        console.log(`   Chef email);
        console.log(`   Manager email);
        if (emailResults.errors.length > 0) { console.log(`   Errors encountered }`);
          emailResults.errors.forEach((error, index) => {
            console.log(`     ${index + 1}. ${error}`);
          });
        }
        
      } catch (emailError) { const errorMsg = emailError instanceof Error ? emailError.message  }`);
        console.error("Email error details);
        console.error("Email error stack);
        emailResults.errors.push(`Critical error);
        // Don't fail the booking if emails fail - booking is already created
      }
      
      console.log(`ðŸ“ FINAL);
      
      res.status(201).json(booking);
    } catch (error) { console.error("Error creating booking });
    }
  });

app.get("/api/chef/bookings", requireChef, async (req, res) => {
    try {
      const bookings = await firebaseStorage.getBookingsByChef(req.user.id);
      res.json(bookings);
    } catch (error) { console.error("Error fetching bookings });
    }
  });

app.put("/api/chef/bookings/) => { try {
      const id = parseInt(req.params.id);
      
      // Get booking details before cancelling
      const booking = await firebaseStorage.getBookingById(id);
      if (!booking) {
        return res.status(404).json({ error });
      }
      
      // Verify the booking belongs to this chef
      if (booking.chefId !== req.user.id) { return res.status(403).json({ error });
      }
      
      await firebaseStorage.cancelKitchenBooking(id, req.user.id);
      
      // Send email notifications to chef and manager
      try {
        // Get kitchen details
        const kitchen = await firebaseStorage.getKitchenById(booking.kitchenId);
        if (!kitchen) {
          console.warn(`âš ï¸ Kitchen ${booking.kitchenId} not found for email notification`);
        } else {
          // Get location details (DIRECT DATABASE QUERY - emails are in Neon database)
          const kitchenLocationId = (kitchen ).locationId || (kitchen ).location_id;
          if (!kitchenLocationId) {
            console.warn(`âš ï¸ Kitchen ${booking.kitchenId} h locationId`);
          } else if (!pool) {
            console.warn(`âš ï¸ Database pool not available for email notification`);
          } else {
            // DIRECT DATABASE QUERY - emails are stored in Neon database
            const locationData = await pool.query(`
              SELECT l.id, l.name, l.manager_id, l.notification_email
              FROM locations l
              WHERE l.id = $1
            `, [kitchenLocationId]);
            
            if (locationData.rows.length === 0) {
              console.warn(`âš ï¸ Location ${kitchenLocationId} not found for email notification`);
            } else {
              const location = locationData.rows[0];
              
              // Get chef details
              const chef = await storage.getUser(booking.chefId);
              if (!chef) {
                console.warn(`âš ï¸ Chef ${booking.chefId} not found for email notification`);
              } else {
                // Get manager details if manager_id is set (DIRECT DATABASE QUERY)
                const managerId = location.manager_id;
                let manager = null;
                if (managerId) {
                  const managerData = await pool.query(`
                    SELECT id, username
                    FROM users
                    WHERE id = $1
                  `, [managerId]);
                  
                  if (managerData.rows.length > 0) {
                    manager = managerData.rows[0];
                  }
                }

                // Get chef phone using utility function (from applications table)
                const chefPhone = await getChefPhone(booking.chefId, pool);
                
                // Import email functions
                const { sendEmail, generateBookingCancellationEmail, generateBookingCancellationNotificationEmail } = await import('./email.js');
                
                // Send email to chef
                try { const chefEmail = generateBookingCancellationEmail({
                    chefEmail });
                  await sendEmail(chefEmail);
                  console.log(`âœ… Booking cancellation email sent to chef);
                } catch (emailError) { console.error("Error sending chef cancellation email }

                // Send SMS to chef
                if (chefPhone) { try {
                    const smsMessage = generateChefSelfCancellationSMS({
                      kitchenName });
                    await sendSMS(chefPhone, smsMessage, { trackingId }_chef_self_cancelled` });
                    console.log(`âœ… Booking cancellation SMS sent to chef);
                  } catch (smsError) { console.error("Error sending chef cancellation SMS }
                }
                
                // Send email to manager (use notification_email from direct database query)
                const notificationEmailAddress = location.notification_email || (manager ? manager.username );
                
                if (notificationEmailAddress) { try {
                    const managerEmail = generateBookingCancellationNotificationEmail({
                      managerEmail,
                      chefName });
                    await sendEmail(managerEmail);
                    console.log(`âœ… Booking cancellation notification email sent to manager);
                  } catch (emailError) { console.error("Error sending manager cancellation email }
                } else {
                  console.warn(`âš ï¸ No notification email found for location ${kitchenLocationId}`);
                }

                // Send SMS to manager
                try { // Get manager phone number using utility function (with fallback to applications table)
                  const managerPhone = await getManagerPhone(location, managerId, pool);

                  if (managerPhone) {
                    const smsMessage = generateManagerBookingCancellationSMS({
                      chefName });
                    await sendSMS(managerPhone, smsMessage, { trackingId }_manager_cancelled` });
                    console.log(`âœ… Booking cancellation SMS sent to manager);
                  }
                } catch (smsError) { console.error("Error sending manager cancellation SMS }
              }
            }
          }
        }
      } catch (emailError) { console.error("Error sending booking cancellation emails }
      
      res.json({ success });
    } catch (error) { console.error("Error cancelling booking });
    }
  });

app.post("/api/chef/share-profile", requireChef, async (req, res) => {
    try {
      const { locationId } = req.body;
      const chefId = req.user.id;
      
      if (!locationId) { return res.status(400).json({ error });
      }

      // Check if chef h-granted access to this location
      const hasLocationAccess = await firebaseStorage.chefHasLocationAccess(chefId, locationId);
      
      if (!hasLocationAccess) { return res.status(403).json({ error });
      }

      // Get chef details before sharing profile
      const chef = await storage.getUser(chefId);
      if (!chef) { return res.status(404).json({ error });
      }

      // Get location details
      const location = await firebaseStorage.getLocationById(locationId);
      if (!location) { return res.status(404).json({ error });
      }

      // Get chef's application details for email
      const chefApp = await db
        .select()
        .from(applications)
        .where(and(
          eq(applications.userId, chefId),
          eq(applications.status, 'approved')
        ))
        .orderBy(desc(applications.createdAt))
        .limit(1);

      const profile = await firebaseStorage.shareChefProfileWithLocation(chefId, locationId);
      
      // Send email to manager if this is a new profile share (status is pending)
      if (profile && profile.status === 'pending') { try {
          const managerEmail = (location ).notificationEmail || (location ).notification_email;
          if (managerEmail) {
            const chefName = chefApp.length > 0 && chefApp[0].fullName 
              ? chefApp[0].fullName 
               });
            await sendEmail(emailContent);
            console.log(`âœ… Chef profile request notification sent to manager);
          }
        } catch (emailError) { console.error("Error sending chef profile request notification }
      }
      
      res.status(201).json(profile);
    } catch (error) { console.error("Error sharing chef profile });
    }
  });

app.get("/api/chef/profiles", requireChef, async (req, res) => {
    try {
      const chefId = req.user.id;
      
      // Get all locations chef h to via admin-granted access
      const locationAccessRecords = await db
        .select()
        .from(chefLocationAccess)
        .where(eq(chefLocationAccess.chefId, chefId));
      
      const locationIds = locationAccessRecords.map(access => access.locationId);
      
      if (locationIds.length === 0) {
        return res.json([]);
      }
      
      // Get all locations with details
      const allLocations = await db
        .select()
        .from(locations)
        .where(inArray(locations.id, locationIds));
      
      // Get profiles for all accessible locations
      const profiles = await Promise.all(
        locationIds.map(async (locationId) => {
          const profile = await firebaseStorage.getChefLocationProfile(chefId, locationId);
          const location = allLocations.find(l => l.id === locationId);
          return { locationId, location, profile };
        })
      );
      
      res.json(profiles);
    } catch (error) { console.error("Error getting chef profiles });
    }
  });

app.post("/api/admin/chef-location-access", async (req, res) => { try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "admin") { return res.status(403).json({ error });
      }

      const { chefId, locationId } = req.body;
      
      if (!chefId || !locationId) { return res.status(400).json({ error });
      }

      const access = await firebaseStorage.grantChefLocationAccess(chefId, locationId, user.id);
      
      // Send email notification to chef when access is granted
      try {
        // Get location details
        const location = await firebaseStorage.getLocationById(locationId);
        if (!location) {
          console.warn(`âš ï¸ Location ${locationId} not found for email notification`);
        } else {
          // Get chef details
          const chef = await storage.getUser(chefId);
          if (!chef) {
            console.warn(`âš ï¸ Chef ${chefId} not found for email notification`);
          } else { try {
              const chefEmail = generateChefLocationAccessApprovedEmail({
                chefEmail });
              await sendEmail(chefEmail);
              console.log(`âœ… Chef location access granted email sent to chef);
            } catch (emailError) { console.error("Error sending chef access email }
          }
        }
      } catch (emailError) { console.error("Error sending chef access emails }
      
      res.status(201).json(access);
    } catch (error) { console.error("Error granting chef location access });
    }
  });

app.delete("/api/admin/chef-location-access", async (req, res) => { try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "admin") { return res.status(403).json({ error });
      }

      const { chefId, locationId } = req.body;
      
      if (!chefId || !locationId) { return res.status(400).json({ error });
      }

      await firebaseStorage.revokeChefLocationAccess(chefId, locationId);
      res.json({ success });
    } catch (error) { console.error("Error revoking chef location access });
    }
  });

app.get("/api/admin/chef-location-access", async (req, res) => { try {
      console.log("[Admin Chef Access] GET request received");
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      console.log("[Admin Chef Access] Auth check });
      
      if (!sessionUser && !isFirebaseAuth) { console.log("[Admin Chef Access] Not authenticated");
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      console.log("[Admin Chef Access] User);
      
      if (user.role !== "admin") { console.log("[Admin Chef Access] Not admin");
        return res.status(403).json({ error });
      }

      // Get all chefs from database
      // Chefs are identified by role = 'chef' OR isChef = true
      const allUsers = await db.select().from(users);
      const chefs = allUsers.filter(u => {
        const role = (u ).role;
        const isChef = (u ).isChef ?? (u ).is_chef;
        return role === 'chef' || isChef === true;
      });
      
      console.log(`[Admin Chef Access] Total users);
      console.log(`[Admin Chef Access] Chefs)));
      
      // Get all locations
      const allLocations = await db.select().from(locations);
      console.log(`[Admin Chef Access] Found ${allLocations.length} locations`);
      
      // Get all location access records (handle case if table doesn't exist yet)
      let allAccess = [];
      try {
        allAccess = await db.select().from(chefLocationAccess);
        console.log(`[Admin Chef Access] Found ${allAccess.length} location access records`);
      } catch (error) { console.error(`[Admin Chef Access] Error querying chef_location_access table } else {
          throw error; // Re-throw if it's a different error
        }
      }
      
      // Build response with chef location access info
      const response = chefs.map(chef => {
        // Handle both camelCase (Drizzle) and snake_case (raw SQL) field names
        const chefAccess = allAccess.filter(a => {
          const accessChefId = (a ).chefId ?? (a ).chef_id;
          return accessChefId === chef.id;
        });
        const accessibleLocations = chefAccess.map(access => { // Handle both camelCase (Drizzle) and snake_case (raw SQL) field names
          const accessLocationId = (access ).locationId ?? (access ).location_id;
          const location = allLocations.find(l => l.id === accessLocationId);
          
          if (location) {
            const grantedAt = (access ).grantedAt ?? (access ).granted_at;
            return {
              id };
          }
          return null;
        }).filter((l): l is NonNullable<typeof l> => l !== null);
        
        return { chef },
          accessibleLocations,
        };
      });
      
      console.log(`[Admin Chef Access] Returning ${response.length} chefs with location access info`);
      res.json(response);
    } catch (error) { console.error("[Admin Chef Access] Error });
    }
  });

app.post("/api/admin/managers", async (req, res) => { try {
      // Check authentication - support both session and Firebase auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "admin") { return res.status(403).json({ error });
      }

      const { username, password, email, name } = req.body;
      
      // Validate required fields
      if (!username || !password) { return res.status(400).json({ error });
      }
      
      // Check if user already exists
      const existingUser = await firebaseStorage.getUserByUsername(username);
      if (existingUser) { return res.status(400).json({ error });
      }

      // Create manager user with hashed password
      // Set has_seen_welcome to false to force password change on first login
      const hashedPassword = await hashPassword(password);
      const manager = await firebaseStorage.createUser({ username,
        password,
        role });

      // Send welcome email to manager with credentials
      try { // Use email field if provided, otherwise fallback to username
        const managerEmail = email || username;
        
        const welcomeEmail = generateManagerCredentialsEmail({
          email,
          name });
        
        await sendEmail(welcomeEmail);
        console.log(`âœ… Welcome email with credentials sent to manager);
      } catch (emailError) { console.error("Error sending manager welcome email }

      res.status(201).json({ success, managerId });
    } catch (error) { console.error("Error creating manager });
    }
  });

app.get("/api/admin/managers", async (req, res) => { try {
      // Check authentication - support both session and Firebase auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      
      if (user.role !== "admin") { return res.status(403).json({ error });
      }

      // Fetch all users with manager role and their managed locations with notification emails
      const { pool, db } = await import('./db');
      
      console.log('ðŸ” GET /api/admin/managers - Pool available?', !!pool);
      console.log('ðŸ” GET /api/admin/managers - DB available?', !!db);
      
      // CRITICAL: Always use pool if available (faster SQL aggregation)
      // Only fallback to Drizzle if pool is not available
      if (pool) { console.log('âœ… Using pool query for GET /api/admin/managers');
        
        // Get managers with their locations and notification emails
        // CRITICAL });
        }
        
        // Transform the result to include notification emails in a flat structure
        console.log(`ðŸ“Š Raw database result - ${result.rows.length} manager(s) found`);
        if (result.rows.length > 0) { console.log(`ðŸ“Š First row keys }
        
        const managersWithEmails = result.rows.map((row) => {
          // Parse JSON if it's a string, otherwise use as-is
          // PostgreSQL json_agg returns JSON  string or object depending on driver
          let locations = row.locations;
          
          console.log(`ðŸ” Manager ${row.id} (${row.username}): raw locations =`, typeof locations, locations);
          console.log(`ðŸ” Manager ${row.id}));
          
          // Handle different return types from PostgreSQL
          // COALESCE in SQL should ensure we get []:, but handle all cases
          if (locations === null || locations === undefined) {
            console.log(`âš ï¸ Manager ${row.id});
            locations = [];
          } else if (typeof locations === 'string') {
            try {
              // Handle empty JSON array string
              const trimmed = locations.trim();
              if (trimmed === '[]' || trimmed === '' || trimmed === 'null') {
                locations = [];
                console.log(`âœ… Manager ${row.id});
              } else {
                locations = JSON.parse(locations);
                console.log(`âœ… Manager ${row.id}) ? locations.length  } items`);
              }
            } catch (e) {
              console.error(`âŒ Error parsing locations JSON for manager ${row.id});
              locations = [];
            }
          } else if (typeof locations === 'object') {
            // Already parsed JSON object/array
            console.log(`âœ… Manager ${row.id})}`);
          }
          
          // Ensure locations is an array (handle case where it's already parsed)
          if (!Array.isArray(locations)) {
            console.warn(`âš ï¸ Manager ${row.id} locations is not an array after processing);
            // Try to extract array if it's wrapped in an object
            if (locations && typeof locations === 'object' && '0' in locations) {
              locations = Object.values(locations);
            } else {
              locations = [];
            }
          }
          
          console.log(`âœ… Manager ${row.id} (${row.username}) FINAL: ${locations.length} location(s):`, JSON.stringify(locations, null, 2));
          
          // Get all notification emails from locations managed by this manager
          // Handle both camelCase (from mapping) and raw snake_case
          const notificationEmails = locations
            .map((loc) => loc.notificationEmail || loc.notification_email)
            .filter((email) => email && email.trim() !== '');
          
          // STEP 4: Map to consistent structure (camelCase)
          const mappedLocations = locations.map((loc) => { // Handle both camelCase and snake_case from database
            const locationId = loc.locationId || loc.location_id || loc.id;
            const locationName = loc.locationName || loc.location_name || loc.name;
            const notificationEmail = loc.notificationEmail || loc.notification_email || null;
            
            return {
              locationId,
              locationName,
              notificationEmail };
          });
          
          // CRITICAL: Build managerData with explicit locations property
          const managerData = { id };
          
          // EXPLICITLY set locations property - do not rely on object spread
          managerData.locations = mappedLocations;
          
          console.log(`ðŸ“¦ Manager ${row.id} FINAL structure (BEFORE return):`, { id });
          
          // Verify the object h before returning
          if (!('locations' in managerData)) { console.error(`âŒ CRITICAL ERROR } object missing locations property!`);
            managerData.locations = [];
          }
          
          return managerData;
        });
        
        console.log('ðŸ“¤ GET /api/admin/managers - managersWithEmails.length);
        if (managersWithEmails.length > 0) { const firstManager = managersWithEmails[0];
          console.log('ðŸ“¤ managersWithEmails[0] keys }
        
        // FINAL VERIFICATION) => { // CRITICAL } is missing locations property! Adding it.`);
            manager.locations = [];
          } else if (!Array.isArray(manager.locations)) {
            console.warn(`âš ï¸ Manager ${manager.id} h but it's not an array (${typeof manager.locations}), converting`);
            manager.locations = Array.isArray(manager.locations) ? manager.locations : [];
          }
          
          // Return a new object with explicit structure to ensure properties are preserved
          return { id };
        });
        
        console.log('ðŸ“¤ FINAL VERIFIED - First manager structure);
        
        // CRITICAL: Log what we're actually sending
        console.log('ðŸ“¤ SENDING RESPONSE - Full response array));
        
        return res.json(verifiedManagers);
      } else {
        // Fallback to Drizzle if pool is not available
        try {
          console.log('âš ï¸ Using Drizzle fallback for GET /api/admin/managers');
          const { users, locations } = await import('@shared/schema');
          const { eq } = await import('drizzle-orm');
          const managerRows = await db
            .select({ id })
            .from(users)
            .where(eq(users.role , 'manager'));
          
          console.log(`Found ${managerRows.length} managers with Drizzle`);
          
          // Get locations for each manager
          const managersWithLocations = await Promise.all(
            managerRows.map(async (manager) => {
              const managerLocations = await db
                .select()
                .from(locations)
                .where(eq(locations.managerId, manager.id));
              
              console.log(`Manager ${manager.id} has ${managerLocations.length} locations`);
              
              const notificationEmails = managerLocations
                .map(loc => (loc ).notificationEmail || (loc ).notification_email)
                .filter(email => email && email.trim() !== '');
              
              // CRITICAL: Build managerData with explicit locations property
              const managerData = { id };
              
              // EXPLICITLY set locations property
              managerData.locations = managerLocations.map(loc => ({ locationId }));
              
              console.log(`ðŸ“¤ Drizzle Manager ${manager.id} final structure);
              
              return managerData;
            })
          );
          
          console.log('ðŸ“¤ Drizzle fallback returning', managersWithLocations.length, 'managers');
          if (managersWithLocations.length > 0) { console.log('ðŸ“¤ Drizzle managersWithLocations[0] FULL }
          // CRITICAL);
        } catch (e) { console.error('âŒ Error fetching managers with Drizzle }
      }
    } catch (error) { console.error("Error fetching managers });
    }
  });

app.post("/api/manager/change-password", async (req, res) => { try {
      // Check authentication - support both session and Firebase auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "manager") { return res.status(403).json({ error });
      }

      const { currentPassword, newPassword } = req.body;

      // Validate required fields
      if (!currentPassword || !newPassword) { return res.status(400).json({ error });
      }

      // Validate new password strength
      if (newPassword.length < 8) { return res.status(400).json({ error });
      }

      // Get full user data to verify current password
      const fullUser = await storage.getUser(user.id);
      if (!fullUser) { return res.status(404).json({ error });
      }

      // Verify current password
      const passwordMatches = await comparePasswords(currentPassword, fullUser.password);
      if (!passwordMatches) { return res.status(400).json({ error });
      }

      // Update password using direct database query
      const hashedNewPassword = await hashPassword(newPassword);
      const { pool } = await import('./db');
      if (pool) {
        await pool.query(
          'UPDATE users SET password = $1 WHERE id = $2',
          [hashedNewPassword, user.id]
        );
      } else {
        // Fallback for in-memory storage
        const memUser = await storage.getUser(user.id);
        if (memUser) {
          (memUser ).password = hashedNewPassword;
        }
      }

      // Mark that manager h password (set has_seen_welcome to true)
      await storage.setUserHasSeenWelcome(user.id);

      res.json({ success, message });
    } catch (error) { console.error("Error changing password });
    }
  });

app.get("/api/admin/locations", async (req, res) => { try {
      // Check authentication - support both session and Firebase auth
      const isSessionAuth = req.isAuthenticated.();
      const isFirebaseAuth = req.neonUser;
      
      if (!isSessionAuth && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : req.user!;
      if (user.role !== "admin") { return res.status(403).json({ error });
      }

      const locations = await firebaseStorage.getAllLocations();
      
      // Map snake_case fields to camelCase for the frontend (consistent with manager endpoint)
      // Drizzle ORM may return snake_case depending on configuration, so we ensure camelCase
      const mappedLocations = locations.map((loc) => ({ ...loc, managerId } hours of the scheduled time.", defaultDailyBookingLimit));
      
      res.json(mappedLocations);
    } catch (error) { console.error("Error fetching locations });
    }
  });

app.post("/api/admin/locations", async (req, res) => { try {
      // Check authentication - support both session and Firebase auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "admin") { return res.status(403).json({ error });
      }

      const { name, address, managerId } = req.body;
      
      // Convert managerId to number or undefined
      // Handle empty strings, null, undefined, and convert to number
      let managerIdNum = undefined;
      if (managerId !== undefined && managerId !== null && managerId !== '') { managerIdNum = parseInt(managerId.toString());
        if (isNaN(managerIdNum) || managerIdNum <= 0) {
          return res.status(400).json({ error });
        }
        
        // Validate that the manager exists and h role
        // Use firebaseStorage to be consistent with location creation
        const manager = await firebaseStorage.getUser(managerIdNum);
        if (!manager) { return res.status(400).json({ error } does not exist` });
        }
        if (manager.role !== 'manager') { return res.status(400).json({ error } is not a manager` });
        }
      }
      
      // Normalize notification phone if provided
      let normalizedNotificationPhone = undefined;
      if (req.body.notificationPhone && req.body.notificationPhone.trim() !== '') { const normalized = normalizePhoneForStorage(req.body.notificationPhone);
        if (!normalized) {
          return res.status(400).json({ 
            error });
        }
        normalizedNotificationPhone = normalized;
      }
      
      console.log('Creating location with);
      
      const location = await firebaseStorage.createLocation({ name, 
        address, 
        managerId,
        notificationEmail });
      
      // Map snake_case to camelCase for consistent API response
      const mappedLocation = { ...location,
        managerId } hours of the scheduled time.",
        defaultDailyBookingLimit: (location ).defaultDailyBookingLimit || (location ).default_daily_booking_limit || 2,
        createdAt: (location ).createdAt || (location ).created_at,
        updatedAt: (location ).updatedAt || (location ).updated_at,
      };
      
      res.status(201).json(mappedLocation);
    } catch (error) { console.error("Error creating location });
    }
  });

app.get("/api/admin/kitchens/) => { try {
      // Check authentication - support both session and Firebase auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "admin") { return res.status(403).json({ error });
      }

      const locationId = parseInt(req.params.locationId);
      if (isNaN(locationId) || locationId <= 0) { return res.status(400).json({ error });
      }

      const kitchens = await firebaseStorage.getKitchensByLocation(locationId);
      res.json(kitchens);
    } catch (error) { console.error("Error fetching kitchens });
    }
  });

app.post("/api/admin/kitchens", async (req, res) => { try {
      // Check authentication - support both session and Firebase auth
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "admin") { return res.status(403).json({ error });
      }

      const { locationId, name, description } = req.body;
      
      // Validate required fields
      if (!locationId || !name) { return res.status(400).json({ error });
      }
      
      // Validate locationId is a valid number
      const locationIdNum = parseInt(locationId.toString());
      if (isNaN(locationIdNum) || locationIdNum <= 0) { return res.status(400).json({ error });
      }
      
      // Validate that the location exists
      const location = await firebaseStorage.getLocationById(locationIdNum);
      if (!location) { return res.status(400).json({ error } does not exist` });
      }
      
      const kitchen = await firebaseStorage.createKitchen({ locationId, name, description, isActive });
      res.status(201).json(kitchen);
    } catch (error) { console.error("Error creating kitchen });
      }
      res.status(500).json({ error });
    }
  });

app.put("/api/admin/locations/) => { try {
      console.log(`ðŸ“ PUT /api/admin/locations/ }`);
      console.log(`ðŸ“ Request body));
      
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) { console.error('âŒ PUT /api/admin/locations/ });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "admin") { console.error(`âŒ PUT /api/admin/locations/ } is not admin (role)`);
        return res.status(403).json({ error });
      }

      const locationId = parseInt(req.params.id);
      if (isNaN(locationId) || locationId <= 0) { console.error(`âŒ Invalid location ID }`);
        return res.status(400).json({ error });
      }
      
      console.log(`âœ… Validated - updating location ${locationId} for admin user ${user.id}`);

      const { name, address, managerId, notificationEmail, notificationPhone } = req.body;
      
      // Validate managerId if provided
      let managerIdNum = undefined;
      if (managerId !== undefined && managerId !== null && managerId !== '') { managerIdNum = parseInt(managerId.toString());
        if (isNaN(managerIdNum) || managerIdNum <= 0) {
          return res.status(400).json({ error });
        }
        
        // Validate that the manager exists and h role
        const manager = await firebaseStorage.getUser(managerIdNum);
        if (!manager) { return res.status(400).json({ error } does not exist` });
        }
        if (manager.role !== 'manager') { return res.status(400).json({ error } is not a manager` });
        }
      } else if (managerId === null || managerId === '') {
        // Explicitly allow setting to null
        managerIdNum = null;
      }

      const updates = {};
      if (name !== undefined) updates.name = name;
      if (address !== undefined) updates.address = address;
      if (managerIdNum !== undefined) updates.managerId = managerIdNum;
      if (notificationEmail !== undefined) updates.notificationEmail = notificationEmail || null;
      
      // Normalize phone number if provided
      if (notificationPhone !== undefined) { if (notificationPhone && notificationPhone.trim() !== '') {
          const normalized = normalizePhoneForStorage(notificationPhone);
          if (!normalized) {
            return res.status(400).json({ 
              error });
          }
          updates.notificationPhone = normalized;
        } else {
          updates.notificationPhone = null;
        }
      }

      console.log(`ðŸ’¾ Updating location ${locationId} with);
      
      const updated = await firebaseStorage.updateLocation(locationId, updates);
      if (!updated) {
        console.error(`âŒ Location ${locationId} not found in database`);
        return res.status(404).json({ error });
      }
      
      console.log(`âœ… Location ${locationId} updated successfully`);
      
      // Map snake_case to camelCase for consistent API response (matching getAllLocations pattern)
      const mappedLocation = { ...updated,
        managerId } hours of the scheduled time.",
        defaultDailyBookingLimit: (updated ).defaultDailyBookingLimit || (updated ).default_daily_booking_limit || 2,
        createdAt: (updated ).createdAt || (updated ).created_at,
        updatedAt: (updated ).updatedAt || (updated ).updated_at,
      };
      
      return res.json(mappedLocation);
    } catch (error) { console.error("âŒ Error updating location });
    }
  });

app.delete("/api/admin/locations/) => { try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "admin") { return res.status(403).json({ error });
      }

      const locationId = parseInt(req.params.id);
      if (isNaN(locationId) || locationId <= 0) { return res.status(400).json({ error });
      }

      await firebaseStorage.deleteLocation(locationId);
      res.json({ success, message });
    } catch (error) { console.error("Error deleting location });
    }
  });

app.put("/api/admin/kitchens/) => { try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "admin") { return res.status(403).json({ error });
      }

      const kitchenId = parseInt(req.params.id);
      if (isNaN(kitchenId) || kitchenId <= 0) { return res.status(400).json({ error });
      }

      // Get current kitchen data for comparison
      const currentKitchen = await firebaseStorage.getKitchenById(kitchenId);
      if (!currentKitchen) { return res.status(404).json({ error });
      }

      const { name, description, isActive, locationId } = req.body;
      
      const updates = {};
      const changesList = [];
      
      if (name !== undefined && name !== currentKitchen.name) {
        updates.name = name;
        changesList.push(`Name changed to "${name}"`);
      }
      if (description !== undefined && description !== currentKitchen.description) {
        updates.description = description;
        changesList.push(`Description updated`);
      }
      if (isActive !== undefined && isActive !== currentKitchen.isActive) { updates.isActive = isActive;
        changesList.push(`Status changed to ${isActive ? 'Active'  }`);
      }
      if (locationId !== undefined) { const locationIdNum = parseInt(locationId.toString());
        if (isNaN(locationIdNum) || locationIdNum <= 0) {
          return res.status(400).json({ error });
        }
        
        // Validate that the location exists
        const location = await firebaseStorage.getLocationById(locationIdNum);
        if (!location) { return res.status(400).json({ error } does not exist` });
        }
        if (locationIdNum !== currentKitchen.locationId) {
          updates.locationId = locationIdNum;
          changesList.push(`Location changed to "${location.name}"`);
        }
      }

      // Only update if there are actual changes
      if (Object.keys(updates).length === 0) {
        return res.json(currentKitchen);
      }

      const updated = await firebaseStorage.updateKitchen(kitchenId, updates);
      if (!updated) { return res.status(404).json({ error });
      }
      
      // Send email notifications to chefs and managers
      if (changesList.length > 0) { try {
          const kitchen = await firebaseStorage.getKitchenById(kitchenId);
          if (kitchen) {
            const location = await firebaseStorage.getLocationById(kitchen.locationId);
            
            // Get all chefs who have bookings at this kitchen
            const bookings = await firebaseStorage.getBookingsByKitchen(kitchenId);
            const uniqueChefIds = Array.from(new Set(bookings.map(b => b.chefId)));
            
            const changes = changesList.join(', ');
            
            // Send emails to chefs
            for (const chefId of uniqueChefIds) {
              try {
                const chef = await storage.getUser(chefId);
                if (chef) {
                  const email = generateKitchenSettingsChangeEmail({
                    email });
                  await sendEmail(email);
                  console.log(`âœ… Kitchen settings change email sent to chef);
                }
              } catch (emailError) {
                console.error(`Error sending email to chef ${chefId});
              }
            }
            
            // Send email to manager
            if (location.managerId) { try {
                const manager = await storage.getUser(location.managerId);
                if (manager) {
                  const notificationEmail = (location ).notificationEmail || (location ).notification_email || manager.username;
                  const email = generateKitchenSettingsChangeEmail({
                    email,
                    name });
                  await sendEmail(email);
                  console.log(`âœ… Kitchen settings change email sent to manager);
                }
              } catch (emailError) { console.error(`Error sending email to manager }
            }
          }
        } catch (emailError) { console.error("Error sending kitchen settings change emails }
      }
      
      res.json(updated);
    } catch (error) { console.error("Error updating kitchen });
    }
  });

app.delete("/api/admin/kitchens/) => { try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "admin") { return res.status(403).json({ error });
      }

      const kitchenId = parseInt(req.params.id);
      if (isNaN(kitchenId) || kitchenId <= 0) { return res.status(400).json({ error });
      }

      await firebaseStorage.deleteKitchen(kitchenId);
      res.json({ success, message });
    } catch (error) { console.error("Error deleting kitchen });
    }
  });

app.put("/api/admin/managers/) => { try {
      console.log(`ðŸ“ PUT /api/admin/managers/ }`);
      console.log(`ðŸ“ Request body));
      
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) { console.error('âŒ PUT /api/admin/managers/ });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "admin") { console.error(`âŒ PUT /api/admin/managers/ } is not admin (role)`);
        return res.status(403).json({ error });
      }

      const managerId = parseInt(req.params.id);
      if (isNaN(managerId) || managerId <= 0) { console.error(`âŒ Invalid manager ID }`);
        return res.status(400).json({ error });
      }
      
      console.log(`âœ… Validated - updating manager ${managerId} for admin user ${user.id}`);

      const { username, role, isManager, locationNotificationEmails } = req.body;
      
      // Verify the user exists and is a manager
      const manager = await firebaseStorage.getUser(managerId);
      if (!manager) { return res.status(404).json({ error });
      }
      if (manager.role !== 'manager') { return res.status(400).json({ error });
      }

      const updates = {};
      if (username !== undefined) { // Check if username is already taken by another user
        const existingUser = await firebaseStorage.getUserByUsername(username);
        if (existingUser && existingUser.id !== managerId) {
          return res.status(400).json({ error });
        }
        updates.username = username;
      }
      if (role !== undefined) updates.role = role;
      if (isManager !== undefined) updates.isManager = isManager;

      const updated = await firebaseStorage.updateUser(managerId, updates);
      if (!updated) { return res.status(404).json({ error });
      }
      
      // Update notification emails for locations managed by this manager
      if (locationNotificationEmails && Array.isArray(locationNotificationEmails)) {
        const { db } = await import('./db');
        const { locations } = await import('@shared/schema');
        const { eq } = await import('drizzle-orm');
        
        // Get all locations managed by this manager
        const managedLocations = await db
          .select()
          .from(locations)
          .where(eq(locations.managerId, managerId));
        
        // Update each location's notification email
        for (const emailUpdate of locationNotificationEmails) {
          if (emailUpdate.locationId && emailUpdate.notificationEmail !== undefined) {
            const locationId = parseInt(emailUpdate.locationId.toString());
            if (!isNaN(locationId)) {
              // Validate email format if provided and not empty
              const email = emailUpdate.notificationEmail.trim() || '';
              if (email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                console.warn(`Invalid email format for location ${locationId});
                continue; // Skip invalid emails
              }
              
              await db
                .update(locations)
                .set({ notificationEmail })
                .where(eq(locations.id, locationId));
              
              console.log(`âœ… Updated notification email for location ${locationId});
            }
          }
        }
      }
      
      // Return updated manager with location info
      const { locations } = await import('@shared/schema');
      const { eq } = await import('drizzle-orm');
      const managedLocations = await db
        .select()
        .from(locations)
        .where(eq(locations.managerId, managerId));
      
      const notificationEmails = managedLocations
        .map(loc => (loc ).notificationEmail || (loc ).notification_email)
        .filter(email => email && email.trim() !== '');
      
      const response = { ...updated,
        locations })),
        notificationEmails,
        primaryNotificationEmail: notificationEmails.length > 0 ? notificationEmails[0] : null
      };
      
      res.json(response);
    } catch (error) { console.error("Error updating manager });
    }
  });

app.delete("/api/admin/managers/) => { try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      if (user.role !== "admin") { return res.status(403).json({ error });
      }

      const managerId = parseInt(req.params.id);
      if (isNaN(managerId) || managerId <= 0) { return res.status(400).json({ error });
      }

      // Prevent deleting yourself
      if (managerId === user.id) { return res.status(400).json({ error });
      }

      // Verify the user exists and is a manager
      const manager = await firebaseStorage.getUser(managerId);
      if (!manager) { return res.status(404).json({ error });
      }
      if (manager.role !== 'manager') { return res.status(400).json({ error });
      }

      await firebaseStorage.deleteUser(managerId);
      res.json({ success, message });
    } catch (error) { console.error("Error deleting manager });
    }
  });

app.post("/api/portal-login", async (req, res) => {
    try {
      const { username, password } = req.body;

      if (!username || !password) { return res.status(400).json({ error });
      }

      console.log('Portal user login attempt for);

      // Get portal user
      const portalUser = await firebaseStorage.getUserByUsername(username);

      if (!portalUser) { console.log('Portal user not found });
      }

      // Verify user is portal user
      const isPortalUser = (portalUser ).isPortalUser || (portalUser ).is_portal_user;
      if (!isPortalUser) { console.log('User is not a portal user });
      }

      // Check password
      const passwordMatches = await comparePasswords(password, portalUser.password);

      if (!passwordMatches) { console.log('Password mismatch for portal user });
      }

      // Log in the user
      req.login(portalUser, (err) => { if (err) {
          console.error('Login error });
        }

        // Get user's assigned location
        const getPortalUserLocation = async () => {
          try {
            const { portalUserLocationAccess } = await import('../shared/schema');
            const { eq } = await import('drizzle-orm');
            
            const accessRecords = await db.select()
              .from(portalUserLocationAccess)
              .where(eq(portalUserLocationAccess.portalUserId, portalUser.id));
            
            if (accessRecords.length > 0) {
              return accessRecords[0].locationId;
            }
            return null;
          } catch (error) { console.error('Error fetching portal user location }
        };

        getPortalUserLocation().then((locationId) => { res.json({
            id });
        });
      });
    } catch (error) { console.error("Portal login error });
    }
  });

app.post("/api/portal-register", async (req, res) => {
    console.log("[Routes] /api/portal-register called");
    try {
      const { username, password, locationId, fullName, email, phone, company } = req.body;

      if (!username || !password || !locationId || !fullName || !email || !phone) { return res.status(400).json({ error });
      }

      // Validate location exists
      const location = await firebaseStorage.getLocationById(parseInt(locationId));
      if (!location) { return res.status(400).json({ error });
      }

      // Check if user already exists
      let user = await firebaseStorage.getUserByUsername(username);
      let isNewUser = false;
      
      if (!user) { // Hash password and create user
        const hashedPassword = await hashPassword(password);

        user = await firebaseStorage.createUser({
          username,
          password,
          role });
        isNewUser = true;
      } else { // Check if user is already a portal user
        const isPortalUser = (user ).isPortalUser || (user ).is_portal_user;
        if (!isPortalUser) {
          return res.status(400).json({ error });
        }
      }

      // Check if user already h application for this location
      let existingApplications = [];
      try {
        existingApplications = await db.select()
          .from(portalUserApplications)
          .where(
            and(
              eq(portalUserApplications.userId, user.id),
              eq(portalUserApplications.locationId, parseInt(locationId))
            )
          );
      } catch (dbError) { console.error("Error checking existing applications });
        }
        throw dbError;
      }
      
      if (existingApplications.length > 0) { const existingApp = existingApplications[0];
        if (existingApp.status === 'inReview' || existingApp.status === 'approved') {
          return res.status(400).json({ 
            error });
        }
      }

      // Create application
      let application: any[];
      try { // Normalize phone number before storing
        const normalizedPhone = normalizePhoneForStorage(phone);
        if (!normalizedPhone) {
          return res.status(400).json({ error });
        }
        
        application = await db.insert(portalUserApplications).values({ userId }).returning();
      } catch (dbError) { console.error("Error creating application });
        }
        throw dbError;
      }

      // Log the user in immediately after registration (for both new and existing users)
      return new Promise<void>((resolve, reject) => { req.login(user, (err) => {
          if (err) {
            console.error("Login error after registration });
          }
          
          // Send notification to manager
          (async () => {
            try {
              const { sendEmail } = await import('./email');
              
              // First, try to get notification_email from location (preferred)
              let managerEmail = (location ).notificationEmail || (location ).notification_email;
              
              // If no notification_email, get manager's email from manager_id
              if (!managerEmail) {
                const managerId = (location ).managerId || (location ).manager_id;
                if (managerId) {
                  const manager = await firebaseStorage.getUser(managerId);
                  if (manager && (manager ).username) {
                    managerEmail = (manager ).username;
                  }
                }
              }
              
              // Send email if we have a manager email
              if (managerEmail) { const emailContent = {
                  to,
                  subject }`,
                  text: `A new portal user h for access to your location:\n\n` +
                        `Location: ${(location ).name}\n` +
                        `Applicant Name: ${fullName}\n` +
                        `Email: ${email}\n` +
                        `Phone: ${phone}\n` +
                        `${ company ? `Company }\n` : ''}` +
                        `\nPlease log in to your manager dashboard to review and approve this application.`,
                  html: `<h2>New Portal User Application</h2>` +
                        `<p><strong>Location:</strong> ${(location ).name}</p>` +
                        `<p><strong>Applicant Name:</strong> ${fullName}</p>` +
                        `<p><strong>Email:</strong> ${email}</p>` +
                        `<p><strong>Phone:</strong> ${phone}</p>` +
                        `${ company ? `<p><strong>Company }</p>` : ''}` +
                        `<p>Please log in to your manager dashboard to review and approve this application.</p>`,
                };
                await sendEmail(emailContent);
                console.log(`âœ… Portal user application notification sent to manager);
              } else {
                console.log("âš ï¸ No manager email found for location - skipping email notification");
              }
            } catch (emailError) { console.error("Error sending application notification email }

            // Return success response
            res.status(201).json({ id }
            });
          })();
        });
      });

    } catch (error) { console.error("Portal registration error });
    }
  });

app.get("/api/portal/my-location", requirePortalUser, async (req, res) => {
    try {
      const userId = (req.user ).id;
      
      const { portalUserLocationAccess, locations } = await import('../shared/schema');
      const { eq } = await import('drizzle-orm');
      
      // Get user's location access
      const accessRecords = await db.select()
        .from(portalUserLocationAccess)
        .where(eq(portalUserLocationAccess.portalUserId, userId))
        .limit(1);
      
      if (accessRecords.length === 0) { return res.status(404).json({ error });
      }
      
      const locationId = accessRecords[0].locationId;
      
      // Get location details
      const locationRecords = await db.select()
        .from(locations)
        .where(eq(locations.id, locationId))
        .limit(1);
      
      if (locationRecords.length === 0) { return res.status(404).json({ error });
      }
      
      const location = locationRecords[0];
      const slug = (location ).name
          .toLowerCase()
          .trim()
          .replace(/[^\w\s-]/g, '')
          .replace(/[\s_-]+/g, '-')
          .replace(/^-+|-+$/g, '');
        
      res.json({ id });
    } catch (error) { console.error("Error fetching portal user location });
    }
  });

app.get("/api/portal/application-status", async (req, res) => { try {
      const sessionUser = await getAuthenticatedUser(req);
      const isFirebaseAuth = req.neonUser;
      
      if (!sessionUser && !isFirebaseAuth) {
        return res.status(401).json({ error });
      }
      
      const user = isFirebaseAuth ? req.neonUser! : sessionUser!;
      const isPortalUser = (user ).isPortalUser || (user ).is_portal_user;
      
      if (!isPortalUser) { return res.status(403).json({ error });
      }

      // Check for approved access first
      const accessRecords = await db.select()
        .from(portalUserLocationAccess)
        .where(eq(portalUserLocationAccess.portalUserId, user.id))
        .limit(1);
      
      if (accessRecords.length > 0) { return res.json({ 
          hasAccess,
          status });
      }

      // Check application status
      const applications = await db.select()
        .from(portalUserApplications)
        .where(eq(portalUserApplications.userId, user.id))
        .orderBy(desc(portalUserApplications.createdAt))
        .limit(1);
      
      if (applications.length > 0) { const app = applications[0];
        return res.json({
          hasAccess,
          status });
      }

      return res.json({ hasAccess,
        status });
    } catch (error) { console.error("Error getting portal application status });
    }
  });

app.get("/api/portal/locations", requirePortalUser, async (req, res) => {
    try {
      const userId = (req.user ).id;
      
      const { portalUserLocationAccess, locations } = await import('../shared/schema');
      const { eq } = await import('drizzle-orm');
      
      // Get user's location access
      const accessRecords = await db.select()
        .from(portalUserLocationAccess)
        .where(eq(portalUserLocationAccess.portalUserId, userId))
        .limit(1);
      
      if (accessRecords.length === 0) { return res.status(404).json({ error });
      }
      
      const locationId = accessRecords[0].locationId;
      
      // Get location details
      const locationRecords = await db.select()
        .from(locations)
        .where(eq(locations.id, locationId))
        .limit(1);
      
      if (locationRecords.length === 0) { return res.status(404).json({ error });
      }
      
      const location = locationRecords[0];
      const slug = (location ).name
          .toLowerCase()
          .trim()
          .replace(/[^\w\s-]/g, '')
          .replace(/[\s_-]+/g, '-')
          .replace(/^-+|-+$/g, '');
      
      res.json([{ id }]);
    } catch (error) { console.error("Error fetching portal user location });
    }
  });

app.get("/api/portal/locations/) => {
    try {
      const userId = (req.user ).id;
      const locationSlug = req.params.locationSlug;
      
      // Get user's assigned location
      const { portalUserLocationAccess, locations } = await import('../shared/schema');
      const { eq } = await import('drizzle-orm');
      
      const accessRecords = await db.select()
        .from(portalUserLocationAccess)
        .where(eq(portalUserLocationAccess.portalUserId, userId))
        .limit(1);
      
      if (accessRecords.length === 0) { return res.status(404).json({ error });
      }
      
      const userLocationId = accessRecords[0].locationId;
      
      // Get location details
      const locationRecords = await db.select()
        .from(locations)
        .where(eq(locations.id, userLocationId))
        .limit(1);
      
      if (locationRecords.length === 0) { return res.status(404).json({ error });
      }

      const location = locationRecords[0];
      const slug = (location ).name
        .toLowerCase()
        .trim()
        .replace(/[^\w\s-]/g, '')
        .replace(/[\s_-]+/g, '-')
        .replace(/^-+|-+$/g, '');
      
      // Verify the slug matches the user's location
      if (slug !== locationSlug) { return res.status(403).json({ error });
      }

      // Return location info
      res.json({ id });
    } catch (error) { console.error("Error fetching portal location });
    }
  });

app.get("/api/portal/locations/) => { try {
      const userId = (req.user ).id;
      const locationSlug = req.params.locationSlug;
      
      // Get user's assigned location
      const accessRecords = await db.select()
        .from(portalUserLocationAccess)
        .where(eq(portalUserLocationAccess.portalUserId, userId))
        .limit(1);
      
      if (accessRecords.length === 0) {
        return res.status(404).json({ error });
      }
      
      const userLocationId = accessRecords[0].locationId;
      
      // Get location details
      const locationRecords = await db.select()
        .from(locations)
        .where(eq(locations.id, userLocationId))
        .limit(1);
      
      if (locationRecords.length === 0) { return res.status(404).json({ error });
      }
      
      const location = locationRecords[0];
      const slug = (location ).name
          .toLowerCase()
          .trim()
          .replace(/[^\w\s-]/g, '')
          .replace(/[\s_-]+/g, '-')
          .replace(/^-+|-+$/g, '');

      // Verify the slug matches the user's location
      if (slug !== locationSlug) { return res.status(403).json({ error });
      }

      const kitchens = await firebaseStorage.getKitchensByLocation(userLocationId);
      
      // Filter only active kitchens and return info
      const publicKitchens = kitchens
        .filter((kitchen) => kitchen.isActive !== false)
        .map((kitchen) => ({ id }));

      res.json(publicKitchens);
    } catch (error) { console.error("Error fetching portal kitchens });
    }
  });

app.get("/api/portal/kitchens/) => { try {
      const userId = (req.user ).id;
      const kitchenId = parseInt(req.params.kitchenId);
      const date = req.query.date ;

      if (isNaN(kitchenId) || kitchenId <= 0) {
        return res.status(400).json({ error });
      }

      if (!date) { return res.status(400).json({ error });
      }

      // Get user's assigned location
      const { portalUserLocationAccess, kitchens } = await import('../shared/schema');
      const { eq } = await import('drizzle-orm');
      
      const accessRecords = await db.select()
        .from(portalUserLocationAccess)
        .where(eq(portalUserLocationAccess.portalUserId, userId))
        .limit(1);
      
      if (accessRecords.length === 0) { return res.status(404).json({ error });
      }
      
      const userLocationId = accessRecords[0].locationId;
      
      // Verify kitchen belongs to user's location
      const kitchenRecords = await db.select()
        .from(kitchens)
        .where(eq(kitchens.id, kitchenId))
        .limit(1);
      
      if (kitchenRecords.length === 0) { return res.status(404).json({ error });
      }
      
      const kitchen = kitchenRecords[0];
      const kitchenLocationId = (kitchen ).locationId || (kitchen ).location_id;
      
      if (kitchenLocationId !== userLocationId) { return res.status(403).json({ error });
      }

      // Get available slots using the same logic  bookings
      const slots = await firebaseStorage.getAvailableSlots(kitchenId, date);
      
      res.json({ slots });
    } catch (error) { console.error("Error fetching portal availability });
    }
  });

app.post("/api/public/bookings", async (req, res) => {
    try {
      const {
        locationId,
        kitchenId,
        bookingDate,
        startTime,
        endTime,
        bookingName,
        bookingEmail,
        bookingPhone,
        bookingCompany,
        specialNotes,
      } = req.body;

      if (!locationId || !kitchenId || !bookingDate || !startTime || !endTime || !bookingName || !bookingEmail) { return res.status(400).json({ error });
      }

      // Validate booking date/time
      const bookingDateObj = new Date(bookingDate);
      const now = new Date();
      
      if (bookingDateObj < now) { return res.status(400).json({ error });
      }

      // Check availability
      const availabilityCheck = await firebaseStorage.validateBookingAvailability(
        kitchenId,
        bookingDateObj,
        startTime,
        endTime
      );

      if (!availabilityCheck.valid) { return res.status(400).json({ error });
      }

      // Get location to check minimum booking window
      const location = await firebaseStorage.getLocationById(locationId);
      const minimumBookingWindowHours = (location ).minimumBookingWindowHours ?? 1;

      // Check minimum booking window if booking is today
      const isToday = bookingDateObj.toDateString() === now.toDateString();
      if (isToday) { const [startHours, startMins] = startTime.split(' } hour(s) in advance` 
          });
        }
      }

      // Create booking /third-party booking
      const booking = await firebaseStorage.createBooking({ kitchenId,
        bookingDate,
        startTime,
        endTime,
        specialNotes }${bookingCompany ? ` (${bookingCompany})` : ''}. Email: ${bookingEmail}${ bookingPhone ? `, Phone }` : ''}`,
        bookingType: 'external',
        createdBy, // No authenticated user
        externalContact: { name,
          email,
          phone },
      });

      // Send notification to manager
      try {
        const { sendEmail } = await import('./email');
        if ((location ).notificationEmail) { // Create simple email notification for third-party booking
          const emailContent = {
            to }`,
            text: `A new booking request h submitted:\n\n` +
                  `Kitchen: ${booking.kitchenName || 'Kitchen'}\n` +
                  `Date: ${bookingDate}\n` +
                  `Time: ${startTime} - ${endTime}\n\n` +
                  `Contact Information:\n` +
                  `Name: ${bookingName}\n` +
                  `Email: ${bookingEmail}\n` +
                  `${ bookingPhone ? `Phone }\n` : ''}` +
                  `${ bookingCompany ? `Company }\n` : ''}` +
                  `${ specialNotes ? `\nNotes }` : ''}\n\n` +
                  `Please log in to your manager dashboard to confirm or manage this booking.`,
            html: `<h2>New Third-Party Booking Request</h2>` +
                  `<p><strong>Location:</strong> ${(location ).name}</p>` +
                  `<p><strong>Kitchen:</strong> ${booking.kitchenName || 'Kitchen'}</p>` +
                  `<p><strong>Date:</strong> ${bookingDate}</p>` +
                  `<p><strong>Time:</strong> ${startTime} - ${endTime}</p>` +
                  `<h3>Contact Information:</h3>` +
                  `<ul>` +
                  `<li><strong>Name:</strong> ${bookingName}</li>` +
                  `<li><strong>Email:</strong> ${bookingEmail}</li>` +
                  `${ bookingPhone ? `<li><strong>Phone }</li>` : ''}` +
                  `${ bookingCompany ? `<li><strong>Company }</li>` : ''}` +
                  `</ul>` +
                  `${ specialNotes ? `<p><strong>Notes }</p>` : ''}` +
                  `<p>Please log in to your manager dashboard to confirm or manage this booking.</p>`,
          };
          await sendEmail(emailContent);
        }
      } catch (emailError) { console.error("Error sending booking notification email }

      res.status(201).json({ success, booking }, message);
    } catch (error) { console.error("Error creating public booking });
    }
  });

app.post("/api/portal/bookings", requirePortalUser, async (req, res) => {
    try {
      const userId = (req.user ).id;
      const {
        locationId,
        kitchenId,
        bookingDate,
        startTime,
        endTime,
        bookingName,
        bookingEmail,
        bookingPhone,
        bookingCompany,
        specialNotes,
      } = req.body;

      if (!locationId || !kitchenId || !bookingDate || !startTime || !endTime || !bookingName || !bookingEmail) { return res.status(400).json({ error });
      }

      // Get user's assigned location
      const { portalUserLocationAccess, kitchens } = await import('../shared/schema');
      const { eq } = await import('drizzle-orm');
      const { db } = await import('./db');
      
      const accessRecords = await db.select()
        .from(portalUserLocationAccess)
        .where(eq(portalUserLocationAccess.portalUserId, userId))
        .limit(1);
      
      if (accessRecords.length === 0) { return res.status(404).json({ error });
      }
      
      const userLocationId = accessRecords[0].locationId;
      
      // Verify location matches user's assigned location
      if (parseInt(locationId) !== userLocationId) { return res.status(403).json({ error });
      }
      
      // Verify kitchen belongs to user's location
      const kitchenRecords = await db.select()
        .from(kitchens)
        .where(eq(kitchens.id, parseInt(kitchenId)))
        .limit(1);
      
      if (kitchenRecords.length === 0) { return res.status(404).json({ error });
      }
      
      const kitchen = kitchenRecords[0];
      const kitchenLocationId = (kitchen ).locationId || (kitchen ).location_id;
      
      if (kitchenLocationId !== userLocationId) { return res.status(403).json({ error });
      }

      // Validate booking date/time
      const bookingDateObj = new Date(bookingDate);
      const now = new Date();
      
      if (bookingDateObj < now) { return res.status(400).json({ error });
      }

      // Check availability
      const availabilityCheck = await firebaseStorage.validateBookingAvailability(
        parseInt(kitchenId),
        bookingDateObj,
        startTime,
        endTime
      );

      if (!availabilityCheck.valid) { return res.status(400).json({ error });
      }

      // Get location to check minimum booking window
      const location = await firebaseStorage.getLocationById(userLocationId);
      const minimumBookingWindowHours = (location ).minimumBookingWindowHours ?? 1;

      // Check minimum booking window if booking is today
      const isToday = bookingDateObj.toDateString() === now.toDateString();
      if (isToday) { const [startHours, startMins] = startTime.split(' } hour(s) in advance` 
          });
        }
      }

      // Check daily booking limit
      const { pool } = await import('./db');
      
      if (pool) { // Calculate requested slots
        const [sH, sM] = startTime.split(' } else {
            // 2. Try weekly schedule for this day of week
            const dayOfWeek = bookingDateObj.getDay();
            const availabilityResult = await pool.query(`
              SELECT max_slots_per_chef
              FROM kitchen_availability
              WHERE kitchen_id = $1 AND day_of_week = $2
            `, [kitchenId, dayOfWeek]);
            
            if (availabilityResult.rows.length > 0) {
              const v = Number(availabilityResult.rows[0].max_slots_per_chef);
              if (Number.isFinite(v) && v > 0) maxSlotsPerChef = v;
            } else {
              // 3. Fall back to location default
              const locationLimitResult = await pool.query(`
                SELECT l.default_daily_booking_limit
                FROM locations l
                INNER JOIN kitchens k ON k.location_id = l.id
                WHERE k.id = $1
              `, [kitchenId]);
              
              if (locationLimitResult.rows.length > 0) {
                const locVal = Number(locationLimitResult.rows[0].default_daily_booking_limit);
                if (Number.isFinite(locVal) && locVal > 0) maxSlotsPerChef = locVal;
              }
            }
          }
        } catch (error) { console.error('Error fetching daily booking limit }

        // Count already booked slots for this portal user on this date (confirmed + pending)
        const existingBookings = await pool.query(`
          SELECT start_time, end_time
          FROM kitchen_bookings
          WHERE chef_id = $1
            AND kitchen_id = $2
            AND DATE(booking_date) = $3::date
            AND status IN ('pending','confirmed')
        `, [userId, kitchenId, dateStr]);

        let existingSlots = 0;
        for (const b of existingBookings.rows) { const [bsH, bsM] = String(b.start_time).split(' }

        // Check if booking would exceed daily limit
        if (existingSlots + requestedSlots > maxSlotsPerChef) { return res.status(400).json({ 
            error } hour(s).` 
          });
        }
      }

      // Create booking /third-party booking (using portal user info)
      const booking = await firebaseStorage.createBooking({ kitchenId }${bookingCompany ? ` (${bookingCompany})` : ''}. Email: ${bookingEmail}${ bookingPhone ? `, Phone }` : ''}`,
        bookingType: 'external',
        createdBy, // Portal user who created the booking
        externalContact: { name,
          email,
          phone },
      });

      // Send notification to manager
      try {
        const { sendEmail } = await import('./email');
        if ((location ).notificationEmail) { // Create simple email notification for portal user booking
          const emailContent = {
            to }`,
            text: `A new booking request h submitted by a portal user:\n\n` +
                  `Kitchen: ${booking.kitchenName || 'Kitchen'}\n` +
                  `Date: ${bookingDate}\n` +
                  `Time: ${startTime} - ${endTime}\n\n` +
                  `Contact Information:\n` +
                  `Name: ${bookingName}\n` +
                  `Email: ${bookingEmail}\n` +
                  `${ bookingPhone ? `Phone }\n` : ''}` +
                  `${ bookingCompany ? `Company }\n` : ''}` +
                  `${ specialNotes ? `\nNotes }` : ''}\n\n` +
                  `Please log in to your manager dashboard to confirm or manage this booking.`,
            html: `<h2>New Portal User Booking Request</h2>` +
                  `<p><strong>Location:</strong> ${(location ).name}</p>` +
                  `<p><strong>Kitchen:</strong> ${booking.kitchenName || 'Kitchen'}</p>` +
                  `<p><strong>Date:</strong> ${bookingDate}</p>` +
                  `<p><strong>Time:</strong> ${startTime} - ${endTime}</p>` +
                  `<h3>Contact Information:</h3>` +
                  `<ul>` +
                  `<li><strong>Name:</strong> ${bookingName}</li>` +
                  `<li><strong>Email:</strong> ${bookingEmail}</li>` +
                  `${ bookingPhone ? `<li><strong>Phone }</li>` : ''}` +
                  `${ bookingCompany ? `<li><strong>Company }</li>` : ''}` +
                  `</ul>` +
                  `${ specialNotes ? `<p><strong>Notes }</p>` : ''}` +
                  `<p>Please log in to your manager dashboard to confirm or manage this booking.</p>`,
          };
          await sendEmail(emailContent);
        }

        // Send SMS to manager
        try {
          const { db, pool } = await import('./db');
          const { locations } = await import('../shared/schema');
          const { eq } = await import('drizzle-orm');
          
          const locationRecord = await db.select().from(locations).where(eq(locations.id, userLocationId)).limit(1);
          const locationData = locationRecord[0];
          
          // Get manager phone number using utility function (with fallback logic and normalization)
          const managerPhone = await getManagerPhone(locationData, (locationData ).managerId, pool);

          if (managerPhone) { const smsMessage = generateManagerPortalBookingSMS({
              portalUserName,
              kitchenName });
            await sendSMS(managerPhone, smsMessage, { trackingId }_manager` });
            console.log(`âœ… Portal booking SMS sent to manager);
          }
        } catch (smsError) { console.error("Error sending booking SMS to manager }
      } catch (emailError) { console.error("Error sending booking notification email }

      res.status(201).json({ success, booking }, message);
    } catch (error) { console.error("Error creating portal booking });
    }
  });

app.get("/api/public/kitchens", async (req, res) => {
    try {
      const kitchens = await firebaseStorage.getAllKitchensWithLocationAndManager();
      
      console.log(`[API] /api/public/kitchens - Found ${kitchens.length} total kitchens`);
      
      // Filter only active kitchens (handle both camelCase and snake_case)
      const activeKitchens = kitchens.filter((kitchen) => { const isActive = kitchen.isActive !== undefined ? kitchen.isActive  });
      
      console.log(`[API] /api/public/kitchens - ${activeKitchens.length} active kitchens after filtering`);
      
      // Return public-safe info with location data (no limit - show all for marketing)
      const publicKitchens = activeKitchens
        .map((kitchen) => {
          const locationId = kitchen.locationId || kitchen.location_id;
          const locationName = kitchen.locationName || kitchen.location_name;
          const locationAddress = kitchen.locationAddress || kitchen.location_address;
          const imageUrl = kitchen.imageUrl || kitchen.image_url || null;
          const locationBrandImageUrl = kitchen.locationBrandImageUrl || kitchen.location_brand_image_url || null;
          const locationLogoUrl = kitchen.locationLogoUrl || kitchen.location_logo_url || null;
          
          // Log for debugging
          if (locationId && !locationName) {
            console.warn(`[API] Kitchen ${kitchen.id} h ${locationId} but no locationName`);
          }
          
          return { id };
        });

      console.log(`[API] /api/public/kitchens - Returning ${publicKitchens.length} kitchens (all active for marketing)`);
      console.log(`[API] Sample kitchen data);

      res.json(publicKitchens);
    } catch (error) { console.error("Error fetching public kitchens });
    }
  });

app.get("/api/public/locations", async (req, res) => { try {
      const allLocations = await firebaseStorage.getAllLocations();
      const allKitchens = await firebaseStorage.getAllKitchensWithLocationAndManager();
      
      // Filter to only active kitchens
      const activeKitchens = allKitchens.filter((kitchen) => {
        const isActive = kitchen.isActive !== undefined ? kitchen.isActive  });
      
      // Get unique location IDs that have active kitchens
      const locationIdsWithKitchens = new Set(
        activeKitchens.map((kitchen) => kitchen.locationId || kitchen.location_id).filter(Boolean)
      );
      
      // Filter locations to only those with active kitchens
      const locationsWithKitchens = allLocations
        .filter((location) => locationIdsWithKitchens.has(location.id))
        .map((location) => { // Count kitchens per location
          const kitchenCount = activeKitchens.filter((kitchen) => 
            (kitchen.locationId || kitchen.location_id) === location.id
          ).length;
          
          // Get first kitchen image  for this location if location doesn't have its own brand image
          const locationKitchens = activeKitchens.filter((kitchen) => 
            (kitchen.locationId || kitchen.location_id) === location.id
          );
          const featuredKitchenImage = locationKitchens.find((k) => k.imageUrl || k.image_url).imageUrl || 
                                        locationKitchens.find((k) => k.imageUrl || k.image_url).image_url || null;
          
          return {
            id };
        });
      
      console.log(`[API] /api/public/locations - Returning ${locationsWithKitchens.length} locations with active kitchens`);
      
      res.json(locationsWithKitchens);
    } catch (error) { console.error("Error fetching public locations });
    }
  });

app.get("/api/public/locations/) => { try {
      const locationId = parseInt(req.params.locationId);
      
      if (isNaN(locationId)) {
        return res.status(400).json({ error });
      }

      // Get location
      const allLocations = await firebaseStorage.getAllLocations();
      const location = allLocations.find((loc) => loc.id === locationId);
      
      if (!location) { return res.status(404).json({ error });
      }

      // Get kitchens for this location
      const allKitchens = await firebaseStorage.getAllKitchensWithLocationAndManager();
      const locationKitchens = allKitchens
        .filter((kitchen) => { const kitchenLocationId = kitchen.locationId || kitchen.location_id;
          const isActive = kitchen.isActive !== undefined ? kitchen.isActive  })
        .map((kitchen) => ({ id }));

      console.log(`[API] /api/public/locations/${locationId}/details - Found location with ${locationKitchens.length} kitchens`);

      res.json({ location },
        kitchens,
      });
    } catch (error) { console.error("Error fetching public location details });
    }
  });

app.get("/api/public/kitchens/) => { try {
      const kitchenId = parseInt(req.params.kitchenId);
      const date = req.query.date  | undefined;

      if (isNaN(kitchenId)) {
        return res.status(400).json({ error });
      }

      // Get kitchen availability settings
      const availabilities = await firebaseStorage.getKitchenAvailability(kitchenId);
      
      // Get operating days (days of week that have availability set)
      const operatingDays = [...new Set(availabilities.map((a) => a.dayOfWeek))];

      // Generate sample slots for preview (not real-time, just example)
      // These are illustrative and don't reflect actual bookings
      const sampleSlots = [];
      
      // If a specific date is provided, get the day of week
      let dayOfWeek = new Date().getDay();
      if (date) {
        const [year, month, day] = date.split('-').map(Number);
        dayOfWeek = new Date(year, month - 1, day).getDay();
      }

      // Find availability for this day
      const dayAvailability = availabilities.find((a) => a.dayOfWeek === dayOfWeek);
      
      if (dayAvailability) { const startTime = dayAvailability.startTime || "08 }:00`;
          // Generate pseudo-random availability for demo purposes
          const seed = kitchenId * 100 + hour;
          const available = (seed % 3) === 0 ? 0 : ((seed % 2) === 0 ? 1 );
          
          sampleSlots.push({
            time,
            available,
            capacity,
            isFullyBooked === 0,
          });
        }
      } else {
        // Default sample slots if no availability set for this day
        for (let hour = 8; hour < 18; hour++) {
          const timeStr = `${hour.toString().padStart(2, '0')}:00`;
          const seed = kitchenId * 100 + hour;
          const available = (seed % 3) === 0 ? 0 : ((seed % 2) === 0 ? 1 );
          
          sampleSlots.push({
            time,
            available,
            capacity,
            isFullyBooked === 0,
          });
        }
      }

      console.log(`[API] /api/public/kitchens/${kitchenId}/availability-preview - Returning ${sampleSlots.length} sample slots`);

      res.json({ operatingDays,
        sampleSlots,
        hasAvailability });
    } catch (error) { console.error("Error fetching public kitchen availability preview });
    }
  });

app.get("/api/public/stats", async (req, res) => { try {
      if (!db) {
        return res.status(500).json({ error });
      }

      // Get counts from database
      const [
        chefCountResult,
        applicationCountResult,
        approvedApplicationCountResult,
        deliveryPartnerCountResult,
        locationCountResult,
        kitchenCountResult,
      ] = await Promise.all([
        db.select().from(users).where(eq(users.isChef, true)),
        db.select().from(applications),
        db.select().from(applications).where(eq(applications.status, "approved")),
        db.select().from(users).where(eq(users.isDeliveryPartner, true)),
        db.select().from(locations),
        db.select().from(kitchens).where(eq(kitchens.isActive, true)),
      ]);

      const stats = { totalChefs };

      res.json(stats);
    } catch (error) { console.error("Error fetching public stats });
    }
  });

// Routes will be inserted here by the sync script

// {{ERROR_HANDLING}}

// Global error handler
app.use((err, req, res, next) => {
  console.error('Global error handler:', err);
  
  // Handle multer errors specifically
  if (err instanceof multer.MulterError) {
    if (err.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({ message: 'File too large. Maximum size is 4.5MB.' });
    }
    return res.status(400).json({ message: 'File upload error: ' + err.message });
  }
  
  // Handle other file upload errors
  if (err.message && err.message.includes('Invalid file type')) {
    return res.status(400).json({ message: err.message });
  }
  
  // Default error response
  res.status(500).json({
    message: 'Internal server error',
    error: process.env.NODE_ENV === 'development' ? err.message : 'Something went wrong'
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ message: 'Route not found' });
});

export default app; 